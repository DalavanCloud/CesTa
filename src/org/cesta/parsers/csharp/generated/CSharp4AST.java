// $ANTLR 3.4 E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g 2013-05-08 00:18:13

/*
[The BSD License]
Copyright (c) 2012 Christian Wulf
All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

    Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
    Neither the name of the author nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
*/
package org.cesta.parsers.csharp.generated;

import java.util.LinkedList;


import org.antlr.runtime.*;
import java.util.Stack;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;

import org.antlr.runtime.tree.*;


@SuppressWarnings({"all", "warnings", "unchecked"})
public class CSharp4AST extends Parser {
    public static final String[] tokenNames = new String[] {
        "<invalid>", "<EOR>", "<DOWN>", "<UP>", "ABSTRACT", "AMP", "AS", "ASSIGNMENT", "Asterisks", "Available_identifier", "BACK_SLASH", "BANG", "BASE", "BITWISE_OR", "BOOL", "BREAK", "BYTE", "CARET", "CASE", "CATCH", "CHAR", "CHARACTER_LITERAL", "CHECKED", "CLASS", "CLOSE_BRACE", "CLOSE_BRACKET", "CLOSE_PARENS", "COLON", "COMMA", "CONST", "CONTINUE", "Character", "Combining_character", "Conditional_symbol", "Connecting_character", "DECIMAL", "DECIMAL_DIGIT", "DEFAULT", "DELEGATE", "DELIMITED_COMMENT", "DELIMITED_DOC_COMMENT", "DIV", "DO", "DOT", "DOUBLE", "DOUBLE_BACK_SLASH", "DOUBLE_COLON", "DOUBLE_QUOTE", "Decimal_digit_character", "Decimal_digits", "Decimal_integer_literal", "Delimited_comment_section", "ELSE", "ENUM", "EVENT", "EXPLICIT", "EXTERN", "Exponent_part", "FALSE", "FINALLY", "FIXED", "FLOAT", "FOR", "FOREACH", "File_name", "File_name_character", "File_name_characters", "Formatting_character", "GOTO", "GT", "HEX_DIGIT", "Hex_digits", "Hexadecimal_escape_sequence", "Hexadecimal_integer_literal", "IDENTIFIER", "IF", "IMPLICIT", "IN", "INT", "INTEGER_LITERAL", "INTERFACE", "INTERNAL", "INTERR", "IS", "Identifier_or_keyword", "Identifier_part_character", "Identifier_start_character", "Input_character", "Input_characters", "Integer_type_suffix", "LOCK", "LONG", "LT", "Letter_character", "Line_indicator", "LiteralAccess", "MINUS", "NAMESPACE", "NEW", "NEW_LINE", "NEW_LINE_CHARACTER", "NULL", "Not_number_sign", "Not_slash_or_asterisk", "OBJECT", "OPEN_BRACE", "OPEN_BRACKET", "OPEN_PARENS", "OPERATOR", "OP_ADD_ASSIGNMENT", "OP_AND", "OP_AND_ASSIGNMENT", "OP_COALESCING", "OP_DEC", "OP_DIV_ASSIGNMENT", "OP_EQ", "OP_GE", "OP_INC", "OP_LE", "OP_LEFT_SHIFT", "OP_LEFT_SHIFT_ASSIGNMENT", "OP_MOD_ASSIGNMENT", "OP_MULT_ASSIGNMENT", "OP_NE", "OP_OR", "OP_OR_ASSIGNMENT", "OP_PTR", "OP_SUB_ASSIGNMENT", "OP_XOR_ASSIGNMENT", "OUT", "OVERRIDE", "PARAMS", "PERCENT", "PLUS", "PRIVATE", "PROTECTED", "PUBLIC", "Pp_and_expression", "Pp_conditional", "Pp_declaration", "Pp_diagnostic", "Pp_directive", "Pp_elif_section", "Pp_else_section", "Pp_end_region", "Pp_endif", "Pp_equality_expression", "Pp_expression", "Pp_if_section", "Pp_line", "Pp_message", "Pp_new_line", "Pp_or_expression", "Pp_pragma", "Pp_pragma_text", "Pp_primary_expression", "Pp_region", "Pp_start_region", "Pp_unary_expression", "QUOTE", "Quote_escape_sequence", "READONLY", "REAL_LITERAL", "REF", "RETURN", "Real_type_suffix", "Regular_string_literal", "Regular_string_literal_character", "SBYTE", "SEALED", "SEMICOLON", "SHARP", "SHORT", "SINGLE_LINE_COMMENT", "SINGLE_LINE_DOC_COMMENT", "SIZEOF", "STACKALLOC", "STAR", "STATIC", "STRING", "STRING_LITERAL", "STRUCT", "SWITCH", "Sign", "Simple_escape_sequence", "Single_character", "Single_regular_string_literal_character", "Single_verbatim_string_literal_character", "SkiPped_characters", "SkiPped_section_part", "THIS", "THROW", "TILDE", "TRUE", "TRY", "TYPEOF", "Tokens", "UINT", "ULONG", "UNCHECKED", "UNICODE_CLASS_CF", "UNICODE_CLASS_LL", "UNICODE_CLASS_LM", "UNICODE_CLASS_LO", "UNICODE_CLASS_LT", "UNICODE_CLASS_LU", "UNICODE_CLASS_MC", "UNICODE_CLASS_MN", "UNICODE_CLASS_ND", "UNICODE_CLASS_NL", "UNICODE_CLASS_PC", "UNICODE_CLASS_ZS", "UNSAFE", "USHORT", "USING", "Unicode_escape_sequence", "VIRTUAL", "VOID", "VOLATILE", "Verbatim_string_literal", "Verbatim_string_literal_character", "WHILE", "WHITESPACE", "Whitespace_character", "Whitespace_characters", "ARGUMENT", "ARGUMENT_VALUE", "ARRAY_ACCESS", "ASSIGNMENT_OPERATOR", "ATTRIBUTE", "ATTRIBUTES", "ATTRIBUTE_LIST", "ATTRIBUTE_NAME", "ATTRIBUTE_TARGET", "BLOCK", "BOOL_NOT", "CAST_EXPRESSION", "CLASS_MEMBER_DECLARATIONS", "CONDITION", "CONDITIONAL_EXPRESSION", "CONSTANT_DECLARATOR", "CONSTANT_DECLARATORS", "CONSTANT_INITIALIZER", "CONSTRUCTOR_DECL", "CSHARP_SOURCE", "ENUM_EXTENDS", "ENUM_MEMBER_DECLARATION", "ENUM_MEMBER_DECLARATIONS", "ENUM_MEMBER_INITIALIZER", "EXPRESSION_STATEMENT", "EXTENDS_OR_IMPLEMENTS", "EXTERN_ALIAS_DIRECTIVES", "FIELD_DECL", "FIRST_OP", "FIXED_PARAMETER", "FORMAL_PARAMETER_LIST", "FOR_INITIALIZER", "FOR_ITERATOR", "IMPLEMENTS", "INDEXER_DECL", "INTERFACE_MEMBER_DECLARATIONS", "LABELED_STATEMENT", "LOCAL_VARIABLE_DECLARATION", "LOCAL_VARIABLE_DECLARATOR", "LOCAL_VARIABLE_INITIALIZER", "LOOP_BODY", "MEMBER_ACCESS", "MEMBER_NAME", "METHOD_DECL", "METHOD_INVOCATION", "MODIFIERS", "NAMESPACE_MEMBER_DECLARATIONS", "NAMESPACE_OR_TYPE_NAME", "NAMESPACE_OR_TYPE_PART", "OBJECT_CREATION_EXPRESSION", "OP_RIGHT_SHIFT", "OP_RIGHT_SHIFT_ASSIGNMENT", "PARAMETER_ARRAY", "PARAMETER_MODIFIER", "POSITIONAL_ARGUMENT_LIST", "POST_DEC", "POST_INC", "PROPERTY_DECL", "QUALIFIED_ALIAS_MEMBER", "QUALIFIED_IDENTIFIER", "RANK_SPECIFIER", "SECOND_OP", "SIMPLE_NAME", "STRUCT_MEMBER_DECLARATIONS", "THEN", "TYPE", "TYPE_ARGUMENT_LIST", "TYPE_PARAM", "TYPE_PARAMETERS", "TYPE_PARAMETER_CONSTRAINTS_CLAUSE", "TYPE_PARAMETER_CONSTRAINTS_CLAUSES", "UNARY_EXPRESSION", "USING_ALIAS_DIRECTIVE", "USING_DIRECTIVES", "USING_NAMESPACE_DIRECTIVE", "VARIABLE_DECLARATOR", "VARIABLE_INITIALIZER", "VARIANCE_ANNOTATION", "VARIANT_TYPE_PARAMETERS"
    };

    public static final int EOF=-1;
    public static final int ABSTRACT=4;
    public static final int AMP=5;
    public static final int AS=6;
    public static final int ASSIGNMENT=7;
    public static final int Asterisks=8;
    public static final int Available_identifier=9;
    public static final int BACK_SLASH=10;
    public static final int BANG=11;
    public static final int BASE=12;
    public static final int BITWISE_OR=13;
    public static final int BOOL=14;
    public static final int BREAK=15;
    public static final int BYTE=16;
    public static final int CARET=17;
    public static final int CASE=18;
    public static final int CATCH=19;
    public static final int CHAR=20;
    public static final int CHARACTER_LITERAL=21;
    public static final int CHECKED=22;
    public static final int CLASS=23;
    public static final int CLOSE_BRACE=24;
    public static final int CLOSE_BRACKET=25;
    public static final int CLOSE_PARENS=26;
    public static final int COLON=27;
    public static final int COMMA=28;
    public static final int CONST=29;
    public static final int CONTINUE=30;
    public static final int Character=31;
    public static final int Combining_character=32;
    public static final int Conditional_symbol=33;
    public static final int Connecting_character=34;
    public static final int DECIMAL=35;
    public static final int DECIMAL_DIGIT=36;
    public static final int DEFAULT=37;
    public static final int DELEGATE=38;
    public static final int DELIMITED_COMMENT=39;
    public static final int DELIMITED_DOC_COMMENT=40;
    public static final int DIV=41;
    public static final int DO=42;
    public static final int DOT=43;
    public static final int DOUBLE=44;
    public static final int DOUBLE_BACK_SLASH=45;
    public static final int DOUBLE_COLON=46;
    public static final int DOUBLE_QUOTE=47;
    public static final int Decimal_digit_character=48;
    public static final int Decimal_digits=49;
    public static final int Decimal_integer_literal=50;
    public static final int Delimited_comment_section=51;
    public static final int ELSE=52;
    public static final int ENUM=53;
    public static final int EVENT=54;
    public static final int EXPLICIT=55;
    public static final int EXTERN=56;
    public static final int Exponent_part=57;
    public static final int FALSE=58;
    public static final int FINALLY=59;
    public static final int FIXED=60;
    public static final int FLOAT=61;
    public static final int FOR=62;
    public static final int FOREACH=63;
    public static final int File_name=64;
    public static final int File_name_character=65;
    public static final int File_name_characters=66;
    public static final int Formatting_character=67;
    public static final int GOTO=68;
    public static final int GT=69;
    public static final int HEX_DIGIT=70;
    public static final int Hex_digits=71;
    public static final int Hexadecimal_escape_sequence=72;
    public static final int Hexadecimal_integer_literal=73;
    public static final int IDENTIFIER=74;
    public static final int IF=75;
    public static final int IMPLICIT=76;
    public static final int IN=77;
    public static final int INT=78;
    public static final int INTEGER_LITERAL=79;
    public static final int INTERFACE=80;
    public static final int INTERNAL=81;
    public static final int INTERR=82;
    public static final int IS=83;
    public static final int Identifier_or_keyword=84;
    public static final int Identifier_part_character=85;
    public static final int Identifier_start_character=86;
    public static final int Input_character=87;
    public static final int Input_characters=88;
    public static final int Integer_type_suffix=89;
    public static final int LOCK=90;
    public static final int LONG=91;
    public static final int LT=92;
    public static final int Letter_character=93;
    public static final int Line_indicator=94;
    public static final int LiteralAccess=95;
    public static final int MINUS=96;
    public static final int NAMESPACE=97;
    public static final int NEW=98;
    public static final int NEW_LINE=99;
    public static final int NEW_LINE_CHARACTER=100;
    public static final int NULL=101;
    public static final int Not_number_sign=102;
    public static final int Not_slash_or_asterisk=103;
    public static final int OBJECT=104;
    public static final int OPEN_BRACE=105;
    public static final int OPEN_BRACKET=106;
    public static final int OPEN_PARENS=107;
    public static final int OPERATOR=108;
    public static final int OP_ADD_ASSIGNMENT=109;
    public static final int OP_AND=110;
    public static final int OP_AND_ASSIGNMENT=111;
    public static final int OP_COALESCING=112;
    public static final int OP_DEC=113;
    public static final int OP_DIV_ASSIGNMENT=114;
    public static final int OP_EQ=115;
    public static final int OP_GE=116;
    public static final int OP_INC=117;
    public static final int OP_LE=118;
    public static final int OP_LEFT_SHIFT=119;
    public static final int OP_LEFT_SHIFT_ASSIGNMENT=120;
    public static final int OP_MOD_ASSIGNMENT=121;
    public static final int OP_MULT_ASSIGNMENT=122;
    public static final int OP_NE=123;
    public static final int OP_OR=124;
    public static final int OP_OR_ASSIGNMENT=125;
    public static final int OP_PTR=126;
    public static final int OP_SUB_ASSIGNMENT=127;
    public static final int OP_XOR_ASSIGNMENT=128;
    public static final int OUT=129;
    public static final int OVERRIDE=130;
    public static final int PARAMS=131;
    public static final int PERCENT=132;
    public static final int PLUS=133;
    public static final int PRIVATE=134;
    public static final int PROTECTED=135;
    public static final int PUBLIC=136;
    public static final int Pp_and_expression=137;
    public static final int Pp_conditional=138;
    public static final int Pp_declaration=139;
    public static final int Pp_diagnostic=140;
    public static final int Pp_directive=141;
    public static final int Pp_elif_section=142;
    public static final int Pp_else_section=143;
    public static final int Pp_end_region=144;
    public static final int Pp_endif=145;
    public static final int Pp_equality_expression=146;
    public static final int Pp_expression=147;
    public static final int Pp_if_section=148;
    public static final int Pp_line=149;
    public static final int Pp_message=150;
    public static final int Pp_new_line=151;
    public static final int Pp_or_expression=152;
    public static final int Pp_pragma=153;
    public static final int Pp_pragma_text=154;
    public static final int Pp_primary_expression=155;
    public static final int Pp_region=156;
    public static final int Pp_start_region=157;
    public static final int Pp_unary_expression=158;
    public static final int QUOTE=159;
    public static final int Quote_escape_sequence=160;
    public static final int READONLY=161;
    public static final int REAL_LITERAL=162;
    public static final int REF=163;
    public static final int RETURN=164;
    public static final int Real_type_suffix=165;
    public static final int Regular_string_literal=166;
    public static final int Regular_string_literal_character=167;
    public static final int SBYTE=168;
    public static final int SEALED=169;
    public static final int SEMICOLON=170;
    public static final int SHARP=171;
    public static final int SHORT=172;
    public static final int SINGLE_LINE_COMMENT=173;
    public static final int SINGLE_LINE_DOC_COMMENT=174;
    public static final int SIZEOF=175;
    public static final int STACKALLOC=176;
    public static final int STAR=177;
    public static final int STATIC=178;
    public static final int STRING=179;
    public static final int STRING_LITERAL=180;
    public static final int STRUCT=181;
    public static final int SWITCH=182;
    public static final int Sign=183;
    public static final int Simple_escape_sequence=184;
    public static final int Single_character=185;
    public static final int Single_regular_string_literal_character=186;
    public static final int Single_verbatim_string_literal_character=187;
    public static final int SkiPped_characters=188;
    public static final int SkiPped_section_part=189;
    public static final int THIS=190;
    public static final int THROW=191;
    public static final int TILDE=192;
    public static final int TRUE=193;
    public static final int TRY=194;
    public static final int TYPEOF=195;
    public static final int Tokens=196;
    public static final int UINT=197;
    public static final int ULONG=198;
    public static final int UNCHECKED=199;
    public static final int UNICODE_CLASS_CF=200;
    public static final int UNICODE_CLASS_LL=201;
    public static final int UNICODE_CLASS_LM=202;
    public static final int UNICODE_CLASS_LO=203;
    public static final int UNICODE_CLASS_LT=204;
    public static final int UNICODE_CLASS_LU=205;
    public static final int UNICODE_CLASS_MC=206;
    public static final int UNICODE_CLASS_MN=207;
    public static final int UNICODE_CLASS_ND=208;
    public static final int UNICODE_CLASS_NL=209;
    public static final int UNICODE_CLASS_PC=210;
    public static final int UNICODE_CLASS_ZS=211;
    public static final int UNSAFE=212;
    public static final int USHORT=213;
    public static final int USING=214;
    public static final int Unicode_escape_sequence=215;
    public static final int VIRTUAL=216;
    public static final int VOID=217;
    public static final int VOLATILE=218;
    public static final int Verbatim_string_literal=219;
    public static final int Verbatim_string_literal_character=220;
    public static final int WHILE=221;
    public static final int WHITESPACE=222;
    public static final int Whitespace_character=223;
    public static final int Whitespace_characters=224;
    public static final int ARGUMENT=225;
    public static final int ARGUMENT_VALUE=226;
    public static final int ARRAY_ACCESS=227;
    public static final int ASSIGNMENT_OPERATOR=228;
    public static final int ATTRIBUTE=229;
    public static final int ATTRIBUTES=230;
    public static final int ATTRIBUTE_LIST=231;
    public static final int ATTRIBUTE_NAME=232;
    public static final int ATTRIBUTE_TARGET=233;
    public static final int BLOCK=234;
    public static final int BOOL_NOT=235;
    public static final int CAST_EXPRESSION=236;
    public static final int CLASS_MEMBER_DECLARATIONS=237;
    public static final int CONDITION=238;
    public static final int CONDITIONAL_EXPRESSION=239;
    public static final int CONSTANT_DECLARATOR=240;
    public static final int CONSTANT_DECLARATORS=241;
    public static final int CONSTANT_INITIALIZER=242;
    public static final int CONSTRUCTOR_DECL=243;
    public static final int CSHARP_SOURCE=244;
    public static final int ENUM_EXTENDS=245;
    public static final int ENUM_MEMBER_DECLARATION=246;
    public static final int ENUM_MEMBER_DECLARATIONS=247;
    public static final int ENUM_MEMBER_INITIALIZER=248;
    public static final int EXPRESSION_STATEMENT=249;
    public static final int EXTENDS_OR_IMPLEMENTS=250;
    public static final int EXTERN_ALIAS_DIRECTIVES=251;
    public static final int FIELD_DECL=252;
    public static final int FIRST_OP=253;
    public static final int FIXED_PARAMETER=254;
    public static final int FORMAL_PARAMETER_LIST=255;
    public static final int FOR_INITIALIZER=256;
    public static final int FOR_ITERATOR=257;
    public static final int IMPLEMENTS=258;
    public static final int INDEXER_DECL=259;
    public static final int INTERFACE_MEMBER_DECLARATIONS=260;
    public static final int LABELED_STATEMENT=261;
    public static final int LOCAL_VARIABLE_DECLARATION=262;
    public static final int LOCAL_VARIABLE_DECLARATOR=263;
    public static final int LOCAL_VARIABLE_INITIALIZER=264;
    public static final int LOOP_BODY=265;
    public static final int MEMBER_ACCESS=266;
    public static final int MEMBER_NAME=267;
    public static final int METHOD_DECL=268;
    public static final int METHOD_INVOCATION=269;
    public static final int MODIFIERS=270;
    public static final int NAMESPACE_MEMBER_DECLARATIONS=271;
    public static final int NAMESPACE_OR_TYPE_NAME=272;
    public static final int NAMESPACE_OR_TYPE_PART=273;
    public static final int OBJECT_CREATION_EXPRESSION=274;
    public static final int OP_RIGHT_SHIFT=275;
    public static final int OP_RIGHT_SHIFT_ASSIGNMENT=276;
    public static final int PARAMETER_ARRAY=277;
    public static final int PARAMETER_MODIFIER=278;
    public static final int POSITIONAL_ARGUMENT_LIST=279;
    public static final int POST_DEC=280;
    public static final int POST_INC=281;
    public static final int PROPERTY_DECL=282;
    public static final int QUALIFIED_ALIAS_MEMBER=283;
    public static final int QUALIFIED_IDENTIFIER=284;
    public static final int RANK_SPECIFIER=285;
    public static final int SECOND_OP=286;
    public static final int SIMPLE_NAME=287;
    public static final int STRUCT_MEMBER_DECLARATIONS=288;
    public static final int THEN=289;
    public static final int TYPE=290;
    public static final int TYPE_ARGUMENT_LIST=291;
    public static final int TYPE_PARAM=292;
    public static final int TYPE_PARAMETERS=293;
    public static final int TYPE_PARAMETER_CONSTRAINTS_CLAUSE=294;
    public static final int TYPE_PARAMETER_CONSTRAINTS_CLAUSES=295;
    public static final int UNARY_EXPRESSION=296;
    public static final int USING_ALIAS_DIRECTIVE=297;
    public static final int USING_DIRECTIVES=298;
    public static final int USING_NAMESPACE_DIRECTIVE=299;
    public static final int VARIABLE_DECLARATOR=300;
    public static final int VARIABLE_INITIALIZER=301;
    public static final int VARIANCE_ANNOTATION=302;
    public static final int VARIANT_TYPE_PARAMETERS=303;

    // delegates
    public Parser[] getDelegates() {
        return new Parser[] {};
    }

    // delegators


    public CSharp4AST(TokenStream input) {
        this(input, new RecognizerSharedState());
    }
    public CSharp4AST(TokenStream input, RecognizerSharedState state) {
        super(input, state);
    }

protected TreeAdaptor adaptor = new CommonTreeAdaptor();

public void setTreeAdaptor(TreeAdaptor adaptor) {
    this.adaptor = adaptor;
}
public TreeAdaptor getTreeAdaptor() {
    return adaptor;
}
    public String[] getTokenNames() { return CSharp4AST.tokenNames; }
    public String getGrammarFileName() { return "E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g"; }


    // the following methods are only used for debug purposes
    private List<String> errors = new LinkedList<String>();

    @Override
    public void displayRecognitionError(String[] tokenNames, RecognitionException e) {
        super.displayRecognitionError(tokenNames, e);
        String hdr = getErrorHeader(e);
        String msg = getErrorMessage(e, tokenNames);
        errors.add(hdr + " " + msg);
    }

    public List<String> getErrors() {
        return errors;
    }

    private void next(int n) {
      System.err.print("next: ");
      for (int i=1; i<=n; i++) {
        System.err.print(" | " + input.LT(i).getType() + "=" + input.LT(i).getText());
      }
      System.err.println();
    }

    // scope variables
    Object attrs;
    Object members;



    public static class namespace_name_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "namespace_name"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:173:1: namespace_name : namespace_or_type_name ;
    public final CSharp4AST.namespace_name_return namespace_name() throws RecognitionException {
        CSharp4AST.namespace_name_return retval = new CSharp4AST.namespace_name_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.namespace_or_type_name_return namespace_or_type_name1 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:174:2: ( namespace_or_type_name )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:174:4: namespace_or_type_name
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_namespace_or_type_name_in_namespace_name572);
            namespace_or_type_name1=namespace_or_type_name();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, namespace_or_type_name1.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "namespace_name"


    public static class type_name_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "type_name"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:176:1: type_name : namespace_or_type_name ;
    public final CSharp4AST.type_name_return type_name() throws RecognitionException {
        CSharp4AST.type_name_return retval = new CSharp4AST.type_name_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.namespace_or_type_name_return namespace_or_type_name2 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:177:2: ( namespace_or_type_name )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:177:4: namespace_or_type_name
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_namespace_or_type_name_in_type_name583);
            namespace_or_type_name2=namespace_or_type_name();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, namespace_or_type_name2.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "type_name"


    public static class namespace_or_type_name_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "namespace_or_type_name"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:187:1: namespace_or_type_name : namespace_or_type_name2 -> ^( NAMESPACE_OR_TYPE_NAME namespace_or_type_name2 ) ;
    public final CSharp4AST.namespace_or_type_name_return namespace_or_type_name() throws RecognitionException {
        CSharp4AST.namespace_or_type_name_return retval = new CSharp4AST.namespace_or_type_name_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.namespace_or_type_name2_return namespace_or_type_name23 =null;


        RewriteRuleSubtreeStream stream_namespace_or_type_name2=new RewriteRuleSubtreeStream(adaptor,"rule namespace_or_type_name2");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:188:3: ( namespace_or_type_name2 -> ^( NAMESPACE_OR_TYPE_NAME namespace_or_type_name2 ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:188:5: namespace_or_type_name2
            {
            pushFollow(FOLLOW_namespace_or_type_name2_in_namespace_or_type_name597);
            namespace_or_type_name23=namespace_or_type_name2();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_namespace_or_type_name2.add(namespace_or_type_name23.getTree());

            // AST REWRITE
            // elements: namespace_or_type_name2
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 188:29: -> ^( NAMESPACE_OR_TYPE_NAME namespace_or_type_name2 )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:188:32: ^( NAMESPACE_OR_TYPE_NAME namespace_or_type_name2 )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(NAMESPACE_OR_TYPE_NAME, "NAMESPACE_OR_TYPE_NAME")
                , root_1);

                adaptor.addChild(root_1, stream_namespace_or_type_name2.nextTree());

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "namespace_or_type_name"


    public static class namespace_or_type_name2_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "namespace_or_type_name2"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:190:1: namespace_or_type_name2 : ( IDENTIFIER type_argument_list_opt | qualified_alias_member ) ( namespace_part )* ;
    public final CSharp4AST.namespace_or_type_name2_return namespace_or_type_name2() throws RecognitionException {
        CSharp4AST.namespace_or_type_name2_return retval = new CSharp4AST.namespace_or_type_name2_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER4=null;
        CSharp4AST.type_argument_list_opt_return type_argument_list_opt5 =null;

        CSharp4AST.qualified_alias_member_return qualified_alias_member6 =null;

        CSharp4AST.namespace_part_return namespace_part7 =null;


        Object IDENTIFIER4_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:191:3: ( ( IDENTIFIER type_argument_list_opt | qualified_alias_member ) ( namespace_part )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:191:5: ( IDENTIFIER type_argument_list_opt | qualified_alias_member ) ( namespace_part )*
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:191:5: ( IDENTIFIER type_argument_list_opt | qualified_alias_member )
            int alt1=2;
            int LA1_0 = input.LA(1);

            if ( (LA1_0==IDENTIFIER) ) {
                int LA1_1 = input.LA(2);

                if ( (LA1_1==DOUBLE_COLON) ) {
                    alt1=2;
                }
                else if ( (LA1_1==EOF||(LA1_1 >= AMP && LA1_1 <= AS)||LA1_1==BITWISE_OR||LA1_1==CARET||(LA1_1 >= CLOSE_BRACE && LA1_1 <= COMMA)||LA1_1==DOT||LA1_1==GT||LA1_1==IDENTIFIER||(LA1_1 >= INTERR && LA1_1 <= IS)||LA1_1==LT||(LA1_1 >= OPEN_BRACE && LA1_1 <= OPERATOR)||LA1_1==OP_AND||LA1_1==OP_COALESCING||(LA1_1 >= OP_EQ && LA1_1 <= OP_GE)||LA1_1==OP_LE||(LA1_1 >= OP_NE && LA1_1 <= OP_OR)||LA1_1==SEMICOLON||LA1_1==STAR||LA1_1==THIS) ) {
                    alt1=1;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 1, 1, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 1, 0, input);

                throw nvae;

            }
            switch (alt1) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:191:7: IDENTIFIER type_argument_list_opt
                    {
                    IDENTIFIER4=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_namespace_or_type_name2620); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    IDENTIFIER4_tree = 
                    (Object)adaptor.create(IDENTIFIER4)
                    ;
                    adaptor.addChild(root_0, IDENTIFIER4_tree);
                    }

                    pushFollow(FOLLOW_type_argument_list_opt_in_namespace_or_type_name2622);
                    type_argument_list_opt5=type_argument_list_opt();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, type_argument_list_opt5.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:192:7: qualified_alias_member
                    {
                    pushFollow(FOLLOW_qualified_alias_member_in_namespace_or_type_name2630);
                    qualified_alias_member6=qualified_alias_member();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, qualified_alias_member6.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:193:7: ( namespace_part )*
            loop2:
            do {
                int alt2=2;
                int LA2_0 = input.LA(1);

                if ( (LA2_0==DOT) ) {
                    int LA2_2 = input.LA(2);

                    if ( (LA2_2==IDENTIFIER) ) {
                        alt2=1;
                    }


                }


                switch (alt2) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:193:7: namespace_part
            	    {
            	    pushFollow(FOLLOW_namespace_part_in_namespace_or_type_name2638);
            	    namespace_part7=namespace_part();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, namespace_part7.getTree());

            	    }
            	    break;

            	default :
            	    break loop2;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "namespace_or_type_name2"


    public static class namespace_part_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "namespace_part"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:197:1: namespace_part : DOT id2= IDENTIFIER type_argument_list_opt -> ^( NAMESPACE_OR_TYPE_PART $id2 ( type_argument_list_opt )? ) ;
    public final CSharp4AST.namespace_part_return namespace_part() throws RecognitionException {
        CSharp4AST.namespace_part_return retval = new CSharp4AST.namespace_part_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token id2=null;
        Token DOT8=null;
        CSharp4AST.type_argument_list_opt_return type_argument_list_opt9 =null;


        Object id2_tree=null;
        Object DOT8_tree=null;
        RewriteRuleTokenStream stream_DOT=new RewriteRuleTokenStream(adaptor,"token DOT");
        RewriteRuleTokenStream stream_IDENTIFIER=new RewriteRuleTokenStream(adaptor,"token IDENTIFIER");
        RewriteRuleSubtreeStream stream_type_argument_list_opt=new RewriteRuleSubtreeStream(adaptor,"rule type_argument_list_opt");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:198:3: ( DOT id2= IDENTIFIER type_argument_list_opt -> ^( NAMESPACE_OR_TYPE_PART $id2 ( type_argument_list_opt )? ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:198:5: DOT id2= IDENTIFIER type_argument_list_opt
            {
            DOT8=(Token)match(input,DOT,FOLLOW_DOT_in_namespace_part653); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_DOT.add(DOT8);


            id2=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_namespace_part657); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_IDENTIFIER.add(id2);


            pushFollow(FOLLOW_type_argument_list_opt_in_namespace_part659);
            type_argument_list_opt9=type_argument_list_opt();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_type_argument_list_opt.add(type_argument_list_opt9.getTree());

            // AST REWRITE
            // elements: id2, type_argument_list_opt
            // token labels: id2
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleTokenStream stream_id2=new RewriteRuleTokenStream(adaptor,"token id2",id2);
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 199:5: -> ^( NAMESPACE_OR_TYPE_PART $id2 ( type_argument_list_opt )? )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:199:8: ^( NAMESPACE_OR_TYPE_PART $id2 ( type_argument_list_opt )? )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(NAMESPACE_OR_TYPE_PART, "NAMESPACE_OR_TYPE_PART")
                , root_1);

                adaptor.addChild(root_1, stream_id2.nextNode());

                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:199:38: ( type_argument_list_opt )?
                if ( stream_type_argument_list_opt.hasNext() ) {
                    adaptor.addChild(root_1, stream_type_argument_list_opt.nextTree());

                }
                stream_type_argument_list_opt.reset();

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "namespace_part"


    public static class type_argument_list_opt_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "type_argument_list_opt"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:203:1: type_argument_list_opt : ( ( type_argument_list )=> type_argument_list |);
    public final CSharp4AST.type_argument_list_opt_return type_argument_list_opt() throws RecognitionException {
        CSharp4AST.type_argument_list_opt_return retval = new CSharp4AST.type_argument_list_opt_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.type_argument_list_return type_argument_list10 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:204:3: ( ( type_argument_list )=> type_argument_list |)
            int alt3=2;
            int LA3_0 = input.LA(1);

            if ( (LA3_0==LT) ) {
                int LA3_1 = input.LA(2);

                if ( (synpred1_CSharp4AST()) ) {
                    alt3=1;
                }
                else if ( (true) ) {
                    alt3=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 3, 1, input);

                    throw nvae;

                }
            }
            else if ( (LA3_0==EOF||(LA3_0 >= AMP && LA3_0 <= ASSIGNMENT)||LA3_0==BITWISE_OR||LA3_0==CARET||(LA3_0 >= CLOSE_BRACE && LA3_0 <= COMMA)||LA3_0==DIV||LA3_0==DOT||LA3_0==GT||LA3_0==IDENTIFIER||(LA3_0 >= INTERR && LA3_0 <= IS)||LA3_0==MINUS||(LA3_0 >= OPEN_BRACE && LA3_0 <= OP_XOR_ASSIGNMENT)||(LA3_0 >= PERCENT && LA3_0 <= PLUS)||LA3_0==SEMICOLON||LA3_0==STAR||LA3_0==THIS) ) {
                alt3=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 3, 0, input);

                throw nvae;

            }
            switch (alt3) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:204:5: ( type_argument_list )=> type_argument_list
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_type_argument_list_in_type_argument_list_opt696);
                    type_argument_list10=type_argument_list();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, type_argument_list10.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:206:3: 
                    {
                    root_0 = (Object)adaptor.nil();


                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "type_argument_list_opt"


    public static class type_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "type"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:216:1: type : type2 -> ^( TYPE type2 ) ;
    public final CSharp4AST.type_return type() throws RecognitionException {
        CSharp4AST.type_return retval = new CSharp4AST.type_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.type2_return type211 =null;


        RewriteRuleSubtreeStream stream_type2=new RewriteRuleSubtreeStream(adaptor,"rule type2");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:217:3: ( type2 -> ^( TYPE type2 ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:217:5: type2
            {
            pushFollow(FOLLOW_type2_in_type720);
            type211=type2();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_type2.add(type211.getTree());

            // AST REWRITE
            // elements: type2
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 218:5: -> ^( TYPE type2 )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:218:8: ^( TYPE type2 )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(TYPE, "TYPE")
                , root_1);

                adaptor.addChild(root_1, stream_type2.nextTree());

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "type"


    public static class type2_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "type2"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:221:1: type2 : base_type ( ( INTERR )=> INTERR | ( rank_specifier )=> rank_specifier | STAR )* ;
    public final CSharp4AST.type2_return type2() throws RecognitionException {
        CSharp4AST.type2_return retval = new CSharp4AST.type2_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token INTERR13=null;
        Token STAR15=null;
        CSharp4AST.base_type_return base_type12 =null;

        CSharp4AST.rank_specifier_return rank_specifier14 =null;


        Object INTERR13_tree=null;
        Object STAR15_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:222:3: ( base_type ( ( INTERR )=> INTERR | ( rank_specifier )=> rank_specifier | STAR )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:222:5: base_type ( ( INTERR )=> INTERR | ( rank_specifier )=> rank_specifier | STAR )*
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_base_type_in_type2745);
            base_type12=base_type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, base_type12.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:223:5: ( ( INTERR )=> INTERR | ( rank_specifier )=> rank_specifier | STAR )*
            loop4:
            do {
                int alt4=4;
                switch ( input.LA(1) ) {
                case OPEN_BRACKET:
                    {
                    int LA4_5 = input.LA(2);

                    if ( (synpred3_CSharp4AST()) ) {
                        alt4=2;
                    }


                    }
                    break;
                case INTERR:
                    {
                    int LA4_15 = input.LA(2);

                    if ( (synpred2_CSharp4AST()) ) {
                        alt4=1;
                    }


                    }
                    break;
                case STAR:
                    {
                    alt4=3;
                    }
                    break;

                }

                switch (alt4) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:223:7: ( INTERR )=> INTERR
            	    {
            	    INTERR13=(Token)match(input,INTERR,FOLLOW_INTERR_in_type2759); if (state.failed) return retval;
            	    if ( state.backtracking==0 ) {
            	    INTERR13_tree = 
            	    (Object)adaptor.create(INTERR13)
            	    ;
            	    adaptor.addChild(root_0, INTERR13_tree);
            	    }

            	    }
            	    break;
            	case 2 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:224:7: ( rank_specifier )=> rank_specifier
            	    {
            	    pushFollow(FOLLOW_rank_specifier_in_type2793);
            	    rank_specifier14=rank_specifier();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, rank_specifier14.getTree());

            	    }
            	    break;
            	case 3 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:225:7: STAR
            	    {
            	    STAR15=(Token)match(input,STAR,FOLLOW_STAR_in_type2804); if (state.failed) return retval;
            	    if ( state.backtracking==0 ) {
            	    STAR15_tree = 
            	    (Object)adaptor.create(STAR15)
            	    ;
            	    adaptor.addChild(root_0, STAR15_tree);
            	    }

            	    }
            	    break;

            	default :
            	    break loop4;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "type2"


    public static class base_type_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "base_type"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:229:1: base_type : ( simple_type | class_type | VOID STAR );
    public final CSharp4AST.base_type_return base_type() throws RecognitionException {
        CSharp4AST.base_type_return retval = new CSharp4AST.base_type_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token VOID18=null;
        Token STAR19=null;
        CSharp4AST.simple_type_return simple_type16 =null;

        CSharp4AST.class_type_return class_type17 =null;


        Object VOID18_tree=null;
        Object STAR19_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:230:3: ( simple_type | class_type | VOID STAR )
            int alt5=3;
            switch ( input.LA(1) ) {
            case BOOL:
            case BYTE:
            case CHAR:
            case DECIMAL:
            case DOUBLE:
            case FLOAT:
            case INT:
            case LONG:
            case SBYTE:
            case SHORT:
            case UINT:
            case ULONG:
            case USHORT:
                {
                alt5=1;
                }
                break;
            case IDENTIFIER:
            case OBJECT:
            case STRING:
                {
                alt5=2;
                }
                break;
            case VOID:
                {
                alt5=3;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 5, 0, input);

                throw nvae;

            }

            switch (alt5) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:230:5: simple_type
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_simple_type_in_base_type858);
                    simple_type16=simple_type();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, simple_type16.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:231:5: class_type
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_class_type_in_base_type864);
                    class_type17=class_type();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, class_type17.getTree());

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:232:5: VOID STAR
                    {
                    root_0 = (Object)adaptor.nil();


                    VOID18=(Token)match(input,VOID,FOLLOW_VOID_in_base_type872); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    VOID18_tree = 
                    (Object)adaptor.create(VOID18)
                    ;
                    adaptor.addChild(root_0, VOID18_tree);
                    }

                    STAR19=(Token)match(input,STAR,FOLLOW_STAR_in_base_type874); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    STAR19_tree = 
                    (Object)adaptor.create(STAR19)
                    ;
                    adaptor.addChild(root_0, STAR19_tree);
                    }

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "base_type"


    public static class simple_type_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "simple_type"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:246:1: simple_type : ( numeric_type | BOOL );
    public final CSharp4AST.simple_type_return simple_type() throws RecognitionException {
        CSharp4AST.simple_type_return retval = new CSharp4AST.simple_type_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token BOOL21=null;
        CSharp4AST.numeric_type_return numeric_type20 =null;


        Object BOOL21_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:247:2: ( numeric_type | BOOL )
            int alt6=2;
            int LA6_0 = input.LA(1);

            if ( (LA6_0==BYTE||LA6_0==CHAR||LA6_0==DECIMAL||LA6_0==DOUBLE||LA6_0==FLOAT||LA6_0==INT||LA6_0==LONG||LA6_0==SBYTE||LA6_0==SHORT||(LA6_0 >= UINT && LA6_0 <= ULONG)||LA6_0==USHORT) ) {
                alt6=1;
            }
            else if ( (LA6_0==BOOL) ) {
                alt6=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 6, 0, input);

                throw nvae;

            }
            switch (alt6) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:247:4: numeric_type
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_numeric_type_in_simple_type890);
                    numeric_type20=numeric_type();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, numeric_type20.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:248:4: BOOL
                    {
                    root_0 = (Object)adaptor.nil();


                    BOOL21=(Token)match(input,BOOL,FOLLOW_BOOL_in_simple_type895); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    BOOL21_tree = 
                    (Object)adaptor.create(BOOL21)
                    ;
                    adaptor.addChild(root_0, BOOL21_tree);
                    }

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "simple_type"


    public static class numeric_type_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "numeric_type"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:250:1: numeric_type : ( integral_type | floating_point_type | DECIMAL );
    public final CSharp4AST.numeric_type_return numeric_type() throws RecognitionException {
        CSharp4AST.numeric_type_return retval = new CSharp4AST.numeric_type_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token DECIMAL24=null;
        CSharp4AST.integral_type_return integral_type22 =null;

        CSharp4AST.floating_point_type_return floating_point_type23 =null;


        Object DECIMAL24_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:251:2: ( integral_type | floating_point_type | DECIMAL )
            int alt7=3;
            switch ( input.LA(1) ) {
            case BYTE:
            case CHAR:
            case INT:
            case LONG:
            case SBYTE:
            case SHORT:
            case UINT:
            case ULONG:
            case USHORT:
                {
                alt7=1;
                }
                break;
            case DOUBLE:
            case FLOAT:
                {
                alt7=2;
                }
                break;
            case DECIMAL:
                {
                alt7=3;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 7, 0, input);

                throw nvae;

            }

            switch (alt7) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:251:4: integral_type
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_integral_type_in_numeric_type906);
                    integral_type22=integral_type();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, integral_type22.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:252:4: floating_point_type
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_floating_point_type_in_numeric_type911);
                    floating_point_type23=floating_point_type();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, floating_point_type23.getTree());

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:253:4: DECIMAL
                    {
                    root_0 = (Object)adaptor.nil();


                    DECIMAL24=(Token)match(input,DECIMAL,FOLLOW_DECIMAL_in_numeric_type916); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    DECIMAL24_tree = 
                    (Object)adaptor.create(DECIMAL24)
                    ;
                    adaptor.addChild(root_0, DECIMAL24_tree);
                    }

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "numeric_type"


    public static class integral_type_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "integral_type"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:255:1: integral_type : ( SBYTE | BYTE | SHORT | USHORT | INT | UINT | LONG | ULONG | CHAR );
    public final CSharp4AST.integral_type_return integral_type() throws RecognitionException {
        CSharp4AST.integral_type_return retval = new CSharp4AST.integral_type_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token set25=null;

        Object set25_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:256:2: ( SBYTE | BYTE | SHORT | USHORT | INT | UINT | LONG | ULONG | CHAR )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:
            {
            root_0 = (Object)adaptor.nil();


            set25=(Token)input.LT(1);

            if ( input.LA(1)==BYTE||input.LA(1)==CHAR||input.LA(1)==INT||input.LA(1)==LONG||input.LA(1)==SBYTE||input.LA(1)==SHORT||(input.LA(1) >= UINT && input.LA(1) <= ULONG)||input.LA(1)==USHORT ) {
                input.consume();
                if ( state.backtracking==0 ) adaptor.addChild(root_0, 
                (Object)adaptor.create(set25)
                );
                state.errorRecovery=false;
                state.failed=false;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                MismatchedSetException mse = new MismatchedSetException(null,input);
                throw mse;
            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "integral_type"


    public static class floating_point_type_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "floating_point_type"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:266:1: floating_point_type : ( FLOAT | DOUBLE );
    public final CSharp4AST.floating_point_type_return floating_point_type() throws RecognitionException {
        CSharp4AST.floating_point_type_return retval = new CSharp4AST.floating_point_type_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token set26=null;

        Object set26_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:267:2: ( FLOAT | DOUBLE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:
            {
            root_0 = (Object)adaptor.nil();


            set26=(Token)input.LT(1);

            if ( input.LA(1)==DOUBLE||input.LA(1)==FLOAT ) {
                input.consume();
                if ( state.backtracking==0 ) adaptor.addChild(root_0, 
                (Object)adaptor.create(set26)
                );
                state.errorRecovery=false;
                state.failed=false;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                MismatchedSetException mse = new MismatchedSetException(null,input);
                throw mse;
            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "floating_point_type"


    public static class nullable_type_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "nullable_type"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:270:1: nullable_type : non_nullable_value_type INTERR ;
    public final CSharp4AST.nullable_type_return nullable_type() throws RecognitionException {
        CSharp4AST.nullable_type_return retval = new CSharp4AST.nullable_type_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token INTERR28=null;
        CSharp4AST.non_nullable_value_type_return non_nullable_value_type27 =null;


        Object INTERR28_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:271:2: ( non_nullable_value_type INTERR )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:271:4: non_nullable_value_type INTERR
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_non_nullable_value_type_in_nullable_type994);
            non_nullable_value_type27=non_nullable_value_type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, non_nullable_value_type27.getTree());

            INTERR28=(Token)match(input,INTERR,FOLLOW_INTERR_in_nullable_type996); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            INTERR28_tree = 
            (Object)adaptor.create(INTERR28)
            ;
            adaptor.addChild(root_0, INTERR28_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "nullable_type"


    public static class non_nullable_value_type_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "non_nullable_value_type"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:279:1: non_nullable_value_type : base_type ( ( rank_specifier )=> rank_specifier | STAR )* ;
    public final CSharp4AST.non_nullable_value_type_return non_nullable_value_type() throws RecognitionException {
        CSharp4AST.non_nullable_value_type_return retval = new CSharp4AST.non_nullable_value_type_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token STAR31=null;
        CSharp4AST.base_type_return base_type29 =null;

        CSharp4AST.rank_specifier_return rank_specifier30 =null;


        Object STAR31_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:280:2: ( base_type ( ( rank_specifier )=> rank_specifier | STAR )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:280:4: base_type ( ( rank_specifier )=> rank_specifier | STAR )*
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_base_type_in_non_nullable_value_type1010);
            base_type29=base_type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, base_type29.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:281:5: ( ( rank_specifier )=> rank_specifier | STAR )*
            loop8:
            do {
                int alt8=3;
                int LA8_0 = input.LA(1);

                if ( (LA8_0==OPEN_BRACKET) && (synpred4_CSharp4AST())) {
                    alt8=1;
                }
                else if ( (LA8_0==STAR) ) {
                    alt8=2;
                }


                switch (alt8) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:281:7: ( rank_specifier )=> rank_specifier
            	    {
            	    pushFollow(FOLLOW_rank_specifier_in_non_nullable_value_type1024);
            	    rank_specifier30=rank_specifier();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, rank_specifier30.getTree());

            	    }
            	    break;
            	case 2 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:282:7: STAR
            	    {
            	    STAR31=(Token)match(input,STAR,FOLLOW_STAR_in_non_nullable_value_type1032); if (state.failed) return retval;
            	    if ( state.backtracking==0 ) {
            	    STAR31_tree = 
            	    (Object)adaptor.create(STAR31)
            	    ;
            	    adaptor.addChild(root_0, STAR31_tree);
            	    }

            	    }
            	    break;

            	default :
            	    break loop8;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "non_nullable_value_type"


    public static class reference_type_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "reference_type"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:298:1: reference_type : ( simple_type | class_type | VOID STAR ) ( ( STAR | INTERR )* rank_specifier )* ({...}? ( STAR | INTERR )* rank_specifier ) ;
    public final CSharp4AST.reference_type_return reference_type() throws RecognitionException {
        CSharp4AST.reference_type_return retval = new CSharp4AST.reference_type_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token VOID34=null;
        Token STAR35=null;
        Token set36=null;
        Token set38=null;
        CSharp4AST.simple_type_return simple_type32 =null;

        CSharp4AST.class_type_return class_type33 =null;

        CSharp4AST.rank_specifier_return rank_specifier37 =null;

        CSharp4AST.rank_specifier_return rank_specifier39 =null;


        Object VOID34_tree=null;
        Object STAR35_tree=null;
        Object set36_tree=null;
        Object set38_tree=null;

        boolean oneOrMore = false;
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:300:3: ( ( simple_type | class_type | VOID STAR ) ( ( STAR | INTERR )* rank_specifier )* ({...}? ( STAR | INTERR )* rank_specifier ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:300:5: ( simple_type | class_type | VOID STAR ) ( ( STAR | INTERR )* rank_specifier )* ({...}? ( STAR | INTERR )* rank_specifier )
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:300:5: ( simple_type | class_type | VOID STAR )
            int alt9=3;
            switch ( input.LA(1) ) {
            case BOOL:
            case BYTE:
            case CHAR:
            case DECIMAL:
            case DOUBLE:
            case FLOAT:
            case INT:
            case LONG:
            case SBYTE:
            case SHORT:
            case UINT:
            case ULONG:
            case USHORT:
                {
                alt9=1;
                }
                break;
            case IDENTIFIER:
            case OBJECT:
            case STRING:
                {
                alt9=2;
                }
                break;
            case VOID:
                {
                alt9=3;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 9, 0, input);

                throw nvae;

            }

            switch (alt9) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:300:7: simple_type
                    {
                    pushFollow(FOLLOW_simple_type_in_reference_type1062);
                    simple_type32=simple_type();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, simple_type32.getTree());

                    if ( state.backtracking==0 ) {oneOrMore=true;}

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:301:7: class_type
                    {
                    pushFollow(FOLLOW_class_type_in_reference_type1072);
                    class_type33=class_type();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, class_type33.getTree());

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:302:7: VOID STAR
                    {
                    VOID34=(Token)match(input,VOID,FOLLOW_VOID_in_reference_type1080); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    VOID34_tree = 
                    (Object)adaptor.create(VOID34)
                    ;
                    adaptor.addChild(root_0, VOID34_tree);
                    }

                    STAR35=(Token)match(input,STAR,FOLLOW_STAR_in_reference_type1082); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    STAR35_tree = 
                    (Object)adaptor.create(STAR35)
                    ;
                    adaptor.addChild(root_0, STAR35_tree);
                    }

                    if ( state.backtracking==0 ) {oneOrMore=true;}

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:303:5: ( ( STAR | INTERR )* rank_specifier )*
            loop11:
            do {
                int alt11=2;
                alt11 = dfa11.predict(input);
                switch (alt11) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:303:6: ( STAR | INTERR )* rank_specifier
            	    {
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:303:6: ( STAR | INTERR )*
            	    loop10:
            	    do {
            	        int alt10=2;
            	        int LA10_0 = input.LA(1);

            	        if ( (LA10_0==INTERR||LA10_0==STAR) ) {
            	            alt10=1;
            	        }


            	        switch (alt10) {
            	    	case 1 :
            	    	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:
            	    	    {
            	    	    set36=(Token)input.LT(1);

            	    	    if ( input.LA(1)==INTERR||input.LA(1)==STAR ) {
            	    	        input.consume();
            	    	        if ( state.backtracking==0 ) adaptor.addChild(root_0, 
            	    	        (Object)adaptor.create(set36)
            	    	        );
            	    	        state.errorRecovery=false;
            	    	        state.failed=false;
            	    	    }
            	    	    else {
            	    	        if (state.backtracking>0) {state.failed=true; return retval;}
            	    	        MismatchedSetException mse = new MismatchedSetException(null,input);
            	    	        throw mse;
            	    	    }


            	    	    }
            	    	    break;

            	    	default :
            	    	    break loop10;
            	        }
            	    } while (true);


            	    pushFollow(FOLLOW_rank_specifier_in_reference_type1100);
            	    rank_specifier37=rank_specifier();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, rank_specifier37.getTree());

            	    }
            	    break;

            	default :
            	    break loop11;
                }
            } while (true);


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:304:5: ({...}? ( STAR | INTERR )* rank_specifier )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:304:6: {...}? ( STAR | INTERR )* rank_specifier
            {
            if ( !((oneOrMore)) ) {
                if (state.backtracking>0) {state.failed=true; return retval;}
                throw new FailedPredicateException(input, "reference_type", "oneOrMore");
            }

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:304:19: ( STAR | INTERR )*
            loop12:
            do {
                int alt12=2;
                int LA12_0 = input.LA(1);

                if ( (LA12_0==INTERR||LA12_0==STAR) ) {
                    alt12=1;
                }


                switch (alt12) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:
            	    {
            	    set38=(Token)input.LT(1);

            	    if ( input.LA(1)==INTERR||input.LA(1)==STAR ) {
            	        input.consume();
            	        if ( state.backtracking==0 ) adaptor.addChild(root_0, 
            	        (Object)adaptor.create(set38)
            	        );
            	        state.errorRecovery=false;
            	        state.failed=false;
            	    }
            	    else {
            	        if (state.backtracking>0) {state.failed=true; return retval;}
            	        MismatchedSetException mse = new MismatchedSetException(null,input);
            	        throw mse;
            	    }


            	    }
            	    break;

            	default :
            	    break loop12;
                }
            } while (true);


            pushFollow(FOLLOW_rank_specifier_in_reference_type1120);
            rank_specifier39=rank_specifier();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, rank_specifier39.getTree());

            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "reference_type"


    public static class class_type_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "class_type"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:307:1: class_type : ( type_name | OBJECT | dynamic_contextual_keyword | STRING );
    public final CSharp4AST.class_type_return class_type() throws RecognitionException {
        CSharp4AST.class_type_return retval = new CSharp4AST.class_type_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token OBJECT41=null;
        Token STRING43=null;
        CSharp4AST.type_name_return type_name40 =null;

        CSharp4AST.dynamic_contextual_keyword_return dynamic_contextual_keyword42 =null;


        Object OBJECT41_tree=null;
        Object STRING43_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:308:2: ( type_name | OBJECT | dynamic_contextual_keyword | STRING )
            int alt13=4;
            switch ( input.LA(1) ) {
            case IDENTIFIER:
                {
                int LA13_1 = input.LA(2);

                if ( (!(((input.LT(1).getText().equals("dynamic"))))) ) {
                    alt13=1;
                }
                else if ( ((input.LT(1).getText().equals("dynamic"))) ) {
                    alt13=3;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 13, 1, input);

                    throw nvae;

                }
                }
                break;
            case OBJECT:
                {
                alt13=2;
                }
                break;
            case STRING:
                {
                alt13=4;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 13, 0, input);

                throw nvae;

            }

            switch (alt13) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:308:4: type_name
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_type_name_in_class_type1135);
                    type_name40=type_name();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, type_name40.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:309:4: OBJECT
                    {
                    root_0 = (Object)adaptor.nil();


                    OBJECT41=(Token)match(input,OBJECT,FOLLOW_OBJECT_in_class_type1140); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OBJECT41_tree = 
                    (Object)adaptor.create(OBJECT41)
                    ;
                    adaptor.addChild(root_0, OBJECT41_tree);
                    }

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:310:4: dynamic_contextual_keyword
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_dynamic_contextual_keyword_in_class_type1145);
                    dynamic_contextual_keyword42=dynamic_contextual_keyword();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, dynamic_contextual_keyword42.getTree());

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:311:4: STRING
                    {
                    root_0 = (Object)adaptor.nil();


                    STRING43=(Token)match(input,STRING,FOLLOW_STRING_in_class_type1150); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    STRING43_tree = 
                    (Object)adaptor.create(STRING43)
                    ;
                    adaptor.addChild(root_0, STRING43_tree);
                    }

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "class_type"


    public static class interface_type_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "interface_type"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:314:1: interface_type : type_name ;
    public final CSharp4AST.interface_type_return interface_type() throws RecognitionException {
        CSharp4AST.interface_type_return retval = new CSharp4AST.interface_type_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.type_name_return type_name44 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:315:2: ( type_name )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:315:4: type_name
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_type_name_in_interface_type1163);
            type_name44=type_name();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, type_name44.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "interface_type"


    public static class delegate_type_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "delegate_type"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:318:1: delegate_type : type_name ;
    public final CSharp4AST.delegate_type_return delegate_type() throws RecognitionException {
        CSharp4AST.delegate_type_return retval = new CSharp4AST.delegate_type_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.type_name_return type_name45 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:319:2: ( type_name )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:319:4: type_name
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_type_name_in_delegate_type1176);
            type_name45=type_name();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, type_name45.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "delegate_type"


    public static class type_argument_list_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "type_argument_list"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:321:1: type_argument_list : LT type_arguments GT -> ^( TYPE_ARGUMENT_LIST type_arguments ) ;
    public final CSharp4AST.type_argument_list_return type_argument_list() throws RecognitionException {
        CSharp4AST.type_argument_list_return retval = new CSharp4AST.type_argument_list_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token LT46=null;
        Token GT48=null;
        CSharp4AST.type_arguments_return type_arguments47 =null;


        Object LT46_tree=null;
        Object GT48_tree=null;
        RewriteRuleTokenStream stream_GT=new RewriteRuleTokenStream(adaptor,"token GT");
        RewriteRuleTokenStream stream_LT=new RewriteRuleTokenStream(adaptor,"token LT");
        RewriteRuleSubtreeStream stream_type_arguments=new RewriteRuleSubtreeStream(adaptor,"rule type_arguments");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:322:2: ( LT type_arguments GT -> ^( TYPE_ARGUMENT_LIST type_arguments ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:322:4: LT type_arguments GT
            {
            LT46=(Token)match(input,LT,FOLLOW_LT_in_type_argument_list1187); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_LT.add(LT46);


            pushFollow(FOLLOW_type_arguments_in_type_argument_list1189);
            type_arguments47=type_arguments();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_type_arguments.add(type_arguments47.getTree());

            GT48=(Token)match(input,GT,FOLLOW_GT_in_type_argument_list1191); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_GT.add(GT48);


            // AST REWRITE
            // elements: type_arguments
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 323:4: -> ^( TYPE_ARGUMENT_LIST type_arguments )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:323:7: ^( TYPE_ARGUMENT_LIST type_arguments )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(TYPE_ARGUMENT_LIST, "TYPE_ARGUMENT_LIST")
                , root_1);

                adaptor.addChild(root_1, stream_type_arguments.nextTree());

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "type_argument_list"


    public static class type_arguments_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "type_arguments"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:325:1: type_arguments : type_argument ( COMMA ! type_argument )* ;
    public final CSharp4AST.type_arguments_return type_arguments() throws RecognitionException {
        CSharp4AST.type_arguments_return retval = new CSharp4AST.type_arguments_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token COMMA50=null;
        CSharp4AST.type_argument_return type_argument49 =null;

        CSharp4AST.type_argument_return type_argument51 =null;


        Object COMMA50_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:326:2: ( type_argument ( COMMA ! type_argument )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:326:4: type_argument ( COMMA ! type_argument )*
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_type_argument_in_type_arguments1213);
            type_argument49=type_argument();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, type_argument49.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:326:18: ( COMMA ! type_argument )*
            loop14:
            do {
                int alt14=2;
                int LA14_0 = input.LA(1);

                if ( (LA14_0==COMMA) ) {
                    alt14=1;
                }


                switch (alt14) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:326:20: COMMA ! type_argument
            	    {
            	    COMMA50=(Token)match(input,COMMA,FOLLOW_COMMA_in_type_arguments1217); if (state.failed) return retval;

            	    pushFollow(FOLLOW_type_argument_in_type_arguments1220);
            	    type_argument51=type_argument();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, type_argument51.getTree());

            	    }
            	    break;

            	default :
            	    break loop14;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "type_arguments"


    public static class type_argument_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "type_argument"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:328:1: type_argument : type ;
    public final CSharp4AST.type_argument_return type_argument() throws RecognitionException {
        CSharp4AST.type_argument_return retval = new CSharp4AST.type_argument_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.type_return type52 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:329:2: ( type )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:329:4: type
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_type_in_type_argument1233);
            type52=type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, type52.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "type_argument"


    public static class type_void_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "type_void"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:332:1: type_void : VOID -> ^( TYPE VOID ) ;
    public final CSharp4AST.type_void_return type_void() throws RecognitionException {
        CSharp4AST.type_void_return retval = new CSharp4AST.type_void_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token VOID53=null;

        Object VOID53_tree=null;
        RewriteRuleTokenStream stream_VOID=new RewriteRuleTokenStream(adaptor,"token VOID");

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:333:3: ( VOID -> ^( TYPE VOID ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:333:5: VOID
            {
            VOID53=(Token)match(input,VOID,FOLLOW_VOID_in_type_void1245); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_VOID.add(VOID53);


            // AST REWRITE
            // elements: VOID
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 333:10: -> ^( TYPE VOID )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:333:13: ^( TYPE VOID )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(TYPE, "TYPE")
                , root_1);

                adaptor.addChild(root_1, 
                stream_VOID.nextNode()
                );

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "type_void"


    public static class variable_reference_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "variable_reference"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:338:1: variable_reference : expression ;
    public final CSharp4AST.variable_reference_return variable_reference() throws RecognitionException {
        CSharp4AST.variable_reference_return retval = new CSharp4AST.variable_reference_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.expression_return expression54 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:339:2: ( expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:339:4: expression
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_expression_in_variable_reference1269);
            expression54=expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, expression54.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "variable_reference"


    public static class argument_list_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "argument_list"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:343:1: argument_list : argument ( COMMA ! argument )* ;
    public final CSharp4AST.argument_list_return argument_list() throws RecognitionException {
        CSharp4AST.argument_list_return retval = new CSharp4AST.argument_list_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token COMMA56=null;
        CSharp4AST.argument_return argument55 =null;

        CSharp4AST.argument_return argument57 =null;


        Object COMMA56_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:344:2: ( argument ( COMMA ! argument )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:344:4: argument ( COMMA ! argument )*
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_argument_in_argument_list1282);
            argument55=argument();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, argument55.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:344:13: ( COMMA ! argument )*
            loop15:
            do {
                int alt15=2;
                int LA15_0 = input.LA(1);

                if ( (LA15_0==COMMA) ) {
                    alt15=1;
                }


                switch (alt15) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:344:15: COMMA ! argument
            	    {
            	    COMMA56=(Token)match(input,COMMA,FOLLOW_COMMA_in_argument_list1286); if (state.failed) return retval;

            	    pushFollow(FOLLOW_argument_in_argument_list1289);
            	    argument57=argument();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, argument57.getTree());

            	    }
            	    break;

            	default :
            	    break loop15;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "argument_list"


    public static class argument_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "argument"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:346:1: argument : ( argument_name )? argument_value -> ^( ARGUMENT ( argument_name )? argument_value ) ;
    public final CSharp4AST.argument_return argument() throws RecognitionException {
        CSharp4AST.argument_return retval = new CSharp4AST.argument_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.argument_name_return argument_name58 =null;

        CSharp4AST.argument_value_return argument_value59 =null;


        RewriteRuleSubtreeStream stream_argument_name=new RewriteRuleSubtreeStream(adaptor,"rule argument_name");
        RewriteRuleSubtreeStream stream_argument_value=new RewriteRuleSubtreeStream(adaptor,"rule argument_value");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:347:2: ( ( argument_name )? argument_value -> ^( ARGUMENT ( argument_name )? argument_value ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:347:4: ( argument_name )? argument_value
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:347:4: ( argument_name )?
            int alt16=2;
            int LA16_0 = input.LA(1);

            if ( (LA16_0==IDENTIFIER) ) {
                int LA16_1 = input.LA(2);

                if ( (LA16_1==COLON) ) {
                    alt16=1;
                }
            }
            switch (alt16) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:347:4: argument_name
                    {
                    pushFollow(FOLLOW_argument_name_in_argument1301);
                    argument_name58=argument_name();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) stream_argument_name.add(argument_name58.getTree());

                    }
                    break;

            }


            pushFollow(FOLLOW_argument_value_in_argument1304);
            argument_value59=argument_value();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_argument_value.add(argument_value59.getTree());

            // AST REWRITE
            // elements: argument_name, argument_value
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 348:4: -> ^( ARGUMENT ( argument_name )? argument_value )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:348:7: ^( ARGUMENT ( argument_name )? argument_value )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(ARGUMENT, "ARGUMENT")
                , root_1);

                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:348:18: ( argument_name )?
                if ( stream_argument_name.hasNext() ) {
                    adaptor.addChild(root_1, stream_argument_name.nextTree());

                }
                stream_argument_name.reset();

                adaptor.addChild(root_1, stream_argument_value.nextTree());

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "argument"


    public static class argument_name_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "argument_name"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:350:1: argument_name : IDENTIFIER COLON !;
    public final CSharp4AST.argument_name_return argument_name() throws RecognitionException {
        CSharp4AST.argument_name_return retval = new CSharp4AST.argument_name_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER60=null;
        Token COLON61=null;

        Object IDENTIFIER60_tree=null;
        Object COLON61_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:351:2: ( IDENTIFIER COLON !)
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:351:4: IDENTIFIER COLON !
            {
            root_0 = (Object)adaptor.nil();


            IDENTIFIER60=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_argument_name1328); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER60_tree = 
            (Object)adaptor.create(IDENTIFIER60)
            ;
            adaptor.addChild(root_0, IDENTIFIER60_tree);
            }

            COLON61=(Token)match(input,COLON,FOLLOW_COLON_in_argument_name1330); if (state.failed) return retval;

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "argument_name"


    public static class argument_value_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "argument_value"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:353:1: argument_value : argument_value2 -> ^( ARGUMENT_VALUE argument_value2 ) ;
    public final CSharp4AST.argument_value_return argument_value() throws RecognitionException {
        CSharp4AST.argument_value_return retval = new CSharp4AST.argument_value_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.argument_value2_return argument_value262 =null;


        RewriteRuleSubtreeStream stream_argument_value2=new RewriteRuleSubtreeStream(adaptor,"rule argument_value2");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:354:3: ( argument_value2 -> ^( ARGUMENT_VALUE argument_value2 ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:354:5: argument_value2
            {
            pushFollow(FOLLOW_argument_value2_in_argument_value1343);
            argument_value262=argument_value2();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_argument_value2.add(argument_value262.getTree());

            // AST REWRITE
            // elements: argument_value2
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 354:21: -> ^( ARGUMENT_VALUE argument_value2 )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:354:24: ^( ARGUMENT_VALUE argument_value2 )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(ARGUMENT_VALUE, "ARGUMENT_VALUE")
                , root_1);

                adaptor.addChild(root_1, stream_argument_value2.nextTree());

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "argument_value"


    public static class argument_value2_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "argument_value2"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:356:1: argument_value2 : ( expression | REF variable_reference | OUT variable_reference );
    public final CSharp4AST.argument_value2_return argument_value2() throws RecognitionException {
        CSharp4AST.argument_value2_return retval = new CSharp4AST.argument_value2_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token REF64=null;
        Token OUT66=null;
        CSharp4AST.expression_return expression63 =null;

        CSharp4AST.variable_reference_return variable_reference65 =null;

        CSharp4AST.variable_reference_return variable_reference67 =null;


        Object REF64_tree=null;
        Object OUT66_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:357:2: ( expression | REF variable_reference | OUT variable_reference )
            int alt17=3;
            switch ( input.LA(1) ) {
            case AMP:
            case BANG:
            case BASE:
            case BOOL:
            case BYTE:
            case CHAR:
            case CHARACTER_LITERAL:
            case CHECKED:
            case DECIMAL:
            case DEFAULT:
            case DELEGATE:
            case DOUBLE:
            case FALSE:
            case FLOAT:
            case IDENTIFIER:
            case INT:
            case INTEGER_LITERAL:
            case LONG:
            case MINUS:
            case NEW:
            case NULL:
            case OBJECT:
            case OPEN_PARENS:
            case OP_DEC:
            case OP_INC:
            case PLUS:
            case REAL_LITERAL:
            case SBYTE:
            case SHORT:
            case SIZEOF:
            case STAR:
            case STRING:
            case STRING_LITERAL:
            case THIS:
            case TILDE:
            case TRUE:
            case TYPEOF:
            case UINT:
            case ULONG:
            case UNCHECKED:
            case USHORT:
                {
                alt17=1;
                }
                break;
            case REF:
                {
                alt17=2;
                }
                break;
            case OUT:
                {
                alt17=3;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 17, 0, input);

                throw nvae;

            }

            switch (alt17) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:357:4: expression
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_expression_in_argument_value21362);
                    expression63=expression();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, expression63.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:358:4: REF variable_reference
                    {
                    root_0 = (Object)adaptor.nil();


                    REF64=(Token)match(input,REF,FOLLOW_REF_in_argument_value21367); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    REF64_tree = 
                    (Object)adaptor.create(REF64)
                    ;
                    adaptor.addChild(root_0, REF64_tree);
                    }

                    pushFollow(FOLLOW_variable_reference_in_argument_value21369);
                    variable_reference65=variable_reference();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, variable_reference65.getTree());

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:359:4: OUT variable_reference
                    {
                    root_0 = (Object)adaptor.nil();


                    OUT66=(Token)match(input,OUT,FOLLOW_OUT_in_argument_value21374); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OUT66_tree = 
                    (Object)adaptor.create(OUT66)
                    ;
                    adaptor.addChild(root_0, OUT66_tree);
                    }

                    pushFollow(FOLLOW_variable_reference_in_argument_value21376);
                    variable_reference67=variable_reference();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, variable_reference67.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "argument_value2"


    public static class primary_expression_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "primary_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:367:1: primary_expression : (e= primary_expression_start -> $e) ( bracket_expression -> ^( bracket_expression $primary_expression) )* ( ( member_access2 -> ^( MEMBER_ACCESS $primary_expression member_access2 ) | method_invocation2 -> ^( METHOD_INVOCATION $primary_expression ( method_invocation2 )? ) | OP_INC -> ^( POST_INC $primary_expression) | OP_DEC -> ^( POST_DEC $primary_expression) | OP_PTR IDENTIFIER -> $primary_expression ^( OP_PTR IDENTIFIER ) ) ( bracket_expression -> ^( bracket_expression $primary_expression) )* )* ;
    public final CSharp4AST.primary_expression_return primary_expression() throws RecognitionException {
        CSharp4AST.primary_expression_return retval = new CSharp4AST.primary_expression_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token OP_INC71=null;
        Token OP_DEC72=null;
        Token OP_PTR73=null;
        Token IDENTIFIER74=null;
        CSharp4AST.primary_expression_start_return e =null;

        CSharp4AST.bracket_expression_return bracket_expression68 =null;

        CSharp4AST.member_access2_return member_access269 =null;

        CSharp4AST.method_invocation2_return method_invocation270 =null;

        CSharp4AST.bracket_expression_return bracket_expression75 =null;


        Object OP_INC71_tree=null;
        Object OP_DEC72_tree=null;
        Object OP_PTR73_tree=null;
        Object IDENTIFIER74_tree=null;
        RewriteRuleTokenStream stream_OP_PTR=new RewriteRuleTokenStream(adaptor,"token OP_PTR");
        RewriteRuleTokenStream stream_OP_DEC=new RewriteRuleTokenStream(adaptor,"token OP_DEC");
        RewriteRuleTokenStream stream_OP_INC=new RewriteRuleTokenStream(adaptor,"token OP_INC");
        RewriteRuleTokenStream stream_IDENTIFIER=new RewriteRuleTokenStream(adaptor,"token IDENTIFIER");
        RewriteRuleSubtreeStream stream_method_invocation2=new RewriteRuleSubtreeStream(adaptor,"rule method_invocation2");
        RewriteRuleSubtreeStream stream_bracket_expression=new RewriteRuleSubtreeStream(adaptor,"rule bracket_expression");
        RewriteRuleSubtreeStream stream_member_access2=new RewriteRuleSubtreeStream(adaptor,"rule member_access2");
        RewriteRuleSubtreeStream stream_primary_expression_start=new RewriteRuleSubtreeStream(adaptor,"rule primary_expression_start");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:368:3: ( (e= primary_expression_start -> $e) ( bracket_expression -> ^( bracket_expression $primary_expression) )* ( ( member_access2 -> ^( MEMBER_ACCESS $primary_expression member_access2 ) | method_invocation2 -> ^( METHOD_INVOCATION $primary_expression ( method_invocation2 )? ) | OP_INC -> ^( POST_INC $primary_expression) | OP_DEC -> ^( POST_DEC $primary_expression) | OP_PTR IDENTIFIER -> $primary_expression ^( OP_PTR IDENTIFIER ) ) ( bracket_expression -> ^( bracket_expression $primary_expression) )* )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:368:5: (e= primary_expression_start -> $e) ( bracket_expression -> ^( bracket_expression $primary_expression) )* ( ( member_access2 -> ^( MEMBER_ACCESS $primary_expression member_access2 ) | method_invocation2 -> ^( METHOD_INVOCATION $primary_expression ( method_invocation2 )? ) | OP_INC -> ^( POST_INC $primary_expression) | OP_DEC -> ^( POST_DEC $primary_expression) | OP_PTR IDENTIFIER -> $primary_expression ^( OP_PTR IDENTIFIER ) ) ( bracket_expression -> ^( bracket_expression $primary_expression) )* )*
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:368:5: (e= primary_expression_start -> $e)
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:368:6: e= primary_expression_start
            {
            pushFollow(FOLLOW_primary_expression_start_in_primary_expression1393);
            e=primary_expression_start();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_primary_expression_start.add(e.getTree());

            // AST REWRITE
            // elements: e
            // token labels: 
            // rule labels: retval, e
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
            RewriteRuleSubtreeStream stream_e=new RewriteRuleSubtreeStream(adaptor,"rule e",e!=null?e.tree:null);

            root_0 = (Object)adaptor.nil();
            // 368:33: -> $e
            {
                adaptor.addChild(root_0, stream_e.nextTree());

            }


            retval.tree = root_0;
            }

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:369:5: ( bracket_expression -> ^( bracket_expression $primary_expression) )*
            loop18:
            do {
                int alt18=2;
                int LA18_0 = input.LA(1);

                if ( (LA18_0==OPEN_BRACKET) ) {
                    alt18=1;
                }


                switch (alt18) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:369:6: bracket_expression
            	    {
            	    pushFollow(FOLLOW_bracket_expression_in_primary_expression1406);
            	    bracket_expression68=bracket_expression();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) stream_bracket_expression.add(bracket_expression68.getTree());

            	    // AST REWRITE
            	    // elements: primary_expression, bracket_expression
            	    // token labels: 
            	    // rule labels: retval
            	    // token list labels: 
            	    // rule list labels: 
            	    // wildcard labels: 
            	    if ( state.backtracking==0 ) {

            	    retval.tree = root_0;
            	    RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            	    root_0 = (Object)adaptor.nil();
            	    // 369:25: -> ^( bracket_expression $primary_expression)
            	    {
            	        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:369:28: ^( bracket_expression $primary_expression)
            	        {
            	        Object root_1 = (Object)adaptor.nil();
            	        root_1 = (Object)adaptor.becomeRoot(stream_bracket_expression.nextNode(), root_1);

            	        adaptor.addChild(root_1, stream_retval.nextTree());

            	        adaptor.addChild(root_0, root_1);
            	        }

            	    }


            	    retval.tree = root_0;
            	    }

            	    }
            	    break;

            	default :
            	    break loop18;
                }
            } while (true);


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:370:5: ( ( member_access2 -> ^( MEMBER_ACCESS $primary_expression member_access2 ) | method_invocation2 -> ^( METHOD_INVOCATION $primary_expression ( method_invocation2 )? ) | OP_INC -> ^( POST_INC $primary_expression) | OP_DEC -> ^( POST_DEC $primary_expression) | OP_PTR IDENTIFIER -> $primary_expression ^( OP_PTR IDENTIFIER ) ) ( bracket_expression -> ^( bracket_expression $primary_expression) )* )*
            loop21:
            do {
                int alt21=2;
                int LA21_0 = input.LA(1);

                if ( (LA21_0==DOT||LA21_0==OPEN_PARENS||LA21_0==OP_DEC||LA21_0==OP_INC||LA21_0==OP_PTR) ) {
                    alt21=1;
                }


                switch (alt21) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:370:7: ( member_access2 -> ^( MEMBER_ACCESS $primary_expression member_access2 ) | method_invocation2 -> ^( METHOD_INVOCATION $primary_expression ( method_invocation2 )? ) | OP_INC -> ^( POST_INC $primary_expression) | OP_DEC -> ^( POST_DEC $primary_expression) | OP_PTR IDENTIFIER -> $primary_expression ^( OP_PTR IDENTIFIER ) ) ( bracket_expression -> ^( bracket_expression $primary_expression) )*
            	    {
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:370:7: ( member_access2 -> ^( MEMBER_ACCESS $primary_expression member_access2 ) | method_invocation2 -> ^( METHOD_INVOCATION $primary_expression ( method_invocation2 )? ) | OP_INC -> ^( POST_INC $primary_expression) | OP_DEC -> ^( POST_DEC $primary_expression) | OP_PTR IDENTIFIER -> $primary_expression ^( OP_PTR IDENTIFIER ) )
            	    int alt19=5;
            	    switch ( input.LA(1) ) {
            	    case DOT:
            	        {
            	        alt19=1;
            	        }
            	        break;
            	    case OPEN_PARENS:
            	        {
            	        alt19=2;
            	        }
            	        break;
            	    case OP_INC:
            	        {
            	        alt19=3;
            	        }
            	        break;
            	    case OP_DEC:
            	        {
            	        alt19=4;
            	        }
            	        break;
            	    case OP_PTR:
            	        {
            	        alt19=5;
            	        }
            	        break;
            	    default:
            	        if (state.backtracking>0) {state.failed=true; return retval;}
            	        NoViableAltException nvae =
            	            new NoViableAltException("", 19, 0, input);

            	        throw nvae;

            	    }

            	    switch (alt19) {
            	        case 1 :
            	            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:370:9: member_access2
            	            {
            	            pushFollow(FOLLOW_member_access2_in_primary_expression1428);
            	            member_access269=member_access2();

            	            state._fsp--;
            	            if (state.failed) return retval;
            	            if ( state.backtracking==0 ) stream_member_access2.add(member_access269.getTree());

            	            // AST REWRITE
            	            // elements: primary_expression, member_access2
            	            // token labels: 
            	            // rule labels: retval
            	            // token list labels: 
            	            // rule list labels: 
            	            // wildcard labels: 
            	            if ( state.backtracking==0 ) {

            	            retval.tree = root_0;
            	            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            	            root_0 = (Object)adaptor.nil();
            	            // 370:24: -> ^( MEMBER_ACCESS $primary_expression member_access2 )
            	            {
            	                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:370:27: ^( MEMBER_ACCESS $primary_expression member_access2 )
            	                {
            	                Object root_1 = (Object)adaptor.nil();
            	                root_1 = (Object)adaptor.becomeRoot(
            	                (Object)adaptor.create(MEMBER_ACCESS, "MEMBER_ACCESS")
            	                , root_1);

            	                adaptor.addChild(root_1, stream_retval.nextTree());

            	                adaptor.addChild(root_1, stream_member_access2.nextTree());

            	                adaptor.addChild(root_0, root_1);
            	                }

            	            }


            	            retval.tree = root_0;
            	            }

            	            }
            	            break;
            	        case 2 :
            	            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:371:8: method_invocation2
            	            {
            	            pushFollow(FOLLOW_method_invocation2_in_primary_expression1448);
            	            method_invocation270=method_invocation2();

            	            state._fsp--;
            	            if (state.failed) return retval;
            	            if ( state.backtracking==0 ) stream_method_invocation2.add(method_invocation270.getTree());

            	            // AST REWRITE
            	            // elements: primary_expression, method_invocation2
            	            // token labels: 
            	            // rule labels: retval
            	            // token list labels: 
            	            // rule list labels: 
            	            // wildcard labels: 
            	            if ( state.backtracking==0 ) {

            	            retval.tree = root_0;
            	            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            	            root_0 = (Object)adaptor.nil();
            	            // 371:27: -> ^( METHOD_INVOCATION $primary_expression ( method_invocation2 )? )
            	            {
            	                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:371:30: ^( METHOD_INVOCATION $primary_expression ( method_invocation2 )? )
            	                {
            	                Object root_1 = (Object)adaptor.nil();
            	                root_1 = (Object)adaptor.becomeRoot(
            	                (Object)adaptor.create(METHOD_INVOCATION, "METHOD_INVOCATION")
            	                , root_1);

            	                adaptor.addChild(root_1, stream_retval.nextTree());

            	                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:371:70: ( method_invocation2 )?
            	                if ( stream_method_invocation2.hasNext() ) {
            	                    adaptor.addChild(root_1, stream_method_invocation2.nextTree());

            	                }
            	                stream_method_invocation2.reset();

            	                adaptor.addChild(root_0, root_1);
            	                }

            	            }


            	            retval.tree = root_0;
            	            }

            	            }
            	            break;
            	        case 3 :
            	            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:372:8: OP_INC
            	            {
            	            OP_INC71=(Token)match(input,OP_INC,FOLLOW_OP_INC_in_primary_expression1469); if (state.failed) return retval; 
            	            if ( state.backtracking==0 ) stream_OP_INC.add(OP_INC71);


            	            // AST REWRITE
            	            // elements: primary_expression
            	            // token labels: 
            	            // rule labels: retval
            	            // token list labels: 
            	            // rule list labels: 
            	            // wildcard labels: 
            	            if ( state.backtracking==0 ) {

            	            retval.tree = root_0;
            	            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            	            root_0 = (Object)adaptor.nil();
            	            // 372:15: -> ^( POST_INC $primary_expression)
            	            {
            	                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:372:18: ^( POST_INC $primary_expression)
            	                {
            	                Object root_1 = (Object)adaptor.nil();
            	                root_1 = (Object)adaptor.becomeRoot(
            	                (Object)adaptor.create(POST_INC, "POST_INC")
            	                , root_1);

            	                adaptor.addChild(root_1, stream_retval.nextTree());

            	                adaptor.addChild(root_0, root_1);
            	                }

            	            }


            	            retval.tree = root_0;
            	            }

            	            }
            	            break;
            	        case 4 :
            	            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:373:8: OP_DEC
            	            {
            	            OP_DEC72=(Token)match(input,OP_DEC,FOLLOW_OP_DEC_in_primary_expression1487); if (state.failed) return retval; 
            	            if ( state.backtracking==0 ) stream_OP_DEC.add(OP_DEC72);


            	            // AST REWRITE
            	            // elements: primary_expression
            	            // token labels: 
            	            // rule labels: retval
            	            // token list labels: 
            	            // rule list labels: 
            	            // wildcard labels: 
            	            if ( state.backtracking==0 ) {

            	            retval.tree = root_0;
            	            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            	            root_0 = (Object)adaptor.nil();
            	            // 373:15: -> ^( POST_DEC $primary_expression)
            	            {
            	                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:373:18: ^( POST_DEC $primary_expression)
            	                {
            	                Object root_1 = (Object)adaptor.nil();
            	                root_1 = (Object)adaptor.becomeRoot(
            	                (Object)adaptor.create(POST_DEC, "POST_DEC")
            	                , root_1);

            	                adaptor.addChild(root_1, stream_retval.nextTree());

            	                adaptor.addChild(root_0, root_1);
            	                }

            	            }


            	            retval.tree = root_0;
            	            }

            	            }
            	            break;
            	        case 5 :
            	            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:374:8: OP_PTR IDENTIFIER
            	            {
            	            OP_PTR73=(Token)match(input,OP_PTR,FOLLOW_OP_PTR_in_primary_expression1505); if (state.failed) return retval; 
            	            if ( state.backtracking==0 ) stream_OP_PTR.add(OP_PTR73);


            	            IDENTIFIER74=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_primary_expression1507); if (state.failed) return retval; 
            	            if ( state.backtracking==0 ) stream_IDENTIFIER.add(IDENTIFIER74);


            	            // AST REWRITE
            	            // elements: IDENTIFIER, primary_expression, OP_PTR
            	            // token labels: 
            	            // rule labels: retval
            	            // token list labels: 
            	            // rule list labels: 
            	            // wildcard labels: 
            	            if ( state.backtracking==0 ) {

            	            retval.tree = root_0;
            	            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            	            root_0 = (Object)adaptor.nil();
            	            // 374:26: -> $primary_expression ^( OP_PTR IDENTIFIER )
            	            {
            	                adaptor.addChild(root_0, stream_retval.nextTree());

            	                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:374:49: ^( OP_PTR IDENTIFIER )
            	                {
            	                Object root_1 = (Object)adaptor.nil();
            	                root_1 = (Object)adaptor.becomeRoot(
            	                stream_OP_PTR.nextNode()
            	                , root_1);

            	                adaptor.addChild(root_1, 
            	                stream_IDENTIFIER.nextNode()
            	                );

            	                adaptor.addChild(root_0, root_1);
            	                }

            	            }


            	            retval.tree = root_0;
            	            }

            	            }
            	            break;

            	    }


            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:376:6: ( bracket_expression -> ^( bracket_expression $primary_expression) )*
            	    loop20:
            	    do {
            	        int alt20=2;
            	        int LA20_0 = input.LA(1);

            	        if ( (LA20_0==OPEN_BRACKET) ) {
            	            alt20=1;
            	        }


            	        switch (alt20) {
            	    	case 1 :
            	    	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:376:7: bracket_expression
            	    	    {
            	    	    pushFollow(FOLLOW_bracket_expression_in_primary_expression1535);
            	    	    bracket_expression75=bracket_expression();

            	    	    state._fsp--;
            	    	    if (state.failed) return retval;
            	    	    if ( state.backtracking==0 ) stream_bracket_expression.add(bracket_expression75.getTree());

            	    	    // AST REWRITE
            	    	    // elements: primary_expression, bracket_expression
            	    	    // token labels: 
            	    	    // rule labels: retval
            	    	    // token list labels: 
            	    	    // rule list labels: 
            	    	    // wildcard labels: 
            	    	    if ( state.backtracking==0 ) {

            	    	    retval.tree = root_0;
            	    	    RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            	    	    root_0 = (Object)adaptor.nil();
            	    	    // 376:26: -> ^( bracket_expression $primary_expression)
            	    	    {
            	    	        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:376:29: ^( bracket_expression $primary_expression)
            	    	        {
            	    	        Object root_1 = (Object)adaptor.nil();
            	    	        root_1 = (Object)adaptor.becomeRoot(stream_bracket_expression.nextNode(), root_1);

            	    	        adaptor.addChild(root_1, stream_retval.nextTree());

            	    	        adaptor.addChild(root_0, root_1);
            	    	        }

            	    	    }


            	    	    retval.tree = root_0;
            	    	    }

            	    	    }
            	    	    break;

            	    	default :
            	    	    break loop20;
            	        }
            	    } while (true);


            	    }
            	    break;

            	default :
            	    break loop21;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "primary_expression"


    public static class primary_expression_start_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "primary_expression_start"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:379:1: primary_expression_start : ( literal | simple_name | parenthesized_expression | predefined_type | qualified_alias_member | this_access | base_access | NEW ( type ( object_creation_expression2 ^| object_or_collection_initializer | OPEN_BRACKET expression_list CLOSE_BRACKET ( rank_specifiers )? ( array_initializer )? | rank_specifiers array_initializer ) | anonymous_object_initializer | rank_specifier array_initializer ) | typeof_expression | checked_expression | unchecked_expression | default_value_expression | anonymous_method_expression | sizeof_expression );
    public final CSharp4AST.primary_expression_start_return primary_expression_start() throws RecognitionException {
        CSharp4AST.primary_expression_start_return retval = new CSharp4AST.primary_expression_start_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token NEW83=null;
        Token OPEN_BRACKET87=null;
        Token CLOSE_BRACKET89=null;
        CSharp4AST.literal_return literal76 =null;

        CSharp4AST.simple_name_return simple_name77 =null;

        CSharp4AST.parenthesized_expression_return parenthesized_expression78 =null;

        CSharp4AST.predefined_type_return predefined_type79 =null;

        CSharp4AST.qualified_alias_member_return qualified_alias_member80 =null;

        CSharp4AST.this_access_return this_access81 =null;

        CSharp4AST.base_access_return base_access82 =null;

        CSharp4AST.type_return type84 =null;

        CSharp4AST.object_creation_expression2_return object_creation_expression285 =null;

        CSharp4AST.object_or_collection_initializer_return object_or_collection_initializer86 =null;

        CSharp4AST.expression_list_return expression_list88 =null;

        CSharp4AST.rank_specifiers_return rank_specifiers90 =null;

        CSharp4AST.array_initializer_return array_initializer91 =null;

        CSharp4AST.rank_specifiers_return rank_specifiers92 =null;

        CSharp4AST.array_initializer_return array_initializer93 =null;

        CSharp4AST.anonymous_object_initializer_return anonymous_object_initializer94 =null;

        CSharp4AST.rank_specifier_return rank_specifier95 =null;

        CSharp4AST.array_initializer_return array_initializer96 =null;

        CSharp4AST.typeof_expression_return typeof_expression97 =null;

        CSharp4AST.checked_expression_return checked_expression98 =null;

        CSharp4AST.unchecked_expression_return unchecked_expression99 =null;

        CSharp4AST.default_value_expression_return default_value_expression100 =null;

        CSharp4AST.anonymous_method_expression_return anonymous_method_expression101 =null;

        CSharp4AST.sizeof_expression_return sizeof_expression102 =null;


        Object NEW83_tree=null;
        Object OPEN_BRACKET87_tree=null;
        Object CLOSE_BRACKET89_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:380:3: ( literal | simple_name | parenthesized_expression | predefined_type | qualified_alias_member | this_access | base_access | NEW ( type ( object_creation_expression2 ^| object_or_collection_initializer | OPEN_BRACKET expression_list CLOSE_BRACKET ( rank_specifiers )? ( array_initializer )? | rank_specifiers array_initializer ) | anonymous_object_initializer | rank_specifier array_initializer ) | typeof_expression | checked_expression | unchecked_expression | default_value_expression | anonymous_method_expression | sizeof_expression )
            int alt26=14;
            switch ( input.LA(1) ) {
            case CHARACTER_LITERAL:
            case FALSE:
            case INTEGER_LITERAL:
            case NULL:
            case REAL_LITERAL:
            case STRING_LITERAL:
            case TRUE:
                {
                alt26=1;
                }
                break;
            case IDENTIFIER:
                {
                int LA26_2 = input.LA(2);

                if ( (LA26_2==DOUBLE_COLON) ) {
                    alt26=5;
                }
                else if ( (LA26_2==EOF||(LA26_2 >= AMP && LA26_2 <= ASSIGNMENT)||LA26_2==BITWISE_OR||LA26_2==CARET||(LA26_2 >= CLOSE_BRACE && LA26_2 <= COMMA)||LA26_2==DIV||LA26_2==DOT||LA26_2==GT||LA26_2==IDENTIFIER||(LA26_2 >= INTERR && LA26_2 <= IS)||LA26_2==LT||LA26_2==MINUS||(LA26_2 >= OPEN_BRACKET && LA26_2 <= OPEN_PARENS)||(LA26_2 >= OP_ADD_ASSIGNMENT && LA26_2 <= OP_XOR_ASSIGNMENT)||(LA26_2 >= PERCENT && LA26_2 <= PLUS)||LA26_2==SEMICOLON||LA26_2==STAR) ) {
                    alt26=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 26, 2, input);

                    throw nvae;

                }
                }
                break;
            case OPEN_PARENS:
                {
                alt26=3;
                }
                break;
            case BOOL:
            case BYTE:
            case CHAR:
            case DECIMAL:
            case DOUBLE:
            case FLOAT:
            case INT:
            case LONG:
            case OBJECT:
            case SBYTE:
            case SHORT:
            case STRING:
            case UINT:
            case ULONG:
            case USHORT:
                {
                alt26=4;
                }
                break;
            case THIS:
                {
                alt26=6;
                }
                break;
            case BASE:
                {
                alt26=7;
                }
                break;
            case NEW:
                {
                alt26=8;
                }
                break;
            case TYPEOF:
                {
                alt26=9;
                }
                break;
            case CHECKED:
                {
                alt26=10;
                }
                break;
            case UNCHECKED:
                {
                alt26=11;
                }
                break;
            case DEFAULT:
                {
                alt26=12;
                }
                break;
            case DELEGATE:
                {
                alt26=13;
                }
                break;
            case SIZEOF:
                {
                alt26=14;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 26, 0, input);

                throw nvae;

            }

            switch (alt26) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:380:5: literal
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_literal_in_primary_expression_start1565);
                    literal76=literal();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, literal76.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:381:5: simple_name
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_simple_name_in_primary_expression_start1571);
                    simple_name77=simple_name();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, simple_name77.getTree());

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:382:5: parenthesized_expression
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_parenthesized_expression_in_primary_expression_start1577);
                    parenthesized_expression78=parenthesized_expression();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, parenthesized_expression78.getTree());

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:383:5: predefined_type
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_predefined_type_in_primary_expression_start1583);
                    predefined_type79=predefined_type();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, predefined_type79.getTree());

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:384:5: qualified_alias_member
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_qualified_alias_member_in_primary_expression_start1590);
                    qualified_alias_member80=qualified_alias_member();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, qualified_alias_member80.getTree());

                    }
                    break;
                case 6 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:385:5: this_access
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_this_access_in_primary_expression_start1598);
                    this_access81=this_access();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, this_access81.getTree());

                    }
                    break;
                case 7 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:386:5: base_access
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_base_access_in_primary_expression_start1604);
                    base_access82=base_access();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, base_access82.getTree());

                    }
                    break;
                case 8 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:387:5: NEW ( type ( object_creation_expression2 ^| object_or_collection_initializer | OPEN_BRACKET expression_list CLOSE_BRACKET ( rank_specifiers )? ( array_initializer )? | rank_specifiers array_initializer ) | anonymous_object_initializer | rank_specifier array_initializer )
                    {
                    root_0 = (Object)adaptor.nil();


                    NEW83=(Token)match(input,NEW,FOLLOW_NEW_in_primary_expression_start1610); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    NEW83_tree = 
                    (Object)adaptor.create(NEW83)
                    ;
                    adaptor.addChild(root_0, NEW83_tree);
                    }

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:387:9: ( type ( object_creation_expression2 ^| object_or_collection_initializer | OPEN_BRACKET expression_list CLOSE_BRACKET ( rank_specifiers )? ( array_initializer )? | rank_specifiers array_initializer ) | anonymous_object_initializer | rank_specifier array_initializer )
                    int alt25=3;
                    switch ( input.LA(1) ) {
                    case BOOL:
                    case BYTE:
                    case CHAR:
                    case DECIMAL:
                    case DOUBLE:
                    case FLOAT:
                    case IDENTIFIER:
                    case INT:
                    case LONG:
                    case OBJECT:
                    case SBYTE:
                    case SHORT:
                    case STRING:
                    case UINT:
                    case ULONG:
                    case USHORT:
                    case VOID:
                        {
                        alt25=1;
                        }
                        break;
                    case OPEN_BRACE:
                        {
                        alt25=2;
                        }
                        break;
                    case OPEN_BRACKET:
                        {
                        alt25=3;
                        }
                        break;
                    default:
                        if (state.backtracking>0) {state.failed=true; return retval;}
                        NoViableAltException nvae =
                            new NoViableAltException("", 25, 0, input);

                        throw nvae;

                    }

                    switch (alt25) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:387:11: type ( object_creation_expression2 ^| object_or_collection_initializer | OPEN_BRACKET expression_list CLOSE_BRACKET ( rank_specifiers )? ( array_initializer )? | rank_specifiers array_initializer )
                            {
                            pushFollow(FOLLOW_type_in_primary_expression_start1614);
                            type84=type();

                            state._fsp--;
                            if (state.failed) return retval;
                            if ( state.backtracking==0 ) adaptor.addChild(root_0, type84.getTree());

                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:387:16: ( object_creation_expression2 ^| object_or_collection_initializer | OPEN_BRACKET expression_list CLOSE_BRACKET ( rank_specifiers )? ( array_initializer )? | rank_specifiers array_initializer )
                            int alt24=4;
                            switch ( input.LA(1) ) {
                            case OPEN_PARENS:
                                {
                                alt24=1;
                                }
                                break;
                            case OPEN_BRACE:
                                {
                                alt24=2;
                                }
                                break;
                            case OPEN_BRACKET:
                                {
                                int LA24_3 = input.LA(2);

                                if ( (LA24_3==AMP||(LA24_3 >= BANG && LA24_3 <= BASE)||LA24_3==BOOL||LA24_3==BYTE||(LA24_3 >= CHAR && LA24_3 <= CHECKED)||LA24_3==DECIMAL||(LA24_3 >= DEFAULT && LA24_3 <= DELEGATE)||LA24_3==DOUBLE||LA24_3==FALSE||LA24_3==FLOAT||LA24_3==IDENTIFIER||(LA24_3 >= INT && LA24_3 <= INTEGER_LITERAL)||LA24_3==LONG||LA24_3==MINUS||LA24_3==NEW||LA24_3==NULL||LA24_3==OBJECT||LA24_3==OPEN_PARENS||LA24_3==OP_DEC||LA24_3==OP_INC||LA24_3==PLUS||LA24_3==REAL_LITERAL||LA24_3==SBYTE||LA24_3==SHORT||LA24_3==SIZEOF||LA24_3==STAR||(LA24_3 >= STRING && LA24_3 <= STRING_LITERAL)||LA24_3==THIS||(LA24_3 >= TILDE && LA24_3 <= TRUE)||LA24_3==TYPEOF||(LA24_3 >= UINT && LA24_3 <= UNCHECKED)||LA24_3==USHORT) ) {
                                    alt24=3;
                                }
                                else if ( (LA24_3==CLOSE_BRACKET||LA24_3==COMMA) ) {
                                    alt24=4;
                                }
                                else {
                                    if (state.backtracking>0) {state.failed=true; return retval;}
                                    NoViableAltException nvae =
                                        new NoViableAltException("", 24, 3, input);

                                    throw nvae;

                                }
                                }
                                break;
                            default:
                                if (state.backtracking>0) {state.failed=true; return retval;}
                                NoViableAltException nvae =
                                    new NoViableAltException("", 24, 0, input);

                                throw nvae;

                            }

                            switch (alt24) {
                                case 1 :
                                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:387:18: object_creation_expression2 ^
                                    {
                                    pushFollow(FOLLOW_object_creation_expression2_in_primary_expression_start1618);
                                    object_creation_expression285=object_creation_expression2();

                                    state._fsp--;
                                    if (state.failed) return retval;
                                    if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(object_creation_expression285.getTree(), root_0);

                                    }
                                    break;
                                case 2 :
                                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:388:18: object_or_collection_initializer
                                    {
                                    pushFollow(FOLLOW_object_or_collection_initializer_in_primary_expression_start1638);
                                    object_or_collection_initializer86=object_or_collection_initializer();

                                    state._fsp--;
                                    if (state.failed) return retval;
                                    if ( state.backtracking==0 ) adaptor.addChild(root_0, object_or_collection_initializer86.getTree());

                                    }
                                    break;
                                case 3 :
                                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:389:18: OPEN_BRACKET expression_list CLOSE_BRACKET ( rank_specifiers )? ( array_initializer )?
                                    {
                                    OPEN_BRACKET87=(Token)match(input,OPEN_BRACKET,FOLLOW_OPEN_BRACKET_in_primary_expression_start1657); if (state.failed) return retval;
                                    if ( state.backtracking==0 ) {
                                    OPEN_BRACKET87_tree = 
                                    (Object)adaptor.create(OPEN_BRACKET87)
                                    ;
                                    adaptor.addChild(root_0, OPEN_BRACKET87_tree);
                                    }

                                    pushFollow(FOLLOW_expression_list_in_primary_expression_start1659);
                                    expression_list88=expression_list();

                                    state._fsp--;
                                    if (state.failed) return retval;
                                    if ( state.backtracking==0 ) adaptor.addChild(root_0, expression_list88.getTree());

                                    CLOSE_BRACKET89=(Token)match(input,CLOSE_BRACKET,FOLLOW_CLOSE_BRACKET_in_primary_expression_start1661); if (state.failed) return retval;
                                    if ( state.backtracking==0 ) {
                                    CLOSE_BRACKET89_tree = 
                                    (Object)adaptor.create(CLOSE_BRACKET89)
                                    ;
                                    adaptor.addChild(root_0, CLOSE_BRACKET89_tree);
                                    }

                                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:389:61: ( rank_specifiers )?
                                    int alt22=2;
                                    int LA22_0 = input.LA(1);

                                    if ( (LA22_0==OPEN_BRACKET) ) {
                                        int LA22_1 = input.LA(2);

                                        if ( (LA22_1==CLOSE_BRACKET||LA22_1==COMMA) ) {
                                            alt22=1;
                                        }
                                    }
                                    switch (alt22) {
                                        case 1 :
                                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:389:61: rank_specifiers
                                            {
                                            pushFollow(FOLLOW_rank_specifiers_in_primary_expression_start1663);
                                            rank_specifiers90=rank_specifiers();

                                            state._fsp--;
                                            if (state.failed) return retval;
                                            if ( state.backtracking==0 ) adaptor.addChild(root_0, rank_specifiers90.getTree());

                                            }
                                            break;

                                    }


                                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:389:78: ( array_initializer )?
                                    int alt23=2;
                                    int LA23_0 = input.LA(1);

                                    if ( (LA23_0==OPEN_BRACE) ) {
                                        alt23=1;
                                    }
                                    switch (alt23) {
                                        case 1 :
                                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:389:78: array_initializer
                                            {
                                            pushFollow(FOLLOW_array_initializer_in_primary_expression_start1666);
                                            array_initializer91=array_initializer();

                                            state._fsp--;
                                            if (state.failed) return retval;
                                            if ( state.backtracking==0 ) adaptor.addChild(root_0, array_initializer91.getTree());

                                            }
                                            break;

                                    }


                                    }
                                    break;
                                case 4 :
                                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:390:18: rank_specifiers array_initializer
                                    {
                                    pushFollow(FOLLOW_rank_specifiers_in_primary_expression_start1686);
                                    rank_specifiers92=rank_specifiers();

                                    state._fsp--;
                                    if (state.failed) return retval;
                                    if ( state.backtracking==0 ) adaptor.addChild(root_0, rank_specifiers92.getTree());

                                    pushFollow(FOLLOW_array_initializer_in_primary_expression_start1688);
                                    array_initializer93=array_initializer();

                                    state._fsp--;
                                    if (state.failed) return retval;
                                    if ( state.backtracking==0 ) adaptor.addChild(root_0, array_initializer93.getTree());

                                    }
                                    break;

                            }


                            }
                            break;
                        case 2 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:392:11: anonymous_object_initializer
                            {
                            pushFollow(FOLLOW_anonymous_object_initializer_in_primary_expression_start1717);
                            anonymous_object_initializer94=anonymous_object_initializer();

                            state._fsp--;
                            if (state.failed) return retval;
                            if ( state.backtracking==0 ) adaptor.addChild(root_0, anonymous_object_initializer94.getTree());

                            }
                            break;
                        case 3 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:393:11: rank_specifier array_initializer
                            {
                            pushFollow(FOLLOW_rank_specifier_in_primary_expression_start1729);
                            rank_specifier95=rank_specifier();

                            state._fsp--;
                            if (state.failed) return retval;
                            if ( state.backtracking==0 ) adaptor.addChild(root_0, rank_specifier95.getTree());

                            pushFollow(FOLLOW_array_initializer_in_primary_expression_start1731);
                            array_initializer96=array_initializer();

                            state._fsp--;
                            if (state.failed) return retval;
                            if ( state.backtracking==0 ) adaptor.addChild(root_0, array_initializer96.getTree());

                            }
                            break;

                    }


                    }
                    break;
                case 9 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:395:5: typeof_expression
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_typeof_expression_in_primary_expression_start1747);
                    typeof_expression97=typeof_expression();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, typeof_expression97.getTree());

                    }
                    break;
                case 10 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:396:5: checked_expression
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_checked_expression_in_primary_expression_start1753);
                    checked_expression98=checked_expression();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, checked_expression98.getTree());

                    }
                    break;
                case 11 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:397:5: unchecked_expression
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_unchecked_expression_in_primary_expression_start1759);
                    unchecked_expression99=unchecked_expression();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, unchecked_expression99.getTree());

                    }
                    break;
                case 12 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:398:5: default_value_expression
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_default_value_expression_in_primary_expression_start1765);
                    default_value_expression100=default_value_expression();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, default_value_expression100.getTree());

                    }
                    break;
                case 13 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:399:5: anonymous_method_expression
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_anonymous_method_expression_in_primary_expression_start1771);
                    anonymous_method_expression101=anonymous_method_expression();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, anonymous_method_expression101.getTree());

                    }
                    break;
                case 14 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:400:5: sizeof_expression
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_sizeof_expression_in_primary_expression_start1777);
                    sizeof_expression102=sizeof_expression();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, sizeof_expression102.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "primary_expression_start"


    public static class bracket_expression_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "bracket_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:408:1: bracket_expression : OPEN_BRACKET expression_list CLOSE_BRACKET -> ^( ARRAY_ACCESS expression_list ) ;
    public final CSharp4AST.bracket_expression_return bracket_expression() throws RecognitionException {
        CSharp4AST.bracket_expression_return retval = new CSharp4AST.bracket_expression_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token OPEN_BRACKET103=null;
        Token CLOSE_BRACKET105=null;
        CSharp4AST.expression_list_return expression_list104 =null;


        Object OPEN_BRACKET103_tree=null;
        Object CLOSE_BRACKET105_tree=null;
        RewriteRuleTokenStream stream_OPEN_BRACKET=new RewriteRuleTokenStream(adaptor,"token OPEN_BRACKET");
        RewriteRuleTokenStream stream_CLOSE_BRACKET=new RewriteRuleTokenStream(adaptor,"token CLOSE_BRACKET");
        RewriteRuleSubtreeStream stream_expression_list=new RewriteRuleSubtreeStream(adaptor,"rule expression_list");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:409:3: ( OPEN_BRACKET expression_list CLOSE_BRACKET -> ^( ARRAY_ACCESS expression_list ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:409:5: OPEN_BRACKET expression_list CLOSE_BRACKET
            {
            OPEN_BRACKET103=(Token)match(input,OPEN_BRACKET,FOLLOW_OPEN_BRACKET_in_bracket_expression1791); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_OPEN_BRACKET.add(OPEN_BRACKET103);


            pushFollow(FOLLOW_expression_list_in_bracket_expression1793);
            expression_list104=expression_list();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_expression_list.add(expression_list104.getTree());

            CLOSE_BRACKET105=(Token)match(input,CLOSE_BRACKET,FOLLOW_CLOSE_BRACKET_in_bracket_expression1795); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_CLOSE_BRACKET.add(CLOSE_BRACKET105);


            // AST REWRITE
            // elements: expression_list
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 410:5: -> ^( ARRAY_ACCESS expression_list )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:410:8: ^( ARRAY_ACCESS expression_list )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(ARRAY_ACCESS, "ARRAY_ACCESS")
                , root_1);

                adaptor.addChild(root_1, stream_expression_list.nextTree());

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "bracket_expression"


    public static class simple_name_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "simple_name"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:487:1: simple_name : IDENTIFIER type_argument_list_opt -> ^( SIMPLE_NAME IDENTIFIER ( type_argument_list_opt )? ) ;
    public final CSharp4AST.simple_name_return simple_name() throws RecognitionException {
        CSharp4AST.simple_name_return retval = new CSharp4AST.simple_name_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER106=null;
        CSharp4AST.type_argument_list_opt_return type_argument_list_opt107 =null;


        Object IDENTIFIER106_tree=null;
        RewriteRuleTokenStream stream_IDENTIFIER=new RewriteRuleTokenStream(adaptor,"token IDENTIFIER");
        RewriteRuleSubtreeStream stream_type_argument_list_opt=new RewriteRuleSubtreeStream(adaptor,"rule type_argument_list_opt");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:488:2: ( IDENTIFIER type_argument_list_opt -> ^( SIMPLE_NAME IDENTIFIER ( type_argument_list_opt )? ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:488:4: IDENTIFIER type_argument_list_opt
            {
            IDENTIFIER106=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_simple_name1825); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_IDENTIFIER.add(IDENTIFIER106);


            pushFollow(FOLLOW_type_argument_list_opt_in_simple_name1827);
            type_argument_list_opt107=type_argument_list_opt();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_type_argument_list_opt.add(type_argument_list_opt107.getTree());

            // AST REWRITE
            // elements: IDENTIFIER, type_argument_list_opt
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 489:4: -> ^( SIMPLE_NAME IDENTIFIER ( type_argument_list_opt )? )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:489:7: ^( SIMPLE_NAME IDENTIFIER ( type_argument_list_opt )? )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(SIMPLE_NAME, "SIMPLE_NAME")
                , root_1);

                adaptor.addChild(root_1, 
                stream_IDENTIFIER.nextNode()
                );

                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:489:32: ( type_argument_list_opt )?
                if ( stream_type_argument_list_opt.hasNext() ) {
                    adaptor.addChild(root_1, stream_type_argument_list_opt.nextTree());

                }
                stream_type_argument_list_opt.reset();

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "simple_name"


    public static class parenthesized_expression_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "parenthesized_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:492:1: parenthesized_expression : OPEN_PARENS ! expression CLOSE_PARENS !;
    public final CSharp4AST.parenthesized_expression_return parenthesized_expression() throws RecognitionException {
        CSharp4AST.parenthesized_expression_return retval = new CSharp4AST.parenthesized_expression_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token OPEN_PARENS108=null;
        Token CLOSE_PARENS110=null;
        CSharp4AST.expression_return expression109 =null;


        Object OPEN_PARENS108_tree=null;
        Object CLOSE_PARENS110_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:493:2: ( OPEN_PARENS ! expression CLOSE_PARENS !)
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:493:4: OPEN_PARENS ! expression CLOSE_PARENS !
            {
            root_0 = (Object)adaptor.nil();


            OPEN_PARENS108=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_parenthesized_expression1854); if (state.failed) return retval;

            pushFollow(FOLLOW_expression_in_parenthesized_expression1857);
            expression109=expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, expression109.getTree());

            CLOSE_PARENS110=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_parenthesized_expression1859); if (state.failed) return retval;

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "parenthesized_expression"


    public static class member_access_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "member_access"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:503:1: member_access : primary_expression ;
    public final CSharp4AST.member_access_return member_access() throws RecognitionException {
        CSharp4AST.member_access_return retval = new CSharp4AST.member_access_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.primary_expression_return primary_expression111 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:504:3: ( primary_expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:504:5: primary_expression
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_primary_expression_in_member_access1876);
            primary_expression111=primary_expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, primary_expression111.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "member_access"


    public static class predefined_type_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "predefined_type"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:506:1: predefined_type : ( BOOL | BYTE | CHAR | DECIMAL | DOUBLE | FLOAT | INT | LONG | OBJECT | SBYTE | SHORT | STRING | UINT | ULONG | USHORT );
    public final CSharp4AST.predefined_type_return predefined_type() throws RecognitionException {
        CSharp4AST.predefined_type_return retval = new CSharp4AST.predefined_type_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token set112=null;

        Object set112_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:507:2: ( BOOL | BYTE | CHAR | DECIMAL | DOUBLE | FLOAT | INT | LONG | OBJECT | SBYTE | SHORT | STRING | UINT | ULONG | USHORT )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:
            {
            root_0 = (Object)adaptor.nil();


            set112=(Token)input.LT(1);

            if ( input.LA(1)==BOOL||input.LA(1)==BYTE||input.LA(1)==CHAR||input.LA(1)==DECIMAL||input.LA(1)==DOUBLE||input.LA(1)==FLOAT||input.LA(1)==INT||input.LA(1)==LONG||input.LA(1)==OBJECT||input.LA(1)==SBYTE||input.LA(1)==SHORT||input.LA(1)==STRING||(input.LA(1) >= UINT && input.LA(1) <= ULONG)||input.LA(1)==USHORT ) {
                input.consume();
                if ( state.backtracking==0 ) adaptor.addChild(root_0, 
                (Object)adaptor.create(set112)
                );
                state.errorRecovery=false;
                state.failed=false;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                MismatchedSetException mse = new MismatchedSetException(null,input);
                throw mse;
            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "predefined_type"


    public static class expression_list_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "expression_list"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:534:1: expression_list : expression ( COMMA expression )* ;
    public final CSharp4AST.expression_list_return expression_list() throws RecognitionException {
        CSharp4AST.expression_list_return retval = new CSharp4AST.expression_list_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token COMMA114=null;
        CSharp4AST.expression_return expression113 =null;

        CSharp4AST.expression_return expression115 =null;


        Object COMMA114_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:535:2: ( expression ( COMMA expression )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:535:4: expression ( COMMA expression )*
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_expression_in_expression_list1975);
            expression113=expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, expression113.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:535:15: ( COMMA expression )*
            loop27:
            do {
                int alt27=2;
                int LA27_0 = input.LA(1);

                if ( (LA27_0==COMMA) ) {
                    alt27=1;
                }


                switch (alt27) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:535:17: COMMA expression
            	    {
            	    COMMA114=(Token)match(input,COMMA,FOLLOW_COMMA_in_expression_list1979); if (state.failed) return retval;
            	    if ( state.backtracking==0 ) {
            	    COMMA114_tree = 
            	    (Object)adaptor.create(COMMA114)
            	    ;
            	    adaptor.addChild(root_0, COMMA114_tree);
            	    }

            	    pushFollow(FOLLOW_expression_in_expression_list1981);
            	    expression115=expression();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, expression115.getTree());

            	    }
            	    break;

            	default :
            	    break loop27;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "expression_list"


    public static class this_access_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "this_access"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:537:1: this_access : THIS ;
    public final CSharp4AST.this_access_return this_access() throws RecognitionException {
        CSharp4AST.this_access_return retval = new CSharp4AST.this_access_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token THIS116=null;

        Object THIS116_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:538:2: ( THIS )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:538:4: THIS
            {
            root_0 = (Object)adaptor.nil();


            THIS116=(Token)match(input,THIS,FOLLOW_THIS_in_this_access1994); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            THIS116_tree = 
            (Object)adaptor.create(THIS116)
            ;
            adaptor.addChild(root_0, THIS116_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "this_access"


    public static class base_access_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "base_access"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:541:1: base_access : ( BASE DOT ! IDENTIFIER type_argument_list_opt | BASE OPEN_BRACKET expression_list CLOSE_BRACKET );
    public final CSharp4AST.base_access_return base_access() throws RecognitionException {
        CSharp4AST.base_access_return retval = new CSharp4AST.base_access_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token BASE117=null;
        Token DOT118=null;
        Token IDENTIFIER119=null;
        Token BASE121=null;
        Token OPEN_BRACKET122=null;
        Token CLOSE_BRACKET124=null;
        CSharp4AST.type_argument_list_opt_return type_argument_list_opt120 =null;

        CSharp4AST.expression_list_return expression_list123 =null;


        Object BASE117_tree=null;
        Object DOT118_tree=null;
        Object IDENTIFIER119_tree=null;
        Object BASE121_tree=null;
        Object OPEN_BRACKET122_tree=null;
        Object CLOSE_BRACKET124_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:542:2: ( BASE DOT ! IDENTIFIER type_argument_list_opt | BASE OPEN_BRACKET expression_list CLOSE_BRACKET )
            int alt28=2;
            int LA28_0 = input.LA(1);

            if ( (LA28_0==BASE) ) {
                int LA28_1 = input.LA(2);

                if ( (LA28_1==DOT) ) {
                    alt28=1;
                }
                else if ( (LA28_1==OPEN_BRACKET) ) {
                    alt28=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 28, 1, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 28, 0, input);

                throw nvae;

            }
            switch (alt28) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:542:4: BASE DOT ! IDENTIFIER type_argument_list_opt
                    {
                    root_0 = (Object)adaptor.nil();


                    BASE117=(Token)match(input,BASE,FOLLOW_BASE_in_base_access2006); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    BASE117_tree = 
                    (Object)adaptor.create(BASE117)
                    ;
                    adaptor.addChild(root_0, BASE117_tree);
                    }

                    DOT118=(Token)match(input,DOT,FOLLOW_DOT_in_base_access2008); if (state.failed) return retval;

                    IDENTIFIER119=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_base_access2011); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    IDENTIFIER119_tree = 
                    (Object)adaptor.create(IDENTIFIER119)
                    ;
                    adaptor.addChild(root_0, IDENTIFIER119_tree);
                    }

                    pushFollow(FOLLOW_type_argument_list_opt_in_base_access2013);
                    type_argument_list_opt120=type_argument_list_opt();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, type_argument_list_opt120.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:543:4: BASE OPEN_BRACKET expression_list CLOSE_BRACKET
                    {
                    root_0 = (Object)adaptor.nil();


                    BASE121=(Token)match(input,BASE,FOLLOW_BASE_in_base_access2018); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    BASE121_tree = 
                    (Object)adaptor.create(BASE121)
                    ;
                    adaptor.addChild(root_0, BASE121_tree);
                    }

                    OPEN_BRACKET122=(Token)match(input,OPEN_BRACKET,FOLLOW_OPEN_BRACKET_in_base_access2020); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OPEN_BRACKET122_tree = 
                    (Object)adaptor.create(OPEN_BRACKET122)
                    ;
                    adaptor.addChild(root_0, OPEN_BRACKET122_tree);
                    }

                    pushFollow(FOLLOW_expression_list_in_base_access2022);
                    expression_list123=expression_list();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, expression_list123.getTree());

                    CLOSE_BRACKET124=(Token)match(input,CLOSE_BRACKET,FOLLOW_CLOSE_BRACKET_in_base_access2024); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    CLOSE_BRACKET124_tree = 
                    (Object)adaptor.create(CLOSE_BRACKET124)
                    ;
                    adaptor.addChild(root_0, CLOSE_BRACKET124_tree);
                    }

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "base_access"


    public static class object_creation_expression_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "object_creation_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:560:1: object_creation_expression : NEW type ( OPEN_PARENS ( argument_list )? CLOSE_PARENS ( object_or_collection_initializer )? | object_or_collection_initializer ) ;
    public final CSharp4AST.object_creation_expression_return object_creation_expression() throws RecognitionException {
        CSharp4AST.object_creation_expression_return retval = new CSharp4AST.object_creation_expression_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token NEW125=null;
        Token OPEN_PARENS127=null;
        Token CLOSE_PARENS129=null;
        CSharp4AST.type_return type126 =null;

        CSharp4AST.argument_list_return argument_list128 =null;

        CSharp4AST.object_or_collection_initializer_return object_or_collection_initializer130 =null;

        CSharp4AST.object_or_collection_initializer_return object_or_collection_initializer131 =null;


        Object NEW125_tree=null;
        Object OPEN_PARENS127_tree=null;
        Object CLOSE_PARENS129_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:561:3: ( NEW type ( OPEN_PARENS ( argument_list )? CLOSE_PARENS ( object_or_collection_initializer )? | object_or_collection_initializer ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:561:5: NEW type ( OPEN_PARENS ( argument_list )? CLOSE_PARENS ( object_or_collection_initializer )? | object_or_collection_initializer )
            {
            root_0 = (Object)adaptor.nil();


            NEW125=(Token)match(input,NEW,FOLLOW_NEW_in_object_creation_expression2042); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            NEW125_tree = 
            (Object)adaptor.create(NEW125)
            ;
            adaptor.addChild(root_0, NEW125_tree);
            }

            pushFollow(FOLLOW_type_in_object_creation_expression2044);
            type126=type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, type126.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:561:14: ( OPEN_PARENS ( argument_list )? CLOSE_PARENS ( object_or_collection_initializer )? | object_or_collection_initializer )
            int alt31=2;
            int LA31_0 = input.LA(1);

            if ( (LA31_0==OPEN_PARENS) ) {
                alt31=1;
            }
            else if ( (LA31_0==OPEN_BRACE) ) {
                alt31=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 31, 0, input);

                throw nvae;

            }
            switch (alt31) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:561:16: OPEN_PARENS ( argument_list )? CLOSE_PARENS ( object_or_collection_initializer )?
                    {
                    OPEN_PARENS127=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_object_creation_expression2048); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OPEN_PARENS127_tree = 
                    (Object)adaptor.create(OPEN_PARENS127)
                    ;
                    adaptor.addChild(root_0, OPEN_PARENS127_tree);
                    }

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:561:28: ( argument_list )?
                    int alt29=2;
                    int LA29_0 = input.LA(1);

                    if ( (LA29_0==AMP||(LA29_0 >= BANG && LA29_0 <= BASE)||LA29_0==BOOL||LA29_0==BYTE||(LA29_0 >= CHAR && LA29_0 <= CHECKED)||LA29_0==DECIMAL||(LA29_0 >= DEFAULT && LA29_0 <= DELEGATE)||LA29_0==DOUBLE||LA29_0==FALSE||LA29_0==FLOAT||LA29_0==IDENTIFIER||(LA29_0 >= INT && LA29_0 <= INTEGER_LITERAL)||LA29_0==LONG||LA29_0==MINUS||LA29_0==NEW||LA29_0==NULL||LA29_0==OBJECT||LA29_0==OPEN_PARENS||LA29_0==OP_DEC||LA29_0==OP_INC||LA29_0==OUT||LA29_0==PLUS||(LA29_0 >= REAL_LITERAL && LA29_0 <= REF)||LA29_0==SBYTE||LA29_0==SHORT||LA29_0==SIZEOF||LA29_0==STAR||(LA29_0 >= STRING && LA29_0 <= STRING_LITERAL)||LA29_0==THIS||(LA29_0 >= TILDE && LA29_0 <= TRUE)||LA29_0==TYPEOF||(LA29_0 >= UINT && LA29_0 <= UNCHECKED)||LA29_0==USHORT) ) {
                        alt29=1;
                    }
                    switch (alt29) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:561:28: argument_list
                            {
                            pushFollow(FOLLOW_argument_list_in_object_creation_expression2050);
                            argument_list128=argument_list();

                            state._fsp--;
                            if (state.failed) return retval;
                            if ( state.backtracking==0 ) adaptor.addChild(root_0, argument_list128.getTree());

                            }
                            break;

                    }


                    CLOSE_PARENS129=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_object_creation_expression2053); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    CLOSE_PARENS129_tree = 
                    (Object)adaptor.create(CLOSE_PARENS129)
                    ;
                    adaptor.addChild(root_0, CLOSE_PARENS129_tree);
                    }

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:561:56: ( object_or_collection_initializer )?
                    int alt30=2;
                    int LA30_0 = input.LA(1);

                    if ( (LA30_0==OPEN_BRACE) ) {
                        alt30=1;
                    }
                    switch (alt30) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:561:56: object_or_collection_initializer
                            {
                            pushFollow(FOLLOW_object_or_collection_initializer_in_object_creation_expression2055);
                            object_or_collection_initializer130=object_or_collection_initializer();

                            state._fsp--;
                            if (state.failed) return retval;
                            if ( state.backtracking==0 ) adaptor.addChild(root_0, object_or_collection_initializer130.getTree());

                            }
                            break;

                    }


                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:562:16: object_or_collection_initializer
                    {
                    pushFollow(FOLLOW_object_or_collection_initializer_in_object_creation_expression2073);
                    object_or_collection_initializer131=object_or_collection_initializer();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, object_or_collection_initializer131.getTree());

                    }
                    break;

            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "object_creation_expression"


    public static class object_or_collection_initializer_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "object_or_collection_initializer"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:566:1: object_or_collection_initializer : ( object_initializer | collection_initializer );
    public final CSharp4AST.object_or_collection_initializer_return object_or_collection_initializer() throws RecognitionException {
        CSharp4AST.object_or_collection_initializer_return retval = new CSharp4AST.object_or_collection_initializer_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.object_initializer_return object_initializer132 =null;

        CSharp4AST.collection_initializer_return collection_initializer133 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:567:2: ( object_initializer | collection_initializer )
            int alt32=2;
            int LA32_0 = input.LA(1);

            if ( (LA32_0==OPEN_BRACE) ) {
                switch ( input.LA(2) ) {
                case CLOSE_BRACE:
                    {
                    alt32=1;
                    }
                    break;
                case IDENTIFIER:
                    {
                    int LA32_3 = input.LA(3);

                    if ( (LA32_3==ASSIGNMENT) ) {
                        int LA32_5 = input.LA(4);

                        if ( (LA32_5==GT) ) {
                            alt32=2;
                        }
                        else if ( (LA32_5==AMP||(LA32_5 >= BANG && LA32_5 <= BASE)||LA32_5==BOOL||LA32_5==BYTE||(LA32_5 >= CHAR && LA32_5 <= CHECKED)||LA32_5==DECIMAL||(LA32_5 >= DEFAULT && LA32_5 <= DELEGATE)||LA32_5==DOUBLE||LA32_5==FALSE||LA32_5==FLOAT||LA32_5==IDENTIFIER||(LA32_5 >= INT && LA32_5 <= INTEGER_LITERAL)||LA32_5==LONG||LA32_5==MINUS||LA32_5==NEW||LA32_5==NULL||(LA32_5 >= OBJECT && LA32_5 <= OPEN_BRACE)||LA32_5==OPEN_PARENS||LA32_5==OP_DEC||LA32_5==OP_INC||LA32_5==PLUS||LA32_5==REAL_LITERAL||LA32_5==SBYTE||LA32_5==SHORT||LA32_5==SIZEOF||LA32_5==STAR||(LA32_5 >= STRING && LA32_5 <= STRING_LITERAL)||LA32_5==THIS||(LA32_5 >= TILDE && LA32_5 <= TRUE)||LA32_5==TYPEOF||(LA32_5 >= UINT && LA32_5 <= UNCHECKED)||LA32_5==USHORT) ) {
                            alt32=1;
                        }
                        else {
                            if (state.backtracking>0) {state.failed=true; return retval;}
                            NoViableAltException nvae =
                                new NoViableAltException("", 32, 5, input);

                            throw nvae;

                        }
                    }
                    else if ( ((LA32_3 >= AMP && LA32_3 <= AS)||(LA32_3 >= BITWISE_OR && LA32_3 <= BOOL)||(LA32_3 >= BYTE && LA32_3 <= CARET)||LA32_3==CHAR||LA32_3==CLOSE_BRACE||LA32_3==COMMA||LA32_3==DECIMAL||LA32_3==DIV||(LA32_3 >= DOT && LA32_3 <= DOUBLE)||LA32_3==DOUBLE_COLON||LA32_3==FLOAT||LA32_3==GT||LA32_3==IDENTIFIER||LA32_3==INT||(LA32_3 >= INTERR && LA32_3 <= IS)||(LA32_3 >= LONG && LA32_3 <= LT)||LA32_3==MINUS||LA32_3==OBJECT||(LA32_3 >= OPEN_BRACKET && LA32_3 <= OPEN_PARENS)||LA32_3==OP_AND||(LA32_3 >= OP_COALESCING && LA32_3 <= OP_DEC)||(LA32_3 >= OP_EQ && LA32_3 <= OP_LEFT_SHIFT)||(LA32_3 >= OP_NE && LA32_3 <= OP_OR)||LA32_3==OP_PTR||(LA32_3 >= PERCENT && LA32_3 <= PLUS)||LA32_3==SBYTE||LA32_3==SHORT||LA32_3==STAR||LA32_3==STRING||(LA32_3 >= UINT && LA32_3 <= ULONG)||LA32_3==USHORT||LA32_3==VOID) ) {
                        alt32=2;
                    }
                    else {
                        if (state.backtracking>0) {state.failed=true; return retval;}
                        NoViableAltException nvae =
                            new NoViableAltException("", 32, 3, input);

                        throw nvae;

                    }
                    }
                    break;
                case AMP:
                case BANG:
                case BASE:
                case BOOL:
                case BYTE:
                case CHAR:
                case CHARACTER_LITERAL:
                case CHECKED:
                case DECIMAL:
                case DEFAULT:
                case DELEGATE:
                case DOUBLE:
                case FALSE:
                case FLOAT:
                case INT:
                case INTEGER_LITERAL:
                case LONG:
                case MINUS:
                case NEW:
                case NULL:
                case OBJECT:
                case OPEN_BRACE:
                case OPEN_PARENS:
                case OP_DEC:
                case OP_INC:
                case PLUS:
                case REAL_LITERAL:
                case SBYTE:
                case SHORT:
                case SIZEOF:
                case STAR:
                case STRING:
                case STRING_LITERAL:
                case THIS:
                case TILDE:
                case TRUE:
                case TYPEOF:
                case UINT:
                case ULONG:
                case UNCHECKED:
                case USHORT:
                    {
                    alt32=2;
                    }
                    break;
                default:
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 32, 1, input);

                    throw nvae;

                }

            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 32, 0, input);

                throw nvae;

            }
            switch (alt32) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:567:4: object_initializer
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_object_initializer_in_object_or_collection_initializer2102);
                    object_initializer132=object_initializer();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, object_initializer132.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:568:4: collection_initializer
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_collection_initializer_in_object_or_collection_initializer2107);
                    collection_initializer133=collection_initializer();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, collection_initializer133.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "object_or_collection_initializer"


    public static class object_initializer_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "object_initializer"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:577:1: object_initializer : ( OPEN_BRACE CLOSE_BRACE | OPEN_BRACE member_initializer_list ( COMMA )? CLOSE_BRACE );
    public final CSharp4AST.object_initializer_return object_initializer() throws RecognitionException {
        CSharp4AST.object_initializer_return retval = new CSharp4AST.object_initializer_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token OPEN_BRACE134=null;
        Token CLOSE_BRACE135=null;
        Token OPEN_BRACE136=null;
        Token COMMA138=null;
        Token CLOSE_BRACE139=null;
        CSharp4AST.member_initializer_list_return member_initializer_list137 =null;


        Object OPEN_BRACE134_tree=null;
        Object CLOSE_BRACE135_tree=null;
        Object OPEN_BRACE136_tree=null;
        Object COMMA138_tree=null;
        Object CLOSE_BRACE139_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:578:3: ( OPEN_BRACE CLOSE_BRACE | OPEN_BRACE member_initializer_list ( COMMA )? CLOSE_BRACE )
            int alt34=2;
            int LA34_0 = input.LA(1);

            if ( (LA34_0==OPEN_BRACE) ) {
                int LA34_1 = input.LA(2);

                if ( (LA34_1==CLOSE_BRACE) ) {
                    alt34=1;
                }
                else if ( (LA34_1==IDENTIFIER) ) {
                    alt34=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 34, 1, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 34, 0, input);

                throw nvae;

            }
            switch (alt34) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:578:5: OPEN_BRACE CLOSE_BRACE
                    {
                    root_0 = (Object)adaptor.nil();


                    OPEN_BRACE134=(Token)match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_object_initializer2123); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OPEN_BRACE134_tree = 
                    (Object)adaptor.create(OPEN_BRACE134)
                    ;
                    adaptor.addChild(root_0, OPEN_BRACE134_tree);
                    }

                    CLOSE_BRACE135=(Token)match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_object_initializer2125); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    CLOSE_BRACE135_tree = 
                    (Object)adaptor.create(CLOSE_BRACE135)
                    ;
                    adaptor.addChild(root_0, CLOSE_BRACE135_tree);
                    }

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:579:5: OPEN_BRACE member_initializer_list ( COMMA )? CLOSE_BRACE
                    {
                    root_0 = (Object)adaptor.nil();


                    OPEN_BRACE136=(Token)match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_object_initializer2131); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OPEN_BRACE136_tree = 
                    (Object)adaptor.create(OPEN_BRACE136)
                    ;
                    adaptor.addChild(root_0, OPEN_BRACE136_tree);
                    }

                    pushFollow(FOLLOW_member_initializer_list_in_object_initializer2133);
                    member_initializer_list137=member_initializer_list();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, member_initializer_list137.getTree());

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:579:40: ( COMMA )?
                    int alt33=2;
                    int LA33_0 = input.LA(1);

                    if ( (LA33_0==COMMA) ) {
                        alt33=1;
                    }
                    switch (alt33) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:579:40: COMMA
                            {
                            COMMA138=(Token)match(input,COMMA,FOLLOW_COMMA_in_object_initializer2135); if (state.failed) return retval;
                            if ( state.backtracking==0 ) {
                            COMMA138_tree = 
                            (Object)adaptor.create(COMMA138)
                            ;
                            adaptor.addChild(root_0, COMMA138_tree);
                            }

                            }
                            break;

                    }


                    CLOSE_BRACE139=(Token)match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_object_initializer2138); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    CLOSE_BRACE139_tree = 
                    (Object)adaptor.create(CLOSE_BRACE139)
                    ;
                    adaptor.addChild(root_0, CLOSE_BRACE139_tree);
                    }

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "object_initializer"


    public static class member_initializer_list_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "member_initializer_list"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:581:1: member_initializer_list : member_initializer ( COMMA member_initializer )* ;
    public final CSharp4AST.member_initializer_list_return member_initializer_list() throws RecognitionException {
        CSharp4AST.member_initializer_list_return retval = new CSharp4AST.member_initializer_list_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token COMMA141=null;
        CSharp4AST.member_initializer_return member_initializer140 =null;

        CSharp4AST.member_initializer_return member_initializer142 =null;


        Object COMMA141_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:582:2: ( member_initializer ( COMMA member_initializer )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:582:4: member_initializer ( COMMA member_initializer )*
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_member_initializer_in_member_initializer_list2150);
            member_initializer140=member_initializer();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, member_initializer140.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:582:23: ( COMMA member_initializer )*
            loop35:
            do {
                int alt35=2;
                int LA35_0 = input.LA(1);

                if ( (LA35_0==COMMA) ) {
                    int LA35_1 = input.LA(2);

                    if ( (LA35_1==IDENTIFIER) ) {
                        alt35=1;
                    }


                }


                switch (alt35) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:582:25: COMMA member_initializer
            	    {
            	    COMMA141=(Token)match(input,COMMA,FOLLOW_COMMA_in_member_initializer_list2154); if (state.failed) return retval;
            	    if ( state.backtracking==0 ) {
            	    COMMA141_tree = 
            	    (Object)adaptor.create(COMMA141)
            	    ;
            	    adaptor.addChild(root_0, COMMA141_tree);
            	    }

            	    pushFollow(FOLLOW_member_initializer_in_member_initializer_list2156);
            	    member_initializer142=member_initializer();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, member_initializer142.getTree());

            	    }
            	    break;

            	default :
            	    break loop35;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "member_initializer_list"


    public static class member_initializer_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "member_initializer"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:584:1: member_initializer : IDENTIFIER ASSIGNMENT initializer_value ;
    public final CSharp4AST.member_initializer_return member_initializer() throws RecognitionException {
        CSharp4AST.member_initializer_return retval = new CSharp4AST.member_initializer_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER143=null;
        Token ASSIGNMENT144=null;
        CSharp4AST.initializer_value_return initializer_value145 =null;


        Object IDENTIFIER143_tree=null;
        Object ASSIGNMENT144_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:585:2: ( IDENTIFIER ASSIGNMENT initializer_value )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:585:4: IDENTIFIER ASSIGNMENT initializer_value
            {
            root_0 = (Object)adaptor.nil();


            IDENTIFIER143=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_member_initializer2169); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER143_tree = 
            (Object)adaptor.create(IDENTIFIER143)
            ;
            adaptor.addChild(root_0, IDENTIFIER143_tree);
            }

            ASSIGNMENT144=(Token)match(input,ASSIGNMENT,FOLLOW_ASSIGNMENT_in_member_initializer2171); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            ASSIGNMENT144_tree = 
            (Object)adaptor.create(ASSIGNMENT144)
            ;
            adaptor.addChild(root_0, ASSIGNMENT144_tree);
            }

            pushFollow(FOLLOW_initializer_value_in_member_initializer2173);
            initializer_value145=initializer_value();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, initializer_value145.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "member_initializer"


    public static class initializer_value_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "initializer_value"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:587:1: initializer_value : ( expression | object_or_collection_initializer );
    public final CSharp4AST.initializer_value_return initializer_value() throws RecognitionException {
        CSharp4AST.initializer_value_return retval = new CSharp4AST.initializer_value_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.expression_return expression146 =null;

        CSharp4AST.object_or_collection_initializer_return object_or_collection_initializer147 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:588:2: ( expression | object_or_collection_initializer )
            int alt36=2;
            int LA36_0 = input.LA(1);

            if ( (LA36_0==AMP||(LA36_0 >= BANG && LA36_0 <= BASE)||LA36_0==BOOL||LA36_0==BYTE||(LA36_0 >= CHAR && LA36_0 <= CHECKED)||LA36_0==DECIMAL||(LA36_0 >= DEFAULT && LA36_0 <= DELEGATE)||LA36_0==DOUBLE||LA36_0==FALSE||LA36_0==FLOAT||LA36_0==IDENTIFIER||(LA36_0 >= INT && LA36_0 <= INTEGER_LITERAL)||LA36_0==LONG||LA36_0==MINUS||LA36_0==NEW||LA36_0==NULL||LA36_0==OBJECT||LA36_0==OPEN_PARENS||LA36_0==OP_DEC||LA36_0==OP_INC||LA36_0==PLUS||LA36_0==REAL_LITERAL||LA36_0==SBYTE||LA36_0==SHORT||LA36_0==SIZEOF||LA36_0==STAR||(LA36_0 >= STRING && LA36_0 <= STRING_LITERAL)||LA36_0==THIS||(LA36_0 >= TILDE && LA36_0 <= TRUE)||LA36_0==TYPEOF||(LA36_0 >= UINT && LA36_0 <= UNCHECKED)||LA36_0==USHORT) ) {
                alt36=1;
            }
            else if ( (LA36_0==OPEN_BRACE) ) {
                alt36=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 36, 0, input);

                throw nvae;

            }
            switch (alt36) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:588:4: expression
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_expression_in_initializer_value2184);
                    expression146=expression();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, expression146.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:589:4: object_or_collection_initializer
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_object_or_collection_initializer_in_initializer_value2189);
                    object_or_collection_initializer147=object_or_collection_initializer();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, object_or_collection_initializer147.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "initializer_value"


    public static class collection_initializer_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "collection_initializer"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:598:1: collection_initializer : OPEN_BRACE element_initializer_list ( COMMA )? CLOSE_BRACE ;
    public final CSharp4AST.collection_initializer_return collection_initializer() throws RecognitionException {
        CSharp4AST.collection_initializer_return retval = new CSharp4AST.collection_initializer_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token OPEN_BRACE148=null;
        Token COMMA150=null;
        Token CLOSE_BRACE151=null;
        CSharp4AST.element_initializer_list_return element_initializer_list149 =null;


        Object OPEN_BRACE148_tree=null;
        Object COMMA150_tree=null;
        Object CLOSE_BRACE151_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:599:3: ( OPEN_BRACE element_initializer_list ( COMMA )? CLOSE_BRACE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:599:5: OPEN_BRACE element_initializer_list ( COMMA )? CLOSE_BRACE
            {
            root_0 = (Object)adaptor.nil();


            OPEN_BRACE148=(Token)match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_collection_initializer2205); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            OPEN_BRACE148_tree = 
            (Object)adaptor.create(OPEN_BRACE148)
            ;
            adaptor.addChild(root_0, OPEN_BRACE148_tree);
            }

            pushFollow(FOLLOW_element_initializer_list_in_collection_initializer2207);
            element_initializer_list149=element_initializer_list();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, element_initializer_list149.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:599:41: ( COMMA )?
            int alt37=2;
            int LA37_0 = input.LA(1);

            if ( (LA37_0==COMMA) ) {
                alt37=1;
            }
            switch (alt37) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:599:41: COMMA
                    {
                    COMMA150=(Token)match(input,COMMA,FOLLOW_COMMA_in_collection_initializer2209); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    COMMA150_tree = 
                    (Object)adaptor.create(COMMA150)
                    ;
                    adaptor.addChild(root_0, COMMA150_tree);
                    }

                    }
                    break;

            }


            CLOSE_BRACE151=(Token)match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_collection_initializer2212); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            CLOSE_BRACE151_tree = 
            (Object)adaptor.create(CLOSE_BRACE151)
            ;
            adaptor.addChild(root_0, CLOSE_BRACE151_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "collection_initializer"


    public static class element_initializer_list_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "element_initializer_list"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:601:1: element_initializer_list : element_initializer ( COMMA element_initializer )* ;
    public final CSharp4AST.element_initializer_list_return element_initializer_list() throws RecognitionException {
        CSharp4AST.element_initializer_list_return retval = new CSharp4AST.element_initializer_list_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token COMMA153=null;
        CSharp4AST.element_initializer_return element_initializer152 =null;

        CSharp4AST.element_initializer_return element_initializer154 =null;


        Object COMMA153_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:602:2: ( element_initializer ( COMMA element_initializer )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:602:4: element_initializer ( COMMA element_initializer )*
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_element_initializer_in_element_initializer_list2224);
            element_initializer152=element_initializer();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, element_initializer152.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:602:24: ( COMMA element_initializer )*
            loop38:
            do {
                int alt38=2;
                int LA38_0 = input.LA(1);

                if ( (LA38_0==COMMA) ) {
                    int LA38_1 = input.LA(2);

                    if ( (LA38_1==AMP||(LA38_1 >= BANG && LA38_1 <= BASE)||LA38_1==BOOL||LA38_1==BYTE||(LA38_1 >= CHAR && LA38_1 <= CHECKED)||LA38_1==DECIMAL||(LA38_1 >= DEFAULT && LA38_1 <= DELEGATE)||LA38_1==DOUBLE||LA38_1==FALSE||LA38_1==FLOAT||LA38_1==IDENTIFIER||(LA38_1 >= INT && LA38_1 <= INTEGER_LITERAL)||LA38_1==LONG||LA38_1==MINUS||LA38_1==NEW||LA38_1==NULL||(LA38_1 >= OBJECT && LA38_1 <= OPEN_BRACE)||LA38_1==OPEN_PARENS||LA38_1==OP_DEC||LA38_1==OP_INC||LA38_1==PLUS||LA38_1==REAL_LITERAL||LA38_1==SBYTE||LA38_1==SHORT||LA38_1==SIZEOF||LA38_1==STAR||(LA38_1 >= STRING && LA38_1 <= STRING_LITERAL)||LA38_1==THIS||(LA38_1 >= TILDE && LA38_1 <= TRUE)||LA38_1==TYPEOF||(LA38_1 >= UINT && LA38_1 <= UNCHECKED)||LA38_1==USHORT) ) {
                        alt38=1;
                    }


                }


                switch (alt38) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:602:26: COMMA element_initializer
            	    {
            	    COMMA153=(Token)match(input,COMMA,FOLLOW_COMMA_in_element_initializer_list2228); if (state.failed) return retval;
            	    if ( state.backtracking==0 ) {
            	    COMMA153_tree = 
            	    (Object)adaptor.create(COMMA153)
            	    ;
            	    adaptor.addChild(root_0, COMMA153_tree);
            	    }

            	    pushFollow(FOLLOW_element_initializer_in_element_initializer_list2230);
            	    element_initializer154=element_initializer();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, element_initializer154.getTree());

            	    }
            	    break;

            	default :
            	    break loop38;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "element_initializer_list"


    public static class element_initializer_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "element_initializer"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:604:1: element_initializer : ( non_assignment_expression | OPEN_BRACE expression_list CLOSE_BRACE );
    public final CSharp4AST.element_initializer_return element_initializer() throws RecognitionException {
        CSharp4AST.element_initializer_return retval = new CSharp4AST.element_initializer_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token OPEN_BRACE156=null;
        Token CLOSE_BRACE158=null;
        CSharp4AST.non_assignment_expression_return non_assignment_expression155 =null;

        CSharp4AST.expression_list_return expression_list157 =null;


        Object OPEN_BRACE156_tree=null;
        Object CLOSE_BRACE158_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:605:2: ( non_assignment_expression | OPEN_BRACE expression_list CLOSE_BRACE )
            int alt39=2;
            int LA39_0 = input.LA(1);

            if ( (LA39_0==AMP||(LA39_0 >= BANG && LA39_0 <= BASE)||LA39_0==BOOL||LA39_0==BYTE||(LA39_0 >= CHAR && LA39_0 <= CHECKED)||LA39_0==DECIMAL||(LA39_0 >= DEFAULT && LA39_0 <= DELEGATE)||LA39_0==DOUBLE||LA39_0==FALSE||LA39_0==FLOAT||LA39_0==IDENTIFIER||(LA39_0 >= INT && LA39_0 <= INTEGER_LITERAL)||LA39_0==LONG||LA39_0==MINUS||LA39_0==NEW||LA39_0==NULL||LA39_0==OBJECT||LA39_0==OPEN_PARENS||LA39_0==OP_DEC||LA39_0==OP_INC||LA39_0==PLUS||LA39_0==REAL_LITERAL||LA39_0==SBYTE||LA39_0==SHORT||LA39_0==SIZEOF||LA39_0==STAR||(LA39_0 >= STRING && LA39_0 <= STRING_LITERAL)||LA39_0==THIS||(LA39_0 >= TILDE && LA39_0 <= TRUE)||LA39_0==TYPEOF||(LA39_0 >= UINT && LA39_0 <= UNCHECKED)||LA39_0==USHORT) ) {
                alt39=1;
            }
            else if ( (LA39_0==OPEN_BRACE) ) {
                alt39=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 39, 0, input);

                throw nvae;

            }
            switch (alt39) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:605:4: non_assignment_expression
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_non_assignment_expression_in_element_initializer2243);
                    non_assignment_expression155=non_assignment_expression();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, non_assignment_expression155.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:606:4: OPEN_BRACE expression_list CLOSE_BRACE
                    {
                    root_0 = (Object)adaptor.nil();


                    OPEN_BRACE156=(Token)match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_element_initializer2248); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OPEN_BRACE156_tree = 
                    (Object)adaptor.create(OPEN_BRACE156)
                    ;
                    adaptor.addChild(root_0, OPEN_BRACE156_tree);
                    }

                    pushFollow(FOLLOW_expression_list_in_element_initializer2250);
                    expression_list157=expression_list();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, expression_list157.getTree());

                    CLOSE_BRACE158=(Token)match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_element_initializer2252); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    CLOSE_BRACE158_tree = 
                    (Object)adaptor.create(CLOSE_BRACE158)
                    ;
                    adaptor.addChild(root_0, CLOSE_BRACE158_tree);
                    }

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "element_initializer"


    public static class array_creation_expression_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "array_creation_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:615:1: array_creation_expression : NEW ( ( array_type OPEN_BRACKET )=> array_type array_initializer | non_array_type OPEN_BRACKET expression_list CLOSE_BRACKET ( rank_specifiers )? ( array_initializer )? | rank_specifier array_initializer ) ;
    public final CSharp4AST.array_creation_expression_return array_creation_expression() throws RecognitionException {
        CSharp4AST.array_creation_expression_return retval = new CSharp4AST.array_creation_expression_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token NEW159=null;
        Token OPEN_BRACKET163=null;
        Token CLOSE_BRACKET165=null;
        CSharp4AST.array_type_return array_type160 =null;

        CSharp4AST.array_initializer_return array_initializer161 =null;

        CSharp4AST.non_array_type_return non_array_type162 =null;

        CSharp4AST.expression_list_return expression_list164 =null;

        CSharp4AST.rank_specifiers_return rank_specifiers166 =null;

        CSharp4AST.array_initializer_return array_initializer167 =null;

        CSharp4AST.rank_specifier_return rank_specifier168 =null;

        CSharp4AST.array_initializer_return array_initializer169 =null;


        Object NEW159_tree=null;
        Object OPEN_BRACKET163_tree=null;
        Object CLOSE_BRACKET165_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:616:3: ( NEW ( ( array_type OPEN_BRACKET )=> array_type array_initializer | non_array_type OPEN_BRACKET expression_list CLOSE_BRACKET ( rank_specifiers )? ( array_initializer )? | rank_specifier array_initializer ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:616:5: NEW ( ( array_type OPEN_BRACKET )=> array_type array_initializer | non_array_type OPEN_BRACKET expression_list CLOSE_BRACKET ( rank_specifiers )? ( array_initializer )? | rank_specifier array_initializer )
            {
            root_0 = (Object)adaptor.nil();


            NEW159=(Token)match(input,NEW,FOLLOW_NEW_in_array_creation_expression2266); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            NEW159_tree = 
            (Object)adaptor.create(NEW159)
            ;
            adaptor.addChild(root_0, NEW159_tree);
            }

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:616:9: ( ( array_type OPEN_BRACKET )=> array_type array_initializer | non_array_type OPEN_BRACKET expression_list CLOSE_BRACKET ( rank_specifiers )? ( array_initializer )? | rank_specifier array_initializer )
            int alt42=3;
            switch ( input.LA(1) ) {
            case BYTE:
            case CHAR:
            case INT:
            case LONG:
            case SBYTE:
            case SHORT:
            case UINT:
            case ULONG:
            case USHORT:
                {
                int LA42_1 = input.LA(2);

                if ( (synpred5_CSharp4AST()) ) {
                    alt42=1;
                }
                else if ( (true) ) {
                    alt42=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 42, 1, input);

                    throw nvae;

                }
                }
                break;
            case DOUBLE:
            case FLOAT:
                {
                int LA42_2 = input.LA(2);

                if ( (synpred5_CSharp4AST()) ) {
                    alt42=1;
                }
                else if ( (true) ) {
                    alt42=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 42, 2, input);

                    throw nvae;

                }
                }
                break;
            case DECIMAL:
                {
                int LA42_3 = input.LA(2);

                if ( (synpred5_CSharp4AST()) ) {
                    alt42=1;
                }
                else if ( (true) ) {
                    alt42=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 42, 3, input);

                    throw nvae;

                }
                }
                break;
            case BOOL:
                {
                int LA42_4 = input.LA(2);

                if ( (synpred5_CSharp4AST()) ) {
                    alt42=1;
                }
                else if ( (true) ) {
                    alt42=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 42, 4, input);

                    throw nvae;

                }
                }
                break;
            case IDENTIFIER:
                {
                int LA42_5 = input.LA(2);

                if ( (synpred5_CSharp4AST()) ) {
                    alt42=1;
                }
                else if ( (true) ) {
                    alt42=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 42, 5, input);

                    throw nvae;

                }
                }
                break;
            case OBJECT:
                {
                int LA42_6 = input.LA(2);

                if ( (synpred5_CSharp4AST()) ) {
                    alt42=1;
                }
                else if ( (true) ) {
                    alt42=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 42, 6, input);

                    throw nvae;

                }
                }
                break;
            case STRING:
                {
                int LA42_7 = input.LA(2);

                if ( (synpred5_CSharp4AST()) ) {
                    alt42=1;
                }
                else if ( (true) ) {
                    alt42=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 42, 7, input);

                    throw nvae;

                }
                }
                break;
            case VOID:
                {
                int LA42_8 = input.LA(2);

                if ( (synpred5_CSharp4AST()) ) {
                    alt42=1;
                }
                else if ( (true) ) {
                    alt42=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 42, 8, input);

                    throw nvae;

                }
                }
                break;
            case OPEN_BRACKET:
                {
                alt42=3;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 42, 0, input);

                throw nvae;

            }

            switch (alt42) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:616:11: ( array_type OPEN_BRACKET )=> array_type array_initializer
                    {
                    pushFollow(FOLLOW_array_type_in_array_creation_expression2278);
                    array_type160=array_type();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, array_type160.getTree());

                    pushFollow(FOLLOW_array_initializer_in_array_creation_expression2280);
                    array_initializer161=array_initializer();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, array_initializer161.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:617:11: non_array_type OPEN_BRACKET expression_list CLOSE_BRACKET ( rank_specifiers )? ( array_initializer )?
                    {
                    pushFollow(FOLLOW_non_array_type_in_array_creation_expression2292);
                    non_array_type162=non_array_type();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, non_array_type162.getTree());

                    OPEN_BRACKET163=(Token)match(input,OPEN_BRACKET,FOLLOW_OPEN_BRACKET_in_array_creation_expression2294); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OPEN_BRACKET163_tree = 
                    (Object)adaptor.create(OPEN_BRACKET163)
                    ;
                    adaptor.addChild(root_0, OPEN_BRACKET163_tree);
                    }

                    pushFollow(FOLLOW_expression_list_in_array_creation_expression2296);
                    expression_list164=expression_list();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, expression_list164.getTree());

                    CLOSE_BRACKET165=(Token)match(input,CLOSE_BRACKET,FOLLOW_CLOSE_BRACKET_in_array_creation_expression2298); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    CLOSE_BRACKET165_tree = 
                    (Object)adaptor.create(CLOSE_BRACKET165)
                    ;
                    adaptor.addChild(root_0, CLOSE_BRACKET165_tree);
                    }

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:617:69: ( rank_specifiers )?
                    int alt40=2;
                    int LA40_0 = input.LA(1);

                    if ( (LA40_0==OPEN_BRACKET) ) {
                        alt40=1;
                    }
                    switch (alt40) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:617:69: rank_specifiers
                            {
                            pushFollow(FOLLOW_rank_specifiers_in_array_creation_expression2300);
                            rank_specifiers166=rank_specifiers();

                            state._fsp--;
                            if (state.failed) return retval;
                            if ( state.backtracking==0 ) adaptor.addChild(root_0, rank_specifiers166.getTree());

                            }
                            break;

                    }


                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:617:86: ( array_initializer )?
                    int alt41=2;
                    int LA41_0 = input.LA(1);

                    if ( (LA41_0==OPEN_BRACE) ) {
                        alt41=1;
                    }
                    switch (alt41) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:617:86: array_initializer
                            {
                            pushFollow(FOLLOW_array_initializer_in_array_creation_expression2303);
                            array_initializer167=array_initializer();

                            state._fsp--;
                            if (state.failed) return retval;
                            if ( state.backtracking==0 ) adaptor.addChild(root_0, array_initializer167.getTree());

                            }
                            break;

                    }


                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:618:11: rank_specifier array_initializer
                    {
                    pushFollow(FOLLOW_rank_specifier_in_array_creation_expression2316);
                    rank_specifier168=rank_specifier();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, rank_specifier168.getTree());

                    pushFollow(FOLLOW_array_initializer_in_array_creation_expression2318);
                    array_initializer169=array_initializer();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, array_initializer169.getTree());

                    }
                    break;

            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "array_creation_expression"


    public static class delegate_creation_expression_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "delegate_creation_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:622:1: delegate_creation_expression : NEW delegate_type OPEN_PARENS expression CLOSE_PARENS ;
    public final CSharp4AST.delegate_creation_expression_return delegate_creation_expression() throws RecognitionException {
        CSharp4AST.delegate_creation_expression_return retval = new CSharp4AST.delegate_creation_expression_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token NEW170=null;
        Token OPEN_PARENS172=null;
        Token CLOSE_PARENS174=null;
        CSharp4AST.delegate_type_return delegate_type171 =null;

        CSharp4AST.expression_return expression173 =null;


        Object NEW170_tree=null;
        Object OPEN_PARENS172_tree=null;
        Object CLOSE_PARENS174_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:623:2: ( NEW delegate_type OPEN_PARENS expression CLOSE_PARENS )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:623:4: NEW delegate_type OPEN_PARENS expression CLOSE_PARENS
            {
            root_0 = (Object)adaptor.nil();


            NEW170=(Token)match(input,NEW,FOLLOW_NEW_in_delegate_creation_expression2342); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            NEW170_tree = 
            (Object)adaptor.create(NEW170)
            ;
            adaptor.addChild(root_0, NEW170_tree);
            }

            pushFollow(FOLLOW_delegate_type_in_delegate_creation_expression2344);
            delegate_type171=delegate_type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, delegate_type171.getTree());

            OPEN_PARENS172=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_delegate_creation_expression2346); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            OPEN_PARENS172_tree = 
            (Object)adaptor.create(OPEN_PARENS172)
            ;
            adaptor.addChild(root_0, OPEN_PARENS172_tree);
            }

            pushFollow(FOLLOW_expression_in_delegate_creation_expression2348);
            expression173=expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, expression173.getTree());

            CLOSE_PARENS174=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_delegate_creation_expression2350); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            CLOSE_PARENS174_tree = 
            (Object)adaptor.create(CLOSE_PARENS174)
            ;
            adaptor.addChild(root_0, CLOSE_PARENS174_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "delegate_creation_expression"


    public static class anonymous_object_creation_expression_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "anonymous_object_creation_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:626:1: anonymous_object_creation_expression : NEW anonymous_object_initializer ;
    public final CSharp4AST.anonymous_object_creation_expression_return anonymous_object_creation_expression() throws RecognitionException {
        CSharp4AST.anonymous_object_creation_expression_return retval = new CSharp4AST.anonymous_object_creation_expression_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token NEW175=null;
        CSharp4AST.anonymous_object_initializer_return anonymous_object_initializer176 =null;


        Object NEW175_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:627:2: ( NEW anonymous_object_initializer )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:627:4: NEW anonymous_object_initializer
            {
            root_0 = (Object)adaptor.nil();


            NEW175=(Token)match(input,NEW,FOLLOW_NEW_in_anonymous_object_creation_expression2363); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            NEW175_tree = 
            (Object)adaptor.create(NEW175)
            ;
            adaptor.addChild(root_0, NEW175_tree);
            }

            pushFollow(FOLLOW_anonymous_object_initializer_in_anonymous_object_creation_expression2365);
            anonymous_object_initializer176=anonymous_object_initializer();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, anonymous_object_initializer176.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "anonymous_object_creation_expression"


    public static class anonymous_object_initializer_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "anonymous_object_initializer"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:636:1: anonymous_object_initializer : ( OPEN_BRACE CLOSE_BRACE | OPEN_BRACE member_declarator_list ( COMMA )? CLOSE_BRACE );
    public final CSharp4AST.anonymous_object_initializer_return anonymous_object_initializer() throws RecognitionException {
        CSharp4AST.anonymous_object_initializer_return retval = new CSharp4AST.anonymous_object_initializer_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token OPEN_BRACE177=null;
        Token CLOSE_BRACE178=null;
        Token OPEN_BRACE179=null;
        Token COMMA181=null;
        Token CLOSE_BRACE182=null;
        CSharp4AST.member_declarator_list_return member_declarator_list180 =null;


        Object OPEN_BRACE177_tree=null;
        Object CLOSE_BRACE178_tree=null;
        Object OPEN_BRACE179_tree=null;
        Object COMMA181_tree=null;
        Object CLOSE_BRACE182_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:637:3: ( OPEN_BRACE CLOSE_BRACE | OPEN_BRACE member_declarator_list ( COMMA )? CLOSE_BRACE )
            int alt44=2;
            int LA44_0 = input.LA(1);

            if ( (LA44_0==OPEN_BRACE) ) {
                int LA44_1 = input.LA(2);

                if ( (LA44_1==CLOSE_BRACE) ) {
                    alt44=1;
                }
                else if ( (LA44_1==BASE||LA44_1==BOOL||LA44_1==BYTE||(LA44_1 >= CHAR && LA44_1 <= CHECKED)||LA44_1==DECIMAL||(LA44_1 >= DEFAULT && LA44_1 <= DELEGATE)||LA44_1==DOUBLE||LA44_1==FALSE||LA44_1==FLOAT||LA44_1==IDENTIFIER||(LA44_1 >= INT && LA44_1 <= INTEGER_LITERAL)||LA44_1==LONG||LA44_1==NEW||LA44_1==NULL||LA44_1==OBJECT||LA44_1==OPEN_PARENS||LA44_1==REAL_LITERAL||LA44_1==SBYTE||LA44_1==SHORT||LA44_1==SIZEOF||(LA44_1 >= STRING && LA44_1 <= STRING_LITERAL)||LA44_1==THIS||LA44_1==TRUE||LA44_1==TYPEOF||(LA44_1 >= UINT && LA44_1 <= UNCHECKED)||LA44_1==USHORT) ) {
                    alt44=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 44, 1, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 44, 0, input);

                throw nvae;

            }
            switch (alt44) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:637:5: OPEN_BRACE CLOSE_BRACE
                    {
                    root_0 = (Object)adaptor.nil();


                    OPEN_BRACE177=(Token)match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_anonymous_object_initializer2381); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OPEN_BRACE177_tree = 
                    (Object)adaptor.create(OPEN_BRACE177)
                    ;
                    adaptor.addChild(root_0, OPEN_BRACE177_tree);
                    }

                    CLOSE_BRACE178=(Token)match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_anonymous_object_initializer2383); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    CLOSE_BRACE178_tree = 
                    (Object)adaptor.create(CLOSE_BRACE178)
                    ;
                    adaptor.addChild(root_0, CLOSE_BRACE178_tree);
                    }

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:638:5: OPEN_BRACE member_declarator_list ( COMMA )? CLOSE_BRACE
                    {
                    root_0 = (Object)adaptor.nil();


                    OPEN_BRACE179=(Token)match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_anonymous_object_initializer2389); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OPEN_BRACE179_tree = 
                    (Object)adaptor.create(OPEN_BRACE179)
                    ;
                    adaptor.addChild(root_0, OPEN_BRACE179_tree);
                    }

                    pushFollow(FOLLOW_member_declarator_list_in_anonymous_object_initializer2391);
                    member_declarator_list180=member_declarator_list();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, member_declarator_list180.getTree());

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:638:39: ( COMMA )?
                    int alt43=2;
                    int LA43_0 = input.LA(1);

                    if ( (LA43_0==COMMA) ) {
                        alt43=1;
                    }
                    switch (alt43) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:638:39: COMMA
                            {
                            COMMA181=(Token)match(input,COMMA,FOLLOW_COMMA_in_anonymous_object_initializer2393); if (state.failed) return retval;
                            if ( state.backtracking==0 ) {
                            COMMA181_tree = 
                            (Object)adaptor.create(COMMA181)
                            ;
                            adaptor.addChild(root_0, COMMA181_tree);
                            }

                            }
                            break;

                    }


                    CLOSE_BRACE182=(Token)match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_anonymous_object_initializer2396); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    CLOSE_BRACE182_tree = 
                    (Object)adaptor.create(CLOSE_BRACE182)
                    ;
                    adaptor.addChild(root_0, CLOSE_BRACE182_tree);
                    }

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "anonymous_object_initializer"


    public static class member_declarator_list_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "member_declarator_list"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:640:1: member_declarator_list : member_declarator ( COMMA member_declarator )* ;
    public final CSharp4AST.member_declarator_list_return member_declarator_list() throws RecognitionException {
        CSharp4AST.member_declarator_list_return retval = new CSharp4AST.member_declarator_list_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token COMMA184=null;
        CSharp4AST.member_declarator_return member_declarator183 =null;

        CSharp4AST.member_declarator_return member_declarator185 =null;


        Object COMMA184_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:641:2: ( member_declarator ( COMMA member_declarator )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:641:4: member_declarator ( COMMA member_declarator )*
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_member_declarator_in_member_declarator_list2408);
            member_declarator183=member_declarator();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, member_declarator183.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:641:22: ( COMMA member_declarator )*
            loop45:
            do {
                int alt45=2;
                int LA45_0 = input.LA(1);

                if ( (LA45_0==COMMA) ) {
                    int LA45_1 = input.LA(2);

                    if ( (LA45_1==BASE||LA45_1==BOOL||LA45_1==BYTE||(LA45_1 >= CHAR && LA45_1 <= CHECKED)||LA45_1==DECIMAL||(LA45_1 >= DEFAULT && LA45_1 <= DELEGATE)||LA45_1==DOUBLE||LA45_1==FALSE||LA45_1==FLOAT||LA45_1==IDENTIFIER||(LA45_1 >= INT && LA45_1 <= INTEGER_LITERAL)||LA45_1==LONG||LA45_1==NEW||LA45_1==NULL||LA45_1==OBJECT||LA45_1==OPEN_PARENS||LA45_1==REAL_LITERAL||LA45_1==SBYTE||LA45_1==SHORT||LA45_1==SIZEOF||(LA45_1 >= STRING && LA45_1 <= STRING_LITERAL)||LA45_1==THIS||LA45_1==TRUE||LA45_1==TYPEOF||(LA45_1 >= UINT && LA45_1 <= UNCHECKED)||LA45_1==USHORT) ) {
                        alt45=1;
                    }


                }


                switch (alt45) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:641:24: COMMA member_declarator
            	    {
            	    COMMA184=(Token)match(input,COMMA,FOLLOW_COMMA_in_member_declarator_list2412); if (state.failed) return retval;
            	    if ( state.backtracking==0 ) {
            	    COMMA184_tree = 
            	    (Object)adaptor.create(COMMA184)
            	    ;
            	    adaptor.addChild(root_0, COMMA184_tree);
            	    }

            	    pushFollow(FOLLOW_member_declarator_in_member_declarator_list2414);
            	    member_declarator185=member_declarator();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, member_declarator185.getTree());

            	    }
            	    break;

            	default :
            	    break loop45;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "member_declarator_list"


    public static class member_declarator_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "member_declarator"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:651:1: member_declarator : ( primary_expression | IDENTIFIER ASSIGNMENT expression );
    public final CSharp4AST.member_declarator_return member_declarator() throws RecognitionException {
        CSharp4AST.member_declarator_return retval = new CSharp4AST.member_declarator_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER187=null;
        Token ASSIGNMENT188=null;
        CSharp4AST.primary_expression_return primary_expression186 =null;

        CSharp4AST.expression_return expression189 =null;


        Object IDENTIFIER187_tree=null;
        Object ASSIGNMENT188_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:652:3: ( primary_expression | IDENTIFIER ASSIGNMENT expression )
            int alt46=2;
            int LA46_0 = input.LA(1);

            if ( (LA46_0==BASE||LA46_0==BOOL||LA46_0==BYTE||(LA46_0 >= CHAR && LA46_0 <= CHECKED)||LA46_0==DECIMAL||(LA46_0 >= DEFAULT && LA46_0 <= DELEGATE)||LA46_0==DOUBLE||LA46_0==FALSE||LA46_0==FLOAT||(LA46_0 >= INT && LA46_0 <= INTEGER_LITERAL)||LA46_0==LONG||LA46_0==NEW||LA46_0==NULL||LA46_0==OBJECT||LA46_0==OPEN_PARENS||LA46_0==REAL_LITERAL||LA46_0==SBYTE||LA46_0==SHORT||LA46_0==SIZEOF||(LA46_0 >= STRING && LA46_0 <= STRING_LITERAL)||LA46_0==THIS||LA46_0==TRUE||LA46_0==TYPEOF||(LA46_0 >= UINT && LA46_0 <= UNCHECKED)||LA46_0==USHORT) ) {
                alt46=1;
            }
            else if ( (LA46_0==IDENTIFIER) ) {
                int LA46_2 = input.LA(2);

                if ( (LA46_2==CLOSE_BRACE||LA46_2==COMMA||LA46_2==DOT||LA46_2==DOUBLE_COLON||LA46_2==LT||(LA46_2 >= OPEN_BRACKET && LA46_2 <= OPEN_PARENS)||LA46_2==OP_DEC||LA46_2==OP_INC||LA46_2==OP_PTR) ) {
                    alt46=1;
                }
                else if ( (LA46_2==ASSIGNMENT) ) {
                    alt46=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 46, 2, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 46, 0, input);

                throw nvae;

            }
            switch (alt46) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:652:5: primary_expression
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_primary_expression_in_member_declarator2430);
                    primary_expression186=primary_expression();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, primary_expression186.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:653:5: IDENTIFIER ASSIGNMENT expression
                    {
                    root_0 = (Object)adaptor.nil();


                    IDENTIFIER187=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_member_declarator2436); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    IDENTIFIER187_tree = 
                    (Object)adaptor.create(IDENTIFIER187)
                    ;
                    adaptor.addChild(root_0, IDENTIFIER187_tree);
                    }

                    ASSIGNMENT188=(Token)match(input,ASSIGNMENT,FOLLOW_ASSIGNMENT_in_member_declarator2438); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    ASSIGNMENT188_tree = 
                    (Object)adaptor.create(ASSIGNMENT188)
                    ;
                    adaptor.addChild(root_0, ASSIGNMENT188_tree);
                    }

                    pushFollow(FOLLOW_expression_in_member_declarator2440);
                    expression189=expression();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, expression189.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "member_declarator"


    public static class typeof_expression_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "typeof_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:655:1: typeof_expression : TYPEOF OPEN_PARENS ( ( unbound_type_name )=> unbound_type_name CLOSE_PARENS | type CLOSE_PARENS | VOID CLOSE_PARENS ) ;
    public final CSharp4AST.typeof_expression_return typeof_expression() throws RecognitionException {
        CSharp4AST.typeof_expression_return retval = new CSharp4AST.typeof_expression_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token TYPEOF190=null;
        Token OPEN_PARENS191=null;
        Token CLOSE_PARENS193=null;
        Token CLOSE_PARENS195=null;
        Token VOID196=null;
        Token CLOSE_PARENS197=null;
        CSharp4AST.unbound_type_name_return unbound_type_name192 =null;

        CSharp4AST.type_return type194 =null;


        Object TYPEOF190_tree=null;
        Object OPEN_PARENS191_tree=null;
        Object CLOSE_PARENS193_tree=null;
        Object CLOSE_PARENS195_tree=null;
        Object VOID196_tree=null;
        Object CLOSE_PARENS197_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:656:2: ( TYPEOF OPEN_PARENS ( ( unbound_type_name )=> unbound_type_name CLOSE_PARENS | type CLOSE_PARENS | VOID CLOSE_PARENS ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:656:4: TYPEOF OPEN_PARENS ( ( unbound_type_name )=> unbound_type_name CLOSE_PARENS | type CLOSE_PARENS | VOID CLOSE_PARENS )
            {
            root_0 = (Object)adaptor.nil();


            TYPEOF190=(Token)match(input,TYPEOF,FOLLOW_TYPEOF_in_typeof_expression2452); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            TYPEOF190_tree = 
            (Object)adaptor.create(TYPEOF190)
            ;
            adaptor.addChild(root_0, TYPEOF190_tree);
            }

            OPEN_PARENS191=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_typeof_expression2454); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            OPEN_PARENS191_tree = 
            (Object)adaptor.create(OPEN_PARENS191)
            ;
            adaptor.addChild(root_0, OPEN_PARENS191_tree);
            }

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:657:4: ( ( unbound_type_name )=> unbound_type_name CLOSE_PARENS | type CLOSE_PARENS | VOID CLOSE_PARENS )
            int alt47=3;
            alt47 = dfa47.predict(input);
            switch (alt47) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:657:6: ( unbound_type_name )=> unbound_type_name CLOSE_PARENS
                    {
                    pushFollow(FOLLOW_unbound_type_name_in_typeof_expression2467);
                    unbound_type_name192=unbound_type_name();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, unbound_type_name192.getTree());

                    CLOSE_PARENS193=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_typeof_expression2469); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    CLOSE_PARENS193_tree = 
                    (Object)adaptor.create(CLOSE_PARENS193)
                    ;
                    adaptor.addChild(root_0, CLOSE_PARENS193_tree);
                    }

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:658:6: type CLOSE_PARENS
                    {
                    pushFollow(FOLLOW_type_in_typeof_expression2476);
                    type194=type();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, type194.getTree());

                    CLOSE_PARENS195=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_typeof_expression2478); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    CLOSE_PARENS195_tree = 
                    (Object)adaptor.create(CLOSE_PARENS195)
                    ;
                    adaptor.addChild(root_0, CLOSE_PARENS195_tree);
                    }

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:659:6: VOID CLOSE_PARENS
                    {
                    VOID196=(Token)match(input,VOID,FOLLOW_VOID_in_typeof_expression2485); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    VOID196_tree = 
                    (Object)adaptor.create(VOID196)
                    ;
                    adaptor.addChild(root_0, VOID196_tree);
                    }

                    CLOSE_PARENS197=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_typeof_expression2487); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    CLOSE_PARENS197_tree = 
                    (Object)adaptor.create(CLOSE_PARENS197)
                    ;
                    adaptor.addChild(root_0, CLOSE_PARENS197_tree);
                    }

                    }
                    break;

            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "typeof_expression"


    public static class unbound_type_name_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "unbound_type_name"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:669:1: unbound_type_name : IDENTIFIER ( ( generic_dimension_specifier )? | DOUBLE_COLON IDENTIFIER ( generic_dimension_specifier )? ) ( DOT IDENTIFIER ( generic_dimension_specifier )? )* ;
    public final CSharp4AST.unbound_type_name_return unbound_type_name() throws RecognitionException {
        CSharp4AST.unbound_type_name_return retval = new CSharp4AST.unbound_type_name_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER198=null;
        Token DOUBLE_COLON200=null;
        Token IDENTIFIER201=null;
        Token DOT203=null;
        Token IDENTIFIER204=null;
        CSharp4AST.generic_dimension_specifier_return generic_dimension_specifier199 =null;

        CSharp4AST.generic_dimension_specifier_return generic_dimension_specifier202 =null;

        CSharp4AST.generic_dimension_specifier_return generic_dimension_specifier205 =null;


        Object IDENTIFIER198_tree=null;
        Object DOUBLE_COLON200_tree=null;
        Object IDENTIFIER201_tree=null;
        Object DOT203_tree=null;
        Object IDENTIFIER204_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:670:3: ( IDENTIFIER ( ( generic_dimension_specifier )? | DOUBLE_COLON IDENTIFIER ( generic_dimension_specifier )? ) ( DOT IDENTIFIER ( generic_dimension_specifier )? )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:670:5: IDENTIFIER ( ( generic_dimension_specifier )? | DOUBLE_COLON IDENTIFIER ( generic_dimension_specifier )? ) ( DOT IDENTIFIER ( generic_dimension_specifier )? )*
            {
            root_0 = (Object)adaptor.nil();


            IDENTIFIER198=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_unbound_type_name2506); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER198_tree = 
            (Object)adaptor.create(IDENTIFIER198)
            ;
            adaptor.addChild(root_0, IDENTIFIER198_tree);
            }

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:670:16: ( ( generic_dimension_specifier )? | DOUBLE_COLON IDENTIFIER ( generic_dimension_specifier )? )
            int alt50=2;
            int LA50_0 = input.LA(1);

            if ( (LA50_0==EOF||LA50_0==CLOSE_PARENS||LA50_0==DOT||LA50_0==LT) ) {
                alt50=1;
            }
            else if ( (LA50_0==DOUBLE_COLON) ) {
                alt50=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 50, 0, input);

                throw nvae;

            }
            switch (alt50) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:670:18: ( generic_dimension_specifier )?
                    {
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:670:18: ( generic_dimension_specifier )?
                    int alt48=2;
                    int LA48_0 = input.LA(1);

                    if ( (LA48_0==LT) ) {
                        alt48=1;
                    }
                    switch (alt48) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:670:18: generic_dimension_specifier
                            {
                            pushFollow(FOLLOW_generic_dimension_specifier_in_unbound_type_name2510);
                            generic_dimension_specifier199=generic_dimension_specifier();

                            state._fsp--;
                            if (state.failed) return retval;
                            if ( state.backtracking==0 ) adaptor.addChild(root_0, generic_dimension_specifier199.getTree());

                            }
                            break;

                    }


                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:671:18: DOUBLE_COLON IDENTIFIER ( generic_dimension_specifier )?
                    {
                    DOUBLE_COLON200=(Token)match(input,DOUBLE_COLON,FOLLOW_DOUBLE_COLON_in_unbound_type_name2530); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    DOUBLE_COLON200_tree = 
                    (Object)adaptor.create(DOUBLE_COLON200)
                    ;
                    adaptor.addChild(root_0, DOUBLE_COLON200_tree);
                    }

                    IDENTIFIER201=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_unbound_type_name2532); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    IDENTIFIER201_tree = 
                    (Object)adaptor.create(IDENTIFIER201)
                    ;
                    adaptor.addChild(root_0, IDENTIFIER201_tree);
                    }

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:671:42: ( generic_dimension_specifier )?
                    int alt49=2;
                    int LA49_0 = input.LA(1);

                    if ( (LA49_0==LT) ) {
                        alt49=1;
                    }
                    switch (alt49) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:671:42: generic_dimension_specifier
                            {
                            pushFollow(FOLLOW_generic_dimension_specifier_in_unbound_type_name2534);
                            generic_dimension_specifier202=generic_dimension_specifier();

                            state._fsp--;
                            if (state.failed) return retval;
                            if ( state.backtracking==0 ) adaptor.addChild(root_0, generic_dimension_specifier202.getTree());

                            }
                            break;

                    }


                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:673:5: ( DOT IDENTIFIER ( generic_dimension_specifier )? )*
            loop52:
            do {
                int alt52=2;
                int LA52_0 = input.LA(1);

                if ( (LA52_0==DOT) ) {
                    alt52=1;
                }


                switch (alt52) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:673:6: DOT IDENTIFIER ( generic_dimension_specifier )?
            	    {
            	    DOT203=(Token)match(input,DOT,FOLLOW_DOT_in_unbound_type_name2559); if (state.failed) return retval;
            	    if ( state.backtracking==0 ) {
            	    DOT203_tree = 
            	    (Object)adaptor.create(DOT203)
            	    ;
            	    adaptor.addChild(root_0, DOT203_tree);
            	    }

            	    IDENTIFIER204=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_unbound_type_name2561); if (state.failed) return retval;
            	    if ( state.backtracking==0 ) {
            	    IDENTIFIER204_tree = 
            	    (Object)adaptor.create(IDENTIFIER204)
            	    ;
            	    adaptor.addChild(root_0, IDENTIFIER204_tree);
            	    }

            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:673:21: ( generic_dimension_specifier )?
            	    int alt51=2;
            	    int LA51_0 = input.LA(1);

            	    if ( (LA51_0==LT) ) {
            	        alt51=1;
            	    }
            	    switch (alt51) {
            	        case 1 :
            	            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:673:21: generic_dimension_specifier
            	            {
            	            pushFollow(FOLLOW_generic_dimension_specifier_in_unbound_type_name2563);
            	            generic_dimension_specifier205=generic_dimension_specifier();

            	            state._fsp--;
            	            if (state.failed) return retval;
            	            if ( state.backtracking==0 ) adaptor.addChild(root_0, generic_dimension_specifier205.getTree());

            	            }
            	            break;

            	    }


            	    }
            	    break;

            	default :
            	    break loop52;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "unbound_type_name"


    public static class generic_dimension_specifier_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "generic_dimension_specifier"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:675:1: generic_dimension_specifier : LT ( commas )? GT ;
    public final CSharp4AST.generic_dimension_specifier_return generic_dimension_specifier() throws RecognitionException {
        CSharp4AST.generic_dimension_specifier_return retval = new CSharp4AST.generic_dimension_specifier_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token LT206=null;
        Token GT208=null;
        CSharp4AST.commas_return commas207 =null;


        Object LT206_tree=null;
        Object GT208_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:676:2: ( LT ( commas )? GT )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:676:4: LT ( commas )? GT
            {
            root_0 = (Object)adaptor.nil();


            LT206=(Token)match(input,LT,FOLLOW_LT_in_generic_dimension_specifier2578); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            LT206_tree = 
            (Object)adaptor.create(LT206)
            ;
            adaptor.addChild(root_0, LT206_tree);
            }

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:676:7: ( commas )?
            int alt53=2;
            int LA53_0 = input.LA(1);

            if ( (LA53_0==COMMA) ) {
                alt53=1;
            }
            switch (alt53) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:676:7: commas
                    {
                    pushFollow(FOLLOW_commas_in_generic_dimension_specifier2580);
                    commas207=commas();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, commas207.getTree());

                    }
                    break;

            }


            GT208=(Token)match(input,GT,FOLLOW_GT_in_generic_dimension_specifier2583); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            GT208_tree = 
            (Object)adaptor.create(GT208)
            ;
            adaptor.addChild(root_0, GT208_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "generic_dimension_specifier"


    public static class commas_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "commas"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:678:1: commas : COMMA ( COMMA )* ;
    public final CSharp4AST.commas_return commas() throws RecognitionException {
        CSharp4AST.commas_return retval = new CSharp4AST.commas_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token COMMA209=null;
        Token COMMA210=null;

        Object COMMA209_tree=null;
        Object COMMA210_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:679:2: ( COMMA ( COMMA )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:679:4: COMMA ( COMMA )*
            {
            root_0 = (Object)adaptor.nil();


            COMMA209=(Token)match(input,COMMA,FOLLOW_COMMA_in_commas2594); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            COMMA209_tree = 
            (Object)adaptor.create(COMMA209)
            ;
            adaptor.addChild(root_0, COMMA209_tree);
            }

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:679:10: ( COMMA )*
            loop54:
            do {
                int alt54=2;
                int LA54_0 = input.LA(1);

                if ( (LA54_0==COMMA) ) {
                    alt54=1;
                }


                switch (alt54) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:679:12: COMMA
            	    {
            	    COMMA210=(Token)match(input,COMMA,FOLLOW_COMMA_in_commas2598); if (state.failed) return retval;
            	    if ( state.backtracking==0 ) {
            	    COMMA210_tree = 
            	    (Object)adaptor.create(COMMA210)
            	    ;
            	    adaptor.addChild(root_0, COMMA210_tree);
            	    }

            	    }
            	    break;

            	default :
            	    break loop54;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "commas"


    public static class checked_expression_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "checked_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:681:1: checked_expression : CHECKED ^ OPEN_PARENS ! expression CLOSE_PARENS !;
    public final CSharp4AST.checked_expression_return checked_expression() throws RecognitionException {
        CSharp4AST.checked_expression_return retval = new CSharp4AST.checked_expression_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token CHECKED211=null;
        Token OPEN_PARENS212=null;
        Token CLOSE_PARENS214=null;
        CSharp4AST.expression_return expression213 =null;


        Object CHECKED211_tree=null;
        Object OPEN_PARENS212_tree=null;
        Object CLOSE_PARENS214_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:682:2: ( CHECKED ^ OPEN_PARENS ! expression CLOSE_PARENS !)
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:682:4: CHECKED ^ OPEN_PARENS ! expression CLOSE_PARENS !
            {
            root_0 = (Object)adaptor.nil();


            CHECKED211=(Token)match(input,CHECKED,FOLLOW_CHECKED_in_checked_expression2612); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            CHECKED211_tree = 
            (Object)adaptor.create(CHECKED211)
            ;
            root_0 = (Object)adaptor.becomeRoot(CHECKED211_tree, root_0);
            }

            OPEN_PARENS212=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_checked_expression2615); if (state.failed) return retval;

            pushFollow(FOLLOW_expression_in_checked_expression2618);
            expression213=expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, expression213.getTree());

            CLOSE_PARENS214=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_checked_expression2620); if (state.failed) return retval;

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "checked_expression"


    public static class unchecked_expression_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "unchecked_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:684:1: unchecked_expression : UNCHECKED ^ OPEN_PARENS ! expression CLOSE_PARENS !;
    public final CSharp4AST.unchecked_expression_return unchecked_expression() throws RecognitionException {
        CSharp4AST.unchecked_expression_return retval = new CSharp4AST.unchecked_expression_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token UNCHECKED215=null;
        Token OPEN_PARENS216=null;
        Token CLOSE_PARENS218=null;
        CSharp4AST.expression_return expression217 =null;


        Object UNCHECKED215_tree=null;
        Object OPEN_PARENS216_tree=null;
        Object CLOSE_PARENS218_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:685:2: ( UNCHECKED ^ OPEN_PARENS ! expression CLOSE_PARENS !)
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:685:4: UNCHECKED ^ OPEN_PARENS ! expression CLOSE_PARENS !
            {
            root_0 = (Object)adaptor.nil();


            UNCHECKED215=(Token)match(input,UNCHECKED,FOLLOW_UNCHECKED_in_unchecked_expression2632); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            UNCHECKED215_tree = 
            (Object)adaptor.create(UNCHECKED215)
            ;
            root_0 = (Object)adaptor.becomeRoot(UNCHECKED215_tree, root_0);
            }

            OPEN_PARENS216=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_unchecked_expression2635); if (state.failed) return retval;

            pushFollow(FOLLOW_expression_in_unchecked_expression2638);
            expression217=expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, expression217.getTree());

            CLOSE_PARENS218=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_unchecked_expression2640); if (state.failed) return retval;

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "unchecked_expression"


    public static class default_value_expression_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "default_value_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:687:1: default_value_expression : DEFAULT ^ OPEN_PARENS ! type CLOSE_PARENS !;
    public final CSharp4AST.default_value_expression_return default_value_expression() throws RecognitionException {
        CSharp4AST.default_value_expression_return retval = new CSharp4AST.default_value_expression_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token DEFAULT219=null;
        Token OPEN_PARENS220=null;
        Token CLOSE_PARENS222=null;
        CSharp4AST.type_return type221 =null;


        Object DEFAULT219_tree=null;
        Object OPEN_PARENS220_tree=null;
        Object CLOSE_PARENS222_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:688:2: ( DEFAULT ^ OPEN_PARENS ! type CLOSE_PARENS !)
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:688:4: DEFAULT ^ OPEN_PARENS ! type CLOSE_PARENS !
            {
            root_0 = (Object)adaptor.nil();


            DEFAULT219=(Token)match(input,DEFAULT,FOLLOW_DEFAULT_in_default_value_expression2652); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            DEFAULT219_tree = 
            (Object)adaptor.create(DEFAULT219)
            ;
            root_0 = (Object)adaptor.becomeRoot(DEFAULT219_tree, root_0);
            }

            OPEN_PARENS220=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_default_value_expression2655); if (state.failed) return retval;

            pushFollow(FOLLOW_type_in_default_value_expression2658);
            type221=type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, type221.getTree());

            CLOSE_PARENS222=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_default_value_expression2660); if (state.failed) return retval;

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "default_value_expression"


    public static class unary_expression_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "unary_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:703:1: unary_expression : unary_expression2 -> ^( UNARY_EXPRESSION unary_expression2 ) ;
    public final CSharp4AST.unary_expression_return unary_expression() throws RecognitionException {
        CSharp4AST.unary_expression_return retval = new CSharp4AST.unary_expression_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.unary_expression2_return unary_expression2223 =null;


        RewriteRuleSubtreeStream stream_unary_expression2=new RewriteRuleSubtreeStream(adaptor,"rule unary_expression2");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:704:3: ( unary_expression2 -> ^( UNARY_EXPRESSION unary_expression2 ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:704:5: unary_expression2
            {
            pushFollow(FOLLOW_unary_expression2_in_unary_expression2675);
            unary_expression2223=unary_expression2();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_unary_expression2.add(unary_expression2223.getTree());

            // AST REWRITE
            // elements: unary_expression2
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 704:23: -> ^( UNARY_EXPRESSION unary_expression2 )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:704:26: ^( UNARY_EXPRESSION unary_expression2 )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(UNARY_EXPRESSION, "UNARY_EXPRESSION")
                , root_1);

                adaptor.addChild(root_1, stream_unary_expression2.nextTree());

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "unary_expression"


    public static class unary_expression2_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "unary_expression2"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:706:1: unary_expression2 : ( ( scan_for_cast_generic_precedence | OPEN_PARENS predefined_type )=> cast_expression | primary_expression | PLUS unary_expression | MINUS unary_expression | BANG unary_expression -> ^( BOOL_NOT unary_expression ) | TILDE unary_expression | pre_increment_expression | pre_decrement_expression | unary_expression_unsafe );
    public final CSharp4AST.unary_expression2_return unary_expression2() throws RecognitionException {
        CSharp4AST.unary_expression2_return retval = new CSharp4AST.unary_expression2_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token PLUS226=null;
        Token MINUS228=null;
        Token BANG230=null;
        Token TILDE232=null;
        CSharp4AST.cast_expression_return cast_expression224 =null;

        CSharp4AST.primary_expression_return primary_expression225 =null;

        CSharp4AST.unary_expression_return unary_expression227 =null;

        CSharp4AST.unary_expression_return unary_expression229 =null;

        CSharp4AST.unary_expression_return unary_expression231 =null;

        CSharp4AST.unary_expression_return unary_expression233 =null;

        CSharp4AST.pre_increment_expression_return pre_increment_expression234 =null;

        CSharp4AST.pre_decrement_expression_return pre_decrement_expression235 =null;

        CSharp4AST.unary_expression_unsafe_return unary_expression_unsafe236 =null;


        Object PLUS226_tree=null;
        Object MINUS228_tree=null;
        Object BANG230_tree=null;
        Object TILDE232_tree=null;
        RewriteRuleTokenStream stream_BANG=new RewriteRuleTokenStream(adaptor,"token BANG");
        RewriteRuleSubtreeStream stream_unary_expression=new RewriteRuleSubtreeStream(adaptor,"rule unary_expression");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:707:2: ( ( scan_for_cast_generic_precedence | OPEN_PARENS predefined_type )=> cast_expression | primary_expression | PLUS unary_expression | MINUS unary_expression | BANG unary_expression -> ^( BOOL_NOT unary_expression ) | TILDE unary_expression | pre_increment_expression | pre_decrement_expression | unary_expression_unsafe )
            int alt55=9;
            switch ( input.LA(1) ) {
            case OPEN_PARENS:
                {
                int LA55_1 = input.LA(2);

                if ( (synpred7_CSharp4AST()) ) {
                    alt55=1;
                }
                else if ( (true) ) {
                    alt55=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 55, 1, input);

                    throw nvae;

                }
                }
                break;
            case BASE:
            case BOOL:
            case BYTE:
            case CHAR:
            case CHARACTER_LITERAL:
            case CHECKED:
            case DECIMAL:
            case DEFAULT:
            case DELEGATE:
            case DOUBLE:
            case FALSE:
            case FLOAT:
            case IDENTIFIER:
            case INT:
            case INTEGER_LITERAL:
            case LONG:
            case NEW:
            case NULL:
            case OBJECT:
            case REAL_LITERAL:
            case SBYTE:
            case SHORT:
            case SIZEOF:
            case STRING:
            case STRING_LITERAL:
            case THIS:
            case TRUE:
            case TYPEOF:
            case UINT:
            case ULONG:
            case UNCHECKED:
            case USHORT:
                {
                alt55=2;
                }
                break;
            case PLUS:
                {
                alt55=3;
                }
                break;
            case MINUS:
                {
                alt55=4;
                }
                break;
            case BANG:
                {
                alt55=5;
                }
                break;
            case TILDE:
                {
                alt55=6;
                }
                break;
            case OP_INC:
                {
                alt55=7;
                }
                break;
            case OP_DEC:
                {
                alt55=8;
                }
                break;
            case AMP:
            case STAR:
                {
                alt55=9;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 55, 0, input);

                throw nvae;

            }

            switch (alt55) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:707:4: ( scan_for_cast_generic_precedence | OPEN_PARENS predefined_type )=> cast_expression
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_cast_expression_in_unary_expression22706);
                    cast_expression224=cast_expression();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, cast_expression224.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:708:4: primary_expression
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_primary_expression_in_unary_expression22711);
                    primary_expression225=primary_expression();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, primary_expression225.getTree());

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:709:4: PLUS unary_expression
                    {
                    root_0 = (Object)adaptor.nil();


                    PLUS226=(Token)match(input,PLUS,FOLLOW_PLUS_in_unary_expression22716); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PLUS226_tree = 
                    (Object)adaptor.create(PLUS226)
                    ;
                    adaptor.addChild(root_0, PLUS226_tree);
                    }

                    pushFollow(FOLLOW_unary_expression_in_unary_expression22718);
                    unary_expression227=unary_expression();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, unary_expression227.getTree());

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:710:4: MINUS unary_expression
                    {
                    root_0 = (Object)adaptor.nil();


                    MINUS228=(Token)match(input,MINUS,FOLLOW_MINUS_in_unary_expression22723); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    MINUS228_tree = 
                    (Object)adaptor.create(MINUS228)
                    ;
                    adaptor.addChild(root_0, MINUS228_tree);
                    }

                    pushFollow(FOLLOW_unary_expression_in_unary_expression22725);
                    unary_expression229=unary_expression();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, unary_expression229.getTree());

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:711:4: BANG unary_expression
                    {
                    BANG230=(Token)match(input,BANG,FOLLOW_BANG_in_unary_expression22730); if (state.failed) return retval; 
                    if ( state.backtracking==0 ) stream_BANG.add(BANG230);


                    pushFollow(FOLLOW_unary_expression_in_unary_expression22732);
                    unary_expression231=unary_expression();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) stream_unary_expression.add(unary_expression231.getTree());

                    // AST REWRITE
                    // elements: unary_expression
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    // wildcard labels: 
                    if ( state.backtracking==0 ) {

                    retval.tree = root_0;
                    RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

                    root_0 = (Object)adaptor.nil();
                    // 711:27: -> ^( BOOL_NOT unary_expression )
                    {
                        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:711:30: ^( BOOL_NOT unary_expression )
                        {
                        Object root_1 = (Object)adaptor.nil();
                        root_1 = (Object)adaptor.becomeRoot(
                        (Object)adaptor.create(BOOL_NOT, "BOOL_NOT")
                        , root_1);

                        adaptor.addChild(root_1, stream_unary_expression.nextTree());

                        adaptor.addChild(root_0, root_1);
                        }

                    }


                    retval.tree = root_0;
                    }

                    }
                    break;
                case 6 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:712:4: TILDE unary_expression
                    {
                    root_0 = (Object)adaptor.nil();


                    TILDE232=(Token)match(input,TILDE,FOLLOW_TILDE_in_unary_expression22746); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    TILDE232_tree = 
                    (Object)adaptor.create(TILDE232)
                    ;
                    adaptor.addChild(root_0, TILDE232_tree);
                    }

                    pushFollow(FOLLOW_unary_expression_in_unary_expression22748);
                    unary_expression233=unary_expression();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, unary_expression233.getTree());

                    }
                    break;
                case 7 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:713:4: pre_increment_expression
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_pre_increment_expression_in_unary_expression22753);
                    pre_increment_expression234=pre_increment_expression();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, pre_increment_expression234.getTree());

                    }
                    break;
                case 8 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:714:4: pre_decrement_expression
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_pre_decrement_expression_in_unary_expression22758);
                    pre_decrement_expression235=pre_decrement_expression();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, pre_decrement_expression235.getTree());

                    }
                    break;
                case 9 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:715:4: unary_expression_unsafe
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_unary_expression_unsafe_in_unary_expression22763);
                    unary_expression_unsafe236=unary_expression_unsafe();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, unary_expression_unsafe236.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "unary_expression2"


    public static class scan_for_cast_generic_precedence_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "scan_for_cast_generic_precedence"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:720:1: scan_for_cast_generic_precedence : OPEN_PARENS type CLOSE_PARENS cast_disambiguation_token ;
    public final CSharp4AST.scan_for_cast_generic_precedence_return scan_for_cast_generic_precedence() throws RecognitionException {
        CSharp4AST.scan_for_cast_generic_precedence_return retval = new CSharp4AST.scan_for_cast_generic_precedence_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token OPEN_PARENS237=null;
        Token CLOSE_PARENS239=null;
        CSharp4AST.type_return type238 =null;

        CSharp4AST.cast_disambiguation_token_return cast_disambiguation_token240 =null;


        Object OPEN_PARENS237_tree=null;
        Object CLOSE_PARENS239_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:721:3: ( OPEN_PARENS type CLOSE_PARENS cast_disambiguation_token )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:721:5: OPEN_PARENS type CLOSE_PARENS cast_disambiguation_token
            {
            root_0 = (Object)adaptor.nil();


            OPEN_PARENS237=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_scan_for_cast_generic_precedence2777); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            OPEN_PARENS237_tree = 
            (Object)adaptor.create(OPEN_PARENS237)
            ;
            adaptor.addChild(root_0, OPEN_PARENS237_tree);
            }

            pushFollow(FOLLOW_type_in_scan_for_cast_generic_precedence2779);
            type238=type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, type238.getTree());

            CLOSE_PARENS239=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_scan_for_cast_generic_precedence2781); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            CLOSE_PARENS239_tree = 
            (Object)adaptor.create(CLOSE_PARENS239)
            ;
            adaptor.addChild(root_0, CLOSE_PARENS239_tree);
            }

            pushFollow(FOLLOW_cast_disambiguation_token_in_scan_for_cast_generic_precedence2783);
            cast_disambiguation_token240=cast_disambiguation_token();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, cast_disambiguation_token240.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "scan_for_cast_generic_precedence"


    public static class cast_disambiguation_token_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "cast_disambiguation_token"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:726:1: cast_disambiguation_token : ( TILDE | BANG | OPEN_PARENS | IDENTIFIER | literal | ABSTRACT | BASE | BOOL | BREAK | BYTE | CASE | CATCH | CHAR | CHECKED | CLASS | CONST | CONTINUE | DECIMAL | DEFAULT | DELEGATE | DO | DOUBLE | ELSE | ENUM | EVENT | EXPLICIT | EXTERN | FINALLY | FIXED | FLOAT | FOR | FOREACH | GOTO | IF | IMPLICIT | IN | INT | INTERFACE | INTERNAL | LOCK | LONG | NAMESPACE | NEW | OBJECT | OPERATOR | OUT | OVERRIDE | PARAMS | PRIVATE | PROTECTED | PUBLIC | READONLY | REF | RETURN | SBYTE | SEALED | SHORT | SIZEOF | STACKALLOC | STATIC | STRING | STRUCT | SWITCH | THIS | THROW | TRY | TYPEOF | UINT | ULONG | UNCHECKED | UNSAFE | USHORT | USING | VIRTUAL | VOID | VOLATILE | WHILE ) ;
    public final CSharp4AST.cast_disambiguation_token_return cast_disambiguation_token() throws RecognitionException {
        CSharp4AST.cast_disambiguation_token_return retval = new CSharp4AST.cast_disambiguation_token_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token TILDE241=null;
        Token BANG242=null;
        Token OPEN_PARENS243=null;
        Token IDENTIFIER244=null;
        Token ABSTRACT246=null;
        Token BASE247=null;
        Token BOOL248=null;
        Token BREAK249=null;
        Token BYTE250=null;
        Token CASE251=null;
        Token CATCH252=null;
        Token CHAR253=null;
        Token CHECKED254=null;
        Token CLASS255=null;
        Token CONST256=null;
        Token CONTINUE257=null;
        Token DECIMAL258=null;
        Token DEFAULT259=null;
        Token DELEGATE260=null;
        Token DO261=null;
        Token DOUBLE262=null;
        Token ELSE263=null;
        Token ENUM264=null;
        Token EVENT265=null;
        Token EXPLICIT266=null;
        Token EXTERN267=null;
        Token FINALLY268=null;
        Token FIXED269=null;
        Token FLOAT270=null;
        Token FOR271=null;
        Token FOREACH272=null;
        Token GOTO273=null;
        Token IF274=null;
        Token IMPLICIT275=null;
        Token IN276=null;
        Token INT277=null;
        Token INTERFACE278=null;
        Token INTERNAL279=null;
        Token LOCK280=null;
        Token LONG281=null;
        Token NAMESPACE282=null;
        Token NEW283=null;
        Token OBJECT284=null;
        Token OPERATOR285=null;
        Token OUT286=null;
        Token OVERRIDE287=null;
        Token PARAMS288=null;
        Token PRIVATE289=null;
        Token PROTECTED290=null;
        Token PUBLIC291=null;
        Token READONLY292=null;
        Token REF293=null;
        Token RETURN294=null;
        Token SBYTE295=null;
        Token SEALED296=null;
        Token SHORT297=null;
        Token SIZEOF298=null;
        Token STACKALLOC299=null;
        Token STATIC300=null;
        Token STRING301=null;
        Token STRUCT302=null;
        Token SWITCH303=null;
        Token THIS304=null;
        Token THROW305=null;
        Token TRY306=null;
        Token TYPEOF307=null;
        Token UINT308=null;
        Token ULONG309=null;
        Token UNCHECKED310=null;
        Token UNSAFE311=null;
        Token USHORT312=null;
        Token USING313=null;
        Token VIRTUAL314=null;
        Token VOID315=null;
        Token VOLATILE316=null;
        Token WHILE317=null;
        CSharp4AST.literal_return literal245 =null;


        Object TILDE241_tree=null;
        Object BANG242_tree=null;
        Object OPEN_PARENS243_tree=null;
        Object IDENTIFIER244_tree=null;
        Object ABSTRACT246_tree=null;
        Object BASE247_tree=null;
        Object BOOL248_tree=null;
        Object BREAK249_tree=null;
        Object BYTE250_tree=null;
        Object CASE251_tree=null;
        Object CATCH252_tree=null;
        Object CHAR253_tree=null;
        Object CHECKED254_tree=null;
        Object CLASS255_tree=null;
        Object CONST256_tree=null;
        Object CONTINUE257_tree=null;
        Object DECIMAL258_tree=null;
        Object DEFAULT259_tree=null;
        Object DELEGATE260_tree=null;
        Object DO261_tree=null;
        Object DOUBLE262_tree=null;
        Object ELSE263_tree=null;
        Object ENUM264_tree=null;
        Object EVENT265_tree=null;
        Object EXPLICIT266_tree=null;
        Object EXTERN267_tree=null;
        Object FINALLY268_tree=null;
        Object FIXED269_tree=null;
        Object FLOAT270_tree=null;
        Object FOR271_tree=null;
        Object FOREACH272_tree=null;
        Object GOTO273_tree=null;
        Object IF274_tree=null;
        Object IMPLICIT275_tree=null;
        Object IN276_tree=null;
        Object INT277_tree=null;
        Object INTERFACE278_tree=null;
        Object INTERNAL279_tree=null;
        Object LOCK280_tree=null;
        Object LONG281_tree=null;
        Object NAMESPACE282_tree=null;
        Object NEW283_tree=null;
        Object OBJECT284_tree=null;
        Object OPERATOR285_tree=null;
        Object OUT286_tree=null;
        Object OVERRIDE287_tree=null;
        Object PARAMS288_tree=null;
        Object PRIVATE289_tree=null;
        Object PROTECTED290_tree=null;
        Object PUBLIC291_tree=null;
        Object READONLY292_tree=null;
        Object REF293_tree=null;
        Object RETURN294_tree=null;
        Object SBYTE295_tree=null;
        Object SEALED296_tree=null;
        Object SHORT297_tree=null;
        Object SIZEOF298_tree=null;
        Object STACKALLOC299_tree=null;
        Object STATIC300_tree=null;
        Object STRING301_tree=null;
        Object STRUCT302_tree=null;
        Object SWITCH303_tree=null;
        Object THIS304_tree=null;
        Object THROW305_tree=null;
        Object TRY306_tree=null;
        Object TYPEOF307_tree=null;
        Object UINT308_tree=null;
        Object ULONG309_tree=null;
        Object UNCHECKED310_tree=null;
        Object UNSAFE311_tree=null;
        Object USHORT312_tree=null;
        Object USING313_tree=null;
        Object VIRTUAL314_tree=null;
        Object VOID315_tree=null;
        Object VOLATILE316_tree=null;
        Object WHILE317_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:727:3: ( ( TILDE | BANG | OPEN_PARENS | IDENTIFIER | literal | ABSTRACT | BASE | BOOL | BREAK | BYTE | CASE | CATCH | CHAR | CHECKED | CLASS | CONST | CONTINUE | DECIMAL | DEFAULT | DELEGATE | DO | DOUBLE | ELSE | ENUM | EVENT | EXPLICIT | EXTERN | FINALLY | FIXED | FLOAT | FOR | FOREACH | GOTO | IF | IMPLICIT | IN | INT | INTERFACE | INTERNAL | LOCK | LONG | NAMESPACE | NEW | OBJECT | OPERATOR | OUT | OVERRIDE | PARAMS | PRIVATE | PROTECTED | PUBLIC | READONLY | REF | RETURN | SBYTE | SEALED | SHORT | SIZEOF | STACKALLOC | STATIC | STRING | STRUCT | SWITCH | THIS | THROW | TRY | TYPEOF | UINT | ULONG | UNCHECKED | UNSAFE | USHORT | USING | VIRTUAL | VOID | VOLATILE | WHILE ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:727:5: ( TILDE | BANG | OPEN_PARENS | IDENTIFIER | literal | ABSTRACT | BASE | BOOL | BREAK | BYTE | CASE | CATCH | CHAR | CHECKED | CLASS | CONST | CONTINUE | DECIMAL | DEFAULT | DELEGATE | DO | DOUBLE | ELSE | ENUM | EVENT | EXPLICIT | EXTERN | FINALLY | FIXED | FLOAT | FOR | FOREACH | GOTO | IF | IMPLICIT | IN | INT | INTERFACE | INTERNAL | LOCK | LONG | NAMESPACE | NEW | OBJECT | OPERATOR | OUT | OVERRIDE | PARAMS | PRIVATE | PROTECTED | PUBLIC | READONLY | REF | RETURN | SBYTE | SEALED | SHORT | SIZEOF | STACKALLOC | STATIC | STRING | STRUCT | SWITCH | THIS | THROW | TRY | TYPEOF | UINT | ULONG | UNCHECKED | UNSAFE | USHORT | USING | VIRTUAL | VOID | VOLATILE | WHILE )
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:727:5: ( TILDE | BANG | OPEN_PARENS | IDENTIFIER | literal | ABSTRACT | BASE | BOOL | BREAK | BYTE | CASE | CATCH | CHAR | CHECKED | CLASS | CONST | CONTINUE | DECIMAL | DEFAULT | DELEGATE | DO | DOUBLE | ELSE | ENUM | EVENT | EXPLICIT | EXTERN | FINALLY | FIXED | FLOAT | FOR | FOREACH | GOTO | IF | IMPLICIT | IN | INT | INTERFACE | INTERNAL | LOCK | LONG | NAMESPACE | NEW | OBJECT | OPERATOR | OUT | OVERRIDE | PARAMS | PRIVATE | PROTECTED | PUBLIC | READONLY | REF | RETURN | SBYTE | SEALED | SHORT | SIZEOF | STACKALLOC | STATIC | STRING | STRUCT | SWITCH | THIS | THROW | TRY | TYPEOF | UINT | ULONG | UNCHECKED | UNSAFE | USHORT | USING | VIRTUAL | VOID | VOLATILE | WHILE )
            int alt56=77;
            alt56 = dfa56.predict(input);
            switch (alt56) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:727:6: TILDE
                    {
                    TILDE241=(Token)match(input,TILDE,FOLLOW_TILDE_in_cast_disambiguation_token2799); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    TILDE241_tree = 
                    (Object)adaptor.create(TILDE241)
                    ;
                    adaptor.addChild(root_0, TILDE241_tree);
                    }

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:727:14: BANG
                    {
                    BANG242=(Token)match(input,BANG,FOLLOW_BANG_in_cast_disambiguation_token2803); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    BANG242_tree = 
                    (Object)adaptor.create(BANG242)
                    ;
                    adaptor.addChild(root_0, BANG242_tree);
                    }

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:727:21: OPEN_PARENS
                    {
                    OPEN_PARENS243=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_cast_disambiguation_token2807); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OPEN_PARENS243_tree = 
                    (Object)adaptor.create(OPEN_PARENS243)
                    ;
                    adaptor.addChild(root_0, OPEN_PARENS243_tree);
                    }

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:727:35: IDENTIFIER
                    {
                    IDENTIFIER244=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_cast_disambiguation_token2811); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    IDENTIFIER244_tree = 
                    (Object)adaptor.create(IDENTIFIER244)
                    ;
                    adaptor.addChild(root_0, IDENTIFIER244_tree);
                    }

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:727:48: literal
                    {
                    pushFollow(FOLLOW_literal_in_cast_disambiguation_token2815);
                    literal245=literal();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, literal245.getTree());

                    }
                    break;
                case 6 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:727:58: ABSTRACT
                    {
                    ABSTRACT246=(Token)match(input,ABSTRACT,FOLLOW_ABSTRACT_in_cast_disambiguation_token2819); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    ABSTRACT246_tree = 
                    (Object)adaptor.create(ABSTRACT246)
                    ;
                    adaptor.addChild(root_0, ABSTRACT246_tree);
                    }

                    }
                    break;
                case 7 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:727:69: BASE
                    {
                    BASE247=(Token)match(input,BASE,FOLLOW_BASE_in_cast_disambiguation_token2823); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    BASE247_tree = 
                    (Object)adaptor.create(BASE247)
                    ;
                    adaptor.addChild(root_0, BASE247_tree);
                    }

                    }
                    break;
                case 8 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:727:76: BOOL
                    {
                    BOOL248=(Token)match(input,BOOL,FOLLOW_BOOL_in_cast_disambiguation_token2827); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    BOOL248_tree = 
                    (Object)adaptor.create(BOOL248)
                    ;
                    adaptor.addChild(root_0, BOOL248_tree);
                    }

                    }
                    break;
                case 9 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:727:83: BREAK
                    {
                    BREAK249=(Token)match(input,BREAK,FOLLOW_BREAK_in_cast_disambiguation_token2831); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    BREAK249_tree = 
                    (Object)adaptor.create(BREAK249)
                    ;
                    adaptor.addChild(root_0, BREAK249_tree);
                    }

                    }
                    break;
                case 10 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:727:91: BYTE
                    {
                    BYTE250=(Token)match(input,BYTE,FOLLOW_BYTE_in_cast_disambiguation_token2835); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    BYTE250_tree = 
                    (Object)adaptor.create(BYTE250)
                    ;
                    adaptor.addChild(root_0, BYTE250_tree);
                    }

                    }
                    break;
                case 11 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:727:98: CASE
                    {
                    CASE251=(Token)match(input,CASE,FOLLOW_CASE_in_cast_disambiguation_token2839); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    CASE251_tree = 
                    (Object)adaptor.create(CASE251)
                    ;
                    adaptor.addChild(root_0, CASE251_tree);
                    }

                    }
                    break;
                case 12 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:727:105: CATCH
                    {
                    CATCH252=(Token)match(input,CATCH,FOLLOW_CATCH_in_cast_disambiguation_token2843); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    CATCH252_tree = 
                    (Object)adaptor.create(CATCH252)
                    ;
                    adaptor.addChild(root_0, CATCH252_tree);
                    }

                    }
                    break;
                case 13 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:728:7: CHAR
                    {
                    CHAR253=(Token)match(input,CHAR,FOLLOW_CHAR_in_cast_disambiguation_token2851); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    CHAR253_tree = 
                    (Object)adaptor.create(CHAR253)
                    ;
                    adaptor.addChild(root_0, CHAR253_tree);
                    }

                    }
                    break;
                case 14 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:728:14: CHECKED
                    {
                    CHECKED254=(Token)match(input,CHECKED,FOLLOW_CHECKED_in_cast_disambiguation_token2855); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    CHECKED254_tree = 
                    (Object)adaptor.create(CHECKED254)
                    ;
                    adaptor.addChild(root_0, CHECKED254_tree);
                    }

                    }
                    break;
                case 15 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:728:24: CLASS
                    {
                    CLASS255=(Token)match(input,CLASS,FOLLOW_CLASS_in_cast_disambiguation_token2859); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    CLASS255_tree = 
                    (Object)adaptor.create(CLASS255)
                    ;
                    adaptor.addChild(root_0, CLASS255_tree);
                    }

                    }
                    break;
                case 16 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:728:32: CONST
                    {
                    CONST256=(Token)match(input,CONST,FOLLOW_CONST_in_cast_disambiguation_token2863); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    CONST256_tree = 
                    (Object)adaptor.create(CONST256)
                    ;
                    adaptor.addChild(root_0, CONST256_tree);
                    }

                    }
                    break;
                case 17 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:728:40: CONTINUE
                    {
                    CONTINUE257=(Token)match(input,CONTINUE,FOLLOW_CONTINUE_in_cast_disambiguation_token2867); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    CONTINUE257_tree = 
                    (Object)adaptor.create(CONTINUE257)
                    ;
                    adaptor.addChild(root_0, CONTINUE257_tree);
                    }

                    }
                    break;
                case 18 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:728:51: DECIMAL
                    {
                    DECIMAL258=(Token)match(input,DECIMAL,FOLLOW_DECIMAL_in_cast_disambiguation_token2871); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    DECIMAL258_tree = 
                    (Object)adaptor.create(DECIMAL258)
                    ;
                    adaptor.addChild(root_0, DECIMAL258_tree);
                    }

                    }
                    break;
                case 19 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:728:61: DEFAULT
                    {
                    DEFAULT259=(Token)match(input,DEFAULT,FOLLOW_DEFAULT_in_cast_disambiguation_token2875); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    DEFAULT259_tree = 
                    (Object)adaptor.create(DEFAULT259)
                    ;
                    adaptor.addChild(root_0, DEFAULT259_tree);
                    }

                    }
                    break;
                case 20 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:728:71: DELEGATE
                    {
                    DELEGATE260=(Token)match(input,DELEGATE,FOLLOW_DELEGATE_in_cast_disambiguation_token2879); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    DELEGATE260_tree = 
                    (Object)adaptor.create(DELEGATE260)
                    ;
                    adaptor.addChild(root_0, DELEGATE260_tree);
                    }

                    }
                    break;
                case 21 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:728:82: DO
                    {
                    DO261=(Token)match(input,DO,FOLLOW_DO_in_cast_disambiguation_token2883); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    DO261_tree = 
                    (Object)adaptor.create(DO261)
                    ;
                    adaptor.addChild(root_0, DO261_tree);
                    }

                    }
                    break;
                case 22 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:728:87: DOUBLE
                    {
                    DOUBLE262=(Token)match(input,DOUBLE,FOLLOW_DOUBLE_in_cast_disambiguation_token2887); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    DOUBLE262_tree = 
                    (Object)adaptor.create(DOUBLE262)
                    ;
                    adaptor.addChild(root_0, DOUBLE262_tree);
                    }

                    }
                    break;
                case 23 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:728:96: ELSE
                    {
                    ELSE263=(Token)match(input,ELSE,FOLLOW_ELSE_in_cast_disambiguation_token2891); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    ELSE263_tree = 
                    (Object)adaptor.create(ELSE263)
                    ;
                    adaptor.addChild(root_0, ELSE263_tree);
                    }

                    }
                    break;
                case 24 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:728:103: ENUM
                    {
                    ENUM264=(Token)match(input,ENUM,FOLLOW_ENUM_in_cast_disambiguation_token2895); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    ENUM264_tree = 
                    (Object)adaptor.create(ENUM264)
                    ;
                    adaptor.addChild(root_0, ENUM264_tree);
                    }

                    }
                    break;
                case 25 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:729:7: EVENT
                    {
                    EVENT265=(Token)match(input,EVENT,FOLLOW_EVENT_in_cast_disambiguation_token2903); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    EVENT265_tree = 
                    (Object)adaptor.create(EVENT265)
                    ;
                    adaptor.addChild(root_0, EVENT265_tree);
                    }

                    }
                    break;
                case 26 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:729:15: EXPLICIT
                    {
                    EXPLICIT266=(Token)match(input,EXPLICIT,FOLLOW_EXPLICIT_in_cast_disambiguation_token2907); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    EXPLICIT266_tree = 
                    (Object)adaptor.create(EXPLICIT266)
                    ;
                    adaptor.addChild(root_0, EXPLICIT266_tree);
                    }

                    }
                    break;
                case 27 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:729:26: EXTERN
                    {
                    EXTERN267=(Token)match(input,EXTERN,FOLLOW_EXTERN_in_cast_disambiguation_token2911); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    EXTERN267_tree = 
                    (Object)adaptor.create(EXTERN267)
                    ;
                    adaptor.addChild(root_0, EXTERN267_tree);
                    }

                    }
                    break;
                case 28 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:729:35: FINALLY
                    {
                    FINALLY268=(Token)match(input,FINALLY,FOLLOW_FINALLY_in_cast_disambiguation_token2915); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    FINALLY268_tree = 
                    (Object)adaptor.create(FINALLY268)
                    ;
                    adaptor.addChild(root_0, FINALLY268_tree);
                    }

                    }
                    break;
                case 29 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:729:45: FIXED
                    {
                    FIXED269=(Token)match(input,FIXED,FOLLOW_FIXED_in_cast_disambiguation_token2919); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    FIXED269_tree = 
                    (Object)adaptor.create(FIXED269)
                    ;
                    adaptor.addChild(root_0, FIXED269_tree);
                    }

                    }
                    break;
                case 30 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:729:53: FLOAT
                    {
                    FLOAT270=(Token)match(input,FLOAT,FOLLOW_FLOAT_in_cast_disambiguation_token2923); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    FLOAT270_tree = 
                    (Object)adaptor.create(FLOAT270)
                    ;
                    adaptor.addChild(root_0, FLOAT270_tree);
                    }

                    }
                    break;
                case 31 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:729:61: FOR
                    {
                    FOR271=(Token)match(input,FOR,FOLLOW_FOR_in_cast_disambiguation_token2927); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    FOR271_tree = 
                    (Object)adaptor.create(FOR271)
                    ;
                    adaptor.addChild(root_0, FOR271_tree);
                    }

                    }
                    break;
                case 32 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:729:67: FOREACH
                    {
                    FOREACH272=(Token)match(input,FOREACH,FOLLOW_FOREACH_in_cast_disambiguation_token2931); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    FOREACH272_tree = 
                    (Object)adaptor.create(FOREACH272)
                    ;
                    adaptor.addChild(root_0, FOREACH272_tree);
                    }

                    }
                    break;
                case 33 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:729:77: GOTO
                    {
                    GOTO273=(Token)match(input,GOTO,FOLLOW_GOTO_in_cast_disambiguation_token2935); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    GOTO273_tree = 
                    (Object)adaptor.create(GOTO273)
                    ;
                    adaptor.addChild(root_0, GOTO273_tree);
                    }

                    }
                    break;
                case 34 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:729:84: IF
                    {
                    IF274=(Token)match(input,IF,FOLLOW_IF_in_cast_disambiguation_token2939); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    IF274_tree = 
                    (Object)adaptor.create(IF274)
                    ;
                    adaptor.addChild(root_0, IF274_tree);
                    }

                    }
                    break;
                case 35 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:729:89: IMPLICIT
                    {
                    IMPLICIT275=(Token)match(input,IMPLICIT,FOLLOW_IMPLICIT_in_cast_disambiguation_token2943); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    IMPLICIT275_tree = 
                    (Object)adaptor.create(IMPLICIT275)
                    ;
                    adaptor.addChild(root_0, IMPLICIT275_tree);
                    }

                    }
                    break;
                case 36 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:729:100: IN
                    {
                    IN276=(Token)match(input,IN,FOLLOW_IN_in_cast_disambiguation_token2947); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    IN276_tree = 
                    (Object)adaptor.create(IN276)
                    ;
                    adaptor.addChild(root_0, IN276_tree);
                    }

                    }
                    break;
                case 37 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:729:105: INT
                    {
                    INT277=(Token)match(input,INT,FOLLOW_INT_in_cast_disambiguation_token2951); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    INT277_tree = 
                    (Object)adaptor.create(INT277)
                    ;
                    adaptor.addChild(root_0, INT277_tree);
                    }

                    }
                    break;
                case 38 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:730:7: INTERFACE
                    {
                    INTERFACE278=(Token)match(input,INTERFACE,FOLLOW_INTERFACE_in_cast_disambiguation_token2959); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    INTERFACE278_tree = 
                    (Object)adaptor.create(INTERFACE278)
                    ;
                    adaptor.addChild(root_0, INTERFACE278_tree);
                    }

                    }
                    break;
                case 39 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:730:19: INTERNAL
                    {
                    INTERNAL279=(Token)match(input,INTERNAL,FOLLOW_INTERNAL_in_cast_disambiguation_token2963); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    INTERNAL279_tree = 
                    (Object)adaptor.create(INTERNAL279)
                    ;
                    adaptor.addChild(root_0, INTERNAL279_tree);
                    }

                    }
                    break;
                case 40 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:730:30: LOCK
                    {
                    LOCK280=(Token)match(input,LOCK,FOLLOW_LOCK_in_cast_disambiguation_token2967); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    LOCK280_tree = 
                    (Object)adaptor.create(LOCK280)
                    ;
                    adaptor.addChild(root_0, LOCK280_tree);
                    }

                    }
                    break;
                case 41 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:730:37: LONG
                    {
                    LONG281=(Token)match(input,LONG,FOLLOW_LONG_in_cast_disambiguation_token2971); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    LONG281_tree = 
                    (Object)adaptor.create(LONG281)
                    ;
                    adaptor.addChild(root_0, LONG281_tree);
                    }

                    }
                    break;
                case 42 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:730:44: NAMESPACE
                    {
                    NAMESPACE282=(Token)match(input,NAMESPACE,FOLLOW_NAMESPACE_in_cast_disambiguation_token2975); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    NAMESPACE282_tree = 
                    (Object)adaptor.create(NAMESPACE282)
                    ;
                    adaptor.addChild(root_0, NAMESPACE282_tree);
                    }

                    }
                    break;
                case 43 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:730:56: NEW
                    {
                    NEW283=(Token)match(input,NEW,FOLLOW_NEW_in_cast_disambiguation_token2979); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    NEW283_tree = 
                    (Object)adaptor.create(NEW283)
                    ;
                    adaptor.addChild(root_0, NEW283_tree);
                    }

                    }
                    break;
                case 44 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:730:62: OBJECT
                    {
                    OBJECT284=(Token)match(input,OBJECT,FOLLOW_OBJECT_in_cast_disambiguation_token2983); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OBJECT284_tree = 
                    (Object)adaptor.create(OBJECT284)
                    ;
                    adaptor.addChild(root_0, OBJECT284_tree);
                    }

                    }
                    break;
                case 45 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:730:71: OPERATOR
                    {
                    OPERATOR285=(Token)match(input,OPERATOR,FOLLOW_OPERATOR_in_cast_disambiguation_token2987); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OPERATOR285_tree = 
                    (Object)adaptor.create(OPERATOR285)
                    ;
                    adaptor.addChild(root_0, OPERATOR285_tree);
                    }

                    }
                    break;
                case 46 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:730:82: OUT
                    {
                    OUT286=(Token)match(input,OUT,FOLLOW_OUT_in_cast_disambiguation_token2991); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OUT286_tree = 
                    (Object)adaptor.create(OUT286)
                    ;
                    adaptor.addChild(root_0, OUT286_tree);
                    }

                    }
                    break;
                case 47 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:730:88: OVERRIDE
                    {
                    OVERRIDE287=(Token)match(input,OVERRIDE,FOLLOW_OVERRIDE_in_cast_disambiguation_token2995); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OVERRIDE287_tree = 
                    (Object)adaptor.create(OVERRIDE287)
                    ;
                    adaptor.addChild(root_0, OVERRIDE287_tree);
                    }

                    }
                    break;
                case 48 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:730:99: PARAMS
                    {
                    PARAMS288=(Token)match(input,PARAMS,FOLLOW_PARAMS_in_cast_disambiguation_token2999); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PARAMS288_tree = 
                    (Object)adaptor.create(PARAMS288)
                    ;
                    adaptor.addChild(root_0, PARAMS288_tree);
                    }

                    }
                    break;
                case 49 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:731:7: PRIVATE
                    {
                    PRIVATE289=(Token)match(input,PRIVATE,FOLLOW_PRIVATE_in_cast_disambiguation_token3007); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PRIVATE289_tree = 
                    (Object)adaptor.create(PRIVATE289)
                    ;
                    adaptor.addChild(root_0, PRIVATE289_tree);
                    }

                    }
                    break;
                case 50 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:731:17: PROTECTED
                    {
                    PROTECTED290=(Token)match(input,PROTECTED,FOLLOW_PROTECTED_in_cast_disambiguation_token3011); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PROTECTED290_tree = 
                    (Object)adaptor.create(PROTECTED290)
                    ;
                    adaptor.addChild(root_0, PROTECTED290_tree);
                    }

                    }
                    break;
                case 51 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:731:29: PUBLIC
                    {
                    PUBLIC291=(Token)match(input,PUBLIC,FOLLOW_PUBLIC_in_cast_disambiguation_token3015); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PUBLIC291_tree = 
                    (Object)adaptor.create(PUBLIC291)
                    ;
                    adaptor.addChild(root_0, PUBLIC291_tree);
                    }

                    }
                    break;
                case 52 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:731:38: READONLY
                    {
                    READONLY292=(Token)match(input,READONLY,FOLLOW_READONLY_in_cast_disambiguation_token3019); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    READONLY292_tree = 
                    (Object)adaptor.create(READONLY292)
                    ;
                    adaptor.addChild(root_0, READONLY292_tree);
                    }

                    }
                    break;
                case 53 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:731:49: REF
                    {
                    REF293=(Token)match(input,REF,FOLLOW_REF_in_cast_disambiguation_token3023); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    REF293_tree = 
                    (Object)adaptor.create(REF293)
                    ;
                    adaptor.addChild(root_0, REF293_tree);
                    }

                    }
                    break;
                case 54 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:731:55: RETURN
                    {
                    RETURN294=(Token)match(input,RETURN,FOLLOW_RETURN_in_cast_disambiguation_token3027); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    RETURN294_tree = 
                    (Object)adaptor.create(RETURN294)
                    ;
                    adaptor.addChild(root_0, RETURN294_tree);
                    }

                    }
                    break;
                case 55 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:731:64: SBYTE
                    {
                    SBYTE295=(Token)match(input,SBYTE,FOLLOW_SBYTE_in_cast_disambiguation_token3031); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    SBYTE295_tree = 
                    (Object)adaptor.create(SBYTE295)
                    ;
                    adaptor.addChild(root_0, SBYTE295_tree);
                    }

                    }
                    break;
                case 56 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:731:72: SEALED
                    {
                    SEALED296=(Token)match(input,SEALED,FOLLOW_SEALED_in_cast_disambiguation_token3035); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    SEALED296_tree = 
                    (Object)adaptor.create(SEALED296)
                    ;
                    adaptor.addChild(root_0, SEALED296_tree);
                    }

                    }
                    break;
                case 57 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:731:81: SHORT
                    {
                    SHORT297=(Token)match(input,SHORT,FOLLOW_SHORT_in_cast_disambiguation_token3039); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    SHORT297_tree = 
                    (Object)adaptor.create(SHORT297)
                    ;
                    adaptor.addChild(root_0, SHORT297_tree);
                    }

                    }
                    break;
                case 58 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:731:89: SIZEOF
                    {
                    SIZEOF298=(Token)match(input,SIZEOF,FOLLOW_SIZEOF_in_cast_disambiguation_token3043); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    SIZEOF298_tree = 
                    (Object)adaptor.create(SIZEOF298)
                    ;
                    adaptor.addChild(root_0, SIZEOF298_tree);
                    }

                    }
                    break;
                case 59 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:731:98: STACKALLOC
                    {
                    STACKALLOC299=(Token)match(input,STACKALLOC,FOLLOW_STACKALLOC_in_cast_disambiguation_token3047); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    STACKALLOC299_tree = 
                    (Object)adaptor.create(STACKALLOC299)
                    ;
                    adaptor.addChild(root_0, STACKALLOC299_tree);
                    }

                    }
                    break;
                case 60 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:732:7: STATIC
                    {
                    STATIC300=(Token)match(input,STATIC,FOLLOW_STATIC_in_cast_disambiguation_token3055); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    STATIC300_tree = 
                    (Object)adaptor.create(STATIC300)
                    ;
                    adaptor.addChild(root_0, STATIC300_tree);
                    }

                    }
                    break;
                case 61 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:732:16: STRING
                    {
                    STRING301=(Token)match(input,STRING,FOLLOW_STRING_in_cast_disambiguation_token3059); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    STRING301_tree = 
                    (Object)adaptor.create(STRING301)
                    ;
                    adaptor.addChild(root_0, STRING301_tree);
                    }

                    }
                    break;
                case 62 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:732:25: STRUCT
                    {
                    STRUCT302=(Token)match(input,STRUCT,FOLLOW_STRUCT_in_cast_disambiguation_token3063); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    STRUCT302_tree = 
                    (Object)adaptor.create(STRUCT302)
                    ;
                    adaptor.addChild(root_0, STRUCT302_tree);
                    }

                    }
                    break;
                case 63 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:732:34: SWITCH
                    {
                    SWITCH303=(Token)match(input,SWITCH,FOLLOW_SWITCH_in_cast_disambiguation_token3067); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    SWITCH303_tree = 
                    (Object)adaptor.create(SWITCH303)
                    ;
                    adaptor.addChild(root_0, SWITCH303_tree);
                    }

                    }
                    break;
                case 64 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:732:43: THIS
                    {
                    THIS304=(Token)match(input,THIS,FOLLOW_THIS_in_cast_disambiguation_token3071); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    THIS304_tree = 
                    (Object)adaptor.create(THIS304)
                    ;
                    adaptor.addChild(root_0, THIS304_tree);
                    }

                    }
                    break;
                case 65 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:732:50: THROW
                    {
                    THROW305=(Token)match(input,THROW,FOLLOW_THROW_in_cast_disambiguation_token3075); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    THROW305_tree = 
                    (Object)adaptor.create(THROW305)
                    ;
                    adaptor.addChild(root_0, THROW305_tree);
                    }

                    }
                    break;
                case 66 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:732:58: TRY
                    {
                    TRY306=(Token)match(input,TRY,FOLLOW_TRY_in_cast_disambiguation_token3079); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    TRY306_tree = 
                    (Object)adaptor.create(TRY306)
                    ;
                    adaptor.addChild(root_0, TRY306_tree);
                    }

                    }
                    break;
                case 67 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:732:64: TYPEOF
                    {
                    TYPEOF307=(Token)match(input,TYPEOF,FOLLOW_TYPEOF_in_cast_disambiguation_token3083); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    TYPEOF307_tree = 
                    (Object)adaptor.create(TYPEOF307)
                    ;
                    adaptor.addChild(root_0, TYPEOF307_tree);
                    }

                    }
                    break;
                case 68 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:732:73: UINT
                    {
                    UINT308=(Token)match(input,UINT,FOLLOW_UINT_in_cast_disambiguation_token3087); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    UINT308_tree = 
                    (Object)adaptor.create(UINT308)
                    ;
                    adaptor.addChild(root_0, UINT308_tree);
                    }

                    }
                    break;
                case 69 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:732:80: ULONG
                    {
                    ULONG309=(Token)match(input,ULONG,FOLLOW_ULONG_in_cast_disambiguation_token3091); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    ULONG309_tree = 
                    (Object)adaptor.create(ULONG309)
                    ;
                    adaptor.addChild(root_0, ULONG309_tree);
                    }

                    }
                    break;
                case 70 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:732:88: UNCHECKED
                    {
                    UNCHECKED310=(Token)match(input,UNCHECKED,FOLLOW_UNCHECKED_in_cast_disambiguation_token3095); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    UNCHECKED310_tree = 
                    (Object)adaptor.create(UNCHECKED310)
                    ;
                    adaptor.addChild(root_0, UNCHECKED310_tree);
                    }

                    }
                    break;
                case 71 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:732:100: UNSAFE
                    {
                    UNSAFE311=(Token)match(input,UNSAFE,FOLLOW_UNSAFE_in_cast_disambiguation_token3099); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    UNSAFE311_tree = 
                    (Object)adaptor.create(UNSAFE311)
                    ;
                    adaptor.addChild(root_0, UNSAFE311_tree);
                    }

                    }
                    break;
                case 72 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:733:7: USHORT
                    {
                    USHORT312=(Token)match(input,USHORT,FOLLOW_USHORT_in_cast_disambiguation_token3107); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    USHORT312_tree = 
                    (Object)adaptor.create(USHORT312)
                    ;
                    adaptor.addChild(root_0, USHORT312_tree);
                    }

                    }
                    break;
                case 73 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:733:16: USING
                    {
                    USING313=(Token)match(input,USING,FOLLOW_USING_in_cast_disambiguation_token3111); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    USING313_tree = 
                    (Object)adaptor.create(USING313)
                    ;
                    adaptor.addChild(root_0, USING313_tree);
                    }

                    }
                    break;
                case 74 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:733:24: VIRTUAL
                    {
                    VIRTUAL314=(Token)match(input,VIRTUAL,FOLLOW_VIRTUAL_in_cast_disambiguation_token3115); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    VIRTUAL314_tree = 
                    (Object)adaptor.create(VIRTUAL314)
                    ;
                    adaptor.addChild(root_0, VIRTUAL314_tree);
                    }

                    }
                    break;
                case 75 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:733:34: VOID
                    {
                    VOID315=(Token)match(input,VOID,FOLLOW_VOID_in_cast_disambiguation_token3119); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    VOID315_tree = 
                    (Object)adaptor.create(VOID315)
                    ;
                    adaptor.addChild(root_0, VOID315_tree);
                    }

                    }
                    break;
                case 76 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:733:41: VOLATILE
                    {
                    VOLATILE316=(Token)match(input,VOLATILE,FOLLOW_VOLATILE_in_cast_disambiguation_token3123); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    VOLATILE316_tree = 
                    (Object)adaptor.create(VOLATILE316)
                    ;
                    adaptor.addChild(root_0, VOLATILE316_tree);
                    }

                    }
                    break;
                case 77 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:733:52: WHILE
                    {
                    WHILE317=(Token)match(input,WHILE,FOLLOW_WHILE_in_cast_disambiguation_token3127); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    WHILE317_tree = 
                    (Object)adaptor.create(WHILE317)
                    ;
                    adaptor.addChild(root_0, WHILE317_tree);
                    }

                    }
                    break;

            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "cast_disambiguation_token"


    public static class pre_increment_expression_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "pre_increment_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:736:1: pre_increment_expression : OP_INC unary_expression ;
    public final CSharp4AST.pre_increment_expression_return pre_increment_expression() throws RecognitionException {
        CSharp4AST.pre_increment_expression_return retval = new CSharp4AST.pre_increment_expression_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token OP_INC318=null;
        CSharp4AST.unary_expression_return unary_expression319 =null;


        Object OP_INC318_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:737:2: ( OP_INC unary_expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:737:4: OP_INC unary_expression
            {
            root_0 = (Object)adaptor.nil();


            OP_INC318=(Token)match(input,OP_INC,FOLLOW_OP_INC_in_pre_increment_expression3145); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            OP_INC318_tree = 
            (Object)adaptor.create(OP_INC318)
            ;
            adaptor.addChild(root_0, OP_INC318_tree);
            }

            pushFollow(FOLLOW_unary_expression_in_pre_increment_expression3147);
            unary_expression319=unary_expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, unary_expression319.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "pre_increment_expression"


    public static class pre_decrement_expression_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "pre_decrement_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:739:1: pre_decrement_expression : OP_DEC unary_expression ;
    public final CSharp4AST.pre_decrement_expression_return pre_decrement_expression() throws RecognitionException {
        CSharp4AST.pre_decrement_expression_return retval = new CSharp4AST.pre_decrement_expression_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token OP_DEC320=null;
        CSharp4AST.unary_expression_return unary_expression321 =null;


        Object OP_DEC320_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:740:2: ( OP_DEC unary_expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:740:4: OP_DEC unary_expression
            {
            root_0 = (Object)adaptor.nil();


            OP_DEC320=(Token)match(input,OP_DEC,FOLLOW_OP_DEC_in_pre_decrement_expression3158); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            OP_DEC320_tree = 
            (Object)adaptor.create(OP_DEC320)
            ;
            adaptor.addChild(root_0, OP_DEC320_tree);
            }

            pushFollow(FOLLOW_unary_expression_in_pre_decrement_expression3160);
            unary_expression321=unary_expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, unary_expression321.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "pre_decrement_expression"


    public static class cast_expression_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "cast_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:742:1: cast_expression : OPEN_PARENS type CLOSE_PARENS unary_expression -> ^( CAST_EXPRESSION type unary_expression ) ;
    public final CSharp4AST.cast_expression_return cast_expression() throws RecognitionException {
        CSharp4AST.cast_expression_return retval = new CSharp4AST.cast_expression_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token OPEN_PARENS322=null;
        Token CLOSE_PARENS324=null;
        CSharp4AST.type_return type323 =null;

        CSharp4AST.unary_expression_return unary_expression325 =null;


        Object OPEN_PARENS322_tree=null;
        Object CLOSE_PARENS324_tree=null;
        RewriteRuleTokenStream stream_OPEN_PARENS=new RewriteRuleTokenStream(adaptor,"token OPEN_PARENS");
        RewriteRuleTokenStream stream_CLOSE_PARENS=new RewriteRuleTokenStream(adaptor,"token CLOSE_PARENS");
        RewriteRuleSubtreeStream stream_unary_expression=new RewriteRuleSubtreeStream(adaptor,"rule unary_expression");
        RewriteRuleSubtreeStream stream_type=new RewriteRuleSubtreeStream(adaptor,"rule type");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:743:2: ( OPEN_PARENS type CLOSE_PARENS unary_expression -> ^( CAST_EXPRESSION type unary_expression ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:743:4: OPEN_PARENS type CLOSE_PARENS unary_expression
            {
            OPEN_PARENS322=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_cast_expression3171); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_OPEN_PARENS.add(OPEN_PARENS322);


            pushFollow(FOLLOW_type_in_cast_expression3173);
            type323=type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_type.add(type323.getTree());

            CLOSE_PARENS324=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_cast_expression3175); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_CLOSE_PARENS.add(CLOSE_PARENS324);


            pushFollow(FOLLOW_unary_expression_in_cast_expression3177);
            unary_expression325=unary_expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_unary_expression.add(unary_expression325.getTree());

            // AST REWRITE
            // elements: type, unary_expression
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 744:4: -> ^( CAST_EXPRESSION type unary_expression )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:744:7: ^( CAST_EXPRESSION type unary_expression )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(CAST_EXPRESSION, "CAST_EXPRESSION")
                , root_1);

                adaptor.addChild(root_1, stream_type.nextTree());

                adaptor.addChild(root_1, stream_unary_expression.nextTree());

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "cast_expression"


    public static class multiplicative_expression_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "multiplicative_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:747:1: multiplicative_expression : (e1= unary_expression -> $e1) ( STAR e2= unary_expression -> ^( STAR $multiplicative_expression $e2) | DIV e2= unary_expression -> ^( DIV $multiplicative_expression $e2) | PERCENT e2= unary_expression -> ^( PERCENT $multiplicative_expression $e2) )* ;
    public final CSharp4AST.multiplicative_expression_return multiplicative_expression() throws RecognitionException {
        CSharp4AST.multiplicative_expression_return retval = new CSharp4AST.multiplicative_expression_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token STAR326=null;
        Token DIV327=null;
        Token PERCENT328=null;
        CSharp4AST.unary_expression_return e1 =null;

        CSharp4AST.unary_expression_return e2 =null;


        Object STAR326_tree=null;
        Object DIV327_tree=null;
        Object PERCENT328_tree=null;
        RewriteRuleTokenStream stream_STAR=new RewriteRuleTokenStream(adaptor,"token STAR");
        RewriteRuleTokenStream stream_PERCENT=new RewriteRuleTokenStream(adaptor,"token PERCENT");
        RewriteRuleTokenStream stream_DIV=new RewriteRuleTokenStream(adaptor,"token DIV");
        RewriteRuleSubtreeStream stream_unary_expression=new RewriteRuleSubtreeStream(adaptor,"rule unary_expression");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:748:2: ( (e1= unary_expression -> $e1) ( STAR e2= unary_expression -> ^( STAR $multiplicative_expression $e2) | DIV e2= unary_expression -> ^( DIV $multiplicative_expression $e2) | PERCENT e2= unary_expression -> ^( PERCENT $multiplicative_expression $e2) )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:748:4: (e1= unary_expression -> $e1) ( STAR e2= unary_expression -> ^( STAR $multiplicative_expression $e2) | DIV e2= unary_expression -> ^( DIV $multiplicative_expression $e2) | PERCENT e2= unary_expression -> ^( PERCENT $multiplicative_expression $e2) )*
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:748:4: (e1= unary_expression -> $e1)
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:748:5: e1= unary_expression
            {
            pushFollow(FOLLOW_unary_expression_in_multiplicative_expression3205);
            e1=unary_expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_unary_expression.add(e1.getTree());

            // AST REWRITE
            // elements: e1
            // token labels: 
            // rule labels: retval, e1
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
            RewriteRuleSubtreeStream stream_e1=new RewriteRuleSubtreeStream(adaptor,"rule e1",e1!=null?e1.tree:null);

            root_0 = (Object)adaptor.nil();
            // 748:25: -> $e1
            {
                adaptor.addChild(root_0, stream_e1.nextTree());

            }


            retval.tree = root_0;
            }

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:749:6: ( STAR e2= unary_expression -> ^( STAR $multiplicative_expression $e2) | DIV e2= unary_expression -> ^( DIV $multiplicative_expression $e2) | PERCENT e2= unary_expression -> ^( PERCENT $multiplicative_expression $e2) )*
            loop57:
            do {
                int alt57=4;
                switch ( input.LA(1) ) {
                case STAR:
                    {
                    alt57=1;
                    }
                    break;
                case DIV:
                    {
                    alt57=2;
                    }
                    break;
                case PERCENT:
                    {
                    alt57=3;
                    }
                    break;

                }

                switch (alt57) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:749:8: STAR e2= unary_expression
            	    {
            	    STAR326=(Token)match(input,STAR,FOLLOW_STAR_in_multiplicative_expression3221); if (state.failed) return retval; 
            	    if ( state.backtracking==0 ) stream_STAR.add(STAR326);


            	    pushFollow(FOLLOW_unary_expression_in_multiplicative_expression3226);
            	    e2=unary_expression();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) stream_unary_expression.add(e2.getTree());

            	    // AST REWRITE
            	    // elements: e2, STAR, multiplicative_expression
            	    // token labels: 
            	    // rule labels: retval, e2
            	    // token list labels: 
            	    // rule list labels: 
            	    // wildcard labels: 
            	    if ( state.backtracking==0 ) {

            	    retval.tree = root_0;
            	    RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
            	    RewriteRuleSubtreeStream stream_e2=new RewriteRuleSubtreeStream(adaptor,"rule e2",e2!=null?e2.tree:null);

            	    root_0 = (Object)adaptor.nil();
            	    // 749:34: -> ^( STAR $multiplicative_expression $e2)
            	    {
            	        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:749:37: ^( STAR $multiplicative_expression $e2)
            	        {
            	        Object root_1 = (Object)adaptor.nil();
            	        root_1 = (Object)adaptor.becomeRoot(
            	        stream_STAR.nextNode()
            	        , root_1);

            	        adaptor.addChild(root_1, stream_retval.nextTree());

            	        adaptor.addChild(root_1, stream_e2.nextTree());

            	        adaptor.addChild(root_0, root_1);
            	        }

            	    }


            	    retval.tree = root_0;
            	    }

            	    }
            	    break;
            	case 2 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:750:8: DIV e2= unary_expression
            	    {
            	    DIV327=(Token)match(input,DIV,FOLLOW_DIV_in_multiplicative_expression3247); if (state.failed) return retval; 
            	    if ( state.backtracking==0 ) stream_DIV.add(DIV327);


            	    pushFollow(FOLLOW_unary_expression_in_multiplicative_expression3252);
            	    e2=unary_expression();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) stream_unary_expression.add(e2.getTree());

            	    // AST REWRITE
            	    // elements: e2, multiplicative_expression, DIV
            	    // token labels: 
            	    // rule labels: retval, e2
            	    // token list labels: 
            	    // rule list labels: 
            	    // wildcard labels: 
            	    if ( state.backtracking==0 ) {

            	    retval.tree = root_0;
            	    RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
            	    RewriteRuleSubtreeStream stream_e2=new RewriteRuleSubtreeStream(adaptor,"rule e2",e2!=null?e2.tree:null);

            	    root_0 = (Object)adaptor.nil();
            	    // 750:33: -> ^( DIV $multiplicative_expression $e2)
            	    {
            	        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:750:36: ^( DIV $multiplicative_expression $e2)
            	        {
            	        Object root_1 = (Object)adaptor.nil();
            	        root_1 = (Object)adaptor.becomeRoot(
            	        stream_DIV.nextNode()
            	        , root_1);

            	        adaptor.addChild(root_1, stream_retval.nextTree());

            	        adaptor.addChild(root_1, stream_e2.nextTree());

            	        adaptor.addChild(root_0, root_1);
            	        }

            	    }


            	    retval.tree = root_0;
            	    }

            	    }
            	    break;
            	case 3 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:751:8: PERCENT e2= unary_expression
            	    {
            	    PERCENT328=(Token)match(input,PERCENT,FOLLOW_PERCENT_in_multiplicative_expression3273); if (state.failed) return retval; 
            	    if ( state.backtracking==0 ) stream_PERCENT.add(PERCENT328);


            	    pushFollow(FOLLOW_unary_expression_in_multiplicative_expression3278);
            	    e2=unary_expression();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) stream_unary_expression.add(e2.getTree());

            	    // AST REWRITE
            	    // elements: multiplicative_expression, PERCENT, e2
            	    // token labels: 
            	    // rule labels: retval, e2
            	    // token list labels: 
            	    // rule list labels: 
            	    // wildcard labels: 
            	    if ( state.backtracking==0 ) {

            	    retval.tree = root_0;
            	    RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
            	    RewriteRuleSubtreeStream stream_e2=new RewriteRuleSubtreeStream(adaptor,"rule e2",e2!=null?e2.tree:null);

            	    root_0 = (Object)adaptor.nil();
            	    // 751:37: -> ^( PERCENT $multiplicative_expression $e2)
            	    {
            	        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:751:40: ^( PERCENT $multiplicative_expression $e2)
            	        {
            	        Object root_1 = (Object)adaptor.nil();
            	        root_1 = (Object)adaptor.becomeRoot(
            	        stream_PERCENT.nextNode()
            	        , root_1);

            	        adaptor.addChild(root_1, stream_retval.nextTree());

            	        adaptor.addChild(root_1, stream_e2.nextTree());

            	        adaptor.addChild(root_0, root_1);
            	        }

            	    }


            	    retval.tree = root_0;
            	    }

            	    }
            	    break;

            	default :
            	    break loop57;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "multiplicative_expression"


    public static class additive_expression_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "additive_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:754:1: additive_expression : (e1= multiplicative_expression -> $e1) ( PLUS e2= multiplicative_expression -> ^( PLUS $additive_expression $e2) | MINUS e2= multiplicative_expression -> ^( MINUS $additive_expression $e2) )* ;
    public final CSharp4AST.additive_expression_return additive_expression() throws RecognitionException {
        CSharp4AST.additive_expression_return retval = new CSharp4AST.additive_expression_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token PLUS329=null;
        Token MINUS330=null;
        CSharp4AST.multiplicative_expression_return e1 =null;

        CSharp4AST.multiplicative_expression_return e2 =null;


        Object PLUS329_tree=null;
        Object MINUS330_tree=null;
        RewriteRuleTokenStream stream_PLUS=new RewriteRuleTokenStream(adaptor,"token PLUS");
        RewriteRuleTokenStream stream_MINUS=new RewriteRuleTokenStream(adaptor,"token MINUS");
        RewriteRuleSubtreeStream stream_multiplicative_expression=new RewriteRuleSubtreeStream(adaptor,"rule multiplicative_expression");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:755:2: ( (e1= multiplicative_expression -> $e1) ( PLUS e2= multiplicative_expression -> ^( PLUS $additive_expression $e2) | MINUS e2= multiplicative_expression -> ^( MINUS $additive_expression $e2) )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:755:4: (e1= multiplicative_expression -> $e1) ( PLUS e2= multiplicative_expression -> ^( PLUS $additive_expression $e2) | MINUS e2= multiplicative_expression -> ^( MINUS $additive_expression $e2) )*
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:755:4: (e1= multiplicative_expression -> $e1)
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:755:5: e1= multiplicative_expression
            {
            pushFollow(FOLLOW_multiplicative_expression_in_additive_expression3312);
            e1=multiplicative_expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_multiplicative_expression.add(e1.getTree());

            // AST REWRITE
            // elements: e1
            // token labels: 
            // rule labels: retval, e1
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
            RewriteRuleSubtreeStream stream_e1=new RewriteRuleSubtreeStream(adaptor,"rule e1",e1!=null?e1.tree:null);

            root_0 = (Object)adaptor.nil();
            // 755:34: -> $e1
            {
                adaptor.addChild(root_0, stream_e1.nextTree());

            }


            retval.tree = root_0;
            }

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:756:6: ( PLUS e2= multiplicative_expression -> ^( PLUS $additive_expression $e2) | MINUS e2= multiplicative_expression -> ^( MINUS $additive_expression $e2) )*
            loop58:
            do {
                int alt58=3;
                int LA58_0 = input.LA(1);

                if ( (LA58_0==PLUS) ) {
                    alt58=1;
                }
                else if ( (LA58_0==MINUS) ) {
                    alt58=2;
                }


                switch (alt58) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:756:8: PLUS e2= multiplicative_expression
            	    {
            	    PLUS329=(Token)match(input,PLUS,FOLLOW_PLUS_in_additive_expression3327); if (state.failed) return retval; 
            	    if ( state.backtracking==0 ) stream_PLUS.add(PLUS329);


            	    pushFollow(FOLLOW_multiplicative_expression_in_additive_expression3332);
            	    e2=multiplicative_expression();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) stream_multiplicative_expression.add(e2.getTree());

            	    // AST REWRITE
            	    // elements: e2, PLUS, additive_expression
            	    // token labels: 
            	    // rule labels: retval, e2
            	    // token list labels: 
            	    // rule list labels: 
            	    // wildcard labels: 
            	    if ( state.backtracking==0 ) {

            	    retval.tree = root_0;
            	    RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
            	    RewriteRuleSubtreeStream stream_e2=new RewriteRuleSubtreeStream(adaptor,"rule e2",e2!=null?e2.tree:null);

            	    root_0 = (Object)adaptor.nil();
            	    // 756:43: -> ^( PLUS $additive_expression $e2)
            	    {
            	        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:756:46: ^( PLUS $additive_expression $e2)
            	        {
            	        Object root_1 = (Object)adaptor.nil();
            	        root_1 = (Object)adaptor.becomeRoot(
            	        stream_PLUS.nextNode()
            	        , root_1);

            	        adaptor.addChild(root_1, stream_retval.nextTree());

            	        adaptor.addChild(root_1, stream_e2.nextTree());

            	        adaptor.addChild(root_0, root_1);
            	        }

            	    }


            	    retval.tree = root_0;
            	    }

            	    }
            	    break;
            	case 2 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:757:8: MINUS e2= multiplicative_expression
            	    {
            	    MINUS330=(Token)match(input,MINUS,FOLLOW_MINUS_in_additive_expression3353); if (state.failed) return retval; 
            	    if ( state.backtracking==0 ) stream_MINUS.add(MINUS330);


            	    pushFollow(FOLLOW_multiplicative_expression_in_additive_expression3358);
            	    e2=multiplicative_expression();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) stream_multiplicative_expression.add(e2.getTree());

            	    // AST REWRITE
            	    // elements: MINUS, additive_expression, e2
            	    // token labels: 
            	    // rule labels: retval, e2
            	    // token list labels: 
            	    // rule list labels: 
            	    // wildcard labels: 
            	    if ( state.backtracking==0 ) {

            	    retval.tree = root_0;
            	    RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
            	    RewriteRuleSubtreeStream stream_e2=new RewriteRuleSubtreeStream(adaptor,"rule e2",e2!=null?e2.tree:null);

            	    root_0 = (Object)adaptor.nil();
            	    // 757:44: -> ^( MINUS $additive_expression $e2)
            	    {
            	        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:757:47: ^( MINUS $additive_expression $e2)
            	        {
            	        Object root_1 = (Object)adaptor.nil();
            	        root_1 = (Object)adaptor.becomeRoot(
            	        stream_MINUS.nextNode()
            	        , root_1);

            	        adaptor.addChild(root_1, stream_retval.nextTree());

            	        adaptor.addChild(root_1, stream_e2.nextTree());

            	        adaptor.addChild(root_0, root_1);
            	        }

            	    }


            	    retval.tree = root_0;
            	    }

            	    }
            	    break;

            	default :
            	    break loop58;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "additive_expression"


    public static class shift_expression_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "shift_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:760:1: shift_expression : (e1= additive_expression -> $e1) ( OP_LEFT_SHIFT e2= additive_expression -> ^( OP_LEFT_SHIFT $shift_expression $e2) | right_shift e2= additive_expression -> ^( right_shift $shift_expression $e2) )* ;
    public final CSharp4AST.shift_expression_return shift_expression() throws RecognitionException {
        CSharp4AST.shift_expression_return retval = new CSharp4AST.shift_expression_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token OP_LEFT_SHIFT331=null;
        CSharp4AST.additive_expression_return e1 =null;

        CSharp4AST.additive_expression_return e2 =null;

        CSharp4AST.right_shift_return right_shift332 =null;


        Object OP_LEFT_SHIFT331_tree=null;
        RewriteRuleTokenStream stream_OP_LEFT_SHIFT=new RewriteRuleTokenStream(adaptor,"token OP_LEFT_SHIFT");
        RewriteRuleSubtreeStream stream_additive_expression=new RewriteRuleSubtreeStream(adaptor,"rule additive_expression");
        RewriteRuleSubtreeStream stream_right_shift=new RewriteRuleSubtreeStream(adaptor,"rule right_shift");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:761:2: ( (e1= additive_expression -> $e1) ( OP_LEFT_SHIFT e2= additive_expression -> ^( OP_LEFT_SHIFT $shift_expression $e2) | right_shift e2= additive_expression -> ^( right_shift $shift_expression $e2) )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:761:4: (e1= additive_expression -> $e1) ( OP_LEFT_SHIFT e2= additive_expression -> ^( OP_LEFT_SHIFT $shift_expression $e2) | right_shift e2= additive_expression -> ^( right_shift $shift_expression $e2) )*
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:761:4: (e1= additive_expression -> $e1)
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:761:5: e1= additive_expression
            {
            pushFollow(FOLLOW_additive_expression_in_shift_expression3392);
            e1=additive_expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_additive_expression.add(e1.getTree());

            // AST REWRITE
            // elements: e1
            // token labels: 
            // rule labels: retval, e1
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
            RewriteRuleSubtreeStream stream_e1=new RewriteRuleSubtreeStream(adaptor,"rule e1",e1!=null?e1.tree:null);

            root_0 = (Object)adaptor.nil();
            // 761:28: -> $e1
            {
                adaptor.addChild(root_0, stream_e1.nextTree());

            }


            retval.tree = root_0;
            }

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:762:6: ( OP_LEFT_SHIFT e2= additive_expression -> ^( OP_LEFT_SHIFT $shift_expression $e2) | right_shift e2= additive_expression -> ^( right_shift $shift_expression $e2) )*
            loop59:
            do {
                int alt59=3;
                int LA59_0 = input.LA(1);

                if ( (LA59_0==GT) ) {
                    int LA59_2 = input.LA(2);

                    if ( (LA59_2==GT) ) {
                        alt59=2;
                    }


                }
                else if ( (LA59_0==OP_LEFT_SHIFT) ) {
                    alt59=1;
                }


                switch (alt59) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:762:8: OP_LEFT_SHIFT e2= additive_expression
            	    {
            	    OP_LEFT_SHIFT331=(Token)match(input,OP_LEFT_SHIFT,FOLLOW_OP_LEFT_SHIFT_in_shift_expression3407); if (state.failed) return retval; 
            	    if ( state.backtracking==0 ) stream_OP_LEFT_SHIFT.add(OP_LEFT_SHIFT331);


            	    pushFollow(FOLLOW_additive_expression_in_shift_expression3412);
            	    e2=additive_expression();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) stream_additive_expression.add(e2.getTree());

            	    // AST REWRITE
            	    // elements: e2, shift_expression, OP_LEFT_SHIFT
            	    // token labels: 
            	    // rule labels: retval, e2
            	    // token list labels: 
            	    // rule list labels: 
            	    // wildcard labels: 
            	    if ( state.backtracking==0 ) {

            	    retval.tree = root_0;
            	    RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
            	    RewriteRuleSubtreeStream stream_e2=new RewriteRuleSubtreeStream(adaptor,"rule e2",e2!=null?e2.tree:null);

            	    root_0 = (Object)adaptor.nil();
            	    // 762:46: -> ^( OP_LEFT_SHIFT $shift_expression $e2)
            	    {
            	        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:762:49: ^( OP_LEFT_SHIFT $shift_expression $e2)
            	        {
            	        Object root_1 = (Object)adaptor.nil();
            	        root_1 = (Object)adaptor.becomeRoot(
            	        stream_OP_LEFT_SHIFT.nextNode()
            	        , root_1);

            	        adaptor.addChild(root_1, stream_retval.nextTree());

            	        adaptor.addChild(root_1, stream_e2.nextTree());

            	        adaptor.addChild(root_0, root_1);
            	        }

            	    }


            	    retval.tree = root_0;
            	    }

            	    }
            	    break;
            	case 2 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:763:8: right_shift e2= additive_expression
            	    {
            	    pushFollow(FOLLOW_right_shift_in_shift_expression3433);
            	    right_shift332=right_shift();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) stream_right_shift.add(right_shift332.getTree());

            	    pushFollow(FOLLOW_additive_expression_in_shift_expression3438);
            	    e2=additive_expression();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) stream_additive_expression.add(e2.getTree());

            	    // AST REWRITE
            	    // elements: right_shift, shift_expression, e2
            	    // token labels: 
            	    // rule labels: retval, e2
            	    // token list labels: 
            	    // rule list labels: 
            	    // wildcard labels: 
            	    if ( state.backtracking==0 ) {

            	    retval.tree = root_0;
            	    RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
            	    RewriteRuleSubtreeStream stream_e2=new RewriteRuleSubtreeStream(adaptor,"rule e2",e2!=null?e2.tree:null);

            	    root_0 = (Object)adaptor.nil();
            	    // 763:44: -> ^( right_shift $shift_expression $e2)
            	    {
            	        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:763:47: ^( right_shift $shift_expression $e2)
            	        {
            	        Object root_1 = (Object)adaptor.nil();
            	        root_1 = (Object)adaptor.becomeRoot(stream_right_shift.nextNode(), root_1);

            	        adaptor.addChild(root_1, stream_retval.nextTree());

            	        adaptor.addChild(root_1, stream_e2.nextTree());

            	        adaptor.addChild(root_0, root_1);
            	        }

            	    }


            	    retval.tree = root_0;
            	    }

            	    }
            	    break;

            	default :
            	    break loop59;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "shift_expression"


    public static class relational_expression_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "relational_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:766:1: relational_expression : (e1= shift_expression -> $e1) ( LT e2= shift_expression -> ^( LT $relational_expression $e2) | GT e2= shift_expression -> ^( GT $relational_expression $e2) | OP_LE e2= shift_expression -> ^( OP_LE $relational_expression $e2) | OP_GE e2= shift_expression -> ^( OP_GE $relational_expression $e2) | IS e3= isType -> ^( IS $relational_expression $e3) | AS e4= type -> ^( AS $relational_expression $e4) )* ;
    public final CSharp4AST.relational_expression_return relational_expression() throws RecognitionException {
        CSharp4AST.relational_expression_return retval = new CSharp4AST.relational_expression_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token LT333=null;
        Token GT334=null;
        Token OP_LE335=null;
        Token OP_GE336=null;
        Token IS337=null;
        Token AS338=null;
        CSharp4AST.shift_expression_return e1 =null;

        CSharp4AST.shift_expression_return e2 =null;

        CSharp4AST.isType_return e3 =null;

        CSharp4AST.type_return e4 =null;


        Object LT333_tree=null;
        Object GT334_tree=null;
        Object OP_LE335_tree=null;
        Object OP_GE336_tree=null;
        Object IS337_tree=null;
        Object AS338_tree=null;
        RewriteRuleTokenStream stream_AS=new RewriteRuleTokenStream(adaptor,"token AS");
        RewriteRuleTokenStream stream_GT=new RewriteRuleTokenStream(adaptor,"token GT");
        RewriteRuleTokenStream stream_LT=new RewriteRuleTokenStream(adaptor,"token LT");
        RewriteRuleTokenStream stream_OP_LE=new RewriteRuleTokenStream(adaptor,"token OP_LE");
        RewriteRuleTokenStream stream_OP_GE=new RewriteRuleTokenStream(adaptor,"token OP_GE");
        RewriteRuleTokenStream stream_IS=new RewriteRuleTokenStream(adaptor,"token IS");
        RewriteRuleSubtreeStream stream_isType=new RewriteRuleSubtreeStream(adaptor,"rule isType");
        RewriteRuleSubtreeStream stream_shift_expression=new RewriteRuleSubtreeStream(adaptor,"rule shift_expression");
        RewriteRuleSubtreeStream stream_type=new RewriteRuleSubtreeStream(adaptor,"rule type");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:767:2: ( (e1= shift_expression -> $e1) ( LT e2= shift_expression -> ^( LT $relational_expression $e2) | GT e2= shift_expression -> ^( GT $relational_expression $e2) | OP_LE e2= shift_expression -> ^( OP_LE $relational_expression $e2) | OP_GE e2= shift_expression -> ^( OP_GE $relational_expression $e2) | IS e3= isType -> ^( IS $relational_expression $e3) | AS e4= type -> ^( AS $relational_expression $e4) )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:767:4: (e1= shift_expression -> $e1) ( LT e2= shift_expression -> ^( LT $relational_expression $e2) | GT e2= shift_expression -> ^( GT $relational_expression $e2) | OP_LE e2= shift_expression -> ^( OP_LE $relational_expression $e2) | OP_GE e2= shift_expression -> ^( OP_GE $relational_expression $e2) | IS e3= isType -> ^( IS $relational_expression $e3) | AS e4= type -> ^( AS $relational_expression $e4) )*
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:767:4: (e1= shift_expression -> $e1)
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:767:5: e1= shift_expression
            {
            pushFollow(FOLLOW_shift_expression_in_relational_expression3472);
            e1=shift_expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_shift_expression.add(e1.getTree());

            // AST REWRITE
            // elements: e1
            // token labels: 
            // rule labels: retval, e1
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
            RewriteRuleSubtreeStream stream_e1=new RewriteRuleSubtreeStream(adaptor,"rule e1",e1!=null?e1.tree:null);

            root_0 = (Object)adaptor.nil();
            // 767:25: -> $e1
            {
                adaptor.addChild(root_0, stream_e1.nextTree());

            }


            retval.tree = root_0;
            }

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:768:6: ( LT e2= shift_expression -> ^( LT $relational_expression $e2) | GT e2= shift_expression -> ^( GT $relational_expression $e2) | OP_LE e2= shift_expression -> ^( OP_LE $relational_expression $e2) | OP_GE e2= shift_expression -> ^( OP_GE $relational_expression $e2) | IS e3= isType -> ^( IS $relational_expression $e3) | AS e4= type -> ^( AS $relational_expression $e4) )*
            loop60:
            do {
                int alt60=7;
                switch ( input.LA(1) ) {
                case LT:
                    {
                    alt60=1;
                    }
                    break;
                case GT:
                    {
                    alt60=2;
                    }
                    break;
                case OP_LE:
                    {
                    alt60=3;
                    }
                    break;
                case OP_GE:
                    {
                    alt60=4;
                    }
                    break;
                case IS:
                    {
                    alt60=5;
                    }
                    break;
                case AS:
                    {
                    alt60=6;
                    }
                    break;

                }

                switch (alt60) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:768:8: LT e2= shift_expression
            	    {
            	    LT333=(Token)match(input,LT,FOLLOW_LT_in_relational_expression3487); if (state.failed) return retval; 
            	    if ( state.backtracking==0 ) stream_LT.add(LT333);


            	    pushFollow(FOLLOW_shift_expression_in_relational_expression3491);
            	    e2=shift_expression();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) stream_shift_expression.add(e2.getTree());

            	    // AST REWRITE
            	    // elements: LT, e2, relational_expression
            	    // token labels: 
            	    // rule labels: retval, e2
            	    // token list labels: 
            	    // rule list labels: 
            	    // wildcard labels: 
            	    if ( state.backtracking==0 ) {

            	    retval.tree = root_0;
            	    RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
            	    RewriteRuleSubtreeStream stream_e2=new RewriteRuleSubtreeStream(adaptor,"rule e2",e2!=null?e2.tree:null);

            	    root_0 = (Object)adaptor.nil();
            	    // 768:31: -> ^( LT $relational_expression $e2)
            	    {
            	        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:768:34: ^( LT $relational_expression $e2)
            	        {
            	        Object root_1 = (Object)adaptor.nil();
            	        root_1 = (Object)adaptor.becomeRoot(
            	        stream_LT.nextNode()
            	        , root_1);

            	        adaptor.addChild(root_1, stream_retval.nextTree());

            	        adaptor.addChild(root_1, stream_e2.nextTree());

            	        adaptor.addChild(root_0, root_1);
            	        }

            	    }


            	    retval.tree = root_0;
            	    }

            	    }
            	    break;
            	case 2 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:769:9: GT e2= shift_expression
            	    {
            	    GT334=(Token)match(input,GT,FOLLOW_GT_in_relational_expression3513); if (state.failed) return retval; 
            	    if ( state.backtracking==0 ) stream_GT.add(GT334);


            	    pushFollow(FOLLOW_shift_expression_in_relational_expression3517);
            	    e2=shift_expression();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) stream_shift_expression.add(e2.getTree());

            	    // AST REWRITE
            	    // elements: e2, GT, relational_expression
            	    // token labels: 
            	    // rule labels: retval, e2
            	    // token list labels: 
            	    // rule list labels: 
            	    // wildcard labels: 
            	    if ( state.backtracking==0 ) {

            	    retval.tree = root_0;
            	    RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
            	    RewriteRuleSubtreeStream stream_e2=new RewriteRuleSubtreeStream(adaptor,"rule e2",e2!=null?e2.tree:null);

            	    root_0 = (Object)adaptor.nil();
            	    // 769:32: -> ^( GT $relational_expression $e2)
            	    {
            	        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:769:35: ^( GT $relational_expression $e2)
            	        {
            	        Object root_1 = (Object)adaptor.nil();
            	        root_1 = (Object)adaptor.becomeRoot(
            	        stream_GT.nextNode()
            	        , root_1);

            	        adaptor.addChild(root_1, stream_retval.nextTree());

            	        adaptor.addChild(root_1, stream_e2.nextTree());

            	        adaptor.addChild(root_0, root_1);
            	        }

            	    }


            	    retval.tree = root_0;
            	    }

            	    }
            	    break;
            	case 3 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:770:9: OP_LE e2= shift_expression
            	    {
            	    OP_LE335=(Token)match(input,OP_LE,FOLLOW_OP_LE_in_relational_expression3539); if (state.failed) return retval; 
            	    if ( state.backtracking==0 ) stream_OP_LE.add(OP_LE335);


            	    pushFollow(FOLLOW_shift_expression_in_relational_expression3543);
            	    e2=shift_expression();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) stream_shift_expression.add(e2.getTree());

            	    // AST REWRITE
            	    // elements: OP_LE, e2, relational_expression
            	    // token labels: 
            	    // rule labels: retval, e2
            	    // token list labels: 
            	    // rule list labels: 
            	    // wildcard labels: 
            	    if ( state.backtracking==0 ) {

            	    retval.tree = root_0;
            	    RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
            	    RewriteRuleSubtreeStream stream_e2=new RewriteRuleSubtreeStream(adaptor,"rule e2",e2!=null?e2.tree:null);

            	    root_0 = (Object)adaptor.nil();
            	    // 770:35: -> ^( OP_LE $relational_expression $e2)
            	    {
            	        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:770:38: ^( OP_LE $relational_expression $e2)
            	        {
            	        Object root_1 = (Object)adaptor.nil();
            	        root_1 = (Object)adaptor.becomeRoot(
            	        stream_OP_LE.nextNode()
            	        , root_1);

            	        adaptor.addChild(root_1, stream_retval.nextTree());

            	        adaptor.addChild(root_1, stream_e2.nextTree());

            	        adaptor.addChild(root_0, root_1);
            	        }

            	    }


            	    retval.tree = root_0;
            	    }

            	    }
            	    break;
            	case 4 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:771:9: OP_GE e2= shift_expression
            	    {
            	    OP_GE336=(Token)match(input,OP_GE,FOLLOW_OP_GE_in_relational_expression3565); if (state.failed) return retval; 
            	    if ( state.backtracking==0 ) stream_OP_GE.add(OP_GE336);


            	    pushFollow(FOLLOW_shift_expression_in_relational_expression3569);
            	    e2=shift_expression();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) stream_shift_expression.add(e2.getTree());

            	    // AST REWRITE
            	    // elements: OP_GE, e2, relational_expression
            	    // token labels: 
            	    // rule labels: retval, e2
            	    // token list labels: 
            	    // rule list labels: 
            	    // wildcard labels: 
            	    if ( state.backtracking==0 ) {

            	    retval.tree = root_0;
            	    RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
            	    RewriteRuleSubtreeStream stream_e2=new RewriteRuleSubtreeStream(adaptor,"rule e2",e2!=null?e2.tree:null);

            	    root_0 = (Object)adaptor.nil();
            	    // 771:35: -> ^( OP_GE $relational_expression $e2)
            	    {
            	        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:771:38: ^( OP_GE $relational_expression $e2)
            	        {
            	        Object root_1 = (Object)adaptor.nil();
            	        root_1 = (Object)adaptor.becomeRoot(
            	        stream_OP_GE.nextNode()
            	        , root_1);

            	        adaptor.addChild(root_1, stream_retval.nextTree());

            	        adaptor.addChild(root_1, stream_e2.nextTree());

            	        adaptor.addChild(root_0, root_1);
            	        }

            	    }


            	    retval.tree = root_0;
            	    }

            	    }
            	    break;
            	case 5 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:772:9: IS e3= isType
            	    {
            	    IS337=(Token)match(input,IS,FOLLOW_IS_in_relational_expression3591); if (state.failed) return retval; 
            	    if ( state.backtracking==0 ) stream_IS.add(IS337);


            	    pushFollow(FOLLOW_isType_in_relational_expression3595);
            	    e3=isType();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) stream_isType.add(e3.getTree());

            	    // AST REWRITE
            	    // elements: relational_expression, IS, e3
            	    // token labels: 
            	    // rule labels: e3, retval
            	    // token list labels: 
            	    // rule list labels: 
            	    // wildcard labels: 
            	    if ( state.backtracking==0 ) {

            	    retval.tree = root_0;
            	    RewriteRuleSubtreeStream stream_e3=new RewriteRuleSubtreeStream(adaptor,"rule e3",e3!=null?e3.tree:null);
            	    RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            	    root_0 = (Object)adaptor.nil();
            	    // 772:22: -> ^( IS $relational_expression $e3)
            	    {
            	        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:772:25: ^( IS $relational_expression $e3)
            	        {
            	        Object root_1 = (Object)adaptor.nil();
            	        root_1 = (Object)adaptor.becomeRoot(
            	        stream_IS.nextNode()
            	        , root_1);

            	        adaptor.addChild(root_1, stream_retval.nextTree());

            	        adaptor.addChild(root_1, stream_e3.nextTree());

            	        adaptor.addChild(root_0, root_1);
            	        }

            	    }


            	    retval.tree = root_0;
            	    }

            	    }
            	    break;
            	case 6 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:773:9: AS e4= type
            	    {
            	    AS338=(Token)match(input,AS,FOLLOW_AS_in_relational_expression3617); if (state.failed) return retval; 
            	    if ( state.backtracking==0 ) stream_AS.add(AS338);


            	    pushFollow(FOLLOW_type_in_relational_expression3621);
            	    e4=type();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) stream_type.add(e4.getTree());

            	    // AST REWRITE
            	    // elements: AS, e4, relational_expression
            	    // token labels: 
            	    // rule labels: e4, retval
            	    // token list labels: 
            	    // rule list labels: 
            	    // wildcard labels: 
            	    if ( state.backtracking==0 ) {

            	    retval.tree = root_0;
            	    RewriteRuleSubtreeStream stream_e4=new RewriteRuleSubtreeStream(adaptor,"rule e4",e4!=null?e4.tree:null);
            	    RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            	    root_0 = (Object)adaptor.nil();
            	    // 773:20: -> ^( AS $relational_expression $e4)
            	    {
            	        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:773:23: ^( AS $relational_expression $e4)
            	        {
            	        Object root_1 = (Object)adaptor.nil();
            	        root_1 = (Object)adaptor.becomeRoot(
            	        stream_AS.nextNode()
            	        , root_1);

            	        adaptor.addChild(root_1, stream_retval.nextTree());

            	        adaptor.addChild(root_1, stream_e4.nextTree());

            	        adaptor.addChild(root_0, root_1);
            	        }

            	    }


            	    retval.tree = root_0;
            	    }

            	    }
            	    break;

            	default :
            	    break loop60;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "relational_expression"


    public static class isType_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "isType"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:777:1: isType : non_nullable_value_type ( ( INTERR is_disambiguation_token )=> INTERR )? ;
    public final CSharp4AST.isType_return isType() throws RecognitionException {
        CSharp4AST.isType_return retval = new CSharp4AST.isType_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token INTERR340=null;
        CSharp4AST.non_nullable_value_type_return non_nullable_value_type339 =null;


        Object INTERR340_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:778:3: ( non_nullable_value_type ( ( INTERR is_disambiguation_token )=> INTERR )? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:778:5: non_nullable_value_type ( ( INTERR is_disambiguation_token )=> INTERR )?
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_non_nullable_value_type_in_isType3654);
            non_nullable_value_type339=non_nullable_value_type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, non_nullable_value_type339.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:778:29: ( ( INTERR is_disambiguation_token )=> INTERR )?
            int alt61=2;
            int LA61_0 = input.LA(1);

            if ( (LA61_0==INTERR) ) {
                int LA61_1 = input.LA(2);

                if ( (synpred8_CSharp4AST()) ) {
                    alt61=1;
                }
            }
            switch (alt61) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:778:31: ( INTERR is_disambiguation_token )=> INTERR
                    {
                    INTERR340=(Token)match(input,INTERR,FOLLOW_INTERR_in_isType3666); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    INTERR340_tree = 
                    (Object)adaptor.create(INTERR340)
                    ;
                    adaptor.addChild(root_0, INTERR340_tree);
                    }

                    }
                    break;

            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "isType"


    public static class is_disambiguation_token_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "is_disambiguation_token"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:780:1: is_disambiguation_token : ( CLOSE_PARENS | OP_AND | OP_OR | INTERR );
    public final CSharp4AST.is_disambiguation_token_return is_disambiguation_token() throws RecognitionException {
        CSharp4AST.is_disambiguation_token_return retval = new CSharp4AST.is_disambiguation_token_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token set341=null;

        Object set341_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:781:3: ( CLOSE_PARENS | OP_AND | OP_OR | INTERR )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:
            {
            root_0 = (Object)adaptor.nil();


            set341=(Token)input.LT(1);

            if ( input.LA(1)==CLOSE_PARENS||input.LA(1)==INTERR||input.LA(1)==OP_AND||input.LA(1)==OP_OR ) {
                input.consume();
                if ( state.backtracking==0 ) adaptor.addChild(root_0, 
                (Object)adaptor.create(set341)
                );
                state.errorRecovery=false;
                state.failed=false;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                MismatchedSetException mse = new MismatchedSetException(null,input);
                throw mse;
            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "is_disambiguation_token"


    public static class equality_expression_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "equality_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:783:1: equality_expression : (e1= relational_expression -> $e1) ( OP_EQ e2= relational_expression -> ^( OP_EQ $equality_expression $e2) | OP_NE e3= relational_expression -> ^( OP_NE $equality_expression $e3) )* ;
    public final CSharp4AST.equality_expression_return equality_expression() throws RecognitionException {
        CSharp4AST.equality_expression_return retval = new CSharp4AST.equality_expression_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token OP_EQ342=null;
        Token OP_NE343=null;
        CSharp4AST.relational_expression_return e1 =null;

        CSharp4AST.relational_expression_return e2 =null;

        CSharp4AST.relational_expression_return e3 =null;


        Object OP_EQ342_tree=null;
        Object OP_NE343_tree=null;
        RewriteRuleTokenStream stream_OP_EQ=new RewriteRuleTokenStream(adaptor,"token OP_EQ");
        RewriteRuleTokenStream stream_OP_NE=new RewriteRuleTokenStream(adaptor,"token OP_NE");
        RewriteRuleSubtreeStream stream_relational_expression=new RewriteRuleSubtreeStream(adaptor,"rule relational_expression");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:784:3: ( (e1= relational_expression -> $e1) ( OP_EQ e2= relational_expression -> ^( OP_EQ $equality_expression $e2) | OP_NE e3= relational_expression -> ^( OP_NE $equality_expression $e3) )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:784:5: (e1= relational_expression -> $e1) ( OP_EQ e2= relational_expression -> ^( OP_EQ $equality_expression $e2) | OP_NE e3= relational_expression -> ^( OP_NE $equality_expression $e3) )*
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:784:5: (e1= relational_expression -> $e1)
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:784:6: e1= relational_expression
            {
            pushFollow(FOLLOW_relational_expression_in_equality_expression3707);
            e1=relational_expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_relational_expression.add(e1.getTree());

            // AST REWRITE
            // elements: e1
            // token labels: 
            // rule labels: retval, e1
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
            RewriteRuleSubtreeStream stream_e1=new RewriteRuleSubtreeStream(adaptor,"rule e1",e1!=null?e1.tree:null);

            root_0 = (Object)adaptor.nil();
            // 784:31: -> $e1
            {
                adaptor.addChild(root_0, stream_e1.nextTree());

            }


            retval.tree = root_0;
            }

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:785:7: ( OP_EQ e2= relational_expression -> ^( OP_EQ $equality_expression $e2) | OP_NE e3= relational_expression -> ^( OP_NE $equality_expression $e3) )*
            loop62:
            do {
                int alt62=3;
                int LA62_0 = input.LA(1);

                if ( (LA62_0==OP_EQ) ) {
                    alt62=1;
                }
                else if ( (LA62_0==OP_NE) ) {
                    alt62=2;
                }


                switch (alt62) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:785:9: OP_EQ e2= relational_expression
            	    {
            	    OP_EQ342=(Token)match(input,OP_EQ,FOLLOW_OP_EQ_in_equality_expression3723); if (state.failed) return retval; 
            	    if ( state.backtracking==0 ) stream_OP_EQ.add(OP_EQ342);


            	    pushFollow(FOLLOW_relational_expression_in_equality_expression3728);
            	    e2=relational_expression();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) stream_relational_expression.add(e2.getTree());

            	    // AST REWRITE
            	    // elements: OP_EQ, e2, equality_expression
            	    // token labels: 
            	    // rule labels: retval, e2
            	    // token list labels: 
            	    // rule list labels: 
            	    // wildcard labels: 
            	    if ( state.backtracking==0 ) {

            	    retval.tree = root_0;
            	    RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
            	    RewriteRuleSubtreeStream stream_e2=new RewriteRuleSubtreeStream(adaptor,"rule e2",e2!=null?e2.tree:null);

            	    root_0 = (Object)adaptor.nil();
            	    // 785:41: -> ^( OP_EQ $equality_expression $e2)
            	    {
            	        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:785:44: ^( OP_EQ $equality_expression $e2)
            	        {
            	        Object root_1 = (Object)adaptor.nil();
            	        root_1 = (Object)adaptor.becomeRoot(
            	        stream_OP_EQ.nextNode()
            	        , root_1);

            	        adaptor.addChild(root_1, stream_retval.nextTree());

            	        adaptor.addChild(root_1, stream_e2.nextTree());

            	        adaptor.addChild(root_0, root_1);
            	        }

            	    }


            	    retval.tree = root_0;
            	    }

            	    }
            	    break;
            	case 2 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:786:9: OP_NE e3= relational_expression
            	    {
            	    OP_NE343=(Token)match(input,OP_NE,FOLLOW_OP_NE_in_equality_expression3750); if (state.failed) return retval; 
            	    if ( state.backtracking==0 ) stream_OP_NE.add(OP_NE343);


            	    pushFollow(FOLLOW_relational_expression_in_equality_expression3755);
            	    e3=relational_expression();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) stream_relational_expression.add(e3.getTree());

            	    // AST REWRITE
            	    // elements: e3, OP_NE, equality_expression
            	    // token labels: 
            	    // rule labels: e3, retval
            	    // token list labels: 
            	    // rule list labels: 
            	    // wildcard labels: 
            	    if ( state.backtracking==0 ) {

            	    retval.tree = root_0;
            	    RewriteRuleSubtreeStream stream_e3=new RewriteRuleSubtreeStream(adaptor,"rule e3",e3!=null?e3.tree:null);
            	    RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            	    root_0 = (Object)adaptor.nil();
            	    // 786:41: -> ^( OP_NE $equality_expression $e3)
            	    {
            	        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:786:44: ^( OP_NE $equality_expression $e3)
            	        {
            	        Object root_1 = (Object)adaptor.nil();
            	        root_1 = (Object)adaptor.becomeRoot(
            	        stream_OP_NE.nextNode()
            	        , root_1);

            	        adaptor.addChild(root_1, stream_retval.nextTree());

            	        adaptor.addChild(root_1, stream_e3.nextTree());

            	        adaptor.addChild(root_0, root_1);
            	        }

            	    }


            	    retval.tree = root_0;
            	    }

            	    }
            	    break;

            	default :
            	    break loop62;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "equality_expression"


    public static class and_expression_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "and_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:789:1: and_expression : (e1= equality_expression -> $e1) ( AMP e2= equality_expression -> ^( AMP $and_expression $e2) )* ;
    public final CSharp4AST.and_expression_return and_expression() throws RecognitionException {
        CSharp4AST.and_expression_return retval = new CSharp4AST.and_expression_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token AMP344=null;
        CSharp4AST.equality_expression_return e1 =null;

        CSharp4AST.equality_expression_return e2 =null;


        Object AMP344_tree=null;
        RewriteRuleTokenStream stream_AMP=new RewriteRuleTokenStream(adaptor,"token AMP");
        RewriteRuleSubtreeStream stream_equality_expression=new RewriteRuleSubtreeStream(adaptor,"rule equality_expression");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:790:2: ( (e1= equality_expression -> $e1) ( AMP e2= equality_expression -> ^( AMP $and_expression $e2) )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:790:4: (e1= equality_expression -> $e1) ( AMP e2= equality_expression -> ^( AMP $and_expression $e2) )*
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:790:4: (e1= equality_expression -> $e1)
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:790:5: e1= equality_expression
            {
            pushFollow(FOLLOW_equality_expression_in_and_expression3791);
            e1=equality_expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_equality_expression.add(e1.getTree());

            // AST REWRITE
            // elements: e1
            // token labels: 
            // rule labels: retval, e1
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
            RewriteRuleSubtreeStream stream_e1=new RewriteRuleSubtreeStream(adaptor,"rule e1",e1!=null?e1.tree:null);

            root_0 = (Object)adaptor.nil();
            // 790:28: -> $e1
            {
                adaptor.addChild(root_0, stream_e1.nextTree());

            }


            retval.tree = root_0;
            }

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:791:6: ( AMP e2= equality_expression -> ^( AMP $and_expression $e2) )*
            loop63:
            do {
                int alt63=2;
                int LA63_0 = input.LA(1);

                if ( (LA63_0==AMP) ) {
                    alt63=1;
                }


                switch (alt63) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:791:8: AMP e2= equality_expression
            	    {
            	    AMP344=(Token)match(input,AMP,FOLLOW_AMP_in_and_expression3806); if (state.failed) return retval; 
            	    if ( state.backtracking==0 ) stream_AMP.add(AMP344);


            	    pushFollow(FOLLOW_equality_expression_in_and_expression3810);
            	    e2=equality_expression();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) stream_equality_expression.add(e2.getTree());

            	    // AST REWRITE
            	    // elements: and_expression, AMP, e2
            	    // token labels: 
            	    // rule labels: retval, e2
            	    // token list labels: 
            	    // rule list labels: 
            	    // wildcard labels: 
            	    if ( state.backtracking==0 ) {

            	    retval.tree = root_0;
            	    RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
            	    RewriteRuleSubtreeStream stream_e2=new RewriteRuleSubtreeStream(adaptor,"rule e2",e2!=null?e2.tree:null);

            	    root_0 = (Object)adaptor.nil();
            	    // 791:35: -> ^( AMP $and_expression $e2)
            	    {
            	        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:791:38: ^( AMP $and_expression $e2)
            	        {
            	        Object root_1 = (Object)adaptor.nil();
            	        root_1 = (Object)adaptor.becomeRoot(
            	        stream_AMP.nextNode()
            	        , root_1);

            	        adaptor.addChild(root_1, stream_retval.nextTree());

            	        adaptor.addChild(root_1, stream_e2.nextTree());

            	        adaptor.addChild(root_0, root_1);
            	        }

            	    }


            	    retval.tree = root_0;
            	    }

            	    }
            	    break;

            	default :
            	    break loop63;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "and_expression"


    public static class exclusive_or_expression_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "exclusive_or_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:794:1: exclusive_or_expression : (e1= and_expression -> $e1) ( CARET e2= and_expression -> ^( CARET $exclusive_or_expression $e2) )* ;
    public final CSharp4AST.exclusive_or_expression_return exclusive_or_expression() throws RecognitionException {
        CSharp4AST.exclusive_or_expression_return retval = new CSharp4AST.exclusive_or_expression_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token CARET345=null;
        CSharp4AST.and_expression_return e1 =null;

        CSharp4AST.and_expression_return e2 =null;


        Object CARET345_tree=null;
        RewriteRuleTokenStream stream_CARET=new RewriteRuleTokenStream(adaptor,"token CARET");
        RewriteRuleSubtreeStream stream_and_expression=new RewriteRuleSubtreeStream(adaptor,"rule and_expression");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:795:2: ( (e1= and_expression -> $e1) ( CARET e2= and_expression -> ^( CARET $exclusive_or_expression $e2) )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:795:4: (e1= and_expression -> $e1) ( CARET e2= and_expression -> ^( CARET $exclusive_or_expression $e2) )*
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:795:4: (e1= and_expression -> $e1)
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:795:5: e1= and_expression
            {
            pushFollow(FOLLOW_and_expression_in_exclusive_or_expression3844);
            e1=and_expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_and_expression.add(e1.getTree());

            // AST REWRITE
            // elements: e1
            // token labels: 
            // rule labels: retval, e1
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
            RewriteRuleSubtreeStream stream_e1=new RewriteRuleSubtreeStream(adaptor,"rule e1",e1!=null?e1.tree:null);

            root_0 = (Object)adaptor.nil();
            // 795:23: -> $e1
            {
                adaptor.addChild(root_0, stream_e1.nextTree());

            }


            retval.tree = root_0;
            }

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:796:6: ( CARET e2= and_expression -> ^( CARET $exclusive_or_expression $e2) )*
            loop64:
            do {
                int alt64=2;
                int LA64_0 = input.LA(1);

                if ( (LA64_0==CARET) ) {
                    alt64=1;
                }


                switch (alt64) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:796:8: CARET e2= and_expression
            	    {
            	    CARET345=(Token)match(input,CARET,FOLLOW_CARET_in_exclusive_or_expression3859); if (state.failed) return retval; 
            	    if ( state.backtracking==0 ) stream_CARET.add(CARET345);


            	    pushFollow(FOLLOW_and_expression_in_exclusive_or_expression3863);
            	    e2=and_expression();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) stream_and_expression.add(e2.getTree());

            	    // AST REWRITE
            	    // elements: e2, CARET, exclusive_or_expression
            	    // token labels: 
            	    // rule labels: retval, e2
            	    // token list labels: 
            	    // rule list labels: 
            	    // wildcard labels: 
            	    if ( state.backtracking==0 ) {

            	    retval.tree = root_0;
            	    RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
            	    RewriteRuleSubtreeStream stream_e2=new RewriteRuleSubtreeStream(adaptor,"rule e2",e2!=null?e2.tree:null);

            	    root_0 = (Object)adaptor.nil();
            	    // 796:32: -> ^( CARET $exclusive_or_expression $e2)
            	    {
            	        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:796:35: ^( CARET $exclusive_or_expression $e2)
            	        {
            	        Object root_1 = (Object)adaptor.nil();
            	        root_1 = (Object)adaptor.becomeRoot(
            	        stream_CARET.nextNode()
            	        , root_1);

            	        adaptor.addChild(root_1, stream_retval.nextTree());

            	        adaptor.addChild(root_1, stream_e2.nextTree());

            	        adaptor.addChild(root_0, root_1);
            	        }

            	    }


            	    retval.tree = root_0;
            	    }

            	    }
            	    break;

            	default :
            	    break loop64;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "exclusive_or_expression"


    public static class inclusive_or_expression_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "inclusive_or_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:799:1: inclusive_or_expression : (e1= exclusive_or_expression -> $e1) ( BITWISE_OR e2= exclusive_or_expression -> ^( BITWISE_OR $inclusive_or_expression $e2) )* ;
    public final CSharp4AST.inclusive_or_expression_return inclusive_or_expression() throws RecognitionException {
        CSharp4AST.inclusive_or_expression_return retval = new CSharp4AST.inclusive_or_expression_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token BITWISE_OR346=null;
        CSharp4AST.exclusive_or_expression_return e1 =null;

        CSharp4AST.exclusive_or_expression_return e2 =null;


        Object BITWISE_OR346_tree=null;
        RewriteRuleTokenStream stream_BITWISE_OR=new RewriteRuleTokenStream(adaptor,"token BITWISE_OR");
        RewriteRuleSubtreeStream stream_exclusive_or_expression=new RewriteRuleSubtreeStream(adaptor,"rule exclusive_or_expression");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:800:2: ( (e1= exclusive_or_expression -> $e1) ( BITWISE_OR e2= exclusive_or_expression -> ^( BITWISE_OR $inclusive_or_expression $e2) )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:800:4: (e1= exclusive_or_expression -> $e1) ( BITWISE_OR e2= exclusive_or_expression -> ^( BITWISE_OR $inclusive_or_expression $e2) )*
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:800:4: (e1= exclusive_or_expression -> $e1)
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:800:5: e1= exclusive_or_expression
            {
            pushFollow(FOLLOW_exclusive_or_expression_in_inclusive_or_expression3897);
            e1=exclusive_or_expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_exclusive_or_expression.add(e1.getTree());

            // AST REWRITE
            // elements: e1
            // token labels: 
            // rule labels: retval, e1
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
            RewriteRuleSubtreeStream stream_e1=new RewriteRuleSubtreeStream(adaptor,"rule e1",e1!=null?e1.tree:null);

            root_0 = (Object)adaptor.nil();
            // 800:32: -> $e1
            {
                adaptor.addChild(root_0, stream_e1.nextTree());

            }


            retval.tree = root_0;
            }

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:801:6: ( BITWISE_OR e2= exclusive_or_expression -> ^( BITWISE_OR $inclusive_or_expression $e2) )*
            loop65:
            do {
                int alt65=2;
                int LA65_0 = input.LA(1);

                if ( (LA65_0==BITWISE_OR) ) {
                    alt65=1;
                }


                switch (alt65) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:801:8: BITWISE_OR e2= exclusive_or_expression
            	    {
            	    BITWISE_OR346=(Token)match(input,BITWISE_OR,FOLLOW_BITWISE_OR_in_inclusive_or_expression3912); if (state.failed) return retval; 
            	    if ( state.backtracking==0 ) stream_BITWISE_OR.add(BITWISE_OR346);


            	    pushFollow(FOLLOW_exclusive_or_expression_in_inclusive_or_expression3916);
            	    e2=exclusive_or_expression();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) stream_exclusive_or_expression.add(e2.getTree());

            	    // AST REWRITE
            	    // elements: inclusive_or_expression, BITWISE_OR, e2
            	    // token labels: 
            	    // rule labels: retval, e2
            	    // token list labels: 
            	    // rule list labels: 
            	    // wildcard labels: 
            	    if ( state.backtracking==0 ) {

            	    retval.tree = root_0;
            	    RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
            	    RewriteRuleSubtreeStream stream_e2=new RewriteRuleSubtreeStream(adaptor,"rule e2",e2!=null?e2.tree:null);

            	    root_0 = (Object)adaptor.nil();
            	    // 801:46: -> ^( BITWISE_OR $inclusive_or_expression $e2)
            	    {
            	        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:801:49: ^( BITWISE_OR $inclusive_or_expression $e2)
            	        {
            	        Object root_1 = (Object)adaptor.nil();
            	        root_1 = (Object)adaptor.becomeRoot(
            	        stream_BITWISE_OR.nextNode()
            	        , root_1);

            	        adaptor.addChild(root_1, stream_retval.nextTree());

            	        adaptor.addChild(root_1, stream_e2.nextTree());

            	        adaptor.addChild(root_0, root_1);
            	        }

            	    }


            	    retval.tree = root_0;
            	    }

            	    }
            	    break;

            	default :
            	    break loop65;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "inclusive_or_expression"


    public static class conditional_and_expression_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "conditional_and_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:804:1: conditional_and_expression : (e1= inclusive_or_expression -> $e1) ( OP_AND e2= inclusive_or_expression -> ^( OP_AND $conditional_and_expression $e2) )* ;
    public final CSharp4AST.conditional_and_expression_return conditional_and_expression() throws RecognitionException {
        CSharp4AST.conditional_and_expression_return retval = new CSharp4AST.conditional_and_expression_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token OP_AND347=null;
        CSharp4AST.inclusive_or_expression_return e1 =null;

        CSharp4AST.inclusive_or_expression_return e2 =null;


        Object OP_AND347_tree=null;
        RewriteRuleTokenStream stream_OP_AND=new RewriteRuleTokenStream(adaptor,"token OP_AND");
        RewriteRuleSubtreeStream stream_inclusive_or_expression=new RewriteRuleSubtreeStream(adaptor,"rule inclusive_or_expression");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:805:2: ( (e1= inclusive_or_expression -> $e1) ( OP_AND e2= inclusive_or_expression -> ^( OP_AND $conditional_and_expression $e2) )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:805:4: (e1= inclusive_or_expression -> $e1) ( OP_AND e2= inclusive_or_expression -> ^( OP_AND $conditional_and_expression $e2) )*
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:805:4: (e1= inclusive_or_expression -> $e1)
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:805:5: e1= inclusive_or_expression
            {
            pushFollow(FOLLOW_inclusive_or_expression_in_conditional_and_expression3950);
            e1=inclusive_or_expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_inclusive_or_expression.add(e1.getTree());

            // AST REWRITE
            // elements: e1
            // token labels: 
            // rule labels: retval, e1
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
            RewriteRuleSubtreeStream stream_e1=new RewriteRuleSubtreeStream(adaptor,"rule e1",e1!=null?e1.tree:null);

            root_0 = (Object)adaptor.nil();
            // 805:32: -> $e1
            {
                adaptor.addChild(root_0, stream_e1.nextTree());

            }


            retval.tree = root_0;
            }

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:806:6: ( OP_AND e2= inclusive_or_expression -> ^( OP_AND $conditional_and_expression $e2) )*
            loop66:
            do {
                int alt66=2;
                int LA66_0 = input.LA(1);

                if ( (LA66_0==OP_AND) ) {
                    alt66=1;
                }


                switch (alt66) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:806:8: OP_AND e2= inclusive_or_expression
            	    {
            	    OP_AND347=(Token)match(input,OP_AND,FOLLOW_OP_AND_in_conditional_and_expression3965); if (state.failed) return retval; 
            	    if ( state.backtracking==0 ) stream_OP_AND.add(OP_AND347);


            	    pushFollow(FOLLOW_inclusive_or_expression_in_conditional_and_expression3969);
            	    e2=inclusive_or_expression();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) stream_inclusive_or_expression.add(e2.getTree());

            	    // AST REWRITE
            	    // elements: OP_AND, e2, conditional_and_expression
            	    // token labels: 
            	    // rule labels: retval, e2
            	    // token list labels: 
            	    // rule list labels: 
            	    // wildcard labels: 
            	    if ( state.backtracking==0 ) {

            	    retval.tree = root_0;
            	    RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
            	    RewriteRuleSubtreeStream stream_e2=new RewriteRuleSubtreeStream(adaptor,"rule e2",e2!=null?e2.tree:null);

            	    root_0 = (Object)adaptor.nil();
            	    // 806:42: -> ^( OP_AND $conditional_and_expression $e2)
            	    {
            	        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:806:45: ^( OP_AND $conditional_and_expression $e2)
            	        {
            	        Object root_1 = (Object)adaptor.nil();
            	        root_1 = (Object)adaptor.becomeRoot(
            	        stream_OP_AND.nextNode()
            	        , root_1);

            	        adaptor.addChild(root_1, stream_retval.nextTree());

            	        adaptor.addChild(root_1, stream_e2.nextTree());

            	        adaptor.addChild(root_0, root_1);
            	        }

            	    }


            	    retval.tree = root_0;
            	    }

            	    }
            	    break;

            	default :
            	    break loop66;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "conditional_and_expression"


    public static class conditional_or_expression_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "conditional_or_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:809:1: conditional_or_expression : (e1= conditional_and_expression -> $e1) ( OP_OR e2= conditional_and_expression -> ^( OP_OR $conditional_or_expression $e2) )* ;
    public final CSharp4AST.conditional_or_expression_return conditional_or_expression() throws RecognitionException {
        CSharp4AST.conditional_or_expression_return retval = new CSharp4AST.conditional_or_expression_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token OP_OR348=null;
        CSharp4AST.conditional_and_expression_return e1 =null;

        CSharp4AST.conditional_and_expression_return e2 =null;


        Object OP_OR348_tree=null;
        RewriteRuleTokenStream stream_OP_OR=new RewriteRuleTokenStream(adaptor,"token OP_OR");
        RewriteRuleSubtreeStream stream_conditional_and_expression=new RewriteRuleSubtreeStream(adaptor,"rule conditional_and_expression");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:810:2: ( (e1= conditional_and_expression -> $e1) ( OP_OR e2= conditional_and_expression -> ^( OP_OR $conditional_or_expression $e2) )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:810:4: (e1= conditional_and_expression -> $e1) ( OP_OR e2= conditional_and_expression -> ^( OP_OR $conditional_or_expression $e2) )*
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:810:4: (e1= conditional_and_expression -> $e1)
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:810:5: e1= conditional_and_expression
            {
            pushFollow(FOLLOW_conditional_and_expression_in_conditional_or_expression4003);
            e1=conditional_and_expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_conditional_and_expression.add(e1.getTree());

            // AST REWRITE
            // elements: e1
            // token labels: 
            // rule labels: retval, e1
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
            RewriteRuleSubtreeStream stream_e1=new RewriteRuleSubtreeStream(adaptor,"rule e1",e1!=null?e1.tree:null);

            root_0 = (Object)adaptor.nil();
            // 810:35: -> $e1
            {
                adaptor.addChild(root_0, stream_e1.nextTree());

            }


            retval.tree = root_0;
            }

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:811:6: ( OP_OR e2= conditional_and_expression -> ^( OP_OR $conditional_or_expression $e2) )*
            loop67:
            do {
                int alt67=2;
                int LA67_0 = input.LA(1);

                if ( (LA67_0==OP_OR) ) {
                    alt67=1;
                }


                switch (alt67) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:811:8: OP_OR e2= conditional_and_expression
            	    {
            	    OP_OR348=(Token)match(input,OP_OR,FOLLOW_OP_OR_in_conditional_or_expression4018); if (state.failed) return retval; 
            	    if ( state.backtracking==0 ) stream_OP_OR.add(OP_OR348);


            	    pushFollow(FOLLOW_conditional_and_expression_in_conditional_or_expression4022);
            	    e2=conditional_and_expression();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) stream_conditional_and_expression.add(e2.getTree());

            	    // AST REWRITE
            	    // elements: conditional_or_expression, OP_OR, e2
            	    // token labels: 
            	    // rule labels: retval, e2
            	    // token list labels: 
            	    // rule list labels: 
            	    // wildcard labels: 
            	    if ( state.backtracking==0 ) {

            	    retval.tree = root_0;
            	    RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
            	    RewriteRuleSubtreeStream stream_e2=new RewriteRuleSubtreeStream(adaptor,"rule e2",e2!=null?e2.tree:null);

            	    root_0 = (Object)adaptor.nil();
            	    // 811:44: -> ^( OP_OR $conditional_or_expression $e2)
            	    {
            	        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:811:47: ^( OP_OR $conditional_or_expression $e2)
            	        {
            	        Object root_1 = (Object)adaptor.nil();
            	        root_1 = (Object)adaptor.becomeRoot(
            	        stream_OP_OR.nextNode()
            	        , root_1);

            	        adaptor.addChild(root_1, stream_retval.nextTree());

            	        adaptor.addChild(root_1, stream_e2.nextTree());

            	        adaptor.addChild(root_0, root_1);
            	        }

            	    }


            	    retval.tree = root_0;
            	    }

            	    }
            	    break;

            	default :
            	    break loop67;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "conditional_or_expression"


    public static class null_coalescing_expression_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "null_coalescing_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:820:1: null_coalescing_expression : conditional_or_expression ( OP_COALESCING ^ null_coalescing_expression )? ;
    public final CSharp4AST.null_coalescing_expression_return null_coalescing_expression() throws RecognitionException {
        CSharp4AST.null_coalescing_expression_return retval = new CSharp4AST.null_coalescing_expression_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token OP_COALESCING350=null;
        CSharp4AST.conditional_or_expression_return conditional_or_expression349 =null;

        CSharp4AST.null_coalescing_expression_return null_coalescing_expression351 =null;


        Object OP_COALESCING350_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:821:3: ( conditional_or_expression ( OP_COALESCING ^ null_coalescing_expression )? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:821:5: conditional_or_expression ( OP_COALESCING ^ null_coalescing_expression )?
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_conditional_or_expression_in_null_coalescing_expression4056);
            conditional_or_expression349=conditional_or_expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, conditional_or_expression349.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:821:31: ( OP_COALESCING ^ null_coalescing_expression )?
            int alt68=2;
            int LA68_0 = input.LA(1);

            if ( (LA68_0==OP_COALESCING) ) {
                alt68=1;
            }
            switch (alt68) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:821:32: OP_COALESCING ^ null_coalescing_expression
                    {
                    OP_COALESCING350=(Token)match(input,OP_COALESCING,FOLLOW_OP_COALESCING_in_null_coalescing_expression4059); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OP_COALESCING350_tree = 
                    (Object)adaptor.create(OP_COALESCING350)
                    ;
                    root_0 = (Object)adaptor.becomeRoot(OP_COALESCING350_tree, root_0);
                    }

                    pushFollow(FOLLOW_null_coalescing_expression_in_null_coalescing_expression4062);
                    null_coalescing_expression351=null_coalescing_expression();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, null_coalescing_expression351.getTree());

                    }
                    break;

            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "null_coalescing_expression"


    public static class conditional_expression_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "conditional_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:830:1: conditional_expression : (e1= null_coalescing_expression -> $e1) ( INTERR expression COLON expression -> ^( CONDITIONAL_EXPRESSION ^( THEN expression ) ^( ELSE expression ) ) )? ;
    public final CSharp4AST.conditional_expression_return conditional_expression() throws RecognitionException {
        CSharp4AST.conditional_expression_return retval = new CSharp4AST.conditional_expression_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token INTERR352=null;
        Token COLON354=null;
        CSharp4AST.null_coalescing_expression_return e1 =null;

        CSharp4AST.expression_return expression353 =null;

        CSharp4AST.expression_return expression355 =null;


        Object INTERR352_tree=null;
        Object COLON354_tree=null;
        RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
        RewriteRuleTokenStream stream_INTERR=new RewriteRuleTokenStream(adaptor,"token INTERR");
        RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
        RewriteRuleSubtreeStream stream_null_coalescing_expression=new RewriteRuleSubtreeStream(adaptor,"rule null_coalescing_expression");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:831:3: ( (e1= null_coalescing_expression -> $e1) ( INTERR expression COLON expression -> ^( CONDITIONAL_EXPRESSION ^( THEN expression ) ^( ELSE expression ) ) )? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:831:5: (e1= null_coalescing_expression -> $e1) ( INTERR expression COLON expression -> ^( CONDITIONAL_EXPRESSION ^( THEN expression ) ^( ELSE expression ) ) )?
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:831:5: (e1= null_coalescing_expression -> $e1)
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:831:6: e1= null_coalescing_expression
            {
            pushFollow(FOLLOW_null_coalescing_expression_in_conditional_expression4083);
            e1=null_coalescing_expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_null_coalescing_expression.add(e1.getTree());

            // AST REWRITE
            // elements: e1
            // token labels: 
            // rule labels: retval, e1
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
            RewriteRuleSubtreeStream stream_e1=new RewriteRuleSubtreeStream(adaptor,"rule e1",e1!=null?e1.tree:null);

            root_0 = (Object)adaptor.nil();
            // 831:36: -> $e1
            {
                adaptor.addChild(root_0, stream_e1.nextTree());

            }


            retval.tree = root_0;
            }

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:832:5: ( INTERR expression COLON expression -> ^( CONDITIONAL_EXPRESSION ^( THEN expression ) ^( ELSE expression ) ) )?
            int alt69=2;
            int LA69_0 = input.LA(1);

            if ( (LA69_0==INTERR) ) {
                alt69=1;
            }
            switch (alt69) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:832:6: INTERR expression COLON expression
                    {
                    INTERR352=(Token)match(input,INTERR,FOLLOW_INTERR_in_conditional_expression4096); if (state.failed) return retval; 
                    if ( state.backtracking==0 ) stream_INTERR.add(INTERR352);


                    pushFollow(FOLLOW_expression_in_conditional_expression4098);
                    expression353=expression();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) stream_expression.add(expression353.getTree());

                    COLON354=(Token)match(input,COLON,FOLLOW_COLON_in_conditional_expression4100); if (state.failed) return retval; 
                    if ( state.backtracking==0 ) stream_COLON.add(COLON354);


                    pushFollow(FOLLOW_expression_in_conditional_expression4102);
                    expression355=expression();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) stream_expression.add(expression355.getTree());

                    // AST REWRITE
                    // elements: expression, expression
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    // wildcard labels: 
                    if ( state.backtracking==0 ) {

                    retval.tree = root_0;
                    RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

                    root_0 = (Object)adaptor.nil();
                    // 832:41: -> ^( CONDITIONAL_EXPRESSION ^( THEN expression ) ^( ELSE expression ) )
                    {
                        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:832:44: ^( CONDITIONAL_EXPRESSION ^( THEN expression ) ^( ELSE expression ) )
                        {
                        Object root_1 = (Object)adaptor.nil();
                        root_1 = (Object)adaptor.becomeRoot(
                        (Object)adaptor.create(CONDITIONAL_EXPRESSION, "CONDITIONAL_EXPRESSION")
                        , root_1);

                        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:832:69: ^( THEN expression )
                        {
                        Object root_2 = (Object)adaptor.nil();
                        root_2 = (Object)adaptor.becomeRoot(
                        (Object)adaptor.create(THEN, "THEN")
                        , root_2);

                        adaptor.addChild(root_2, stream_expression.nextTree());

                        adaptor.addChild(root_1, root_2);
                        }

                        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:832:88: ^( ELSE expression )
                        {
                        Object root_2 = (Object)adaptor.nil();
                        root_2 = (Object)adaptor.becomeRoot(
                        (Object)adaptor.create(ELSE, "ELSE")
                        , root_2);

                        adaptor.addChild(root_2, stream_expression.nextTree());

                        adaptor.addChild(root_1, root_2);
                        }

                        adaptor.addChild(root_0, root_1);
                        }

                    }


                    retval.tree = root_0;
                    }

                    }
                    break;

            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "conditional_expression"


    public static class lambda_expression_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "lambda_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:836:1: lambda_expression : anonymous_function_signature right_arrow anonymous_function_body ;
    public final CSharp4AST.lambda_expression_return lambda_expression() throws RecognitionException {
        CSharp4AST.lambda_expression_return retval = new CSharp4AST.lambda_expression_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.anonymous_function_signature_return anonymous_function_signature356 =null;

        CSharp4AST.right_arrow_return right_arrow357 =null;

        CSharp4AST.anonymous_function_body_return anonymous_function_body358 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:837:2: ( anonymous_function_signature right_arrow anonymous_function_body )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:837:4: anonymous_function_signature right_arrow anonymous_function_body
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_anonymous_function_signature_in_lambda_expression4138);
            anonymous_function_signature356=anonymous_function_signature();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, anonymous_function_signature356.getTree());

            pushFollow(FOLLOW_right_arrow_in_lambda_expression4140);
            right_arrow357=right_arrow();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, right_arrow357.getTree());

            pushFollow(FOLLOW_anonymous_function_body_in_lambda_expression4142);
            anonymous_function_body358=anonymous_function_body();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, anonymous_function_body358.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "lambda_expression"


    public static class anonymous_method_expression_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "anonymous_method_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:840:1: anonymous_method_expression : DELEGATE ^ ( explicit_anonymous_function_signature )? block ;
    public final CSharp4AST.anonymous_method_expression_return anonymous_method_expression() throws RecognitionException {
        CSharp4AST.anonymous_method_expression_return retval = new CSharp4AST.anonymous_method_expression_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token DELEGATE359=null;
        CSharp4AST.explicit_anonymous_function_signature_return explicit_anonymous_function_signature360 =null;

        CSharp4AST.block_return block361 =null;


        Object DELEGATE359_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:841:2: ( DELEGATE ^ ( explicit_anonymous_function_signature )? block )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:841:4: DELEGATE ^ ( explicit_anonymous_function_signature )? block
            {
            root_0 = (Object)adaptor.nil();


            DELEGATE359=(Token)match(input,DELEGATE,FOLLOW_DELEGATE_in_anonymous_method_expression4155); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            DELEGATE359_tree = 
            (Object)adaptor.create(DELEGATE359)
            ;
            root_0 = (Object)adaptor.becomeRoot(DELEGATE359_tree, root_0);
            }

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:841:14: ( explicit_anonymous_function_signature )?
            int alt70=2;
            int LA70_0 = input.LA(1);

            if ( (LA70_0==OPEN_PARENS) ) {
                alt70=1;
            }
            switch (alt70) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:841:14: explicit_anonymous_function_signature
                    {
                    pushFollow(FOLLOW_explicit_anonymous_function_signature_in_anonymous_method_expression4158);
                    explicit_anonymous_function_signature360=explicit_anonymous_function_signature();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, explicit_anonymous_function_signature360.getTree());

                    }
                    break;

            }


            pushFollow(FOLLOW_block_in_anonymous_method_expression4161);
            block361=block();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, block361.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "anonymous_method_expression"


    public static class anonymous_function_signature_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "anonymous_function_signature"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:850:1: anonymous_function_signature : ( OPEN_PARENS CLOSE_PARENS | OPEN_PARENS explicit_anonymous_function_parameter_list CLOSE_PARENS | OPEN_PARENS implicit_anonymous_function_parameter_list CLOSE_PARENS | implicit_anonymous_function_parameter );
    public final CSharp4AST.anonymous_function_signature_return anonymous_function_signature() throws RecognitionException {
        CSharp4AST.anonymous_function_signature_return retval = new CSharp4AST.anonymous_function_signature_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token OPEN_PARENS362=null;
        Token CLOSE_PARENS363=null;
        Token OPEN_PARENS364=null;
        Token CLOSE_PARENS366=null;
        Token OPEN_PARENS367=null;
        Token CLOSE_PARENS369=null;
        CSharp4AST.explicit_anonymous_function_parameter_list_return explicit_anonymous_function_parameter_list365 =null;

        CSharp4AST.implicit_anonymous_function_parameter_list_return implicit_anonymous_function_parameter_list368 =null;

        CSharp4AST.implicit_anonymous_function_parameter_return implicit_anonymous_function_parameter370 =null;


        Object OPEN_PARENS362_tree=null;
        Object CLOSE_PARENS363_tree=null;
        Object OPEN_PARENS364_tree=null;
        Object CLOSE_PARENS366_tree=null;
        Object OPEN_PARENS367_tree=null;
        Object CLOSE_PARENS369_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:851:3: ( OPEN_PARENS CLOSE_PARENS | OPEN_PARENS explicit_anonymous_function_parameter_list CLOSE_PARENS | OPEN_PARENS implicit_anonymous_function_parameter_list CLOSE_PARENS | implicit_anonymous_function_parameter )
            int alt71=4;
            int LA71_0 = input.LA(1);

            if ( (LA71_0==OPEN_PARENS) ) {
                switch ( input.LA(2) ) {
                case CLOSE_PARENS:
                    {
                    alt71=1;
                    }
                    break;
                case BOOL:
                case BYTE:
                case CHAR:
                case DECIMAL:
                case DOUBLE:
                case FLOAT:
                case INT:
                case LONG:
                case OBJECT:
                case OUT:
                case REF:
                case SBYTE:
                case SHORT:
                case STRING:
                case UINT:
                case ULONG:
                case USHORT:
                case VOID:
                    {
                    alt71=2;
                    }
                    break;
                case IDENTIFIER:
                    {
                    int LA71_5 = input.LA(3);

                    if ( (LA71_5==DOT||LA71_5==DOUBLE_COLON||LA71_5==IDENTIFIER||LA71_5==INTERR||LA71_5==LT||LA71_5==OPEN_BRACKET||LA71_5==STAR) ) {
                        alt71=2;
                    }
                    else if ( (LA71_5==CLOSE_PARENS||LA71_5==COMMA) ) {
                        alt71=3;
                    }
                    else {
                        if (state.backtracking>0) {state.failed=true; return retval;}
                        NoViableAltException nvae =
                            new NoViableAltException("", 71, 5, input);

                        throw nvae;

                    }
                    }
                    break;
                default:
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 71, 1, input);

                    throw nvae;

                }

            }
            else if ( (LA71_0==IDENTIFIER) ) {
                alt71=4;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 71, 0, input);

                throw nvae;

            }
            switch (alt71) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:851:5: OPEN_PARENS CLOSE_PARENS
                    {
                    root_0 = (Object)adaptor.nil();


                    OPEN_PARENS362=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_anonymous_function_signature4177); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OPEN_PARENS362_tree = 
                    (Object)adaptor.create(OPEN_PARENS362)
                    ;
                    adaptor.addChild(root_0, OPEN_PARENS362_tree);
                    }

                    CLOSE_PARENS363=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_anonymous_function_signature4179); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    CLOSE_PARENS363_tree = 
                    (Object)adaptor.create(CLOSE_PARENS363)
                    ;
                    adaptor.addChild(root_0, CLOSE_PARENS363_tree);
                    }

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:852:5: OPEN_PARENS explicit_anonymous_function_parameter_list CLOSE_PARENS
                    {
                    root_0 = (Object)adaptor.nil();


                    OPEN_PARENS364=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_anonymous_function_signature4185); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OPEN_PARENS364_tree = 
                    (Object)adaptor.create(OPEN_PARENS364)
                    ;
                    adaptor.addChild(root_0, OPEN_PARENS364_tree);
                    }

                    pushFollow(FOLLOW_explicit_anonymous_function_parameter_list_in_anonymous_function_signature4187);
                    explicit_anonymous_function_parameter_list365=explicit_anonymous_function_parameter_list();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, explicit_anonymous_function_parameter_list365.getTree());

                    CLOSE_PARENS366=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_anonymous_function_signature4189); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    CLOSE_PARENS366_tree = 
                    (Object)adaptor.create(CLOSE_PARENS366)
                    ;
                    adaptor.addChild(root_0, CLOSE_PARENS366_tree);
                    }

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:853:5: OPEN_PARENS implicit_anonymous_function_parameter_list CLOSE_PARENS
                    {
                    root_0 = (Object)adaptor.nil();


                    OPEN_PARENS367=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_anonymous_function_signature4195); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OPEN_PARENS367_tree = 
                    (Object)adaptor.create(OPEN_PARENS367)
                    ;
                    adaptor.addChild(root_0, OPEN_PARENS367_tree);
                    }

                    pushFollow(FOLLOW_implicit_anonymous_function_parameter_list_in_anonymous_function_signature4197);
                    implicit_anonymous_function_parameter_list368=implicit_anonymous_function_parameter_list();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, implicit_anonymous_function_parameter_list368.getTree());

                    CLOSE_PARENS369=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_anonymous_function_signature4199); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    CLOSE_PARENS369_tree = 
                    (Object)adaptor.create(CLOSE_PARENS369)
                    ;
                    adaptor.addChild(root_0, CLOSE_PARENS369_tree);
                    }

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:854:5: implicit_anonymous_function_parameter
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_implicit_anonymous_function_parameter_in_anonymous_function_signature4205);
                    implicit_anonymous_function_parameter370=implicit_anonymous_function_parameter();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, implicit_anonymous_function_parameter370.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "anonymous_function_signature"


    public static class explicit_anonymous_function_signature_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "explicit_anonymous_function_signature"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:856:1: explicit_anonymous_function_signature : OPEN_PARENS ( explicit_anonymous_function_parameter_list )? CLOSE_PARENS ;
    public final CSharp4AST.explicit_anonymous_function_signature_return explicit_anonymous_function_signature() throws RecognitionException {
        CSharp4AST.explicit_anonymous_function_signature_return retval = new CSharp4AST.explicit_anonymous_function_signature_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token OPEN_PARENS371=null;
        Token CLOSE_PARENS373=null;
        CSharp4AST.explicit_anonymous_function_parameter_list_return explicit_anonymous_function_parameter_list372 =null;


        Object OPEN_PARENS371_tree=null;
        Object CLOSE_PARENS373_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:857:2: ( OPEN_PARENS ( explicit_anonymous_function_parameter_list )? CLOSE_PARENS )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:857:4: OPEN_PARENS ( explicit_anonymous_function_parameter_list )? CLOSE_PARENS
            {
            root_0 = (Object)adaptor.nil();


            OPEN_PARENS371=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_explicit_anonymous_function_signature4217); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            OPEN_PARENS371_tree = 
            (Object)adaptor.create(OPEN_PARENS371)
            ;
            adaptor.addChild(root_0, OPEN_PARENS371_tree);
            }

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:857:16: ( explicit_anonymous_function_parameter_list )?
            int alt72=2;
            int LA72_0 = input.LA(1);

            if ( (LA72_0==BOOL||LA72_0==BYTE||LA72_0==CHAR||LA72_0==DECIMAL||LA72_0==DOUBLE||LA72_0==FLOAT||LA72_0==IDENTIFIER||LA72_0==INT||LA72_0==LONG||LA72_0==OBJECT||LA72_0==OUT||LA72_0==REF||LA72_0==SBYTE||LA72_0==SHORT||LA72_0==STRING||(LA72_0 >= UINT && LA72_0 <= ULONG)||LA72_0==USHORT||LA72_0==VOID) ) {
                alt72=1;
            }
            switch (alt72) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:857:16: explicit_anonymous_function_parameter_list
                    {
                    pushFollow(FOLLOW_explicit_anonymous_function_parameter_list_in_explicit_anonymous_function_signature4219);
                    explicit_anonymous_function_parameter_list372=explicit_anonymous_function_parameter_list();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, explicit_anonymous_function_parameter_list372.getTree());

                    }
                    break;

            }


            CLOSE_PARENS373=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_explicit_anonymous_function_signature4222); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            CLOSE_PARENS373_tree = 
            (Object)adaptor.create(CLOSE_PARENS373)
            ;
            adaptor.addChild(root_0, CLOSE_PARENS373_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "explicit_anonymous_function_signature"


    public static class explicit_anonymous_function_parameter_list_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "explicit_anonymous_function_parameter_list"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:859:1: explicit_anonymous_function_parameter_list : explicit_anonymous_function_parameter ( COMMA explicit_anonymous_function_parameter )* ;
    public final CSharp4AST.explicit_anonymous_function_parameter_list_return explicit_anonymous_function_parameter_list() throws RecognitionException {
        CSharp4AST.explicit_anonymous_function_parameter_list_return retval = new CSharp4AST.explicit_anonymous_function_parameter_list_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token COMMA375=null;
        CSharp4AST.explicit_anonymous_function_parameter_return explicit_anonymous_function_parameter374 =null;

        CSharp4AST.explicit_anonymous_function_parameter_return explicit_anonymous_function_parameter376 =null;


        Object COMMA375_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:860:2: ( explicit_anonymous_function_parameter ( COMMA explicit_anonymous_function_parameter )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:860:4: explicit_anonymous_function_parameter ( COMMA explicit_anonymous_function_parameter )*
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_explicit_anonymous_function_parameter_in_explicit_anonymous_function_parameter_list4233);
            explicit_anonymous_function_parameter374=explicit_anonymous_function_parameter();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, explicit_anonymous_function_parameter374.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:860:42: ( COMMA explicit_anonymous_function_parameter )*
            loop73:
            do {
                int alt73=2;
                int LA73_0 = input.LA(1);

                if ( (LA73_0==COMMA) ) {
                    alt73=1;
                }


                switch (alt73) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:860:44: COMMA explicit_anonymous_function_parameter
            	    {
            	    COMMA375=(Token)match(input,COMMA,FOLLOW_COMMA_in_explicit_anonymous_function_parameter_list4237); if (state.failed) return retval;
            	    if ( state.backtracking==0 ) {
            	    COMMA375_tree = 
            	    (Object)adaptor.create(COMMA375)
            	    ;
            	    adaptor.addChild(root_0, COMMA375_tree);
            	    }

            	    pushFollow(FOLLOW_explicit_anonymous_function_parameter_in_explicit_anonymous_function_parameter_list4239);
            	    explicit_anonymous_function_parameter376=explicit_anonymous_function_parameter();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, explicit_anonymous_function_parameter376.getTree());

            	    }
            	    break;

            	default :
            	    break loop73;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "explicit_anonymous_function_parameter_list"


    public static class explicit_anonymous_function_parameter_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "explicit_anonymous_function_parameter"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:862:1: explicit_anonymous_function_parameter : ( anonymous_function_parameter_modifier )? type IDENTIFIER ;
    public final CSharp4AST.explicit_anonymous_function_parameter_return explicit_anonymous_function_parameter() throws RecognitionException {
        CSharp4AST.explicit_anonymous_function_parameter_return retval = new CSharp4AST.explicit_anonymous_function_parameter_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER379=null;
        CSharp4AST.anonymous_function_parameter_modifier_return anonymous_function_parameter_modifier377 =null;

        CSharp4AST.type_return type378 =null;


        Object IDENTIFIER379_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:863:2: ( ( anonymous_function_parameter_modifier )? type IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:863:4: ( anonymous_function_parameter_modifier )? type IDENTIFIER
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:863:4: ( anonymous_function_parameter_modifier )?
            int alt74=2;
            int LA74_0 = input.LA(1);

            if ( (LA74_0==OUT||LA74_0==REF) ) {
                alt74=1;
            }
            switch (alt74) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:863:4: anonymous_function_parameter_modifier
                    {
                    pushFollow(FOLLOW_anonymous_function_parameter_modifier_in_explicit_anonymous_function_parameter4252);
                    anonymous_function_parameter_modifier377=anonymous_function_parameter_modifier();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, anonymous_function_parameter_modifier377.getTree());

                    }
                    break;

            }


            pushFollow(FOLLOW_type_in_explicit_anonymous_function_parameter4255);
            type378=type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, type378.getTree());

            IDENTIFIER379=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_explicit_anonymous_function_parameter4257); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER379_tree = 
            (Object)adaptor.create(IDENTIFIER379)
            ;
            adaptor.addChild(root_0, IDENTIFIER379_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "explicit_anonymous_function_parameter"


    public static class anonymous_function_parameter_modifier_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "anonymous_function_parameter_modifier"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:865:1: anonymous_function_parameter_modifier : ( REF | OUT );
    public final CSharp4AST.anonymous_function_parameter_modifier_return anonymous_function_parameter_modifier() throws RecognitionException {
        CSharp4AST.anonymous_function_parameter_modifier_return retval = new CSharp4AST.anonymous_function_parameter_modifier_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token set380=null;

        Object set380_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:866:2: ( REF | OUT )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:
            {
            root_0 = (Object)adaptor.nil();


            set380=(Token)input.LT(1);

            if ( input.LA(1)==OUT||input.LA(1)==REF ) {
                input.consume();
                if ( state.backtracking==0 ) adaptor.addChild(root_0, 
                (Object)adaptor.create(set380)
                );
                state.errorRecovery=false;
                state.failed=false;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                MismatchedSetException mse = new MismatchedSetException(null,input);
                throw mse;
            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "anonymous_function_parameter_modifier"


    public static class implicit_anonymous_function_signature_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "implicit_anonymous_function_signature"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:869:1: implicit_anonymous_function_signature : ( OPEN_PARENS ( implicit_anonymous_function_parameter_list )? CLOSE_PARENS | implicit_anonymous_function_parameter );
    public final CSharp4AST.implicit_anonymous_function_signature_return implicit_anonymous_function_signature() throws RecognitionException {
        CSharp4AST.implicit_anonymous_function_signature_return retval = new CSharp4AST.implicit_anonymous_function_signature_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token OPEN_PARENS381=null;
        Token CLOSE_PARENS383=null;
        CSharp4AST.implicit_anonymous_function_parameter_list_return implicit_anonymous_function_parameter_list382 =null;

        CSharp4AST.implicit_anonymous_function_parameter_return implicit_anonymous_function_parameter384 =null;


        Object OPEN_PARENS381_tree=null;
        Object CLOSE_PARENS383_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:870:2: ( OPEN_PARENS ( implicit_anonymous_function_parameter_list )? CLOSE_PARENS | implicit_anonymous_function_parameter )
            int alt76=2;
            int LA76_0 = input.LA(1);

            if ( (LA76_0==OPEN_PARENS) ) {
                alt76=1;
            }
            else if ( (LA76_0==IDENTIFIER) ) {
                alt76=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 76, 0, input);

                throw nvae;

            }
            switch (alt76) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:870:4: OPEN_PARENS ( implicit_anonymous_function_parameter_list )? CLOSE_PARENS
                    {
                    root_0 = (Object)adaptor.nil();


                    OPEN_PARENS381=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_implicit_anonymous_function_signature4284); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OPEN_PARENS381_tree = 
                    (Object)adaptor.create(OPEN_PARENS381)
                    ;
                    adaptor.addChild(root_0, OPEN_PARENS381_tree);
                    }

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:870:16: ( implicit_anonymous_function_parameter_list )?
                    int alt75=2;
                    int LA75_0 = input.LA(1);

                    if ( (LA75_0==IDENTIFIER) ) {
                        alt75=1;
                    }
                    switch (alt75) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:870:16: implicit_anonymous_function_parameter_list
                            {
                            pushFollow(FOLLOW_implicit_anonymous_function_parameter_list_in_implicit_anonymous_function_signature4286);
                            implicit_anonymous_function_parameter_list382=implicit_anonymous_function_parameter_list();

                            state._fsp--;
                            if (state.failed) return retval;
                            if ( state.backtracking==0 ) adaptor.addChild(root_0, implicit_anonymous_function_parameter_list382.getTree());

                            }
                            break;

                    }


                    CLOSE_PARENS383=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_implicit_anonymous_function_signature4289); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    CLOSE_PARENS383_tree = 
                    (Object)adaptor.create(CLOSE_PARENS383)
                    ;
                    adaptor.addChild(root_0, CLOSE_PARENS383_tree);
                    }

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:871:4: implicit_anonymous_function_parameter
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_implicit_anonymous_function_parameter_in_implicit_anonymous_function_signature4294);
                    implicit_anonymous_function_parameter384=implicit_anonymous_function_parameter();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, implicit_anonymous_function_parameter384.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "implicit_anonymous_function_signature"


    public static class implicit_anonymous_function_parameter_list_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "implicit_anonymous_function_parameter_list"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:873:1: implicit_anonymous_function_parameter_list : implicit_anonymous_function_parameter ( COMMA implicit_anonymous_function_parameter )* ;
    public final CSharp4AST.implicit_anonymous_function_parameter_list_return implicit_anonymous_function_parameter_list() throws RecognitionException {
        CSharp4AST.implicit_anonymous_function_parameter_list_return retval = new CSharp4AST.implicit_anonymous_function_parameter_list_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token COMMA386=null;
        CSharp4AST.implicit_anonymous_function_parameter_return implicit_anonymous_function_parameter385 =null;

        CSharp4AST.implicit_anonymous_function_parameter_return implicit_anonymous_function_parameter387 =null;


        Object COMMA386_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:874:2: ( implicit_anonymous_function_parameter ( COMMA implicit_anonymous_function_parameter )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:874:4: implicit_anonymous_function_parameter ( COMMA implicit_anonymous_function_parameter )*
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_implicit_anonymous_function_parameter_in_implicit_anonymous_function_parameter_list4305);
            implicit_anonymous_function_parameter385=implicit_anonymous_function_parameter();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, implicit_anonymous_function_parameter385.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:874:42: ( COMMA implicit_anonymous_function_parameter )*
            loop77:
            do {
                int alt77=2;
                int LA77_0 = input.LA(1);

                if ( (LA77_0==COMMA) ) {
                    alt77=1;
                }


                switch (alt77) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:874:44: COMMA implicit_anonymous_function_parameter
            	    {
            	    COMMA386=(Token)match(input,COMMA,FOLLOW_COMMA_in_implicit_anonymous_function_parameter_list4309); if (state.failed) return retval;
            	    if ( state.backtracking==0 ) {
            	    COMMA386_tree = 
            	    (Object)adaptor.create(COMMA386)
            	    ;
            	    adaptor.addChild(root_0, COMMA386_tree);
            	    }

            	    pushFollow(FOLLOW_implicit_anonymous_function_parameter_in_implicit_anonymous_function_parameter_list4311);
            	    implicit_anonymous_function_parameter387=implicit_anonymous_function_parameter();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, implicit_anonymous_function_parameter387.getTree());

            	    }
            	    break;

            	default :
            	    break loop77;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "implicit_anonymous_function_parameter_list"


    public static class implicit_anonymous_function_parameter_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "implicit_anonymous_function_parameter"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:877:1: implicit_anonymous_function_parameter : IDENTIFIER ;
    public final CSharp4AST.implicit_anonymous_function_parameter_return implicit_anonymous_function_parameter() throws RecognitionException {
        CSharp4AST.implicit_anonymous_function_parameter_return retval = new CSharp4AST.implicit_anonymous_function_parameter_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER388=null;

        Object IDENTIFIER388_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:878:2: ( IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:878:4: IDENTIFIER
            {
            root_0 = (Object)adaptor.nil();


            IDENTIFIER388=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_implicit_anonymous_function_parameter4326); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER388_tree = 
            (Object)adaptor.create(IDENTIFIER388)
            ;
            adaptor.addChild(root_0, IDENTIFIER388_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "implicit_anonymous_function_parameter"


    public static class anonymous_function_body_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "anonymous_function_body"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:880:1: anonymous_function_body : ( expression | block );
    public final CSharp4AST.anonymous_function_body_return anonymous_function_body() throws RecognitionException {
        CSharp4AST.anonymous_function_body_return retval = new CSharp4AST.anonymous_function_body_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.expression_return expression389 =null;

        CSharp4AST.block_return block390 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:881:2: ( expression | block )
            int alt78=2;
            int LA78_0 = input.LA(1);

            if ( (LA78_0==AMP||(LA78_0 >= BANG && LA78_0 <= BASE)||LA78_0==BOOL||LA78_0==BYTE||(LA78_0 >= CHAR && LA78_0 <= CHECKED)||LA78_0==DECIMAL||(LA78_0 >= DEFAULT && LA78_0 <= DELEGATE)||LA78_0==DOUBLE||LA78_0==FALSE||LA78_0==FLOAT||LA78_0==IDENTIFIER||(LA78_0 >= INT && LA78_0 <= INTEGER_LITERAL)||LA78_0==LONG||LA78_0==MINUS||LA78_0==NEW||LA78_0==NULL||LA78_0==OBJECT||LA78_0==OPEN_PARENS||LA78_0==OP_DEC||LA78_0==OP_INC||LA78_0==PLUS||LA78_0==REAL_LITERAL||LA78_0==SBYTE||LA78_0==SHORT||LA78_0==SIZEOF||LA78_0==STAR||(LA78_0 >= STRING && LA78_0 <= STRING_LITERAL)||LA78_0==THIS||(LA78_0 >= TILDE && LA78_0 <= TRUE)||LA78_0==TYPEOF||(LA78_0 >= UINT && LA78_0 <= UNCHECKED)||LA78_0==USHORT) ) {
                alt78=1;
            }
            else if ( (LA78_0==OPEN_BRACE) ) {
                alt78=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 78, 0, input);

                throw nvae;

            }
            switch (alt78) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:881:4: expression
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_expression_in_anonymous_function_body4337);
                    expression389=expression();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, expression389.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:882:4: block
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_block_in_anonymous_function_body4342);
                    block390=block();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, block390.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "anonymous_function_body"


    public static class query_expression_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "query_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:885:1: query_expression : from_clause query_body ;
    public final CSharp4AST.query_expression_return query_expression() throws RecognitionException {
        CSharp4AST.query_expression_return retval = new CSharp4AST.query_expression_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.from_clause_return from_clause391 =null;

        CSharp4AST.query_body_return query_body392 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:886:2: ( from_clause query_body )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:886:4: from_clause query_body
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_from_clause_in_query_expression4355);
            from_clause391=from_clause();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, from_clause391.getTree());

            pushFollow(FOLLOW_query_body_in_query_expression4357);
            query_body392=query_body();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, query_body392.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "query_expression"


    public static class from_clause_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "from_clause"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:888:1: from_clause : from_contextual_keyword ( ( type IDENTIFIER IN )=> type )? IDENTIFIER IN expression ;
    public final CSharp4AST.from_clause_return from_clause() throws RecognitionException {
        CSharp4AST.from_clause_return retval = new CSharp4AST.from_clause_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER395=null;
        Token IN396=null;
        CSharp4AST.from_contextual_keyword_return from_contextual_keyword393 =null;

        CSharp4AST.type_return type394 =null;

        CSharp4AST.expression_return expression397 =null;


        Object IDENTIFIER395_tree=null;
        Object IN396_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:889:2: ( from_contextual_keyword ( ( type IDENTIFIER IN )=> type )? IDENTIFIER IN expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:889:4: from_contextual_keyword ( ( type IDENTIFIER IN )=> type )? IDENTIFIER IN expression
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_from_contextual_keyword_in_from_clause4368);
            from_contextual_keyword393=from_contextual_keyword();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, from_contextual_keyword393.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:889:28: ( ( type IDENTIFIER IN )=> type )?
            int alt79=2;
            int LA79_0 = input.LA(1);

            if ( (LA79_0==BYTE||LA79_0==CHAR||LA79_0==INT||LA79_0==LONG||LA79_0==SBYTE||LA79_0==SHORT||(LA79_0 >= UINT && LA79_0 <= ULONG)||LA79_0==USHORT) && (synpred9_CSharp4AST())) {
                alt79=1;
            }
            else if ( (LA79_0==DOUBLE||LA79_0==FLOAT) && (synpred9_CSharp4AST())) {
                alt79=1;
            }
            else if ( (LA79_0==DECIMAL) && (synpred9_CSharp4AST())) {
                alt79=1;
            }
            else if ( (LA79_0==BOOL) && (synpred9_CSharp4AST())) {
                alt79=1;
            }
            else if ( (LA79_0==IDENTIFIER) ) {
                int LA79_5 = input.LA(2);

                if ( (LA79_5==DOUBLE_COLON) && (synpred9_CSharp4AST())) {
                    alt79=1;
                }
                else if ( (LA79_5==LT) && (synpred9_CSharp4AST())) {
                    alt79=1;
                }
                else if ( (LA79_5==DOT) && (synpred9_CSharp4AST())) {
                    alt79=1;
                }
                else if ( (LA79_5==INTERR) && (synpred9_CSharp4AST())) {
                    alt79=1;
                }
                else if ( (LA79_5==OPEN_BRACKET) && (synpred9_CSharp4AST())) {
                    alt79=1;
                }
                else if ( (LA79_5==STAR) && (synpred9_CSharp4AST())) {
                    alt79=1;
                }
                else if ( (LA79_5==IDENTIFIER) && (synpred9_CSharp4AST())) {
                    alt79=1;
                }
            }
            else if ( (LA79_0==OBJECT) && (synpred9_CSharp4AST())) {
                alt79=1;
            }
            else if ( (LA79_0==STRING) && (synpred9_CSharp4AST())) {
                alt79=1;
            }
            else if ( (LA79_0==VOID) && (synpred9_CSharp4AST())) {
                alt79=1;
            }
            switch (alt79) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:889:29: ( type IDENTIFIER IN )=> type
                    {
                    pushFollow(FOLLOW_type_in_from_clause4381);
                    type394=type();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, type394.getTree());

                    }
                    break;

            }


            IDENTIFIER395=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_from_clause4385); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER395_tree = 
            (Object)adaptor.create(IDENTIFIER395)
            ;
            adaptor.addChild(root_0, IDENTIFIER395_tree);
            }

            IN396=(Token)match(input,IN,FOLLOW_IN_in_from_clause4387); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IN396_tree = 
            (Object)adaptor.create(IN396)
            ;
            adaptor.addChild(root_0, IN396_tree);
            }

            pushFollow(FOLLOW_expression_in_from_clause4389);
            expression397=expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, expression397.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "from_clause"


    public static class query_body_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "query_body"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:896:1: query_body : ( query_body_clauses )? select_or_group_clause ( ( into_contextual_keyword )=> query_continuation )? ;
    public final CSharp4AST.query_body_return query_body() throws RecognitionException {
        CSharp4AST.query_body_return retval = new CSharp4AST.query_body_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.query_body_clauses_return query_body_clauses398 =null;

        CSharp4AST.select_or_group_clause_return select_or_group_clause399 =null;

        CSharp4AST.query_continuation_return query_continuation400 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:897:3: ( ( query_body_clauses )? select_or_group_clause ( ( into_contextual_keyword )=> query_continuation )? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:897:5: ( query_body_clauses )? select_or_group_clause ( ( into_contextual_keyword )=> query_continuation )?
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:897:5: ( query_body_clauses )?
            int alt80=2;
            int LA80_0 = input.LA(1);

            if ( (LA80_0==IDENTIFIER) ) {
                int LA80_1 = input.LA(2);

                if ( (((input.LT(1).getText().equals("where"))||(input.LT(1).getText().equals("orderby"))||(input.LT(1).getText().equals("let"))||(input.LT(1).getText().equals("join"))||(input.LT(1).getText().equals("from")))) ) {
                    alt80=1;
                }
            }
            switch (alt80) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:897:5: query_body_clauses
                    {
                    pushFollow(FOLLOW_query_body_clauses_in_query_body4403);
                    query_body_clauses398=query_body_clauses();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, query_body_clauses398.getTree());

                    }
                    break;

            }


            pushFollow(FOLLOW_select_or_group_clause_in_query_body4406);
            select_or_group_clause399=select_or_group_clause();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, select_or_group_clause399.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:897:48: ( ( into_contextual_keyword )=> query_continuation )?
            int alt81=2;
            int LA81_0 = input.LA(1);

            if ( (LA81_0==IDENTIFIER) ) {
                int LA81_1 = input.LA(2);

                if ( (((synpred10_CSharp4AST()&&synpred10_CSharp4AST())&&(input.LT(1).getText().equals("into")))) ) {
                    alt81=1;
                }
            }
            switch (alt81) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:897:49: ( into_contextual_keyword )=> query_continuation
                    {
                    pushFollow(FOLLOW_query_continuation_in_query_body4415);
                    query_continuation400=query_continuation();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, query_continuation400.getTree());

                    }
                    break;

            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "query_body"


    public static class query_body_clauses_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "query_body_clauses"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:899:1: query_body_clauses : query_body_clause ( query_body_clause )* ;
    public final CSharp4AST.query_body_clauses_return query_body_clauses() throws RecognitionException {
        CSharp4AST.query_body_clauses_return retval = new CSharp4AST.query_body_clauses_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.query_body_clause_return query_body_clause401 =null;

        CSharp4AST.query_body_clause_return query_body_clause402 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:900:2: ( query_body_clause ( query_body_clause )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:900:4: query_body_clause ( query_body_clause )*
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_query_body_clause_in_query_body_clauses4429);
            query_body_clause401=query_body_clause();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, query_body_clause401.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:900:22: ( query_body_clause )*
            loop82:
            do {
                int alt82=2;
                int LA82_0 = input.LA(1);

                if ( (LA82_0==IDENTIFIER) ) {
                    int LA82_1 = input.LA(2);

                    if ( (((input.LT(1).getText().equals("where"))||(input.LT(1).getText().equals("orderby"))||(input.LT(1).getText().equals("let"))||(input.LT(1).getText().equals("join"))||(input.LT(1).getText().equals("from")))) ) {
                        alt82=1;
                    }


                }


                switch (alt82) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:900:24: query_body_clause
            	    {
            	    pushFollow(FOLLOW_query_body_clause_in_query_body_clauses4433);
            	    query_body_clause402=query_body_clause();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, query_body_clause402.getTree());

            	    }
            	    break;

            	default :
            	    break loop82;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "query_body_clauses"


    public static class query_body_clause_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "query_body_clause"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:912:1: query_body_clause : ( from_clause | let_clause | where_clause | combined_join_clause | orderby_clause );
    public final CSharp4AST.query_body_clause_return query_body_clause() throws RecognitionException {
        CSharp4AST.query_body_clause_return retval = new CSharp4AST.query_body_clause_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.from_clause_return from_clause403 =null;

        CSharp4AST.let_clause_return let_clause404 =null;

        CSharp4AST.where_clause_return where_clause405 =null;

        CSharp4AST.combined_join_clause_return combined_join_clause406 =null;

        CSharp4AST.orderby_clause_return orderby_clause407 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:913:3: ( from_clause | let_clause | where_clause | combined_join_clause | orderby_clause )
            int alt83=5;
            int LA83_0 = input.LA(1);

            if ( (LA83_0==IDENTIFIER) ) {
                int LA83_1 = input.LA(2);

                if ( ((input.LT(1).getText().equals("from"))) ) {
                    alt83=1;
                }
                else if ( ((input.LT(1).getText().equals("let"))) ) {
                    alt83=2;
                }
                else if ( ((input.LT(1).getText().equals("where"))) ) {
                    alt83=3;
                }
                else if ( ((input.LT(1).getText().equals("join"))) ) {
                    alt83=4;
                }
                else if ( ((input.LT(1).getText().equals("orderby"))) ) {
                    alt83=5;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 83, 1, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 83, 0, input);

                throw nvae;

            }
            switch (alt83) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:913:5: from_clause
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_from_clause_in_query_body_clause4450);
                    from_clause403=from_clause();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, from_clause403.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:914:5: let_clause
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_let_clause_in_query_body_clause4456);
                    let_clause404=let_clause();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, let_clause404.getTree());

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:915:5: where_clause
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_where_clause_in_query_body_clause4462);
                    where_clause405=where_clause();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, where_clause405.getTree());

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:916:5: combined_join_clause
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_combined_join_clause_in_query_body_clause4468);
                    combined_join_clause406=combined_join_clause();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, combined_join_clause406.getTree());

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:917:5: orderby_clause
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_orderby_clause_in_query_body_clause4474);
                    orderby_clause407=orderby_clause();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, orderby_clause407.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "query_body_clause"


    public static class let_clause_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "let_clause"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:919:1: let_clause : let_contextual_keyword IDENTIFIER ASSIGNMENT expression ;
    public final CSharp4AST.let_clause_return let_clause() throws RecognitionException {
        CSharp4AST.let_clause_return retval = new CSharp4AST.let_clause_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER409=null;
        Token ASSIGNMENT410=null;
        CSharp4AST.let_contextual_keyword_return let_contextual_keyword408 =null;

        CSharp4AST.expression_return expression411 =null;


        Object IDENTIFIER409_tree=null;
        Object ASSIGNMENT410_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:920:2: ( let_contextual_keyword IDENTIFIER ASSIGNMENT expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:920:4: let_contextual_keyword IDENTIFIER ASSIGNMENT expression
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_let_contextual_keyword_in_let_clause4486);
            let_contextual_keyword408=let_contextual_keyword();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, let_contextual_keyword408.getTree());

            IDENTIFIER409=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_let_clause4488); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER409_tree = 
            (Object)adaptor.create(IDENTIFIER409)
            ;
            adaptor.addChild(root_0, IDENTIFIER409_tree);
            }

            ASSIGNMENT410=(Token)match(input,ASSIGNMENT,FOLLOW_ASSIGNMENT_in_let_clause4490); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            ASSIGNMENT410_tree = 
            (Object)adaptor.create(ASSIGNMENT410)
            ;
            adaptor.addChild(root_0, ASSIGNMENT410_tree);
            }

            pushFollow(FOLLOW_expression_in_let_clause4492);
            expression411=expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, expression411.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "let_clause"


    public static class where_clause_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "where_clause"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:922:1: where_clause : where_contextual_keyword boolean_expression ;
    public final CSharp4AST.where_clause_return where_clause() throws RecognitionException {
        CSharp4AST.where_clause_return retval = new CSharp4AST.where_clause_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.where_contextual_keyword_return where_contextual_keyword412 =null;

        CSharp4AST.boolean_expression_return boolean_expression413 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:923:2: ( where_contextual_keyword boolean_expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:923:4: where_contextual_keyword boolean_expression
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_where_contextual_keyword_in_where_clause4503);
            where_contextual_keyword412=where_contextual_keyword();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, where_contextual_keyword412.getTree());

            pushFollow(FOLLOW_boolean_expression_in_where_clause4505);
            boolean_expression413=boolean_expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, boolean_expression413.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "where_clause"


    public static class join_clause_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "join_clause"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:925:1: join_clause : join_contextual_keyword ( type )? IDENTIFIER IN expression on_contextual_keyword expression equals_contextual_keyword expression ;
    public final CSharp4AST.join_clause_return join_clause() throws RecognitionException {
        CSharp4AST.join_clause_return retval = new CSharp4AST.join_clause_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER416=null;
        Token IN417=null;
        CSharp4AST.join_contextual_keyword_return join_contextual_keyword414 =null;

        CSharp4AST.type_return type415 =null;

        CSharp4AST.expression_return expression418 =null;

        CSharp4AST.on_contextual_keyword_return on_contextual_keyword419 =null;

        CSharp4AST.expression_return expression420 =null;

        CSharp4AST.equals_contextual_keyword_return equals_contextual_keyword421 =null;

        CSharp4AST.expression_return expression422 =null;


        Object IDENTIFIER416_tree=null;
        Object IN417_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:926:2: ( join_contextual_keyword ( type )? IDENTIFIER IN expression on_contextual_keyword expression equals_contextual_keyword expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:926:4: join_contextual_keyword ( type )? IDENTIFIER IN expression on_contextual_keyword expression equals_contextual_keyword expression
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_join_contextual_keyword_in_join_clause4516);
            join_contextual_keyword414=join_contextual_keyword();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, join_contextual_keyword414.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:926:28: ( type )?
            int alt84=2;
            int LA84_0 = input.LA(1);

            if ( (LA84_0==BOOL||LA84_0==BYTE||LA84_0==CHAR||LA84_0==DECIMAL||LA84_0==DOUBLE||LA84_0==FLOAT||LA84_0==INT||LA84_0==LONG||LA84_0==OBJECT||LA84_0==SBYTE||LA84_0==SHORT||LA84_0==STRING||(LA84_0 >= UINT && LA84_0 <= ULONG)||LA84_0==USHORT||LA84_0==VOID) ) {
                alt84=1;
            }
            else if ( (LA84_0==IDENTIFIER) ) {
                int LA84_2 = input.LA(2);

                if ( (LA84_2==DOT||LA84_2==DOUBLE_COLON||LA84_2==IDENTIFIER||LA84_2==INTERR||LA84_2==LT||LA84_2==OPEN_BRACKET||LA84_2==STAR) ) {
                    alt84=1;
                }
            }
            switch (alt84) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:926:28: type
                    {
                    pushFollow(FOLLOW_type_in_join_clause4518);
                    type415=type();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, type415.getTree());

                    }
                    break;

            }


            IDENTIFIER416=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_join_clause4521); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER416_tree = 
            (Object)adaptor.create(IDENTIFIER416)
            ;
            adaptor.addChild(root_0, IDENTIFIER416_tree);
            }

            IN417=(Token)match(input,IN,FOLLOW_IN_in_join_clause4523); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IN417_tree = 
            (Object)adaptor.create(IN417)
            ;
            adaptor.addChild(root_0, IN417_tree);
            }

            pushFollow(FOLLOW_expression_in_join_clause4525);
            expression418=expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, expression418.getTree());

            pushFollow(FOLLOW_on_contextual_keyword_in_join_clause4527);
            on_contextual_keyword419=on_contextual_keyword();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, on_contextual_keyword419.getTree());

            pushFollow(FOLLOW_expression_in_join_clause4529);
            expression420=expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, expression420.getTree());

            pushFollow(FOLLOW_equals_contextual_keyword_in_join_clause4531);
            equals_contextual_keyword421=equals_contextual_keyword();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, equals_contextual_keyword421.getTree());

            pushFollow(FOLLOW_expression_in_join_clause4533);
            expression422=expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, expression422.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "join_clause"


    public static class join_into_clause_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "join_into_clause"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:928:1: join_into_clause : join_contextual_keyword ( type )? IDENTIFIER IN expression on_contextual_keyword expression equals_contextual_keyword expression into_contextual_keyword IDENTIFIER ;
    public final CSharp4AST.join_into_clause_return join_into_clause() throws RecognitionException {
        CSharp4AST.join_into_clause_return retval = new CSharp4AST.join_into_clause_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER425=null;
        Token IN426=null;
        Token IDENTIFIER433=null;
        CSharp4AST.join_contextual_keyword_return join_contextual_keyword423 =null;

        CSharp4AST.type_return type424 =null;

        CSharp4AST.expression_return expression427 =null;

        CSharp4AST.on_contextual_keyword_return on_contextual_keyword428 =null;

        CSharp4AST.expression_return expression429 =null;

        CSharp4AST.equals_contextual_keyword_return equals_contextual_keyword430 =null;

        CSharp4AST.expression_return expression431 =null;

        CSharp4AST.into_contextual_keyword_return into_contextual_keyword432 =null;


        Object IDENTIFIER425_tree=null;
        Object IN426_tree=null;
        Object IDENTIFIER433_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:929:2: ( join_contextual_keyword ( type )? IDENTIFIER IN expression on_contextual_keyword expression equals_contextual_keyword expression into_contextual_keyword IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:929:4: join_contextual_keyword ( type )? IDENTIFIER IN expression on_contextual_keyword expression equals_contextual_keyword expression into_contextual_keyword IDENTIFIER
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_join_contextual_keyword_in_join_into_clause4544);
            join_contextual_keyword423=join_contextual_keyword();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, join_contextual_keyword423.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:929:28: ( type )?
            int alt85=2;
            int LA85_0 = input.LA(1);

            if ( (LA85_0==BOOL||LA85_0==BYTE||LA85_0==CHAR||LA85_0==DECIMAL||LA85_0==DOUBLE||LA85_0==FLOAT||LA85_0==INT||LA85_0==LONG||LA85_0==OBJECT||LA85_0==SBYTE||LA85_0==SHORT||LA85_0==STRING||(LA85_0 >= UINT && LA85_0 <= ULONG)||LA85_0==USHORT||LA85_0==VOID) ) {
                alt85=1;
            }
            else if ( (LA85_0==IDENTIFIER) ) {
                int LA85_2 = input.LA(2);

                if ( (LA85_2==DOT||LA85_2==DOUBLE_COLON||LA85_2==IDENTIFIER||LA85_2==INTERR||LA85_2==LT||LA85_2==OPEN_BRACKET||LA85_2==STAR) ) {
                    alt85=1;
                }
            }
            switch (alt85) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:929:28: type
                    {
                    pushFollow(FOLLOW_type_in_join_into_clause4546);
                    type424=type();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, type424.getTree());

                    }
                    break;

            }


            IDENTIFIER425=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_join_into_clause4549); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER425_tree = 
            (Object)adaptor.create(IDENTIFIER425)
            ;
            adaptor.addChild(root_0, IDENTIFIER425_tree);
            }

            IN426=(Token)match(input,IN,FOLLOW_IN_in_join_into_clause4551); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IN426_tree = 
            (Object)adaptor.create(IN426)
            ;
            adaptor.addChild(root_0, IN426_tree);
            }

            pushFollow(FOLLOW_expression_in_join_into_clause4553);
            expression427=expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, expression427.getTree());

            pushFollow(FOLLOW_on_contextual_keyword_in_join_into_clause4555);
            on_contextual_keyword428=on_contextual_keyword();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, on_contextual_keyword428.getTree());

            pushFollow(FOLLOW_expression_in_join_into_clause4557);
            expression429=expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, expression429.getTree());

            pushFollow(FOLLOW_equals_contextual_keyword_in_join_into_clause4559);
            equals_contextual_keyword430=equals_contextual_keyword();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, equals_contextual_keyword430.getTree());

            pushFollow(FOLLOW_expression_in_join_into_clause4561);
            expression431=expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, expression431.getTree());

            pushFollow(FOLLOW_into_contextual_keyword_in_join_into_clause4563);
            into_contextual_keyword432=into_contextual_keyword();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, into_contextual_keyword432.getTree());

            IDENTIFIER433=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_join_into_clause4565); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER433_tree = 
            (Object)adaptor.create(IDENTIFIER433)
            ;
            adaptor.addChild(root_0, IDENTIFIER433_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "join_into_clause"


    public static class combined_join_clause_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "combined_join_clause"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:932:1: combined_join_clause : join_contextual_keyword ( type )? IDENTIFIER IN expression on_contextual_keyword expression equals_contextual_keyword expression ( into_contextual_keyword IDENTIFIER )? ;
    public final CSharp4AST.combined_join_clause_return combined_join_clause() throws RecognitionException {
        CSharp4AST.combined_join_clause_return retval = new CSharp4AST.combined_join_clause_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER436=null;
        Token IN437=null;
        Token IDENTIFIER444=null;
        CSharp4AST.join_contextual_keyword_return join_contextual_keyword434 =null;

        CSharp4AST.type_return type435 =null;

        CSharp4AST.expression_return expression438 =null;

        CSharp4AST.on_contextual_keyword_return on_contextual_keyword439 =null;

        CSharp4AST.expression_return expression440 =null;

        CSharp4AST.equals_contextual_keyword_return equals_contextual_keyword441 =null;

        CSharp4AST.expression_return expression442 =null;

        CSharp4AST.into_contextual_keyword_return into_contextual_keyword443 =null;


        Object IDENTIFIER436_tree=null;
        Object IN437_tree=null;
        Object IDENTIFIER444_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:933:3: ( join_contextual_keyword ( type )? IDENTIFIER IN expression on_contextual_keyword expression equals_contextual_keyword expression ( into_contextual_keyword IDENTIFIER )? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:933:5: join_contextual_keyword ( type )? IDENTIFIER IN expression on_contextual_keyword expression equals_contextual_keyword expression ( into_contextual_keyword IDENTIFIER )?
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_join_contextual_keyword_in_combined_join_clause4577);
            join_contextual_keyword434=join_contextual_keyword();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, join_contextual_keyword434.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:933:29: ( type )?
            int alt86=2;
            int LA86_0 = input.LA(1);

            if ( (LA86_0==BOOL||LA86_0==BYTE||LA86_0==CHAR||LA86_0==DECIMAL||LA86_0==DOUBLE||LA86_0==FLOAT||LA86_0==INT||LA86_0==LONG||LA86_0==OBJECT||LA86_0==SBYTE||LA86_0==SHORT||LA86_0==STRING||(LA86_0 >= UINT && LA86_0 <= ULONG)||LA86_0==USHORT||LA86_0==VOID) ) {
                alt86=1;
            }
            else if ( (LA86_0==IDENTIFIER) ) {
                int LA86_2 = input.LA(2);

                if ( (LA86_2==DOT||LA86_2==DOUBLE_COLON||LA86_2==IDENTIFIER||LA86_2==INTERR||LA86_2==LT||LA86_2==OPEN_BRACKET||LA86_2==STAR) ) {
                    alt86=1;
                }
            }
            switch (alt86) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:933:29: type
                    {
                    pushFollow(FOLLOW_type_in_combined_join_clause4579);
                    type435=type();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, type435.getTree());

                    }
                    break;

            }


            IDENTIFIER436=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_combined_join_clause4582); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER436_tree = 
            (Object)adaptor.create(IDENTIFIER436)
            ;
            adaptor.addChild(root_0, IDENTIFIER436_tree);
            }

            IN437=(Token)match(input,IN,FOLLOW_IN_in_combined_join_clause4584); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IN437_tree = 
            (Object)adaptor.create(IN437)
            ;
            adaptor.addChild(root_0, IN437_tree);
            }

            pushFollow(FOLLOW_expression_in_combined_join_clause4586);
            expression438=expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, expression438.getTree());

            pushFollow(FOLLOW_on_contextual_keyword_in_combined_join_clause4588);
            on_contextual_keyword439=on_contextual_keyword();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, on_contextual_keyword439.getTree());

            pushFollow(FOLLOW_expression_in_combined_join_clause4590);
            expression440=expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, expression440.getTree());

            pushFollow(FOLLOW_equals_contextual_keyword_in_combined_join_clause4592);
            equals_contextual_keyword441=equals_contextual_keyword();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, equals_contextual_keyword441.getTree());

            pushFollow(FOLLOW_expression_in_combined_join_clause4594);
            expression442=expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, expression442.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:933:130: ( into_contextual_keyword IDENTIFIER )?
            int alt87=2;
            int LA87_0 = input.LA(1);

            if ( (LA87_0==IDENTIFIER) ) {
                int LA87_1 = input.LA(2);

                if ( (LA87_1==IDENTIFIER) ) {
                    int LA87_2 = input.LA(3);

                    if ( ((input.LT(1).getText().equals("into"))) ) {
                        alt87=1;
                    }
                }
            }
            switch (alt87) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:933:131: into_contextual_keyword IDENTIFIER
                    {
                    pushFollow(FOLLOW_into_contextual_keyword_in_combined_join_clause4597);
                    into_contextual_keyword443=into_contextual_keyword();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, into_contextual_keyword443.getTree());

                    IDENTIFIER444=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_combined_join_clause4599); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    IDENTIFIER444_tree = 
                    (Object)adaptor.create(IDENTIFIER444)
                    ;
                    adaptor.addChild(root_0, IDENTIFIER444_tree);
                    }

                    }
                    break;

            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "combined_join_clause"


    public static class orderby_clause_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "orderby_clause"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:935:1: orderby_clause : orderby_contextual_keyword orderings ;
    public final CSharp4AST.orderby_clause_return orderby_clause() throws RecognitionException {
        CSharp4AST.orderby_clause_return retval = new CSharp4AST.orderby_clause_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.orderby_contextual_keyword_return orderby_contextual_keyword445 =null;

        CSharp4AST.orderings_return orderings446 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:936:2: ( orderby_contextual_keyword orderings )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:936:4: orderby_contextual_keyword orderings
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_orderby_contextual_keyword_in_orderby_clause4613);
            orderby_contextual_keyword445=orderby_contextual_keyword();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, orderby_contextual_keyword445.getTree());

            pushFollow(FOLLOW_orderings_in_orderby_clause4615);
            orderings446=orderings();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, orderings446.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "orderby_clause"


    public static class orderings_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "orderings"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:938:1: orderings : ordering ( COMMA ordering )* ;
    public final CSharp4AST.orderings_return orderings() throws RecognitionException {
        CSharp4AST.orderings_return retval = new CSharp4AST.orderings_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token COMMA448=null;
        CSharp4AST.ordering_return ordering447 =null;

        CSharp4AST.ordering_return ordering449 =null;


        Object COMMA448_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:939:2: ( ordering ( COMMA ordering )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:939:4: ordering ( COMMA ordering )*
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_ordering_in_orderings4626);
            ordering447=ordering();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, ordering447.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:939:13: ( COMMA ordering )*
            loop88:
            do {
                int alt88=2;
                int LA88_0 = input.LA(1);

                if ( (LA88_0==COMMA) ) {
                    alt88=1;
                }


                switch (alt88) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:939:15: COMMA ordering
            	    {
            	    COMMA448=(Token)match(input,COMMA,FOLLOW_COMMA_in_orderings4630); if (state.failed) return retval;
            	    if ( state.backtracking==0 ) {
            	    COMMA448_tree = 
            	    (Object)adaptor.create(COMMA448)
            	    ;
            	    adaptor.addChild(root_0, COMMA448_tree);
            	    }

            	    pushFollow(FOLLOW_ordering_in_orderings4633);
            	    ordering449=ordering();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, ordering449.getTree());

            	    }
            	    break;

            	default :
            	    break loop88;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "orderings"


    public static class ordering_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "ordering"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:941:1: ordering : expression ( ordering_direction )? ;
    public final CSharp4AST.ordering_return ordering() throws RecognitionException {
        CSharp4AST.ordering_return retval = new CSharp4AST.ordering_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.expression_return expression450 =null;

        CSharp4AST.ordering_direction_return ordering_direction451 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:942:2: ( expression ( ordering_direction )? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:942:4: expression ( ordering_direction )?
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_expression_in_ordering4647);
            expression450=expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, expression450.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:942:15: ( ordering_direction )?
            int alt89=2;
            int LA89_0 = input.LA(1);

            if ( (LA89_0==IDENTIFIER) ) {
                int LA89_1 = input.LA(2);

                if ( (LA89_1==COMMA) ) {
                    alt89=1;
                }
                else if ( (LA89_1==IDENTIFIER) ) {
                    int LA89_4 = input.LA(3);

                    if ( (((input.LT(1).getText().equals("ascending"))||(input.LT(1).getText().equals("descending")))) ) {
                        alt89=1;
                    }
                }
            }
            switch (alt89) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:942:15: ordering_direction
                    {
                    pushFollow(FOLLOW_ordering_direction_in_ordering4649);
                    ordering_direction451=ordering_direction();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, ordering_direction451.getTree());

                    }
                    break;

            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "ordering"


    public static class ordering_direction_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "ordering_direction"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:944:1: ordering_direction : ( ascending_contextual_keyword | descending_contextual_keyword );
    public final CSharp4AST.ordering_direction_return ordering_direction() throws RecognitionException {
        CSharp4AST.ordering_direction_return retval = new CSharp4AST.ordering_direction_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.ascending_contextual_keyword_return ascending_contextual_keyword452 =null;

        CSharp4AST.descending_contextual_keyword_return descending_contextual_keyword453 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:945:2: ( ascending_contextual_keyword | descending_contextual_keyword )
            int alt90=2;
            int LA90_0 = input.LA(1);

            if ( (LA90_0==IDENTIFIER) ) {
                int LA90_1 = input.LA(2);

                if ( ((input.LT(1).getText().equals("ascending"))) ) {
                    alt90=1;
                }
                else if ( ((input.LT(1).getText().equals("descending"))) ) {
                    alt90=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 90, 1, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 90, 0, input);

                throw nvae;

            }
            switch (alt90) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:945:4: ascending_contextual_keyword
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_ascending_contextual_keyword_in_ordering_direction4661);
                    ascending_contextual_keyword452=ascending_contextual_keyword();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, ascending_contextual_keyword452.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:946:4: descending_contextual_keyword
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_descending_contextual_keyword_in_ordering_direction4666);
                    descending_contextual_keyword453=descending_contextual_keyword();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, descending_contextual_keyword453.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "ordering_direction"


    public static class select_or_group_clause_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "select_or_group_clause"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:948:1: select_or_group_clause : ( select_clause | group_clause );
    public final CSharp4AST.select_or_group_clause_return select_or_group_clause() throws RecognitionException {
        CSharp4AST.select_or_group_clause_return retval = new CSharp4AST.select_or_group_clause_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.select_clause_return select_clause454 =null;

        CSharp4AST.group_clause_return group_clause455 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:949:2: ( select_clause | group_clause )
            int alt91=2;
            int LA91_0 = input.LA(1);

            if ( (LA91_0==IDENTIFIER) ) {
                int LA91_1 = input.LA(2);

                if ( ((input.LT(1).getText().equals("select"))) ) {
                    alt91=1;
                }
                else if ( ((input.LT(1).getText().equals("group"))) ) {
                    alt91=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 91, 1, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 91, 0, input);

                throw nvae;

            }
            switch (alt91) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:949:4: select_clause
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_select_clause_in_select_or_group_clause4677);
                    select_clause454=select_clause();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, select_clause454.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:950:4: group_clause
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_group_clause_in_select_or_group_clause4682);
                    group_clause455=group_clause();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, group_clause455.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "select_or_group_clause"


    public static class select_clause_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "select_clause"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:952:1: select_clause : select_contextual_keyword expression ;
    public final CSharp4AST.select_clause_return select_clause() throws RecognitionException {
        CSharp4AST.select_clause_return retval = new CSharp4AST.select_clause_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.select_contextual_keyword_return select_contextual_keyword456 =null;

        CSharp4AST.expression_return expression457 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:953:2: ( select_contextual_keyword expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:953:4: select_contextual_keyword expression
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_select_contextual_keyword_in_select_clause4693);
            select_contextual_keyword456=select_contextual_keyword();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, select_contextual_keyword456.getTree());

            pushFollow(FOLLOW_expression_in_select_clause4695);
            expression457=expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, expression457.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "select_clause"


    public static class group_clause_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "group_clause"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:955:1: group_clause : group_contextual_keyword expression by_contextual_keyword expression ;
    public final CSharp4AST.group_clause_return group_clause() throws RecognitionException {
        CSharp4AST.group_clause_return retval = new CSharp4AST.group_clause_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.group_contextual_keyword_return group_contextual_keyword458 =null;

        CSharp4AST.expression_return expression459 =null;

        CSharp4AST.by_contextual_keyword_return by_contextual_keyword460 =null;

        CSharp4AST.expression_return expression461 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:956:2: ( group_contextual_keyword expression by_contextual_keyword expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:956:4: group_contextual_keyword expression by_contextual_keyword expression
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_group_contextual_keyword_in_group_clause4706);
            group_contextual_keyword458=group_contextual_keyword();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, group_contextual_keyword458.getTree());

            pushFollow(FOLLOW_expression_in_group_clause4708);
            expression459=expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, expression459.getTree());

            pushFollow(FOLLOW_by_contextual_keyword_in_group_clause4710);
            by_contextual_keyword460=by_contextual_keyword();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, by_contextual_keyword460.getTree());

            pushFollow(FOLLOW_expression_in_group_clause4712);
            expression461=expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, expression461.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "group_clause"


    public static class query_continuation_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "query_continuation"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:959:1: query_continuation : into_contextual_keyword IDENTIFIER query_body ;
    public final CSharp4AST.query_continuation_return query_continuation() throws RecognitionException {
        CSharp4AST.query_continuation_return retval = new CSharp4AST.query_continuation_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER463=null;
        CSharp4AST.into_contextual_keyword_return into_contextual_keyword462 =null;

        CSharp4AST.query_body_return query_body464 =null;


        Object IDENTIFIER463_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:960:2: ( into_contextual_keyword IDENTIFIER query_body )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:960:4: into_contextual_keyword IDENTIFIER query_body
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_into_contextual_keyword_in_query_continuation4725);
            into_contextual_keyword462=into_contextual_keyword();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, into_contextual_keyword462.getTree());

            IDENTIFIER463=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_query_continuation4727); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER463_tree = 
            (Object)adaptor.create(IDENTIFIER463)
            ;
            adaptor.addChild(root_0, IDENTIFIER463_tree);
            }

            pushFollow(FOLLOW_query_body_in_query_continuation4729);
            query_body464=query_body();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, query_body464.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "query_continuation"


    public static class assignment_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "assignment"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:963:1: assignment : unary_expression assignment_operator ^ expression ;
    public final CSharp4AST.assignment_return assignment() throws RecognitionException {
        CSharp4AST.assignment_return retval = new CSharp4AST.assignment_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.unary_expression_return unary_expression465 =null;

        CSharp4AST.assignment_operator_return assignment_operator466 =null;

        CSharp4AST.expression_return expression467 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:964:2: ( unary_expression assignment_operator ^ expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:964:4: unary_expression assignment_operator ^ expression
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_unary_expression_in_assignment4742);
            unary_expression465=unary_expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, unary_expression465.getTree());

            pushFollow(FOLLOW_assignment_operator_in_assignment4744);
            assignment_operator466=assignment_operator();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(assignment_operator466.getTree(), root_0);

            pushFollow(FOLLOW_expression_in_assignment4747);
            expression467=expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, expression467.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "assignment"


    public static class assignment_operator_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "assignment_operator"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:966:1: assignment_operator : assignment_operator2 -> ^( ASSIGNMENT_OPERATOR assignment_operator2 ) ;
    public final CSharp4AST.assignment_operator_return assignment_operator() throws RecognitionException {
        CSharp4AST.assignment_operator_return retval = new CSharp4AST.assignment_operator_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.assignment_operator2_return assignment_operator2468 =null;


        RewriteRuleSubtreeStream stream_assignment_operator2=new RewriteRuleSubtreeStream(adaptor,"rule assignment_operator2");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:967:3: ( assignment_operator2 -> ^( ASSIGNMENT_OPERATOR assignment_operator2 ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:967:5: assignment_operator2
            {
            pushFollow(FOLLOW_assignment_operator2_in_assignment_operator4758);
            assignment_operator2468=assignment_operator2();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_assignment_operator2.add(assignment_operator2468.getTree());

            // AST REWRITE
            // elements: assignment_operator2
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 967:27: -> ^( ASSIGNMENT_OPERATOR assignment_operator2 )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:967:30: ^( ASSIGNMENT_OPERATOR assignment_operator2 )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(ASSIGNMENT_OPERATOR, "ASSIGNMENT_OPERATOR")
                , root_1);

                adaptor.addChild(root_1, stream_assignment_operator2.nextTree());

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "assignment_operator"


    public static class assignment_operator2_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "assignment_operator2"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:969:1: assignment_operator2 : ( ASSIGNMENT | OP_ADD_ASSIGNMENT | OP_SUB_ASSIGNMENT | OP_MULT_ASSIGNMENT | OP_DIV_ASSIGNMENT | OP_MOD_ASSIGNMENT | OP_AND_ASSIGNMENT | OP_OR_ASSIGNMENT | OP_XOR_ASSIGNMENT | OP_LEFT_SHIFT_ASSIGNMENT | right_shift_assignment );
    public final CSharp4AST.assignment_operator2_return assignment_operator2() throws RecognitionException {
        CSharp4AST.assignment_operator2_return retval = new CSharp4AST.assignment_operator2_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token ASSIGNMENT469=null;
        Token OP_ADD_ASSIGNMENT470=null;
        Token OP_SUB_ASSIGNMENT471=null;
        Token OP_MULT_ASSIGNMENT472=null;
        Token OP_DIV_ASSIGNMENT473=null;
        Token OP_MOD_ASSIGNMENT474=null;
        Token OP_AND_ASSIGNMENT475=null;
        Token OP_OR_ASSIGNMENT476=null;
        Token OP_XOR_ASSIGNMENT477=null;
        Token OP_LEFT_SHIFT_ASSIGNMENT478=null;
        CSharp4AST.right_shift_assignment_return right_shift_assignment479 =null;


        Object ASSIGNMENT469_tree=null;
        Object OP_ADD_ASSIGNMENT470_tree=null;
        Object OP_SUB_ASSIGNMENT471_tree=null;
        Object OP_MULT_ASSIGNMENT472_tree=null;
        Object OP_DIV_ASSIGNMENT473_tree=null;
        Object OP_MOD_ASSIGNMENT474_tree=null;
        Object OP_AND_ASSIGNMENT475_tree=null;
        Object OP_OR_ASSIGNMENT476_tree=null;
        Object OP_XOR_ASSIGNMENT477_tree=null;
        Object OP_LEFT_SHIFT_ASSIGNMENT478_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:970:2: ( ASSIGNMENT | OP_ADD_ASSIGNMENT | OP_SUB_ASSIGNMENT | OP_MULT_ASSIGNMENT | OP_DIV_ASSIGNMENT | OP_MOD_ASSIGNMENT | OP_AND_ASSIGNMENT | OP_OR_ASSIGNMENT | OP_XOR_ASSIGNMENT | OP_LEFT_SHIFT_ASSIGNMENT | right_shift_assignment )
            int alt92=11;
            switch ( input.LA(1) ) {
            case ASSIGNMENT:
                {
                alt92=1;
                }
                break;
            case OP_ADD_ASSIGNMENT:
                {
                alt92=2;
                }
                break;
            case OP_SUB_ASSIGNMENT:
                {
                alt92=3;
                }
                break;
            case OP_MULT_ASSIGNMENT:
                {
                alt92=4;
                }
                break;
            case OP_DIV_ASSIGNMENT:
                {
                alt92=5;
                }
                break;
            case OP_MOD_ASSIGNMENT:
                {
                alt92=6;
                }
                break;
            case OP_AND_ASSIGNMENT:
                {
                alt92=7;
                }
                break;
            case OP_OR_ASSIGNMENT:
                {
                alt92=8;
                }
                break;
            case OP_XOR_ASSIGNMENT:
                {
                alt92=9;
                }
                break;
            case OP_LEFT_SHIFT_ASSIGNMENT:
                {
                alt92=10;
                }
                break;
            case GT:
                {
                alt92=11;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 92, 0, input);

                throw nvae;

            }

            switch (alt92) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:970:4: ASSIGNMENT
                    {
                    root_0 = (Object)adaptor.nil();


                    ASSIGNMENT469=(Token)match(input,ASSIGNMENT,FOLLOW_ASSIGNMENT_in_assignment_operator24778); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    ASSIGNMENT469_tree = 
                    (Object)adaptor.create(ASSIGNMENT469)
                    ;
                    adaptor.addChild(root_0, ASSIGNMENT469_tree);
                    }

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:971:4: OP_ADD_ASSIGNMENT
                    {
                    root_0 = (Object)adaptor.nil();


                    OP_ADD_ASSIGNMENT470=(Token)match(input,OP_ADD_ASSIGNMENT,FOLLOW_OP_ADD_ASSIGNMENT_in_assignment_operator24783); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OP_ADD_ASSIGNMENT470_tree = 
                    (Object)adaptor.create(OP_ADD_ASSIGNMENT470)
                    ;
                    adaptor.addChild(root_0, OP_ADD_ASSIGNMENT470_tree);
                    }

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:972:4: OP_SUB_ASSIGNMENT
                    {
                    root_0 = (Object)adaptor.nil();


                    OP_SUB_ASSIGNMENT471=(Token)match(input,OP_SUB_ASSIGNMENT,FOLLOW_OP_SUB_ASSIGNMENT_in_assignment_operator24788); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OP_SUB_ASSIGNMENT471_tree = 
                    (Object)adaptor.create(OP_SUB_ASSIGNMENT471)
                    ;
                    adaptor.addChild(root_0, OP_SUB_ASSIGNMENT471_tree);
                    }

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:973:4: OP_MULT_ASSIGNMENT
                    {
                    root_0 = (Object)adaptor.nil();


                    OP_MULT_ASSIGNMENT472=(Token)match(input,OP_MULT_ASSIGNMENT,FOLLOW_OP_MULT_ASSIGNMENT_in_assignment_operator24793); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OP_MULT_ASSIGNMENT472_tree = 
                    (Object)adaptor.create(OP_MULT_ASSIGNMENT472)
                    ;
                    adaptor.addChild(root_0, OP_MULT_ASSIGNMENT472_tree);
                    }

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:974:4: OP_DIV_ASSIGNMENT
                    {
                    root_0 = (Object)adaptor.nil();


                    OP_DIV_ASSIGNMENT473=(Token)match(input,OP_DIV_ASSIGNMENT,FOLLOW_OP_DIV_ASSIGNMENT_in_assignment_operator24798); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OP_DIV_ASSIGNMENT473_tree = 
                    (Object)adaptor.create(OP_DIV_ASSIGNMENT473)
                    ;
                    adaptor.addChild(root_0, OP_DIV_ASSIGNMENT473_tree);
                    }

                    }
                    break;
                case 6 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:975:4: OP_MOD_ASSIGNMENT
                    {
                    root_0 = (Object)adaptor.nil();


                    OP_MOD_ASSIGNMENT474=(Token)match(input,OP_MOD_ASSIGNMENT,FOLLOW_OP_MOD_ASSIGNMENT_in_assignment_operator24803); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OP_MOD_ASSIGNMENT474_tree = 
                    (Object)adaptor.create(OP_MOD_ASSIGNMENT474)
                    ;
                    adaptor.addChild(root_0, OP_MOD_ASSIGNMENT474_tree);
                    }

                    }
                    break;
                case 7 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:976:4: OP_AND_ASSIGNMENT
                    {
                    root_0 = (Object)adaptor.nil();


                    OP_AND_ASSIGNMENT475=(Token)match(input,OP_AND_ASSIGNMENT,FOLLOW_OP_AND_ASSIGNMENT_in_assignment_operator24808); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OP_AND_ASSIGNMENT475_tree = 
                    (Object)adaptor.create(OP_AND_ASSIGNMENT475)
                    ;
                    adaptor.addChild(root_0, OP_AND_ASSIGNMENT475_tree);
                    }

                    }
                    break;
                case 8 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:977:4: OP_OR_ASSIGNMENT
                    {
                    root_0 = (Object)adaptor.nil();


                    OP_OR_ASSIGNMENT476=(Token)match(input,OP_OR_ASSIGNMENT,FOLLOW_OP_OR_ASSIGNMENT_in_assignment_operator24813); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OP_OR_ASSIGNMENT476_tree = 
                    (Object)adaptor.create(OP_OR_ASSIGNMENT476)
                    ;
                    adaptor.addChild(root_0, OP_OR_ASSIGNMENT476_tree);
                    }

                    }
                    break;
                case 9 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:978:4: OP_XOR_ASSIGNMENT
                    {
                    root_0 = (Object)adaptor.nil();


                    OP_XOR_ASSIGNMENT477=(Token)match(input,OP_XOR_ASSIGNMENT,FOLLOW_OP_XOR_ASSIGNMENT_in_assignment_operator24818); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OP_XOR_ASSIGNMENT477_tree = 
                    (Object)adaptor.create(OP_XOR_ASSIGNMENT477)
                    ;
                    adaptor.addChild(root_0, OP_XOR_ASSIGNMENT477_tree);
                    }

                    }
                    break;
                case 10 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:979:4: OP_LEFT_SHIFT_ASSIGNMENT
                    {
                    root_0 = (Object)adaptor.nil();


                    OP_LEFT_SHIFT_ASSIGNMENT478=(Token)match(input,OP_LEFT_SHIFT_ASSIGNMENT,FOLLOW_OP_LEFT_SHIFT_ASSIGNMENT_in_assignment_operator24823); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OP_LEFT_SHIFT_ASSIGNMENT478_tree = 
                    (Object)adaptor.create(OP_LEFT_SHIFT_ASSIGNMENT478)
                    ;
                    adaptor.addChild(root_0, OP_LEFT_SHIFT_ASSIGNMENT478_tree);
                    }

                    }
                    break;
                case 11 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:980:4: right_shift_assignment
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_right_shift_assignment_in_assignment_operator24828);
                    right_shift_assignment479=right_shift_assignment();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, right_shift_assignment479.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "assignment_operator2"


    public static class expression_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:982:1: expression : ( ( assignment )=>e1= assignment |e2= non_assignment_expression );
    public final CSharp4AST.expression_return expression() throws RecognitionException {
        CSharp4AST.expression_return retval = new CSharp4AST.expression_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.assignment_return e1 =null;

        CSharp4AST.non_assignment_expression_return e2 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:983:2: ( ( assignment )=>e1= assignment |e2= non_assignment_expression )
            int alt93=2;
            switch ( input.LA(1) ) {
            case OPEN_PARENS:
                {
                int LA93_1 = input.LA(2);

                if ( (synpred11_CSharp4AST()) ) {
                    alt93=1;
                }
                else if ( (true) ) {
                    alt93=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 93, 1, input);

                    throw nvae;

                }
                }
                break;
            case FALSE:
            case TRUE:
                {
                int LA93_2 = input.LA(2);

                if ( (synpred11_CSharp4AST()) ) {
                    alt93=1;
                }
                else if ( (true) ) {
                    alt93=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 93, 2, input);

                    throw nvae;

                }
                }
                break;
            case INTEGER_LITERAL:
                {
                int LA93_3 = input.LA(2);

                if ( (synpred11_CSharp4AST()) ) {
                    alt93=1;
                }
                else if ( (true) ) {
                    alt93=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 93, 3, input);

                    throw nvae;

                }
                }
                break;
            case REAL_LITERAL:
                {
                int LA93_4 = input.LA(2);

                if ( (synpred11_CSharp4AST()) ) {
                    alt93=1;
                }
                else if ( (true) ) {
                    alt93=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 93, 4, input);

                    throw nvae;

                }
                }
                break;
            case CHARACTER_LITERAL:
                {
                int LA93_5 = input.LA(2);

                if ( (synpred11_CSharp4AST()) ) {
                    alt93=1;
                }
                else if ( (true) ) {
                    alt93=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 93, 5, input);

                    throw nvae;

                }
                }
                break;
            case STRING_LITERAL:
                {
                int LA93_6 = input.LA(2);

                if ( (synpred11_CSharp4AST()) ) {
                    alt93=1;
                }
                else if ( (true) ) {
                    alt93=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 93, 6, input);

                    throw nvae;

                }
                }
                break;
            case NULL:
                {
                int LA93_7 = input.LA(2);

                if ( (synpred11_CSharp4AST()) ) {
                    alt93=1;
                }
                else if ( (true) ) {
                    alt93=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 93, 7, input);

                    throw nvae;

                }
                }
                break;
            case IDENTIFIER:
                {
                int LA93_8 = input.LA(2);

                if ( (synpred11_CSharp4AST()) ) {
                    alt93=1;
                }
                else if ( (true) ) {
                    alt93=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 93, 8, input);

                    throw nvae;

                }
                }
                break;
            case BOOL:
            case BYTE:
            case CHAR:
            case DECIMAL:
            case DOUBLE:
            case FLOAT:
            case INT:
            case LONG:
            case OBJECT:
            case SBYTE:
            case SHORT:
            case STRING:
            case UINT:
            case ULONG:
            case USHORT:
                {
                int LA93_9 = input.LA(2);

                if ( (synpred11_CSharp4AST()) ) {
                    alt93=1;
                }
                else if ( (true) ) {
                    alt93=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 93, 9, input);

                    throw nvae;

                }
                }
                break;
            case THIS:
                {
                int LA93_10 = input.LA(2);

                if ( (synpred11_CSharp4AST()) ) {
                    alt93=1;
                }
                else if ( (true) ) {
                    alt93=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 93, 10, input);

                    throw nvae;

                }
                }
                break;
            case BASE:
                {
                int LA93_11 = input.LA(2);

                if ( (synpred11_CSharp4AST()) ) {
                    alt93=1;
                }
                else if ( (true) ) {
                    alt93=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 93, 11, input);

                    throw nvae;

                }
                }
                break;
            case NEW:
                {
                int LA93_12 = input.LA(2);

                if ( (synpred11_CSharp4AST()) ) {
                    alt93=1;
                }
                else if ( (true) ) {
                    alt93=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 93, 12, input);

                    throw nvae;

                }
                }
                break;
            case TYPEOF:
                {
                int LA93_13 = input.LA(2);

                if ( (synpred11_CSharp4AST()) ) {
                    alt93=1;
                }
                else if ( (true) ) {
                    alt93=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 93, 13, input);

                    throw nvae;

                }
                }
                break;
            case CHECKED:
                {
                int LA93_14 = input.LA(2);

                if ( (synpred11_CSharp4AST()) ) {
                    alt93=1;
                }
                else if ( (true) ) {
                    alt93=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 93, 14, input);

                    throw nvae;

                }
                }
                break;
            case UNCHECKED:
                {
                int LA93_15 = input.LA(2);

                if ( (synpred11_CSharp4AST()) ) {
                    alt93=1;
                }
                else if ( (true) ) {
                    alt93=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 93, 15, input);

                    throw nvae;

                }
                }
                break;
            case DEFAULT:
                {
                int LA93_16 = input.LA(2);

                if ( (synpred11_CSharp4AST()) ) {
                    alt93=1;
                }
                else if ( (true) ) {
                    alt93=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 93, 16, input);

                    throw nvae;

                }
                }
                break;
            case DELEGATE:
                {
                int LA93_17 = input.LA(2);

                if ( (synpred11_CSharp4AST()) ) {
                    alt93=1;
                }
                else if ( (true) ) {
                    alt93=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 93, 17, input);

                    throw nvae;

                }
                }
                break;
            case SIZEOF:
                {
                int LA93_18 = input.LA(2);

                if ( (synpred11_CSharp4AST()) ) {
                    alt93=1;
                }
                else if ( (true) ) {
                    alt93=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 93, 18, input);

                    throw nvae;

                }
                }
                break;
            case PLUS:
                {
                int LA93_19 = input.LA(2);

                if ( (synpred11_CSharp4AST()) ) {
                    alt93=1;
                }
                else if ( (true) ) {
                    alt93=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 93, 19, input);

                    throw nvae;

                }
                }
                break;
            case MINUS:
                {
                int LA93_20 = input.LA(2);

                if ( (synpred11_CSharp4AST()) ) {
                    alt93=1;
                }
                else if ( (true) ) {
                    alt93=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 93, 20, input);

                    throw nvae;

                }
                }
                break;
            case BANG:
                {
                int LA93_21 = input.LA(2);

                if ( (synpred11_CSharp4AST()) ) {
                    alt93=1;
                }
                else if ( (true) ) {
                    alt93=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 93, 21, input);

                    throw nvae;

                }
                }
                break;
            case TILDE:
                {
                int LA93_22 = input.LA(2);

                if ( (synpred11_CSharp4AST()) ) {
                    alt93=1;
                }
                else if ( (true) ) {
                    alt93=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 93, 22, input);

                    throw nvae;

                }
                }
                break;
            case OP_INC:
                {
                int LA93_23 = input.LA(2);

                if ( (synpred11_CSharp4AST()) ) {
                    alt93=1;
                }
                else if ( (true) ) {
                    alt93=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 93, 23, input);

                    throw nvae;

                }
                }
                break;
            case OP_DEC:
                {
                int LA93_24 = input.LA(2);

                if ( (synpred11_CSharp4AST()) ) {
                    alt93=1;
                }
                else if ( (true) ) {
                    alt93=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 93, 24, input);

                    throw nvae;

                }
                }
                break;
            case STAR:
                {
                int LA93_25 = input.LA(2);

                if ( (synpred11_CSharp4AST()) ) {
                    alt93=1;
                }
                else if ( (true) ) {
                    alt93=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 93, 25, input);

                    throw nvae;

                }
                }
                break;
            case AMP:
                {
                int LA93_26 = input.LA(2);

                if ( (synpred11_CSharp4AST()) ) {
                    alt93=1;
                }
                else if ( (true) ) {
                    alt93=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 93, 26, input);

                    throw nvae;

                }
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 93, 0, input);

                throw nvae;

            }

            switch (alt93) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:983:4: ( assignment )=>e1= assignment
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_assignment_in_expression4847);
                    e1=assignment();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, e1.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:984:4: e2= non_assignment_expression
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_non_assignment_expression_in_expression4854);
                    e2=non_assignment_expression();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, e2.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "expression"


    public static class non_assignment_expression_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "non_assignment_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:986:1: non_assignment_expression : ( ( lambda_expression )=> lambda_expression | ( query_expression )=> query_expression |c= conditional_expression );
    public final CSharp4AST.non_assignment_expression_return non_assignment_expression() throws RecognitionException {
        CSharp4AST.non_assignment_expression_return retval = new CSharp4AST.non_assignment_expression_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.conditional_expression_return c =null;

        CSharp4AST.lambda_expression_return lambda_expression480 =null;

        CSharp4AST.query_expression_return query_expression481 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:987:2: ( ( lambda_expression )=> lambda_expression | ( query_expression )=> query_expression |c= conditional_expression )
            int alt94=3;
            switch ( input.LA(1) ) {
            case OPEN_PARENS:
                {
                int LA94_1 = input.LA(2);

                if ( (synpred12_CSharp4AST()) ) {
                    alt94=1;
                }
                else if ( (true) ) {
                    alt94=3;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 94, 1, input);

                    throw nvae;

                }
                }
                break;
            case IDENTIFIER:
                {
                int LA94_2 = input.LA(2);

                if ( (synpred12_CSharp4AST()) ) {
                    alt94=1;
                }
                else if ( (((synpred13_CSharp4AST()&&synpred13_CSharp4AST())&&(input.LT(1).getText().equals("from")))) ) {
                    alt94=2;
                }
                else if ( (true) ) {
                    alt94=3;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 94, 2, input);

                    throw nvae;

                }
                }
                break;
            case AMP:
            case BANG:
            case BASE:
            case BOOL:
            case BYTE:
            case CHAR:
            case CHARACTER_LITERAL:
            case CHECKED:
            case DECIMAL:
            case DEFAULT:
            case DELEGATE:
            case DOUBLE:
            case FALSE:
            case FLOAT:
            case INT:
            case INTEGER_LITERAL:
            case LONG:
            case MINUS:
            case NEW:
            case NULL:
            case OBJECT:
            case OP_DEC:
            case OP_INC:
            case PLUS:
            case REAL_LITERAL:
            case SBYTE:
            case SHORT:
            case SIZEOF:
            case STAR:
            case STRING:
            case STRING_LITERAL:
            case THIS:
            case TILDE:
            case TRUE:
            case TYPEOF:
            case UINT:
            case ULONG:
            case UNCHECKED:
            case USHORT:
                {
                alt94=3;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 94, 0, input);

                throw nvae;

            }

            switch (alt94) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:987:4: ( lambda_expression )=> lambda_expression
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_lambda_expression_in_non_assignment_expression4870);
                    lambda_expression480=lambda_expression();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, lambda_expression480.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:988:4: ( query_expression )=> query_expression
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_query_expression_in_non_assignment_expression4881);
                    query_expression481=query_expression();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, query_expression481.getTree());

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:989:4: c= conditional_expression
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_conditional_expression_in_non_assignment_expression4888);
                    c=conditional_expression();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, c.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "non_assignment_expression"


    public static class constant_expression_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "constant_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:991:1: constant_expression : expression ;
    public final CSharp4AST.constant_expression_return constant_expression() throws RecognitionException {
        CSharp4AST.constant_expression_return retval = new CSharp4AST.constant_expression_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.expression_return expression482 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:992:2: ( expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:992:4: expression
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_expression_in_constant_expression4899);
            expression482=expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, expression482.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "constant_expression"


    public static class boolean_expression_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "boolean_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:994:1: boolean_expression : expression ;
    public final CSharp4AST.boolean_expression_return boolean_expression() throws RecognitionException {
        CSharp4AST.boolean_expression_return retval = new CSharp4AST.boolean_expression_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.expression_return expression483 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:995:2: ( expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:995:4: expression
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_expression_in_boolean_expression4910);
            expression483=expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, expression483.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "boolean_expression"


    public static class statement_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:999:1: statement : ( ( labeled_statement )=> labeled_statement | ( declaration_statement )=> declaration_statement | embedded_statement );
    public final CSharp4AST.statement_return statement() throws RecognitionException {
        CSharp4AST.statement_return retval = new CSharp4AST.statement_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.labeled_statement_return labeled_statement484 =null;

        CSharp4AST.declaration_statement_return declaration_statement485 =null;

        CSharp4AST.embedded_statement_return embedded_statement486 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1000:2: ( ( labeled_statement )=> labeled_statement | ( declaration_statement )=> declaration_statement | embedded_statement )
            int alt95=3;
            int LA95_0 = input.LA(1);

            if ( (LA95_0==IDENTIFIER) ) {
                int LA95_1 = input.LA(2);

                if ( (synpred14_CSharp4AST()) ) {
                    alt95=1;
                }
                else if ( (synpred15_CSharp4AST()) ) {
                    alt95=2;
                }
                else if ( (true) ) {
                    alt95=3;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 95, 1, input);

                    throw nvae;

                }
            }
            else if ( (LA95_0==BYTE||LA95_0==CHAR||LA95_0==INT||LA95_0==LONG||LA95_0==SBYTE||LA95_0==SHORT||(LA95_0 >= UINT && LA95_0 <= ULONG)||LA95_0==USHORT) ) {
                int LA95_2 = input.LA(2);

                if ( (synpred15_CSharp4AST()) ) {
                    alt95=2;
                }
                else if ( (true) ) {
                    alt95=3;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 95, 2, input);

                    throw nvae;

                }
            }
            else if ( (LA95_0==DOUBLE||LA95_0==FLOAT) ) {
                int LA95_3 = input.LA(2);

                if ( (synpred15_CSharp4AST()) ) {
                    alt95=2;
                }
                else if ( (true) ) {
                    alt95=3;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 95, 3, input);

                    throw nvae;

                }
            }
            else if ( (LA95_0==DECIMAL) ) {
                int LA95_4 = input.LA(2);

                if ( (synpred15_CSharp4AST()) ) {
                    alt95=2;
                }
                else if ( (true) ) {
                    alt95=3;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 95, 4, input);

                    throw nvae;

                }
            }
            else if ( (LA95_0==BOOL) ) {
                int LA95_5 = input.LA(2);

                if ( (synpred15_CSharp4AST()) ) {
                    alt95=2;
                }
                else if ( (true) ) {
                    alt95=3;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 95, 5, input);

                    throw nvae;

                }
            }
            else if ( (LA95_0==OBJECT) ) {
                int LA95_6 = input.LA(2);

                if ( (synpred15_CSharp4AST()) ) {
                    alt95=2;
                }
                else if ( (true) ) {
                    alt95=3;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 95, 6, input);

                    throw nvae;

                }
            }
            else if ( (LA95_0==STRING) ) {
                int LA95_7 = input.LA(2);

                if ( (synpred15_CSharp4AST()) ) {
                    alt95=2;
                }
                else if ( (true) ) {
                    alt95=3;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 95, 7, input);

                    throw nvae;

                }
            }
            else if ( (LA95_0==VOID) && (synpred15_CSharp4AST())) {
                alt95=2;
            }
            else if ( (LA95_0==CONST) && (synpred15_CSharp4AST())) {
                alt95=2;
            }
            else if ( (LA95_0==AMP||(LA95_0 >= BANG && LA95_0 <= BASE)||LA95_0==BREAK||(LA95_0 >= CHARACTER_LITERAL && LA95_0 <= CHECKED)||LA95_0==CONTINUE||(LA95_0 >= DEFAULT && LA95_0 <= DELEGATE)||LA95_0==DO||LA95_0==FALSE||LA95_0==FIXED||(LA95_0 >= FOR && LA95_0 <= FOREACH)||LA95_0==GOTO||LA95_0==IF||LA95_0==INTEGER_LITERAL||LA95_0==LOCK||LA95_0==MINUS||LA95_0==NEW||LA95_0==NULL||LA95_0==OPEN_BRACE||LA95_0==OPEN_PARENS||LA95_0==OP_DEC||LA95_0==OP_INC||LA95_0==PLUS||LA95_0==REAL_LITERAL||LA95_0==RETURN||LA95_0==SEMICOLON||LA95_0==SIZEOF||LA95_0==STAR||LA95_0==STRING_LITERAL||LA95_0==SWITCH||(LA95_0 >= THIS && LA95_0 <= TYPEOF)||LA95_0==UNCHECKED||LA95_0==UNSAFE||LA95_0==USING||LA95_0==WHILE) ) {
                alt95=3;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 95, 0, input);

                throw nvae;

            }
            switch (alt95) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1000:4: ( labeled_statement )=> labeled_statement
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_labeled_statement_in_statement4929);
                    labeled_statement484=labeled_statement();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, labeled_statement484.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1001:4: ( declaration_statement )=> declaration_statement
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_declaration_statement_in_statement4940);
                    declaration_statement485=declaration_statement();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, declaration_statement485.getTree());

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1002:4: embedded_statement
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_embedded_statement_in_statement4945);
                    embedded_statement486=embedded_statement();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, embedded_statement486.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "statement"


    public static class embedded_statement_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "embedded_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1004:1: embedded_statement : ( block | empty_statement | expression_statement | selection_statement | iteration_statement | jump_statement | try_statement | checked_statement | unchecked_statement | lock_statement | using_statement | yield_statement | embedded_statement_unsafe );
    public final CSharp4AST.embedded_statement_return embedded_statement() throws RecognitionException {
        CSharp4AST.embedded_statement_return retval = new CSharp4AST.embedded_statement_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.block_return block487 =null;

        CSharp4AST.empty_statement_return empty_statement488 =null;

        CSharp4AST.expression_statement_return expression_statement489 =null;

        CSharp4AST.selection_statement_return selection_statement490 =null;

        CSharp4AST.iteration_statement_return iteration_statement491 =null;

        CSharp4AST.jump_statement_return jump_statement492 =null;

        CSharp4AST.try_statement_return try_statement493 =null;

        CSharp4AST.checked_statement_return checked_statement494 =null;

        CSharp4AST.unchecked_statement_return unchecked_statement495 =null;

        CSharp4AST.lock_statement_return lock_statement496 =null;

        CSharp4AST.using_statement_return using_statement497 =null;

        CSharp4AST.yield_statement_return yield_statement498 =null;

        CSharp4AST.embedded_statement_unsafe_return embedded_statement_unsafe499 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1005:2: ( block | empty_statement | expression_statement | selection_statement | iteration_statement | jump_statement | try_statement | checked_statement | unchecked_statement | lock_statement | using_statement | yield_statement | embedded_statement_unsafe )
            int alt96=13;
            switch ( input.LA(1) ) {
            case OPEN_BRACE:
                {
                alt96=1;
                }
                break;
            case SEMICOLON:
                {
                alt96=2;
                }
                break;
            case AMP:
            case BANG:
            case BASE:
            case BOOL:
            case BYTE:
            case CHAR:
            case CHARACTER_LITERAL:
            case DECIMAL:
            case DEFAULT:
            case DELEGATE:
            case DOUBLE:
            case FALSE:
            case FLOAT:
            case INT:
            case INTEGER_LITERAL:
            case LONG:
            case MINUS:
            case NEW:
            case NULL:
            case OBJECT:
            case OPEN_PARENS:
            case OP_DEC:
            case OP_INC:
            case PLUS:
            case REAL_LITERAL:
            case SBYTE:
            case SHORT:
            case SIZEOF:
            case STAR:
            case STRING:
            case STRING_LITERAL:
            case THIS:
            case TILDE:
            case TRUE:
            case TYPEOF:
            case UINT:
            case ULONG:
            case USHORT:
                {
                alt96=3;
                }
                break;
            case IDENTIFIER:
                {
                int LA96_4 = input.LA(2);

                if ( ((LA96_4 >= AMP && LA96_4 <= ASSIGNMENT)||(LA96_4 >= BITWISE_OR && LA96_4 <= BOOL)||(LA96_4 >= BYTE && LA96_4 <= CARET)||LA96_4==CHAR||LA96_4==DECIMAL||LA96_4==DIV||(LA96_4 >= DOT && LA96_4 <= DOUBLE)||LA96_4==DOUBLE_COLON||LA96_4==FLOAT||LA96_4==GT||LA96_4==IDENTIFIER||LA96_4==INT||(LA96_4 >= INTERR && LA96_4 <= IS)||(LA96_4 >= LONG && LA96_4 <= LT)||LA96_4==MINUS||LA96_4==OBJECT||(LA96_4 >= OPEN_BRACKET && LA96_4 <= OPEN_PARENS)||(LA96_4 >= OP_ADD_ASSIGNMENT && LA96_4 <= OP_XOR_ASSIGNMENT)||(LA96_4 >= PERCENT && LA96_4 <= PLUS)||LA96_4==SBYTE||LA96_4==SEMICOLON||LA96_4==SHORT||LA96_4==STAR||LA96_4==STRING||(LA96_4 >= UINT && LA96_4 <= ULONG)||LA96_4==USHORT||LA96_4==VOID) ) {
                    alt96=3;
                }
                else if ( (LA96_4==BREAK||LA96_4==RETURN) ) {
                    alt96=12;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 96, 4, input);

                    throw nvae;

                }
                }
                break;
            case CHECKED:
                {
                int LA96_5 = input.LA(2);

                if ( (LA96_5==OPEN_PARENS) ) {
                    alt96=3;
                }
                else if ( (LA96_5==OPEN_BRACE) ) {
                    alt96=8;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 96, 5, input);

                    throw nvae;

                }
                }
                break;
            case UNCHECKED:
                {
                int LA96_6 = input.LA(2);

                if ( (LA96_6==OPEN_PARENS) ) {
                    alt96=3;
                }
                else if ( (LA96_6==OPEN_BRACE) ) {
                    alt96=9;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 96, 6, input);

                    throw nvae;

                }
                }
                break;
            case IF:
            case SWITCH:
                {
                alt96=4;
                }
                break;
            case DO:
            case FOR:
            case FOREACH:
            case WHILE:
                {
                alt96=5;
                }
                break;
            case BREAK:
            case CONTINUE:
            case GOTO:
            case RETURN:
            case THROW:
                {
                alt96=6;
                }
                break;
            case TRY:
                {
                alt96=7;
                }
                break;
            case LOCK:
                {
                alt96=10;
                }
                break;
            case USING:
                {
                alt96=11;
                }
                break;
            case FIXED:
            case UNSAFE:
                {
                alt96=13;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 96, 0, input);

                throw nvae;

            }

            switch (alt96) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1005:4: block
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_block_in_embedded_statement4956);
                    block487=block();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, block487.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1006:4: empty_statement
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_empty_statement_in_embedded_statement4961);
                    empty_statement488=empty_statement();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, empty_statement488.getTree());

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1007:4: expression_statement
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_expression_statement_in_embedded_statement4966);
                    expression_statement489=expression_statement();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, expression_statement489.getTree());

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1008:4: selection_statement
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_selection_statement_in_embedded_statement4971);
                    selection_statement490=selection_statement();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, selection_statement490.getTree());

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1009:4: iteration_statement
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_iteration_statement_in_embedded_statement4976);
                    iteration_statement491=iteration_statement();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, iteration_statement491.getTree());

                    }
                    break;
                case 6 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1010:4: jump_statement
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_jump_statement_in_embedded_statement4981);
                    jump_statement492=jump_statement();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, jump_statement492.getTree());

                    }
                    break;
                case 7 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1011:4: try_statement
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_try_statement_in_embedded_statement4986);
                    try_statement493=try_statement();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, try_statement493.getTree());

                    }
                    break;
                case 8 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1012:4: checked_statement
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_checked_statement_in_embedded_statement4991);
                    checked_statement494=checked_statement();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, checked_statement494.getTree());

                    }
                    break;
                case 9 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1013:4: unchecked_statement
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_unchecked_statement_in_embedded_statement4996);
                    unchecked_statement495=unchecked_statement();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, unchecked_statement495.getTree());

                    }
                    break;
                case 10 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1014:4: lock_statement
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_lock_statement_in_embedded_statement5001);
                    lock_statement496=lock_statement();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, lock_statement496.getTree());

                    }
                    break;
                case 11 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1015:4: using_statement
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_using_statement_in_embedded_statement5006);
                    using_statement497=using_statement();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, using_statement497.getTree());

                    }
                    break;
                case 12 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1016:4: yield_statement
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_yield_statement_in_embedded_statement5011);
                    yield_statement498=yield_statement();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, yield_statement498.getTree());

                    }
                    break;
                case 13 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1017:4: embedded_statement_unsafe
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_embedded_statement_unsafe_in_embedded_statement5016);
                    embedded_statement_unsafe499=embedded_statement_unsafe();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, embedded_statement_unsafe499.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "embedded_statement"


    public static class block_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "block"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1020:1: block : OPEN_BRACE ( statement_list )? CLOSE_BRACE -> ^( BLOCK ( statement_list )? ) ;
    public final CSharp4AST.block_return block() throws RecognitionException {
        CSharp4AST.block_return retval = new CSharp4AST.block_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token OPEN_BRACE500=null;
        Token CLOSE_BRACE502=null;
        CSharp4AST.statement_list_return statement_list501 =null;


        Object OPEN_BRACE500_tree=null;
        Object CLOSE_BRACE502_tree=null;
        RewriteRuleTokenStream stream_CLOSE_BRACE=new RewriteRuleTokenStream(adaptor,"token CLOSE_BRACE");
        RewriteRuleTokenStream stream_OPEN_BRACE=new RewriteRuleTokenStream(adaptor,"token OPEN_BRACE");
        RewriteRuleSubtreeStream stream_statement_list=new RewriteRuleSubtreeStream(adaptor,"rule statement_list");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1021:2: ( OPEN_BRACE ( statement_list )? CLOSE_BRACE -> ^( BLOCK ( statement_list )? ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1021:4: OPEN_BRACE ( statement_list )? CLOSE_BRACE
            {
            OPEN_BRACE500=(Token)match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_block5029); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_OPEN_BRACE.add(OPEN_BRACE500);


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1021:15: ( statement_list )?
            int alt97=2;
            int LA97_0 = input.LA(1);

            if ( (LA97_0==AMP||(LA97_0 >= BANG && LA97_0 <= BASE)||(LA97_0 >= BOOL && LA97_0 <= BYTE)||(LA97_0 >= CHAR && LA97_0 <= CHECKED)||(LA97_0 >= CONST && LA97_0 <= CONTINUE)||LA97_0==DECIMAL||(LA97_0 >= DEFAULT && LA97_0 <= DELEGATE)||LA97_0==DO||LA97_0==DOUBLE||LA97_0==FALSE||(LA97_0 >= FIXED && LA97_0 <= FOREACH)||LA97_0==GOTO||(LA97_0 >= IDENTIFIER && LA97_0 <= IF)||(LA97_0 >= INT && LA97_0 <= INTEGER_LITERAL)||(LA97_0 >= LOCK && LA97_0 <= LONG)||LA97_0==MINUS||LA97_0==NEW||LA97_0==NULL||(LA97_0 >= OBJECT && LA97_0 <= OPEN_BRACE)||LA97_0==OPEN_PARENS||LA97_0==OP_DEC||LA97_0==OP_INC||LA97_0==PLUS||LA97_0==REAL_LITERAL||LA97_0==RETURN||LA97_0==SBYTE||LA97_0==SEMICOLON||LA97_0==SHORT||LA97_0==SIZEOF||LA97_0==STAR||(LA97_0 >= STRING && LA97_0 <= STRING_LITERAL)||LA97_0==SWITCH||(LA97_0 >= THIS && LA97_0 <= TYPEOF)||(LA97_0 >= UINT && LA97_0 <= UNCHECKED)||(LA97_0 >= UNSAFE && LA97_0 <= USING)||LA97_0==VOID||LA97_0==WHILE) ) {
                alt97=1;
            }
            switch (alt97) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1021:15: statement_list
                    {
                    pushFollow(FOLLOW_statement_list_in_block5031);
                    statement_list501=statement_list();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) stream_statement_list.add(statement_list501.getTree());

                    }
                    break;

            }


            CLOSE_BRACE502=(Token)match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_block5034); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_CLOSE_BRACE.add(CLOSE_BRACE502);


            // AST REWRITE
            // elements: statement_list
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 1022:4: -> ^( BLOCK ( statement_list )? )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1022:7: ^( BLOCK ( statement_list )? )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(BLOCK, "BLOCK")
                , root_1);

                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1022:15: ( statement_list )?
                if ( stream_statement_list.hasNext() ) {
                    adaptor.addChild(root_1, stream_statement_list.nextTree());

                }
                stream_statement_list.reset();

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "block"


    public static class statement_list_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "statement_list"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1024:1: statement_list : ( statement )+ ;
    public final CSharp4AST.statement_list_return statement_list() throws RecognitionException {
        CSharp4AST.statement_list_return retval = new CSharp4AST.statement_list_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.statement_return statement503 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1025:2: ( ( statement )+ )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1025:4: ( statement )+
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1025:4: ( statement )+
            int cnt98=0;
            loop98:
            do {
                int alt98=2;
                int LA98_0 = input.LA(1);

                if ( (LA98_0==DEFAULT) ) {
                    int LA98_2 = input.LA(2);

                    if ( (LA98_2==OPEN_PARENS) ) {
                        alt98=1;
                    }


                }
                else if ( (LA98_0==AMP||(LA98_0 >= BANG && LA98_0 <= BASE)||(LA98_0 >= BOOL && LA98_0 <= BYTE)||(LA98_0 >= CHAR && LA98_0 <= CHECKED)||(LA98_0 >= CONST && LA98_0 <= CONTINUE)||LA98_0==DECIMAL||LA98_0==DELEGATE||LA98_0==DO||LA98_0==DOUBLE||LA98_0==FALSE||(LA98_0 >= FIXED && LA98_0 <= FOREACH)||LA98_0==GOTO||(LA98_0 >= IDENTIFIER && LA98_0 <= IF)||(LA98_0 >= INT && LA98_0 <= INTEGER_LITERAL)||(LA98_0 >= LOCK && LA98_0 <= LONG)||LA98_0==MINUS||LA98_0==NEW||LA98_0==NULL||(LA98_0 >= OBJECT && LA98_0 <= OPEN_BRACE)||LA98_0==OPEN_PARENS||LA98_0==OP_DEC||LA98_0==OP_INC||LA98_0==PLUS||LA98_0==REAL_LITERAL||LA98_0==RETURN||LA98_0==SBYTE||LA98_0==SEMICOLON||LA98_0==SHORT||LA98_0==SIZEOF||LA98_0==STAR||(LA98_0 >= STRING && LA98_0 <= STRING_LITERAL)||LA98_0==SWITCH||(LA98_0 >= THIS && LA98_0 <= TYPEOF)||(LA98_0 >= UINT && LA98_0 <= UNCHECKED)||(LA98_0 >= UNSAFE && LA98_0 <= USING)||LA98_0==VOID||LA98_0==WHILE) ) {
                    alt98=1;
                }


                switch (alt98) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1025:4: statement
            	    {
            	    pushFollow(FOLLOW_statement_in_statement_list5057);
            	    statement503=statement();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, statement503.getTree());

            	    }
            	    break;

            	default :
            	    if ( cnt98 >= 1 ) break loop98;
            	    if (state.backtracking>0) {state.failed=true; return retval;}
                        EarlyExitException eee =
                            new EarlyExitException(98, input);
                        throw eee;
                }
                cnt98++;
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "statement_list"


    public static class empty_statement_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "empty_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1027:1: empty_statement : SEMICOLON ;
    public final CSharp4AST.empty_statement_return empty_statement() throws RecognitionException {
        CSharp4AST.empty_statement_return retval = new CSharp4AST.empty_statement_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token SEMICOLON504=null;

        Object SEMICOLON504_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1028:2: ( SEMICOLON )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1028:4: SEMICOLON
            {
            root_0 = (Object)adaptor.nil();


            SEMICOLON504=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_empty_statement5069); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            SEMICOLON504_tree = 
            (Object)adaptor.create(SEMICOLON504)
            ;
            adaptor.addChild(root_0, SEMICOLON504_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "empty_statement"


    public static class labeled_statement_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "labeled_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1031:1: labeled_statement : IDENTIFIER COLON statement -> ^( LABELED_STATEMENT IDENTIFIER statement ) ;
    public final CSharp4AST.labeled_statement_return labeled_statement() throws RecognitionException {
        CSharp4AST.labeled_statement_return retval = new CSharp4AST.labeled_statement_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER505=null;
        Token COLON506=null;
        CSharp4AST.statement_return statement507 =null;


        Object IDENTIFIER505_tree=null;
        Object COLON506_tree=null;
        RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
        RewriteRuleTokenStream stream_IDENTIFIER=new RewriteRuleTokenStream(adaptor,"token IDENTIFIER");
        RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1032:2: ( IDENTIFIER COLON statement -> ^( LABELED_STATEMENT IDENTIFIER statement ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1032:4: IDENTIFIER COLON statement
            {
            IDENTIFIER505=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_labeled_statement5082); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_IDENTIFIER.add(IDENTIFIER505);


            COLON506=(Token)match(input,COLON,FOLLOW_COLON_in_labeled_statement5084); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_COLON.add(COLON506);


            pushFollow(FOLLOW_statement_in_labeled_statement5086);
            statement507=statement();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_statement.add(statement507.getTree());

            // AST REWRITE
            // elements: statement, IDENTIFIER
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 1033:4: -> ^( LABELED_STATEMENT IDENTIFIER statement )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1033:7: ^( LABELED_STATEMENT IDENTIFIER statement )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(LABELED_STATEMENT, "LABELED_STATEMENT")
                , root_1);

                adaptor.addChild(root_1, 
                stream_IDENTIFIER.nextNode()
                );

                adaptor.addChild(root_1, stream_statement.nextTree());

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "labeled_statement"


    public static class declaration_statement_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "declaration_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1036:1: declaration_statement : ( local_variable_declaration SEMICOLON !| local_constant_declaration SEMICOLON !);
    public final CSharp4AST.declaration_statement_return declaration_statement() throws RecognitionException {
        CSharp4AST.declaration_statement_return retval = new CSharp4AST.declaration_statement_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token SEMICOLON509=null;
        Token SEMICOLON511=null;
        CSharp4AST.local_variable_declaration_return local_variable_declaration508 =null;

        CSharp4AST.local_constant_declaration_return local_constant_declaration510 =null;


        Object SEMICOLON509_tree=null;
        Object SEMICOLON511_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1037:2: ( local_variable_declaration SEMICOLON !| local_constant_declaration SEMICOLON !)
            int alt99=2;
            int LA99_0 = input.LA(1);

            if ( (LA99_0==BOOL||LA99_0==BYTE||LA99_0==CHAR||LA99_0==DECIMAL||LA99_0==DOUBLE||LA99_0==FLOAT||LA99_0==IDENTIFIER||LA99_0==INT||LA99_0==LONG||LA99_0==OBJECT||LA99_0==SBYTE||LA99_0==SHORT||LA99_0==STRING||(LA99_0 >= UINT && LA99_0 <= ULONG)||LA99_0==USHORT||LA99_0==VOID) ) {
                alt99=1;
            }
            else if ( (LA99_0==CONST) ) {
                alt99=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 99, 0, input);

                throw nvae;

            }
            switch (alt99) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1037:4: local_variable_declaration SEMICOLON !
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_local_variable_declaration_in_declaration_statement5113);
                    local_variable_declaration508=local_variable_declaration();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, local_variable_declaration508.getTree());

                    SEMICOLON509=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_declaration_statement5115); if (state.failed) return retval;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1038:4: local_constant_declaration SEMICOLON !
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_local_constant_declaration_in_declaration_statement5121);
                    local_constant_declaration510=local_constant_declaration();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, local_constant_declaration510.getTree());

                    SEMICOLON511=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_declaration_statement5123); if (state.failed) return retval;

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "declaration_statement"


    protected static class local_variable_declaration_scope {
        Object type;
    }
    protected Stack local_variable_declaration_stack = new Stack();


    public static class local_variable_declaration_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "local_variable_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1040:1: local_variable_declaration : t= local_variable_type ! local_variable_declarators ;
    public final CSharp4AST.local_variable_declaration_return local_variable_declaration() throws RecognitionException {
        local_variable_declaration_stack.push(new local_variable_declaration_scope());
        CSharp4AST.local_variable_declaration_return retval = new CSharp4AST.local_variable_declaration_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.local_variable_type_return t =null;

        CSharp4AST.local_variable_declarators_return local_variable_declarators512 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1044:2: (t= local_variable_type ! local_variable_declarators )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1044:4: t= local_variable_type ! local_variable_declarators
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_local_variable_type_in_local_variable_declaration5141);
            t=local_variable_type();

            state._fsp--;
            if (state.failed) return retval;

            if ( state.backtracking==0 ) {((local_variable_declaration_scope)local_variable_declaration_stack.peek()).type = (t!=null?((Object)t.tree):null);}

            pushFollow(FOLLOW_local_variable_declarators_in_local_variable_declaration5148);
            local_variable_declarators512=local_variable_declarators();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, local_variable_declarators512.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
            local_variable_declaration_stack.pop();
        }
        return retval;
    }
    // $ANTLR end "local_variable_declaration"


    public static class local_variable_type_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "local_variable_type"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1052:1: local_variable_type : type ;
    public final CSharp4AST.local_variable_type_return local_variable_type() throws RecognitionException {
        CSharp4AST.local_variable_type_return retval = new CSharp4AST.local_variable_type_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.type_return type513 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1053:2: ( type )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1053:4: type
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_type_in_local_variable_type5161);
            type513=type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, type513.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "local_variable_type"


    public static class local_variable_declarators_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "local_variable_declarators"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1056:1: local_variable_declarators : local_variable_declarator ( COMMA local_variable_declarator )* -> ( ^( LOCAL_VARIABLE_DECLARATOR local_variable_declarator ) )+ ;
    public final CSharp4AST.local_variable_declarators_return local_variable_declarators() throws RecognitionException {
        CSharp4AST.local_variable_declarators_return retval = new CSharp4AST.local_variable_declarators_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token COMMA515=null;
        CSharp4AST.local_variable_declarator_return local_variable_declarator514 =null;

        CSharp4AST.local_variable_declarator_return local_variable_declarator516 =null;


        Object COMMA515_tree=null;
        RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
        RewriteRuleSubtreeStream stream_local_variable_declarator=new RewriteRuleSubtreeStream(adaptor,"rule local_variable_declarator");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1057:2: ( local_variable_declarator ( COMMA local_variable_declarator )* -> ( ^( LOCAL_VARIABLE_DECLARATOR local_variable_declarator ) )+ )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1057:4: local_variable_declarator ( COMMA local_variable_declarator )*
            {
            pushFollow(FOLLOW_local_variable_declarator_in_local_variable_declarators5175);
            local_variable_declarator514=local_variable_declarator();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_local_variable_declarator.add(local_variable_declarator514.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1057:30: ( COMMA local_variable_declarator )*
            loop100:
            do {
                int alt100=2;
                int LA100_0 = input.LA(1);

                if ( (LA100_0==COMMA) ) {
                    alt100=1;
                }


                switch (alt100) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1057:32: COMMA local_variable_declarator
            	    {
            	    COMMA515=(Token)match(input,COMMA,FOLLOW_COMMA_in_local_variable_declarators5179); if (state.failed) return retval; 
            	    if ( state.backtracking==0 ) stream_COMMA.add(COMMA515);


            	    pushFollow(FOLLOW_local_variable_declarator_in_local_variable_declarators5182);
            	    local_variable_declarator516=local_variable_declarator();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) stream_local_variable_declarator.add(local_variable_declarator516.getTree());

            	    }
            	    break;

            	default :
            	    break loop100;
                }
            } while (true);


            // AST REWRITE
            // elements: local_variable_declarator
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 1058:4: -> ( ^( LOCAL_VARIABLE_DECLARATOR local_variable_declarator ) )+
            {
                if ( !(stream_local_variable_declarator.hasNext()) ) {
                    throw new RewriteEarlyExitException();
                }
                while ( stream_local_variable_declarator.hasNext() ) {
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1058:7: ^( LOCAL_VARIABLE_DECLARATOR local_variable_declarator )
                    {
                    Object root_1 = (Object)adaptor.nil();
                    root_1 = (Object)adaptor.becomeRoot(
                    (Object)adaptor.create(LOCAL_VARIABLE_DECLARATOR, "LOCAL_VARIABLE_DECLARATOR")
                    , root_1);

                    adaptor.addChild(root_1, ((local_variable_declaration_scope)local_variable_declaration_stack.peek()).type);

                    adaptor.addChild(root_1, stream_local_variable_declarator.nextTree());

                    adaptor.addChild(root_0, root_1);
                    }

                }
                stream_local_variable_declarator.reset();

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "local_variable_declarators"


    public static class local_variable_declarator_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "local_variable_declarator"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1066:1: local_variable_declarator : IDENTIFIER ( ASSIGNMENT ! local_variable_initializer )? ;
    public final CSharp4AST.local_variable_declarator_return local_variable_declarator() throws RecognitionException {
        CSharp4AST.local_variable_declarator_return retval = new CSharp4AST.local_variable_declarator_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER517=null;
        Token ASSIGNMENT518=null;
        CSharp4AST.local_variable_initializer_return local_variable_initializer519 =null;


        Object IDENTIFIER517_tree=null;
        Object ASSIGNMENT518_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1067:3: ( IDENTIFIER ( ASSIGNMENT ! local_variable_initializer )? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1067:5: IDENTIFIER ( ASSIGNMENT ! local_variable_initializer )?
            {
            root_0 = (Object)adaptor.nil();


            IDENTIFIER517=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_local_variable_declarator5215); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER517_tree = 
            (Object)adaptor.create(IDENTIFIER517)
            ;
            adaptor.addChild(root_0, IDENTIFIER517_tree);
            }

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1067:16: ( ASSIGNMENT ! local_variable_initializer )?
            int alt101=2;
            int LA101_0 = input.LA(1);

            if ( (LA101_0==ASSIGNMENT) ) {
                alt101=1;
            }
            switch (alt101) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1067:17: ASSIGNMENT ! local_variable_initializer
                    {
                    ASSIGNMENT518=(Token)match(input,ASSIGNMENT,FOLLOW_ASSIGNMENT_in_local_variable_declarator5218); if (state.failed) return retval;

                    pushFollow(FOLLOW_local_variable_initializer_in_local_variable_declarator5221);
                    local_variable_initializer519=local_variable_initializer();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, local_variable_initializer519.getTree());

                    }
                    break;

            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "local_variable_declarator"


    public static class local_variable_initializer_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "local_variable_initializer"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1069:1: local_variable_initializer : local_variable_initializer2 -> ^( LOCAL_VARIABLE_INITIALIZER local_variable_initializer2 ) ;
    public final CSharp4AST.local_variable_initializer_return local_variable_initializer() throws RecognitionException {
        CSharp4AST.local_variable_initializer_return retval = new CSharp4AST.local_variable_initializer_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.local_variable_initializer2_return local_variable_initializer2520 =null;


        RewriteRuleSubtreeStream stream_local_variable_initializer2=new RewriteRuleSubtreeStream(adaptor,"rule local_variable_initializer2");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1070:3: ( local_variable_initializer2 -> ^( LOCAL_VARIABLE_INITIALIZER local_variable_initializer2 ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1070:5: local_variable_initializer2
            {
            pushFollow(FOLLOW_local_variable_initializer2_in_local_variable_initializer5235);
            local_variable_initializer2520=local_variable_initializer2();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_local_variable_initializer2.add(local_variable_initializer2520.getTree());

            // AST REWRITE
            // elements: local_variable_initializer2
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 1070:33: -> ^( LOCAL_VARIABLE_INITIALIZER local_variable_initializer2 )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1070:36: ^( LOCAL_VARIABLE_INITIALIZER local_variable_initializer2 )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(LOCAL_VARIABLE_INITIALIZER, "LOCAL_VARIABLE_INITIALIZER")
                , root_1);

                adaptor.addChild(root_1, stream_local_variable_initializer2.nextTree());

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "local_variable_initializer"


    public static class local_variable_initializer2_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "local_variable_initializer2"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1072:1: local_variable_initializer2 : ( expression | array_initializer | local_variable_initializer_unsafe );
    public final CSharp4AST.local_variable_initializer2_return local_variable_initializer2() throws RecognitionException {
        CSharp4AST.local_variable_initializer2_return retval = new CSharp4AST.local_variable_initializer2_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.expression_return expression521 =null;

        CSharp4AST.array_initializer_return array_initializer522 =null;

        CSharp4AST.local_variable_initializer_unsafe_return local_variable_initializer_unsafe523 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1073:2: ( expression | array_initializer | local_variable_initializer_unsafe )
            int alt102=3;
            switch ( input.LA(1) ) {
            case AMP:
            case BANG:
            case BASE:
            case BOOL:
            case BYTE:
            case CHAR:
            case CHARACTER_LITERAL:
            case CHECKED:
            case DECIMAL:
            case DEFAULT:
            case DELEGATE:
            case DOUBLE:
            case FALSE:
            case FLOAT:
            case IDENTIFIER:
            case INT:
            case INTEGER_LITERAL:
            case LONG:
            case MINUS:
            case NEW:
            case NULL:
            case OBJECT:
            case OPEN_PARENS:
            case OP_DEC:
            case OP_INC:
            case PLUS:
            case REAL_LITERAL:
            case SBYTE:
            case SHORT:
            case SIZEOF:
            case STAR:
            case STRING:
            case STRING_LITERAL:
            case THIS:
            case TILDE:
            case TRUE:
            case TYPEOF:
            case UINT:
            case ULONG:
            case UNCHECKED:
            case USHORT:
                {
                alt102=1;
                }
                break;
            case OPEN_BRACE:
                {
                alt102=2;
                }
                break;
            case STACKALLOC:
                {
                alt102=3;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 102, 0, input);

                throw nvae;

            }

            switch (alt102) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1073:4: expression
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_expression_in_local_variable_initializer25254);
                    expression521=expression();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, expression521.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1074:4: array_initializer
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_array_initializer_in_local_variable_initializer25259);
                    array_initializer522=array_initializer();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, array_initializer522.getTree());

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1075:4: local_variable_initializer_unsafe
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_local_variable_initializer_unsafe_in_local_variable_initializer25264);
                    local_variable_initializer_unsafe523=local_variable_initializer_unsafe();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, local_variable_initializer_unsafe523.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "local_variable_initializer2"


    public static class local_constant_declaration_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "local_constant_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1077:1: local_constant_declaration : CONST !t= type ! constant_declarators[t.tree] ;
    public final CSharp4AST.local_constant_declaration_return local_constant_declaration() throws RecognitionException {
        CSharp4AST.local_constant_declaration_return retval = new CSharp4AST.local_constant_declaration_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token CONST524=null;
        CSharp4AST.type_return t =null;

        CSharp4AST.constant_declarators_return constant_declarators525 =null;


        Object CONST524_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1078:2: ( CONST !t= type ! constant_declarators[t.tree] )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1078:4: CONST !t= type ! constant_declarators[t.tree]
            {
            root_0 = (Object)adaptor.nil();


            CONST524=(Token)match(input,CONST,FOLLOW_CONST_in_local_constant_declaration5275); if (state.failed) return retval;

            pushFollow(FOLLOW_type_in_local_constant_declaration5280);
            t=type();

            state._fsp--;
            if (state.failed) return retval;

            pushFollow(FOLLOW_constant_declarators_in_local_constant_declaration5283);
            constant_declarators525=constant_declarators(t.tree);

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, constant_declarators525.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "local_constant_declaration"


    public static class expression_statement_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "expression_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1080:1: expression_statement : statement_expression SEMICOLON -> ^( EXPRESSION_STATEMENT statement_expression ) ;
    public final CSharp4AST.expression_statement_return expression_statement() throws RecognitionException {
        CSharp4AST.expression_statement_return retval = new CSharp4AST.expression_statement_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token SEMICOLON527=null;
        CSharp4AST.statement_expression_return statement_expression526 =null;


        Object SEMICOLON527_tree=null;
        RewriteRuleTokenStream stream_SEMICOLON=new RewriteRuleTokenStream(adaptor,"token SEMICOLON");
        RewriteRuleSubtreeStream stream_statement_expression=new RewriteRuleSubtreeStream(adaptor,"rule statement_expression");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1081:2: ( statement_expression SEMICOLON -> ^( EXPRESSION_STATEMENT statement_expression ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1081:4: statement_expression SEMICOLON
            {
            pushFollow(FOLLOW_statement_expression_in_expression_statement5294);
            statement_expression526=statement_expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_statement_expression.add(statement_expression526.getTree());

            SEMICOLON527=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_expression_statement5296); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_SEMICOLON.add(SEMICOLON527);


            // AST REWRITE
            // elements: statement_expression
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 1082:4: -> ^( EXPRESSION_STATEMENT statement_expression )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1082:7: ^( EXPRESSION_STATEMENT statement_expression )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(EXPRESSION_STATEMENT, "EXPRESSION_STATEMENT")
                , root_1);

                adaptor.addChild(root_1, stream_statement_expression.nextTree());

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "expression_statement"


    public static class statement_expression_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "statement_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1097:1: statement_expression : expression ;
    public final CSharp4AST.statement_expression_return statement_expression() throws RecognitionException {
        CSharp4AST.statement_expression_return retval = new CSharp4AST.statement_expression_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.expression_return expression528 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1098:2: ( expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1098:4: expression
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_expression_in_statement_expression5322);
            expression528=expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, expression528.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "statement_expression"


    public static class selection_statement_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "selection_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1100:1: selection_statement : ( if_statement | switch_statement );
    public final CSharp4AST.selection_statement_return selection_statement() throws RecognitionException {
        CSharp4AST.selection_statement_return retval = new CSharp4AST.selection_statement_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.if_statement_return if_statement529 =null;

        CSharp4AST.switch_statement_return switch_statement530 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1101:2: ( if_statement | switch_statement )
            int alt103=2;
            int LA103_0 = input.LA(1);

            if ( (LA103_0==IF) ) {
                alt103=1;
            }
            else if ( (LA103_0==SWITCH) ) {
                alt103=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 103, 0, input);

                throw nvae;

            }
            switch (alt103) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1101:4: if_statement
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_if_statement_in_selection_statement5333);
                    if_statement529=if_statement();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, if_statement529.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1102:4: switch_statement
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_switch_statement_in_selection_statement5338);
                    switch_statement530=switch_statement();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, switch_statement530.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "selection_statement"


    public static class if_statement_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "if_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1110:1: if_statement : IF OPEN_PARENS be= boolean_expression CLOSE_PARENS thenStmt= embedded_statement ( ( ELSE )=> ELSE elseStmt= embedded_statement )? -> ^( IF ^( CONDITION $be) ^( THEN $thenStmt) ( ^( ELSE $elseStmt) )? ) ;
    public final CSharp4AST.if_statement_return if_statement() throws RecognitionException {
        CSharp4AST.if_statement_return retval = new CSharp4AST.if_statement_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IF531=null;
        Token OPEN_PARENS532=null;
        Token CLOSE_PARENS533=null;
        Token ELSE534=null;
        CSharp4AST.boolean_expression_return be =null;

        CSharp4AST.embedded_statement_return thenStmt =null;

        CSharp4AST.embedded_statement_return elseStmt =null;


        Object IF531_tree=null;
        Object OPEN_PARENS532_tree=null;
        Object CLOSE_PARENS533_tree=null;
        Object ELSE534_tree=null;
        RewriteRuleTokenStream stream_OPEN_PARENS=new RewriteRuleTokenStream(adaptor,"token OPEN_PARENS");
        RewriteRuleTokenStream stream_IF=new RewriteRuleTokenStream(adaptor,"token IF");
        RewriteRuleTokenStream stream_ELSE=new RewriteRuleTokenStream(adaptor,"token ELSE");
        RewriteRuleTokenStream stream_CLOSE_PARENS=new RewriteRuleTokenStream(adaptor,"token CLOSE_PARENS");
        RewriteRuleSubtreeStream stream_embedded_statement=new RewriteRuleSubtreeStream(adaptor,"rule embedded_statement");
        RewriteRuleSubtreeStream stream_boolean_expression=new RewriteRuleSubtreeStream(adaptor,"rule boolean_expression");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1111:3: ( IF OPEN_PARENS be= boolean_expression CLOSE_PARENS thenStmt= embedded_statement ( ( ELSE )=> ELSE elseStmt= embedded_statement )? -> ^( IF ^( CONDITION $be) ^( THEN $thenStmt) ( ^( ELSE $elseStmt) )? ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1111:5: IF OPEN_PARENS be= boolean_expression CLOSE_PARENS thenStmt= embedded_statement ( ( ELSE )=> ELSE elseStmt= embedded_statement )?
            {
            IF531=(Token)match(input,IF,FOLLOW_IF_in_if_statement5352); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_IF.add(IF531);


            OPEN_PARENS532=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_if_statement5354); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_OPEN_PARENS.add(OPEN_PARENS532);


            pushFollow(FOLLOW_boolean_expression_in_if_statement5358);
            be=boolean_expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_boolean_expression.add(be.getTree());

            CLOSE_PARENS533=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_if_statement5360); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_CLOSE_PARENS.add(CLOSE_PARENS533);


            pushFollow(FOLLOW_embedded_statement_in_if_statement5364);
            thenStmt=embedded_statement();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_embedded_statement.add(thenStmt.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1112:7: ( ( ELSE )=> ELSE elseStmt= embedded_statement )?
            int alt104=2;
            int LA104_0 = input.LA(1);

            if ( (LA104_0==ELSE) ) {
                int LA104_1 = input.LA(2);

                if ( (synpred16_CSharp4AST()) ) {
                    alt104=1;
                }
            }
            switch (alt104) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1112:9: ( ELSE )=> ELSE elseStmt= embedded_statement
                    {
                    ELSE534=(Token)match(input,ELSE,FOLLOW_ELSE_in_if_statement5380); if (state.failed) return retval; 
                    if ( state.backtracking==0 ) stream_ELSE.add(ELSE534);


                    pushFollow(FOLLOW_embedded_statement_in_if_statement5384);
                    elseStmt=embedded_statement();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) stream_embedded_statement.add(elseStmt.getTree());

                    }
                    break;

            }


            // AST REWRITE
            // elements: elseStmt, thenStmt, be, ELSE, IF
            // token labels: 
            // rule labels: retval, elseStmt, thenStmt, be
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
            RewriteRuleSubtreeStream stream_elseStmt=new RewriteRuleSubtreeStream(adaptor,"rule elseStmt",elseStmt!=null?elseStmt.tree:null);
            RewriteRuleSubtreeStream stream_thenStmt=new RewriteRuleSubtreeStream(adaptor,"rule thenStmt",thenStmt!=null?thenStmt.tree:null);
            RewriteRuleSubtreeStream stream_be=new RewriteRuleSubtreeStream(adaptor,"rule be",be!=null?be.tree:null);

            root_0 = (Object)adaptor.nil();
            // 1113:5: -> ^( IF ^( CONDITION $be) ^( THEN $thenStmt) ( ^( ELSE $elseStmt) )? )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1113:8: ^( IF ^( CONDITION $be) ^( THEN $thenStmt) ( ^( ELSE $elseStmt) )? )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                stream_IF.nextNode()
                , root_1);

                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1113:13: ^( CONDITION $be)
                {
                Object root_2 = (Object)adaptor.nil();
                root_2 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(CONDITION, "CONDITION")
                , root_2);

                adaptor.addChild(root_2, stream_be.nextTree());

                adaptor.addChild(root_1, root_2);
                }

                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1113:30: ^( THEN $thenStmt)
                {
                Object root_2 = (Object)adaptor.nil();
                root_2 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(THEN, "THEN")
                , root_2);

                adaptor.addChild(root_2, stream_thenStmt.nextTree());

                adaptor.addChild(root_1, root_2);
                }

                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1113:48: ( ^( ELSE $elseStmt) )?
                if ( stream_elseStmt.hasNext()||stream_ELSE.hasNext() ) {
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1113:48: ^( ELSE $elseStmt)
                    {
                    Object root_2 = (Object)adaptor.nil();
                    root_2 = (Object)adaptor.becomeRoot(
                    stream_ELSE.nextNode()
                    , root_2);

                    adaptor.addChild(root_2, stream_elseStmt.nextTree());

                    adaptor.addChild(root_1, root_2);
                    }

                }
                stream_elseStmt.reset();
                stream_ELSE.reset();

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "if_statement"


    public static class switch_statement_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "switch_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1115:1: switch_statement : SWITCH ^ OPEN_PARENS expression CLOSE_PARENS switch_block ;
    public final CSharp4AST.switch_statement_return switch_statement() throws RecognitionException {
        CSharp4AST.switch_statement_return retval = new CSharp4AST.switch_statement_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token SWITCH535=null;
        Token OPEN_PARENS536=null;
        Token CLOSE_PARENS538=null;
        CSharp4AST.expression_return expression537 =null;

        CSharp4AST.switch_block_return switch_block539 =null;


        Object SWITCH535_tree=null;
        Object OPEN_PARENS536_tree=null;
        Object CLOSE_PARENS538_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1116:2: ( SWITCH ^ OPEN_PARENS expression CLOSE_PARENS switch_block )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1116:4: SWITCH ^ OPEN_PARENS expression CLOSE_PARENS switch_block
            {
            root_0 = (Object)adaptor.nil();


            SWITCH535=(Token)match(input,SWITCH,FOLLOW_SWITCH_in_switch_statement5432); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            SWITCH535_tree = 
            (Object)adaptor.create(SWITCH535)
            ;
            root_0 = (Object)adaptor.becomeRoot(SWITCH535_tree, root_0);
            }

            OPEN_PARENS536=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_switch_statement5435); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            OPEN_PARENS536_tree = 
            (Object)adaptor.create(OPEN_PARENS536)
            ;
            adaptor.addChild(root_0, OPEN_PARENS536_tree);
            }

            pushFollow(FOLLOW_expression_in_switch_statement5437);
            expression537=expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, expression537.getTree());

            CLOSE_PARENS538=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_switch_statement5439); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            CLOSE_PARENS538_tree = 
            (Object)adaptor.create(CLOSE_PARENS538)
            ;
            adaptor.addChild(root_0, CLOSE_PARENS538_tree);
            }

            pushFollow(FOLLOW_switch_block_in_switch_statement5441);
            switch_block539=switch_block();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, switch_block539.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "switch_statement"


    public static class switch_block_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "switch_block"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1118:1: switch_block : OPEN_BRACE ( switch_sections )? CLOSE_BRACE ;
    public final CSharp4AST.switch_block_return switch_block() throws RecognitionException {
        CSharp4AST.switch_block_return retval = new CSharp4AST.switch_block_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token OPEN_BRACE540=null;
        Token CLOSE_BRACE542=null;
        CSharp4AST.switch_sections_return switch_sections541 =null;


        Object OPEN_BRACE540_tree=null;
        Object CLOSE_BRACE542_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1119:2: ( OPEN_BRACE ( switch_sections )? CLOSE_BRACE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1119:4: OPEN_BRACE ( switch_sections )? CLOSE_BRACE
            {
            root_0 = (Object)adaptor.nil();


            OPEN_BRACE540=(Token)match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_switch_block5452); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            OPEN_BRACE540_tree = 
            (Object)adaptor.create(OPEN_BRACE540)
            ;
            adaptor.addChild(root_0, OPEN_BRACE540_tree);
            }

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1119:15: ( switch_sections )?
            int alt105=2;
            int LA105_0 = input.LA(1);

            if ( (LA105_0==CASE||LA105_0==DEFAULT) ) {
                alt105=1;
            }
            switch (alt105) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1119:15: switch_sections
                    {
                    pushFollow(FOLLOW_switch_sections_in_switch_block5454);
                    switch_sections541=switch_sections();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, switch_sections541.getTree());

                    }
                    break;

            }


            CLOSE_BRACE542=(Token)match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_switch_block5457); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            CLOSE_BRACE542_tree = 
            (Object)adaptor.create(CLOSE_BRACE542)
            ;
            adaptor.addChild(root_0, CLOSE_BRACE542_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "switch_block"


    public static class switch_sections_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "switch_sections"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1121:1: switch_sections : switch_section ( switch_section )* ;
    public final CSharp4AST.switch_sections_return switch_sections() throws RecognitionException {
        CSharp4AST.switch_sections_return retval = new CSharp4AST.switch_sections_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.switch_section_return switch_section543 =null;

        CSharp4AST.switch_section_return switch_section544 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1122:2: ( switch_section ( switch_section )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1122:4: switch_section ( switch_section )*
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_switch_section_in_switch_sections5468);
            switch_section543=switch_section();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, switch_section543.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1122:19: ( switch_section )*
            loop106:
            do {
                int alt106=2;
                int LA106_0 = input.LA(1);

                if ( (LA106_0==CASE||LA106_0==DEFAULT) ) {
                    alt106=1;
                }


                switch (alt106) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1122:21: switch_section
            	    {
            	    pushFollow(FOLLOW_switch_section_in_switch_sections5472);
            	    switch_section544=switch_section();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, switch_section544.getTree());

            	    }
            	    break;

            	default :
            	    break loop106;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "switch_sections"


    public static class switch_section_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "switch_section"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1124:1: switch_section : switch_labels statement_list ;
    public final CSharp4AST.switch_section_return switch_section() throws RecognitionException {
        CSharp4AST.switch_section_return retval = new CSharp4AST.switch_section_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.switch_labels_return switch_labels545 =null;

        CSharp4AST.statement_list_return statement_list546 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1125:2: ( switch_labels statement_list )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1125:4: switch_labels statement_list
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_switch_labels_in_switch_section5486);
            switch_labels545=switch_labels();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, switch_labels545.getTree());

            pushFollow(FOLLOW_statement_list_in_switch_section5488);
            statement_list546=statement_list();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, statement_list546.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "switch_section"


    public static class switch_labels_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "switch_labels"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1127:1: switch_labels : switch_label ( switch_label )* ;
    public final CSharp4AST.switch_labels_return switch_labels() throws RecognitionException {
        CSharp4AST.switch_labels_return retval = new CSharp4AST.switch_labels_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.switch_label_return switch_label547 =null;

        CSharp4AST.switch_label_return switch_label548 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1128:2: ( switch_label ( switch_label )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1128:4: switch_label ( switch_label )*
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_switch_label_in_switch_labels5499);
            switch_label547=switch_label();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, switch_label547.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1128:17: ( switch_label )*
            loop107:
            do {
                int alt107=2;
                int LA107_0 = input.LA(1);

                if ( (LA107_0==DEFAULT) ) {
                    int LA107_2 = input.LA(2);

                    if ( (LA107_2==COLON) ) {
                        alt107=1;
                    }


                }
                else if ( (LA107_0==CASE) ) {
                    alt107=1;
                }


                switch (alt107) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1128:19: switch_label
            	    {
            	    pushFollow(FOLLOW_switch_label_in_switch_labels5503);
            	    switch_label548=switch_label();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, switch_label548.getTree());

            	    }
            	    break;

            	default :
            	    break loop107;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "switch_labels"


    public static class switch_label_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "switch_label"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1130:1: switch_label : ( CASE constant_expression COLON | DEFAULT COLON );
    public final CSharp4AST.switch_label_return switch_label() throws RecognitionException {
        CSharp4AST.switch_label_return retval = new CSharp4AST.switch_label_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token CASE549=null;
        Token COLON551=null;
        Token DEFAULT552=null;
        Token COLON553=null;
        CSharp4AST.constant_expression_return constant_expression550 =null;


        Object CASE549_tree=null;
        Object COLON551_tree=null;
        Object DEFAULT552_tree=null;
        Object COLON553_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1131:2: ( CASE constant_expression COLON | DEFAULT COLON )
            int alt108=2;
            int LA108_0 = input.LA(1);

            if ( (LA108_0==CASE) ) {
                alt108=1;
            }
            else if ( (LA108_0==DEFAULT) ) {
                alt108=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 108, 0, input);

                throw nvae;

            }
            switch (alt108) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1131:4: CASE constant_expression COLON
                    {
                    root_0 = (Object)adaptor.nil();


                    CASE549=(Token)match(input,CASE,FOLLOW_CASE_in_switch_label5517); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    CASE549_tree = 
                    (Object)adaptor.create(CASE549)
                    ;
                    adaptor.addChild(root_0, CASE549_tree);
                    }

                    pushFollow(FOLLOW_constant_expression_in_switch_label5519);
                    constant_expression550=constant_expression();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, constant_expression550.getTree());

                    COLON551=(Token)match(input,COLON,FOLLOW_COLON_in_switch_label5521); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    COLON551_tree = 
                    (Object)adaptor.create(COLON551)
                    ;
                    adaptor.addChild(root_0, COLON551_tree);
                    }

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1132:4: DEFAULT COLON
                    {
                    root_0 = (Object)adaptor.nil();


                    DEFAULT552=(Token)match(input,DEFAULT,FOLLOW_DEFAULT_in_switch_label5526); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    DEFAULT552_tree = 
                    (Object)adaptor.create(DEFAULT552)
                    ;
                    adaptor.addChild(root_0, DEFAULT552_tree);
                    }

                    COLON553=(Token)match(input,COLON,FOLLOW_COLON_in_switch_label5528); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    COLON553_tree = 
                    (Object)adaptor.create(COLON553)
                    ;
                    adaptor.addChild(root_0, COLON553_tree);
                    }

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "switch_label"


    public static class iteration_statement_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "iteration_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1135:1: iteration_statement : ( while_statement | do_statement | for_statement | foreach_statement );
    public final CSharp4AST.iteration_statement_return iteration_statement() throws RecognitionException {
        CSharp4AST.iteration_statement_return retval = new CSharp4AST.iteration_statement_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.while_statement_return while_statement554 =null;

        CSharp4AST.do_statement_return do_statement555 =null;

        CSharp4AST.for_statement_return for_statement556 =null;

        CSharp4AST.foreach_statement_return foreach_statement557 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1136:2: ( while_statement | do_statement | for_statement | foreach_statement )
            int alt109=4;
            switch ( input.LA(1) ) {
            case WHILE:
                {
                alt109=1;
                }
                break;
            case DO:
                {
                alt109=2;
                }
                break;
            case FOR:
                {
                alt109=3;
                }
                break;
            case FOREACH:
                {
                alt109=4;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 109, 0, input);

                throw nvae;

            }

            switch (alt109) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1136:4: while_statement
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_while_statement_in_iteration_statement5541);
                    while_statement554=while_statement();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, while_statement554.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1137:4: do_statement
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_do_statement_in_iteration_statement5546);
                    do_statement555=do_statement();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, do_statement555.getTree());

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1138:4: for_statement
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_for_statement_in_iteration_statement5551);
                    for_statement556=for_statement();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, for_statement556.getTree());

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1139:4: foreach_statement
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_foreach_statement_in_iteration_statement5556);
                    foreach_statement557=foreach_statement();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, foreach_statement557.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "iteration_statement"


    public static class while_statement_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "while_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1141:1: while_statement : WHILE OPEN_PARENS boolean_expression CLOSE_PARENS embedded_statement -> ^( WHILE ^( CONDITION boolean_expression ) ^( LOOP_BODY embedded_statement ) ) ;
    public final CSharp4AST.while_statement_return while_statement() throws RecognitionException {
        CSharp4AST.while_statement_return retval = new CSharp4AST.while_statement_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token WHILE558=null;
        Token OPEN_PARENS559=null;
        Token CLOSE_PARENS561=null;
        CSharp4AST.boolean_expression_return boolean_expression560 =null;

        CSharp4AST.embedded_statement_return embedded_statement562 =null;


        Object WHILE558_tree=null;
        Object OPEN_PARENS559_tree=null;
        Object CLOSE_PARENS561_tree=null;
        RewriteRuleTokenStream stream_WHILE=new RewriteRuleTokenStream(adaptor,"token WHILE");
        RewriteRuleTokenStream stream_OPEN_PARENS=new RewriteRuleTokenStream(adaptor,"token OPEN_PARENS");
        RewriteRuleTokenStream stream_CLOSE_PARENS=new RewriteRuleTokenStream(adaptor,"token CLOSE_PARENS");
        RewriteRuleSubtreeStream stream_embedded_statement=new RewriteRuleSubtreeStream(adaptor,"rule embedded_statement");
        RewriteRuleSubtreeStream stream_boolean_expression=new RewriteRuleSubtreeStream(adaptor,"rule boolean_expression");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1142:2: ( WHILE OPEN_PARENS boolean_expression CLOSE_PARENS embedded_statement -> ^( WHILE ^( CONDITION boolean_expression ) ^( LOOP_BODY embedded_statement ) ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1142:4: WHILE OPEN_PARENS boolean_expression CLOSE_PARENS embedded_statement
            {
            WHILE558=(Token)match(input,WHILE,FOLLOW_WHILE_in_while_statement5567); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_WHILE.add(WHILE558);


            OPEN_PARENS559=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_while_statement5569); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_OPEN_PARENS.add(OPEN_PARENS559);


            pushFollow(FOLLOW_boolean_expression_in_while_statement5571);
            boolean_expression560=boolean_expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_boolean_expression.add(boolean_expression560.getTree());

            CLOSE_PARENS561=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_while_statement5573); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_CLOSE_PARENS.add(CLOSE_PARENS561);


            pushFollow(FOLLOW_embedded_statement_in_while_statement5575);
            embedded_statement562=embedded_statement();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_embedded_statement.add(embedded_statement562.getTree());

            // AST REWRITE
            // elements: embedded_statement, boolean_expression, WHILE
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 1143:4: -> ^( WHILE ^( CONDITION boolean_expression ) ^( LOOP_BODY embedded_statement ) )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1143:7: ^( WHILE ^( CONDITION boolean_expression ) ^( LOOP_BODY embedded_statement ) )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                stream_WHILE.nextNode()
                , root_1);

                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1143:15: ^( CONDITION boolean_expression )
                {
                Object root_2 = (Object)adaptor.nil();
                root_2 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(CONDITION, "CONDITION")
                , root_2);

                adaptor.addChild(root_2, stream_boolean_expression.nextTree());

                adaptor.addChild(root_1, root_2);
                }

                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1143:47: ^( LOOP_BODY embedded_statement )
                {
                Object root_2 = (Object)adaptor.nil();
                root_2 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(LOOP_BODY, "LOOP_BODY")
                , root_2);

                adaptor.addChild(root_2, stream_embedded_statement.nextTree());

                adaptor.addChild(root_1, root_2);
                }

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "while_statement"


    public static class do_statement_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "do_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1145:1: do_statement : DO embedded_statement WHILE OPEN_PARENS boolean_expression CLOSE_PARENS SEMICOLON -> ^( DO ^( CONDITION boolean_expression ) ^( LOOP_BODY embedded_statement ) ) ;
    public final CSharp4AST.do_statement_return do_statement() throws RecognitionException {
        CSharp4AST.do_statement_return retval = new CSharp4AST.do_statement_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token DO563=null;
        Token WHILE565=null;
        Token OPEN_PARENS566=null;
        Token CLOSE_PARENS568=null;
        Token SEMICOLON569=null;
        CSharp4AST.embedded_statement_return embedded_statement564 =null;

        CSharp4AST.boolean_expression_return boolean_expression567 =null;


        Object DO563_tree=null;
        Object WHILE565_tree=null;
        Object OPEN_PARENS566_tree=null;
        Object CLOSE_PARENS568_tree=null;
        Object SEMICOLON569_tree=null;
        RewriteRuleTokenStream stream_DO=new RewriteRuleTokenStream(adaptor,"token DO");
        RewriteRuleTokenStream stream_SEMICOLON=new RewriteRuleTokenStream(adaptor,"token SEMICOLON");
        RewriteRuleTokenStream stream_WHILE=new RewriteRuleTokenStream(adaptor,"token WHILE");
        RewriteRuleTokenStream stream_OPEN_PARENS=new RewriteRuleTokenStream(adaptor,"token OPEN_PARENS");
        RewriteRuleTokenStream stream_CLOSE_PARENS=new RewriteRuleTokenStream(adaptor,"token CLOSE_PARENS");
        RewriteRuleSubtreeStream stream_embedded_statement=new RewriteRuleSubtreeStream(adaptor,"rule embedded_statement");
        RewriteRuleSubtreeStream stream_boolean_expression=new RewriteRuleSubtreeStream(adaptor,"rule boolean_expression");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1146:2: ( DO embedded_statement WHILE OPEN_PARENS boolean_expression CLOSE_PARENS SEMICOLON -> ^( DO ^( CONDITION boolean_expression ) ^( LOOP_BODY embedded_statement ) ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1146:4: DO embedded_statement WHILE OPEN_PARENS boolean_expression CLOSE_PARENS SEMICOLON
            {
            DO563=(Token)match(input,DO,FOLLOW_DO_in_do_statement5608); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_DO.add(DO563);


            pushFollow(FOLLOW_embedded_statement_in_do_statement5610);
            embedded_statement564=embedded_statement();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_embedded_statement.add(embedded_statement564.getTree());

            WHILE565=(Token)match(input,WHILE,FOLLOW_WHILE_in_do_statement5612); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_WHILE.add(WHILE565);


            OPEN_PARENS566=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_do_statement5614); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_OPEN_PARENS.add(OPEN_PARENS566);


            pushFollow(FOLLOW_boolean_expression_in_do_statement5616);
            boolean_expression567=boolean_expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_boolean_expression.add(boolean_expression567.getTree());

            CLOSE_PARENS568=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_do_statement5618); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_CLOSE_PARENS.add(CLOSE_PARENS568);


            SEMICOLON569=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_do_statement5620); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_SEMICOLON.add(SEMICOLON569);


            // AST REWRITE
            // elements: DO, embedded_statement, boolean_expression
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 1147:4: -> ^( DO ^( CONDITION boolean_expression ) ^( LOOP_BODY embedded_statement ) )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1147:7: ^( DO ^( CONDITION boolean_expression ) ^( LOOP_BODY embedded_statement ) )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                stream_DO.nextNode()
                , root_1);

                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1147:12: ^( CONDITION boolean_expression )
                {
                Object root_2 = (Object)adaptor.nil();
                root_2 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(CONDITION, "CONDITION")
                , root_2);

                adaptor.addChild(root_2, stream_boolean_expression.nextTree());

                adaptor.addChild(root_1, root_2);
                }

                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1147:44: ^( LOOP_BODY embedded_statement )
                {
                Object root_2 = (Object)adaptor.nil();
                root_2 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(LOOP_BODY, "LOOP_BODY")
                , root_2);

                adaptor.addChild(root_2, stream_embedded_statement.nextTree());

                adaptor.addChild(root_1, root_2);
                }

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "do_statement"


    public static class for_statement_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "for_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1149:1: for_statement : FOR OPEN_PARENS ( for_initializer )? SEMICOLON ( for_condition )? SEMICOLON ( for_iterator )? CLOSE_PARENS embedded_statement -> ^( FOR ( ^( FOR_INITIALIZER for_initializer ) )? ( ^( CONDITION for_condition ) )? ( ^( FOR_ITERATOR for_iterator ) )? ^( LOOP_BODY embedded_statement ) ) ;
    public final CSharp4AST.for_statement_return for_statement() throws RecognitionException {
        CSharp4AST.for_statement_return retval = new CSharp4AST.for_statement_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token FOR570=null;
        Token OPEN_PARENS571=null;
        Token SEMICOLON573=null;
        Token SEMICOLON575=null;
        Token CLOSE_PARENS577=null;
        CSharp4AST.for_initializer_return for_initializer572 =null;

        CSharp4AST.for_condition_return for_condition574 =null;

        CSharp4AST.for_iterator_return for_iterator576 =null;

        CSharp4AST.embedded_statement_return embedded_statement578 =null;


        Object FOR570_tree=null;
        Object OPEN_PARENS571_tree=null;
        Object SEMICOLON573_tree=null;
        Object SEMICOLON575_tree=null;
        Object CLOSE_PARENS577_tree=null;
        RewriteRuleTokenStream stream_FOR=new RewriteRuleTokenStream(adaptor,"token FOR");
        RewriteRuleTokenStream stream_SEMICOLON=new RewriteRuleTokenStream(adaptor,"token SEMICOLON");
        RewriteRuleTokenStream stream_OPEN_PARENS=new RewriteRuleTokenStream(adaptor,"token OPEN_PARENS");
        RewriteRuleTokenStream stream_CLOSE_PARENS=new RewriteRuleTokenStream(adaptor,"token CLOSE_PARENS");
        RewriteRuleSubtreeStream stream_for_condition=new RewriteRuleSubtreeStream(adaptor,"rule for_condition");
        RewriteRuleSubtreeStream stream_embedded_statement=new RewriteRuleSubtreeStream(adaptor,"rule embedded_statement");
        RewriteRuleSubtreeStream stream_for_iterator=new RewriteRuleSubtreeStream(adaptor,"rule for_iterator");
        RewriteRuleSubtreeStream stream_for_initializer=new RewriteRuleSubtreeStream(adaptor,"rule for_initializer");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1150:2: ( FOR OPEN_PARENS ( for_initializer )? SEMICOLON ( for_condition )? SEMICOLON ( for_iterator )? CLOSE_PARENS embedded_statement -> ^( FOR ( ^( FOR_INITIALIZER for_initializer ) )? ( ^( CONDITION for_condition ) )? ( ^( FOR_ITERATOR for_iterator ) )? ^( LOOP_BODY embedded_statement ) ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1150:4: FOR OPEN_PARENS ( for_initializer )? SEMICOLON ( for_condition )? SEMICOLON ( for_iterator )? CLOSE_PARENS embedded_statement
            {
            FOR570=(Token)match(input,FOR,FOLLOW_FOR_in_for_statement5653); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_FOR.add(FOR570);


            OPEN_PARENS571=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_for_statement5655); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_OPEN_PARENS.add(OPEN_PARENS571);


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1150:20: ( for_initializer )?
            int alt110=2;
            int LA110_0 = input.LA(1);

            if ( (LA110_0==AMP||(LA110_0 >= BANG && LA110_0 <= BASE)||LA110_0==BOOL||LA110_0==BYTE||(LA110_0 >= CHAR && LA110_0 <= CHECKED)||LA110_0==DECIMAL||(LA110_0 >= DEFAULT && LA110_0 <= DELEGATE)||LA110_0==DOUBLE||LA110_0==FALSE||LA110_0==FLOAT||LA110_0==IDENTIFIER||(LA110_0 >= INT && LA110_0 <= INTEGER_LITERAL)||LA110_0==LONG||LA110_0==MINUS||LA110_0==NEW||LA110_0==NULL||LA110_0==OBJECT||LA110_0==OPEN_PARENS||LA110_0==OP_DEC||LA110_0==OP_INC||LA110_0==PLUS||LA110_0==REAL_LITERAL||LA110_0==SBYTE||LA110_0==SHORT||LA110_0==SIZEOF||LA110_0==STAR||(LA110_0 >= STRING && LA110_0 <= STRING_LITERAL)||LA110_0==THIS||(LA110_0 >= TILDE && LA110_0 <= TRUE)||LA110_0==TYPEOF||(LA110_0 >= UINT && LA110_0 <= UNCHECKED)||LA110_0==USHORT||LA110_0==VOID) ) {
                alt110=1;
            }
            switch (alt110) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1150:20: for_initializer
                    {
                    pushFollow(FOLLOW_for_initializer_in_for_statement5657);
                    for_initializer572=for_initializer();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) stream_for_initializer.add(for_initializer572.getTree());

                    }
                    break;

            }


            SEMICOLON573=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_for_statement5660); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_SEMICOLON.add(SEMICOLON573);


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1150:47: ( for_condition )?
            int alt111=2;
            int LA111_0 = input.LA(1);

            if ( (LA111_0==AMP||(LA111_0 >= BANG && LA111_0 <= BASE)||LA111_0==BOOL||LA111_0==BYTE||(LA111_0 >= CHAR && LA111_0 <= CHECKED)||LA111_0==DECIMAL||(LA111_0 >= DEFAULT && LA111_0 <= DELEGATE)||LA111_0==DOUBLE||LA111_0==FALSE||LA111_0==FLOAT||LA111_0==IDENTIFIER||(LA111_0 >= INT && LA111_0 <= INTEGER_LITERAL)||LA111_0==LONG||LA111_0==MINUS||LA111_0==NEW||LA111_0==NULL||LA111_0==OBJECT||LA111_0==OPEN_PARENS||LA111_0==OP_DEC||LA111_0==OP_INC||LA111_0==PLUS||LA111_0==REAL_LITERAL||LA111_0==SBYTE||LA111_0==SHORT||LA111_0==SIZEOF||LA111_0==STAR||(LA111_0 >= STRING && LA111_0 <= STRING_LITERAL)||LA111_0==THIS||(LA111_0 >= TILDE && LA111_0 <= TRUE)||LA111_0==TYPEOF||(LA111_0 >= UINT && LA111_0 <= UNCHECKED)||LA111_0==USHORT) ) {
                alt111=1;
            }
            switch (alt111) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1150:47: for_condition
                    {
                    pushFollow(FOLLOW_for_condition_in_for_statement5662);
                    for_condition574=for_condition();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) stream_for_condition.add(for_condition574.getTree());

                    }
                    break;

            }


            SEMICOLON575=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_for_statement5665); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_SEMICOLON.add(SEMICOLON575);


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1150:72: ( for_iterator )?
            int alt112=2;
            int LA112_0 = input.LA(1);

            if ( (LA112_0==AMP||(LA112_0 >= BANG && LA112_0 <= BASE)||LA112_0==BOOL||LA112_0==BYTE||(LA112_0 >= CHAR && LA112_0 <= CHECKED)||LA112_0==DECIMAL||(LA112_0 >= DEFAULT && LA112_0 <= DELEGATE)||LA112_0==DOUBLE||LA112_0==FALSE||LA112_0==FLOAT||LA112_0==IDENTIFIER||(LA112_0 >= INT && LA112_0 <= INTEGER_LITERAL)||LA112_0==LONG||LA112_0==MINUS||LA112_0==NEW||LA112_0==NULL||LA112_0==OBJECT||LA112_0==OPEN_PARENS||LA112_0==OP_DEC||LA112_0==OP_INC||LA112_0==PLUS||LA112_0==REAL_LITERAL||LA112_0==SBYTE||LA112_0==SHORT||LA112_0==SIZEOF||LA112_0==STAR||(LA112_0 >= STRING && LA112_0 <= STRING_LITERAL)||LA112_0==THIS||(LA112_0 >= TILDE && LA112_0 <= TRUE)||LA112_0==TYPEOF||(LA112_0 >= UINT && LA112_0 <= UNCHECKED)||LA112_0==USHORT) ) {
                alt112=1;
            }
            switch (alt112) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1150:72: for_iterator
                    {
                    pushFollow(FOLLOW_for_iterator_in_for_statement5667);
                    for_iterator576=for_iterator();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) stream_for_iterator.add(for_iterator576.getTree());

                    }
                    break;

            }


            CLOSE_PARENS577=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_for_statement5670); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_CLOSE_PARENS.add(CLOSE_PARENS577);


            pushFollow(FOLLOW_embedded_statement_in_for_statement5672);
            embedded_statement578=embedded_statement();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_embedded_statement.add(embedded_statement578.getTree());

            // AST REWRITE
            // elements: embedded_statement, for_iterator, FOR, for_condition, for_initializer
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 1151:4: -> ^( FOR ( ^( FOR_INITIALIZER for_initializer ) )? ( ^( CONDITION for_condition ) )? ( ^( FOR_ITERATOR for_iterator ) )? ^( LOOP_BODY embedded_statement ) )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1151:7: ^( FOR ( ^( FOR_INITIALIZER for_initializer ) )? ( ^( CONDITION for_condition ) )? ( ^( FOR_ITERATOR for_iterator ) )? ^( LOOP_BODY embedded_statement ) )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                stream_FOR.nextNode()
                , root_1);

                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1151:13: ( ^( FOR_INITIALIZER for_initializer ) )?
                if ( stream_for_initializer.hasNext() ) {
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1151:13: ^( FOR_INITIALIZER for_initializer )
                    {
                    Object root_2 = (Object)adaptor.nil();
                    root_2 = (Object)adaptor.becomeRoot(
                    (Object)adaptor.create(FOR_INITIALIZER, "FOR_INITIALIZER")
                    , root_2);

                    adaptor.addChild(root_2, stream_for_initializer.nextTree());

                    adaptor.addChild(root_1, root_2);
                    }

                }
                stream_for_initializer.reset();

                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1151:49: ( ^( CONDITION for_condition ) )?
                if ( stream_for_condition.hasNext() ) {
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1151:49: ^( CONDITION for_condition )
                    {
                    Object root_2 = (Object)adaptor.nil();
                    root_2 = (Object)adaptor.becomeRoot(
                    (Object)adaptor.create(CONDITION, "CONDITION")
                    , root_2);

                    adaptor.addChild(root_2, stream_for_condition.nextTree());

                    adaptor.addChild(root_1, root_2);
                    }

                }
                stream_for_condition.reset();

                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1152:12: ( ^( FOR_ITERATOR for_iterator ) )?
                if ( stream_for_iterator.hasNext() ) {
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1152:12: ^( FOR_ITERATOR for_iterator )
                    {
                    Object root_2 = (Object)adaptor.nil();
                    root_2 = (Object)adaptor.becomeRoot(
                    (Object)adaptor.create(FOR_ITERATOR, "FOR_ITERATOR")
                    , root_2);

                    adaptor.addChild(root_2, stream_for_iterator.nextTree());

                    adaptor.addChild(root_1, root_2);
                    }

                }
                stream_for_iterator.reset();

                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1152:43: ^( LOOP_BODY embedded_statement )
                {
                Object root_2 = (Object)adaptor.nil();
                root_2 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(LOOP_BODY, "LOOP_BODY")
                , root_2);

                adaptor.addChild(root_2, stream_embedded_statement.nextTree());

                adaptor.addChild(root_1, root_2);
                }

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "for_statement"


    public static class for_initializer_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "for_initializer"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1154:1: for_initializer : ( ( local_variable_declaration )=> local_variable_declaration | statement_expression_list );
    public final CSharp4AST.for_initializer_return for_initializer() throws RecognitionException {
        CSharp4AST.for_initializer_return retval = new CSharp4AST.for_initializer_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.local_variable_declaration_return local_variable_declaration579 =null;

        CSharp4AST.statement_expression_list_return statement_expression_list580 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1155:2: ( ( local_variable_declaration )=> local_variable_declaration | statement_expression_list )
            int alt113=2;
            int LA113_0 = input.LA(1);

            if ( (LA113_0==BYTE||LA113_0==CHAR||LA113_0==INT||LA113_0==LONG||LA113_0==SBYTE||LA113_0==SHORT||(LA113_0 >= UINT && LA113_0 <= ULONG)||LA113_0==USHORT) ) {
                int LA113_1 = input.LA(2);

                if ( (synpred17_CSharp4AST()) ) {
                    alt113=1;
                }
                else if ( (true) ) {
                    alt113=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 113, 1, input);

                    throw nvae;

                }
            }
            else if ( (LA113_0==DOUBLE||LA113_0==FLOAT) ) {
                int LA113_2 = input.LA(2);

                if ( (synpred17_CSharp4AST()) ) {
                    alt113=1;
                }
                else if ( (true) ) {
                    alt113=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 113, 2, input);

                    throw nvae;

                }
            }
            else if ( (LA113_0==DECIMAL) ) {
                int LA113_3 = input.LA(2);

                if ( (synpred17_CSharp4AST()) ) {
                    alt113=1;
                }
                else if ( (true) ) {
                    alt113=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 113, 3, input);

                    throw nvae;

                }
            }
            else if ( (LA113_0==BOOL) ) {
                int LA113_4 = input.LA(2);

                if ( (synpred17_CSharp4AST()) ) {
                    alt113=1;
                }
                else if ( (true) ) {
                    alt113=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 113, 4, input);

                    throw nvae;

                }
            }
            else if ( (LA113_0==IDENTIFIER) ) {
                int LA113_5 = input.LA(2);

                if ( (synpred17_CSharp4AST()) ) {
                    alt113=1;
                }
                else if ( (true) ) {
                    alt113=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 113, 5, input);

                    throw nvae;

                }
            }
            else if ( (LA113_0==OBJECT) ) {
                int LA113_6 = input.LA(2);

                if ( (synpred17_CSharp4AST()) ) {
                    alt113=1;
                }
                else if ( (true) ) {
                    alt113=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 113, 6, input);

                    throw nvae;

                }
            }
            else if ( (LA113_0==STRING) ) {
                int LA113_7 = input.LA(2);

                if ( (synpred17_CSharp4AST()) ) {
                    alt113=1;
                }
                else if ( (true) ) {
                    alt113=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 113, 7, input);

                    throw nvae;

                }
            }
            else if ( (LA113_0==VOID) && (synpred17_CSharp4AST())) {
                alt113=1;
            }
            else if ( (LA113_0==AMP||(LA113_0 >= BANG && LA113_0 <= BASE)||(LA113_0 >= CHARACTER_LITERAL && LA113_0 <= CHECKED)||(LA113_0 >= DEFAULT && LA113_0 <= DELEGATE)||LA113_0==FALSE||LA113_0==INTEGER_LITERAL||LA113_0==MINUS||LA113_0==NEW||LA113_0==NULL||LA113_0==OPEN_PARENS||LA113_0==OP_DEC||LA113_0==OP_INC||LA113_0==PLUS||LA113_0==REAL_LITERAL||LA113_0==SIZEOF||LA113_0==STAR||LA113_0==STRING_LITERAL||LA113_0==THIS||(LA113_0 >= TILDE && LA113_0 <= TRUE)||LA113_0==TYPEOF||LA113_0==UNCHECKED) ) {
                alt113=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 113, 0, input);

                throw nvae;

            }
            switch (alt113) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1155:4: ( local_variable_declaration )=> local_variable_declaration
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_local_variable_declaration_in_for_initializer5739);
                    local_variable_declaration579=local_variable_declaration();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, local_variable_declaration579.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1156:4: statement_expression_list
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_statement_expression_list_in_for_initializer5744);
                    statement_expression_list580=statement_expression_list();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, statement_expression_list580.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "for_initializer"


    public static class for_condition_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "for_condition"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1158:1: for_condition : boolean_expression ;
    public final CSharp4AST.for_condition_return for_condition() throws RecognitionException {
        CSharp4AST.for_condition_return retval = new CSharp4AST.for_condition_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.boolean_expression_return boolean_expression581 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1159:2: ( boolean_expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1159:4: boolean_expression
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_boolean_expression_in_for_condition5755);
            boolean_expression581=boolean_expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, boolean_expression581.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "for_condition"


    public static class for_iterator_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "for_iterator"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1161:1: for_iterator : statement_expression_list ;
    public final CSharp4AST.for_iterator_return for_iterator() throws RecognitionException {
        CSharp4AST.for_iterator_return retval = new CSharp4AST.for_iterator_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.statement_expression_list_return statement_expression_list582 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1162:2: ( statement_expression_list )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1162:4: statement_expression_list
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_statement_expression_list_in_for_iterator5766);
            statement_expression_list582=statement_expression_list();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, statement_expression_list582.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "for_iterator"


    public static class statement_expression_list_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "statement_expression_list"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1164:1: statement_expression_list : statement_expression ( COMMA statement_expression )* ;
    public final CSharp4AST.statement_expression_list_return statement_expression_list() throws RecognitionException {
        CSharp4AST.statement_expression_list_return retval = new CSharp4AST.statement_expression_list_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token COMMA584=null;
        CSharp4AST.statement_expression_return statement_expression583 =null;

        CSharp4AST.statement_expression_return statement_expression585 =null;


        Object COMMA584_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1165:2: ( statement_expression ( COMMA statement_expression )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1165:4: statement_expression ( COMMA statement_expression )*
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_statement_expression_in_statement_expression_list5777);
            statement_expression583=statement_expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, statement_expression583.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1165:25: ( COMMA statement_expression )*
            loop114:
            do {
                int alt114=2;
                int LA114_0 = input.LA(1);

                if ( (LA114_0==COMMA) ) {
                    alt114=1;
                }


                switch (alt114) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1165:27: COMMA statement_expression
            	    {
            	    COMMA584=(Token)match(input,COMMA,FOLLOW_COMMA_in_statement_expression_list5781); if (state.failed) return retval;
            	    if ( state.backtracking==0 ) {
            	    COMMA584_tree = 
            	    (Object)adaptor.create(COMMA584)
            	    ;
            	    adaptor.addChild(root_0, COMMA584_tree);
            	    }

            	    pushFollow(FOLLOW_statement_expression_in_statement_expression_list5784);
            	    statement_expression585=statement_expression();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, statement_expression585.getTree());

            	    }
            	    break;

            	default :
            	    break loop114;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "statement_expression_list"


    public static class foreach_statement_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "foreach_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1167:1: foreach_statement : FOREACH OPEN_PARENS local_variable_type IDENTIFIER IN expression CLOSE_PARENS embedded_statement -> ^( FOREACH local_variable_type IDENTIFIER ^( IN expression ) embedded_statement ) ;
    public final CSharp4AST.foreach_statement_return foreach_statement() throws RecognitionException {
        CSharp4AST.foreach_statement_return retval = new CSharp4AST.foreach_statement_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token FOREACH586=null;
        Token OPEN_PARENS587=null;
        Token IDENTIFIER589=null;
        Token IN590=null;
        Token CLOSE_PARENS592=null;
        CSharp4AST.local_variable_type_return local_variable_type588 =null;

        CSharp4AST.expression_return expression591 =null;

        CSharp4AST.embedded_statement_return embedded_statement593 =null;


        Object FOREACH586_tree=null;
        Object OPEN_PARENS587_tree=null;
        Object IDENTIFIER589_tree=null;
        Object IN590_tree=null;
        Object CLOSE_PARENS592_tree=null;
        RewriteRuleTokenStream stream_FOREACH=new RewriteRuleTokenStream(adaptor,"token FOREACH");
        RewriteRuleTokenStream stream_IN=new RewriteRuleTokenStream(adaptor,"token IN");
        RewriteRuleTokenStream stream_IDENTIFIER=new RewriteRuleTokenStream(adaptor,"token IDENTIFIER");
        RewriteRuleTokenStream stream_OPEN_PARENS=new RewriteRuleTokenStream(adaptor,"token OPEN_PARENS");
        RewriteRuleTokenStream stream_CLOSE_PARENS=new RewriteRuleTokenStream(adaptor,"token CLOSE_PARENS");
        RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
        RewriteRuleSubtreeStream stream_local_variable_type=new RewriteRuleSubtreeStream(adaptor,"rule local_variable_type");
        RewriteRuleSubtreeStream stream_embedded_statement=new RewriteRuleSubtreeStream(adaptor,"rule embedded_statement");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1168:2: ( FOREACH OPEN_PARENS local_variable_type IDENTIFIER IN expression CLOSE_PARENS embedded_statement -> ^( FOREACH local_variable_type IDENTIFIER ^( IN expression ) embedded_statement ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1168:4: FOREACH OPEN_PARENS local_variable_type IDENTIFIER IN expression CLOSE_PARENS embedded_statement
            {
            FOREACH586=(Token)match(input,FOREACH,FOLLOW_FOREACH_in_foreach_statement5798); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_FOREACH.add(FOREACH586);


            OPEN_PARENS587=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_foreach_statement5800); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_OPEN_PARENS.add(OPEN_PARENS587);


            pushFollow(FOLLOW_local_variable_type_in_foreach_statement5802);
            local_variable_type588=local_variable_type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_local_variable_type.add(local_variable_type588.getTree());

            IDENTIFIER589=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_foreach_statement5804); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_IDENTIFIER.add(IDENTIFIER589);


            IN590=(Token)match(input,IN,FOLLOW_IN_in_foreach_statement5806); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_IN.add(IN590);


            pushFollow(FOLLOW_expression_in_foreach_statement5808);
            expression591=expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_expression.add(expression591.getTree());

            CLOSE_PARENS592=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_foreach_statement5810); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_CLOSE_PARENS.add(CLOSE_PARENS592);


            pushFollow(FOLLOW_embedded_statement_in_foreach_statement5812);
            embedded_statement593=embedded_statement();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_embedded_statement.add(embedded_statement593.getTree());

            // AST REWRITE
            // elements: embedded_statement, expression, IDENTIFIER, local_variable_type, FOREACH, IN
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 1169:4: -> ^( FOREACH local_variable_type IDENTIFIER ^( IN expression ) embedded_statement )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1169:7: ^( FOREACH local_variable_type IDENTIFIER ^( IN expression ) embedded_statement )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                stream_FOREACH.nextNode()
                , root_1);

                adaptor.addChild(root_1, stream_local_variable_type.nextTree());

                adaptor.addChild(root_1, 
                stream_IDENTIFIER.nextNode()
                );

                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1169:49: ^( IN expression )
                {
                Object root_2 = (Object)adaptor.nil();
                root_2 = (Object)adaptor.becomeRoot(
                stream_IN.nextNode()
                , root_2);

                adaptor.addChild(root_2, stream_expression.nextTree());

                adaptor.addChild(root_1, root_2);
                }

                adaptor.addChild(root_1, stream_embedded_statement.nextTree());

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "foreach_statement"


    public static class jump_statement_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "jump_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1171:1: jump_statement : ( break_statement | continue_statement | goto_statement | return_statement | throw_statement );
    public final CSharp4AST.jump_statement_return jump_statement() throws RecognitionException {
        CSharp4AST.jump_statement_return retval = new CSharp4AST.jump_statement_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.break_statement_return break_statement594 =null;

        CSharp4AST.continue_statement_return continue_statement595 =null;

        CSharp4AST.goto_statement_return goto_statement596 =null;

        CSharp4AST.return_statement_return return_statement597 =null;

        CSharp4AST.throw_statement_return throw_statement598 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1172:2: ( break_statement | continue_statement | goto_statement | return_statement | throw_statement )
            int alt115=5;
            switch ( input.LA(1) ) {
            case BREAK:
                {
                alt115=1;
                }
                break;
            case CONTINUE:
                {
                alt115=2;
                }
                break;
            case GOTO:
                {
                alt115=3;
                }
                break;
            case RETURN:
                {
                alt115=4;
                }
                break;
            case THROW:
                {
                alt115=5;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 115, 0, input);

                throw nvae;

            }

            switch (alt115) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1172:4: break_statement
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_break_statement_in_jump_statement5846);
                    break_statement594=break_statement();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, break_statement594.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1173:4: continue_statement
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_continue_statement_in_jump_statement5851);
                    continue_statement595=continue_statement();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, continue_statement595.getTree());

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1174:4: goto_statement
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_goto_statement_in_jump_statement5856);
                    goto_statement596=goto_statement();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, goto_statement596.getTree());

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1175:4: return_statement
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_return_statement_in_jump_statement5861);
                    return_statement597=return_statement();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, return_statement597.getTree());

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1176:4: throw_statement
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_throw_statement_in_jump_statement5866);
                    throw_statement598=throw_statement();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, throw_statement598.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "jump_statement"


    public static class break_statement_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "break_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1178:1: break_statement : BREAK ^ SEMICOLON !;
    public final CSharp4AST.break_statement_return break_statement() throws RecognitionException {
        CSharp4AST.break_statement_return retval = new CSharp4AST.break_statement_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token BREAK599=null;
        Token SEMICOLON600=null;

        Object BREAK599_tree=null;
        Object SEMICOLON600_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1179:2: ( BREAK ^ SEMICOLON !)
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1179:4: BREAK ^ SEMICOLON !
            {
            root_0 = (Object)adaptor.nil();


            BREAK599=(Token)match(input,BREAK,FOLLOW_BREAK_in_break_statement5877); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            BREAK599_tree = 
            (Object)adaptor.create(BREAK599)
            ;
            root_0 = (Object)adaptor.becomeRoot(BREAK599_tree, root_0);
            }

            SEMICOLON600=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_break_statement5880); if (state.failed) return retval;

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "break_statement"


    public static class continue_statement_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "continue_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1181:1: continue_statement : CONTINUE ^ SEMICOLON !;
    public final CSharp4AST.continue_statement_return continue_statement() throws RecognitionException {
        CSharp4AST.continue_statement_return retval = new CSharp4AST.continue_statement_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token CONTINUE601=null;
        Token SEMICOLON602=null;

        Object CONTINUE601_tree=null;
        Object SEMICOLON602_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1182:2: ( CONTINUE ^ SEMICOLON !)
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1182:4: CONTINUE ^ SEMICOLON !
            {
            root_0 = (Object)adaptor.nil();


            CONTINUE601=(Token)match(input,CONTINUE,FOLLOW_CONTINUE_in_continue_statement5892); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            CONTINUE601_tree = 
            (Object)adaptor.create(CONTINUE601)
            ;
            root_0 = (Object)adaptor.becomeRoot(CONTINUE601_tree, root_0);
            }

            SEMICOLON602=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_continue_statement5895); if (state.failed) return retval;

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "continue_statement"


    public static class goto_statement_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "goto_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1184:1: goto_statement : ( GOTO ^ IDENTIFIER SEMICOLON | GOTO ^ CASE constant_expression SEMICOLON | GOTO ^ DEFAULT SEMICOLON );
    public final CSharp4AST.goto_statement_return goto_statement() throws RecognitionException {
        CSharp4AST.goto_statement_return retval = new CSharp4AST.goto_statement_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token GOTO603=null;
        Token IDENTIFIER604=null;
        Token SEMICOLON605=null;
        Token GOTO606=null;
        Token CASE607=null;
        Token SEMICOLON609=null;
        Token GOTO610=null;
        Token DEFAULT611=null;
        Token SEMICOLON612=null;
        CSharp4AST.constant_expression_return constant_expression608 =null;


        Object GOTO603_tree=null;
        Object IDENTIFIER604_tree=null;
        Object SEMICOLON605_tree=null;
        Object GOTO606_tree=null;
        Object CASE607_tree=null;
        Object SEMICOLON609_tree=null;
        Object GOTO610_tree=null;
        Object DEFAULT611_tree=null;
        Object SEMICOLON612_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1185:2: ( GOTO ^ IDENTIFIER SEMICOLON | GOTO ^ CASE constant_expression SEMICOLON | GOTO ^ DEFAULT SEMICOLON )
            int alt116=3;
            int LA116_0 = input.LA(1);

            if ( (LA116_0==GOTO) ) {
                switch ( input.LA(2) ) {
                case IDENTIFIER:
                    {
                    alt116=1;
                    }
                    break;
                case CASE:
                    {
                    alt116=2;
                    }
                    break;
                case DEFAULT:
                    {
                    alt116=3;
                    }
                    break;
                default:
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 116, 1, input);

                    throw nvae;

                }

            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 116, 0, input);

                throw nvae;

            }
            switch (alt116) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1185:4: GOTO ^ IDENTIFIER SEMICOLON
                    {
                    root_0 = (Object)adaptor.nil();


                    GOTO603=(Token)match(input,GOTO,FOLLOW_GOTO_in_goto_statement5907); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    GOTO603_tree = 
                    (Object)adaptor.create(GOTO603)
                    ;
                    root_0 = (Object)adaptor.becomeRoot(GOTO603_tree, root_0);
                    }

                    IDENTIFIER604=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_goto_statement5910); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    IDENTIFIER604_tree = 
                    (Object)adaptor.create(IDENTIFIER604)
                    ;
                    adaptor.addChild(root_0, IDENTIFIER604_tree);
                    }

                    SEMICOLON605=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_goto_statement5912); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    SEMICOLON605_tree = 
                    (Object)adaptor.create(SEMICOLON605)
                    ;
                    adaptor.addChild(root_0, SEMICOLON605_tree);
                    }

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1186:4: GOTO ^ CASE constant_expression SEMICOLON
                    {
                    root_0 = (Object)adaptor.nil();


                    GOTO606=(Token)match(input,GOTO,FOLLOW_GOTO_in_goto_statement5917); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    GOTO606_tree = 
                    (Object)adaptor.create(GOTO606)
                    ;
                    root_0 = (Object)adaptor.becomeRoot(GOTO606_tree, root_0);
                    }

                    CASE607=(Token)match(input,CASE,FOLLOW_CASE_in_goto_statement5920); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    CASE607_tree = 
                    (Object)adaptor.create(CASE607)
                    ;
                    adaptor.addChild(root_0, CASE607_tree);
                    }

                    pushFollow(FOLLOW_constant_expression_in_goto_statement5922);
                    constant_expression608=constant_expression();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, constant_expression608.getTree());

                    SEMICOLON609=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_goto_statement5924); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    SEMICOLON609_tree = 
                    (Object)adaptor.create(SEMICOLON609)
                    ;
                    adaptor.addChild(root_0, SEMICOLON609_tree);
                    }

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1187:4: GOTO ^ DEFAULT SEMICOLON
                    {
                    root_0 = (Object)adaptor.nil();


                    GOTO610=(Token)match(input,GOTO,FOLLOW_GOTO_in_goto_statement5929); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    GOTO610_tree = 
                    (Object)adaptor.create(GOTO610)
                    ;
                    root_0 = (Object)adaptor.becomeRoot(GOTO610_tree, root_0);
                    }

                    DEFAULT611=(Token)match(input,DEFAULT,FOLLOW_DEFAULT_in_goto_statement5932); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    DEFAULT611_tree = 
                    (Object)adaptor.create(DEFAULT611)
                    ;
                    adaptor.addChild(root_0, DEFAULT611_tree);
                    }

                    SEMICOLON612=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_goto_statement5934); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    SEMICOLON612_tree = 
                    (Object)adaptor.create(SEMICOLON612)
                    ;
                    adaptor.addChild(root_0, SEMICOLON612_tree);
                    }

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "goto_statement"


    public static class return_statement_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "return_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1189:1: return_statement : RETURN ^ ( expression )? SEMICOLON !;
    public final CSharp4AST.return_statement_return return_statement() throws RecognitionException {
        CSharp4AST.return_statement_return retval = new CSharp4AST.return_statement_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token RETURN613=null;
        Token SEMICOLON615=null;
        CSharp4AST.expression_return expression614 =null;


        Object RETURN613_tree=null;
        Object SEMICOLON615_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1190:2: ( RETURN ^ ( expression )? SEMICOLON !)
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1190:4: RETURN ^ ( expression )? SEMICOLON !
            {
            root_0 = (Object)adaptor.nil();


            RETURN613=(Token)match(input,RETURN,FOLLOW_RETURN_in_return_statement5945); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            RETURN613_tree = 
            (Object)adaptor.create(RETURN613)
            ;
            root_0 = (Object)adaptor.becomeRoot(RETURN613_tree, root_0);
            }

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1190:12: ( expression )?
            int alt117=2;
            int LA117_0 = input.LA(1);

            if ( (LA117_0==AMP||(LA117_0 >= BANG && LA117_0 <= BASE)||LA117_0==BOOL||LA117_0==BYTE||(LA117_0 >= CHAR && LA117_0 <= CHECKED)||LA117_0==DECIMAL||(LA117_0 >= DEFAULT && LA117_0 <= DELEGATE)||LA117_0==DOUBLE||LA117_0==FALSE||LA117_0==FLOAT||LA117_0==IDENTIFIER||(LA117_0 >= INT && LA117_0 <= INTEGER_LITERAL)||LA117_0==LONG||LA117_0==MINUS||LA117_0==NEW||LA117_0==NULL||LA117_0==OBJECT||LA117_0==OPEN_PARENS||LA117_0==OP_DEC||LA117_0==OP_INC||LA117_0==PLUS||LA117_0==REAL_LITERAL||LA117_0==SBYTE||LA117_0==SHORT||LA117_0==SIZEOF||LA117_0==STAR||(LA117_0 >= STRING && LA117_0 <= STRING_LITERAL)||LA117_0==THIS||(LA117_0 >= TILDE && LA117_0 <= TRUE)||LA117_0==TYPEOF||(LA117_0 >= UINT && LA117_0 <= UNCHECKED)||LA117_0==USHORT) ) {
                alt117=1;
            }
            switch (alt117) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1190:12: expression
                    {
                    pushFollow(FOLLOW_expression_in_return_statement5948);
                    expression614=expression();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, expression614.getTree());

                    }
                    break;

            }


            SEMICOLON615=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_return_statement5951); if (state.failed) return retval;

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "return_statement"


    public static class throw_statement_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "throw_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1192:1: throw_statement : THROW ^ ( expression )? SEMICOLON !;
    public final CSharp4AST.throw_statement_return throw_statement() throws RecognitionException {
        CSharp4AST.throw_statement_return retval = new CSharp4AST.throw_statement_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token THROW616=null;
        Token SEMICOLON618=null;
        CSharp4AST.expression_return expression617 =null;


        Object THROW616_tree=null;
        Object SEMICOLON618_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1193:2: ( THROW ^ ( expression )? SEMICOLON !)
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1193:4: THROW ^ ( expression )? SEMICOLON !
            {
            root_0 = (Object)adaptor.nil();


            THROW616=(Token)match(input,THROW,FOLLOW_THROW_in_throw_statement5963); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            THROW616_tree = 
            (Object)adaptor.create(THROW616)
            ;
            root_0 = (Object)adaptor.becomeRoot(THROW616_tree, root_0);
            }

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1193:11: ( expression )?
            int alt118=2;
            int LA118_0 = input.LA(1);

            if ( (LA118_0==AMP||(LA118_0 >= BANG && LA118_0 <= BASE)||LA118_0==BOOL||LA118_0==BYTE||(LA118_0 >= CHAR && LA118_0 <= CHECKED)||LA118_0==DECIMAL||(LA118_0 >= DEFAULT && LA118_0 <= DELEGATE)||LA118_0==DOUBLE||LA118_0==FALSE||LA118_0==FLOAT||LA118_0==IDENTIFIER||(LA118_0 >= INT && LA118_0 <= INTEGER_LITERAL)||LA118_0==LONG||LA118_0==MINUS||LA118_0==NEW||LA118_0==NULL||LA118_0==OBJECT||LA118_0==OPEN_PARENS||LA118_0==OP_DEC||LA118_0==OP_INC||LA118_0==PLUS||LA118_0==REAL_LITERAL||LA118_0==SBYTE||LA118_0==SHORT||LA118_0==SIZEOF||LA118_0==STAR||(LA118_0 >= STRING && LA118_0 <= STRING_LITERAL)||LA118_0==THIS||(LA118_0 >= TILDE && LA118_0 <= TRUE)||LA118_0==TYPEOF||(LA118_0 >= UINT && LA118_0 <= UNCHECKED)||LA118_0==USHORT) ) {
                alt118=1;
            }
            switch (alt118) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1193:11: expression
                    {
                    pushFollow(FOLLOW_expression_in_throw_statement5966);
                    expression617=expression();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, expression617.getTree());

                    }
                    break;

            }


            SEMICOLON618=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_throw_statement5969); if (state.failed) return retval;

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "throw_statement"


    public static class try_statement_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "try_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1202:1: try_statement : TRY ^ block ( catch_clauses )? ( finally_clause )? ;
    public final CSharp4AST.try_statement_return try_statement() throws RecognitionException {
        CSharp4AST.try_statement_return retval = new CSharp4AST.try_statement_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token TRY619=null;
        CSharp4AST.block_return block620 =null;

        CSharp4AST.catch_clauses_return catch_clauses621 =null;

        CSharp4AST.finally_clause_return finally_clause622 =null;


        Object TRY619_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1203:3: ( TRY ^ block ( catch_clauses )? ( finally_clause )? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1203:5: TRY ^ block ( catch_clauses )? ( finally_clause )?
            {
            root_0 = (Object)adaptor.nil();


            TRY619=(Token)match(input,TRY,FOLLOW_TRY_in_try_statement5984); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            TRY619_tree = 
            (Object)adaptor.create(TRY619)
            ;
            root_0 = (Object)adaptor.becomeRoot(TRY619_tree, root_0);
            }

            pushFollow(FOLLOW_block_in_try_statement5987);
            block620=block();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, block620.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1203:16: ( catch_clauses )?
            int alt119=2;
            int LA119_0 = input.LA(1);

            if ( (LA119_0==CATCH) ) {
                alt119=1;
            }
            switch (alt119) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1203:16: catch_clauses
                    {
                    pushFollow(FOLLOW_catch_clauses_in_try_statement5989);
                    catch_clauses621=catch_clauses();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, catch_clauses621.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1203:31: ( finally_clause )?
            int alt120=2;
            int LA120_0 = input.LA(1);

            if ( (LA120_0==FINALLY) ) {
                alt120=1;
            }
            switch (alt120) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1203:31: finally_clause
                    {
                    pushFollow(FOLLOW_finally_clause_in_try_statement5992);
                    finally_clause622=finally_clause();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, finally_clause622.getTree());

                    }
                    break;

            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "try_statement"


    public static class catch_clauses_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "catch_clauses"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1211:1: catch_clauses : ( specific_catch_clauses ( general_catch_clause )? | general_catch_clause );
    public final CSharp4AST.catch_clauses_return catch_clauses() throws RecognitionException {
        CSharp4AST.catch_clauses_return retval = new CSharp4AST.catch_clauses_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.specific_catch_clauses_return specific_catch_clauses623 =null;

        CSharp4AST.general_catch_clause_return general_catch_clause624 =null;

        CSharp4AST.general_catch_clause_return general_catch_clause625 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1212:3: ( specific_catch_clauses ( general_catch_clause )? | general_catch_clause )
            int alt122=2;
            int LA122_0 = input.LA(1);

            if ( (LA122_0==CATCH) ) {
                int LA122_1 = input.LA(2);

                if ( (LA122_1==OPEN_PARENS) ) {
                    alt122=1;
                }
                else if ( (LA122_1==OPEN_BRACE) ) {
                    alt122=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 122, 1, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 122, 0, input);

                throw nvae;

            }
            switch (alt122) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1212:5: specific_catch_clauses ( general_catch_clause )?
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_specific_catch_clauses_in_catch_clauses6008);
                    specific_catch_clauses623=specific_catch_clauses();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, specific_catch_clauses623.getTree());

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1212:28: ( general_catch_clause )?
                    int alt121=2;
                    int LA121_0 = input.LA(1);

                    if ( (LA121_0==CATCH) ) {
                        alt121=1;
                    }
                    switch (alt121) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1212:28: general_catch_clause
                            {
                            pushFollow(FOLLOW_general_catch_clause_in_catch_clauses6010);
                            general_catch_clause624=general_catch_clause();

                            state._fsp--;
                            if (state.failed) return retval;
                            if ( state.backtracking==0 ) adaptor.addChild(root_0, general_catch_clause624.getTree());

                            }
                            break;

                    }


                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1213:5: general_catch_clause
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_general_catch_clause_in_catch_clauses6017);
                    general_catch_clause625=general_catch_clause();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, general_catch_clause625.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "catch_clauses"


    public static class specific_catch_clauses_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "specific_catch_clauses"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1215:1: specific_catch_clauses : specific_catch_clause ( specific_catch_clause )* ;
    public final CSharp4AST.specific_catch_clauses_return specific_catch_clauses() throws RecognitionException {
        CSharp4AST.specific_catch_clauses_return retval = new CSharp4AST.specific_catch_clauses_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.specific_catch_clause_return specific_catch_clause626 =null;

        CSharp4AST.specific_catch_clause_return specific_catch_clause627 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1216:2: ( specific_catch_clause ( specific_catch_clause )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1216:4: specific_catch_clause ( specific_catch_clause )*
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_specific_catch_clause_in_specific_catch_clauses6029);
            specific_catch_clause626=specific_catch_clause();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, specific_catch_clause626.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1216:26: ( specific_catch_clause )*
            loop123:
            do {
                int alt123=2;
                int LA123_0 = input.LA(1);

                if ( (LA123_0==CATCH) ) {
                    int LA123_1 = input.LA(2);

                    if ( (LA123_1==OPEN_PARENS) ) {
                        alt123=1;
                    }


                }


                switch (alt123) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1216:28: specific_catch_clause
            	    {
            	    pushFollow(FOLLOW_specific_catch_clause_in_specific_catch_clauses6033);
            	    specific_catch_clause627=specific_catch_clause();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, specific_catch_clause627.getTree());

            	    }
            	    break;

            	default :
            	    break loop123;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "specific_catch_clauses"


    public static class specific_catch_clause_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "specific_catch_clause"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1218:1: specific_catch_clause : CATCH ^ OPEN_PARENS class_type ( IDENTIFIER )? CLOSE_PARENS block ;
    public final CSharp4AST.specific_catch_clause_return specific_catch_clause() throws RecognitionException {
        CSharp4AST.specific_catch_clause_return retval = new CSharp4AST.specific_catch_clause_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token CATCH628=null;
        Token OPEN_PARENS629=null;
        Token IDENTIFIER631=null;
        Token CLOSE_PARENS632=null;
        CSharp4AST.class_type_return class_type630 =null;

        CSharp4AST.block_return block633 =null;


        Object CATCH628_tree=null;
        Object OPEN_PARENS629_tree=null;
        Object IDENTIFIER631_tree=null;
        Object CLOSE_PARENS632_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1219:2: ( CATCH ^ OPEN_PARENS class_type ( IDENTIFIER )? CLOSE_PARENS block )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1219:4: CATCH ^ OPEN_PARENS class_type ( IDENTIFIER )? CLOSE_PARENS block
            {
            root_0 = (Object)adaptor.nil();


            CATCH628=(Token)match(input,CATCH,FOLLOW_CATCH_in_specific_catch_clause6047); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            CATCH628_tree = 
            (Object)adaptor.create(CATCH628)
            ;
            root_0 = (Object)adaptor.becomeRoot(CATCH628_tree, root_0);
            }

            OPEN_PARENS629=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_specific_catch_clause6050); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            OPEN_PARENS629_tree = 
            (Object)adaptor.create(OPEN_PARENS629)
            ;
            adaptor.addChild(root_0, OPEN_PARENS629_tree);
            }

            pushFollow(FOLLOW_class_type_in_specific_catch_clause6052);
            class_type630=class_type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, class_type630.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1219:34: ( IDENTIFIER )?
            int alt124=2;
            int LA124_0 = input.LA(1);

            if ( (LA124_0==IDENTIFIER) ) {
                alt124=1;
            }
            switch (alt124) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1219:34: IDENTIFIER
                    {
                    IDENTIFIER631=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_specific_catch_clause6054); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    IDENTIFIER631_tree = 
                    (Object)adaptor.create(IDENTIFIER631)
                    ;
                    adaptor.addChild(root_0, IDENTIFIER631_tree);
                    }

                    }
                    break;

            }


            CLOSE_PARENS632=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_specific_catch_clause6057); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            CLOSE_PARENS632_tree = 
            (Object)adaptor.create(CLOSE_PARENS632)
            ;
            adaptor.addChild(root_0, CLOSE_PARENS632_tree);
            }

            pushFollow(FOLLOW_block_in_specific_catch_clause6059);
            block633=block();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, block633.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "specific_catch_clause"


    public static class general_catch_clause_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "general_catch_clause"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1221:1: general_catch_clause : CATCH ^ block ;
    public final CSharp4AST.general_catch_clause_return general_catch_clause() throws RecognitionException {
        CSharp4AST.general_catch_clause_return retval = new CSharp4AST.general_catch_clause_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token CATCH634=null;
        CSharp4AST.block_return block635 =null;


        Object CATCH634_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1222:2: ( CATCH ^ block )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1222:4: CATCH ^ block
            {
            root_0 = (Object)adaptor.nil();


            CATCH634=(Token)match(input,CATCH,FOLLOW_CATCH_in_general_catch_clause6070); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            CATCH634_tree = 
            (Object)adaptor.create(CATCH634)
            ;
            root_0 = (Object)adaptor.becomeRoot(CATCH634_tree, root_0);
            }

            pushFollow(FOLLOW_block_in_general_catch_clause6073);
            block635=block();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, block635.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "general_catch_clause"


    public static class finally_clause_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "finally_clause"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1224:1: finally_clause : FINALLY ^ block ;
    public final CSharp4AST.finally_clause_return finally_clause() throws RecognitionException {
        CSharp4AST.finally_clause_return retval = new CSharp4AST.finally_clause_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token FINALLY636=null;
        CSharp4AST.block_return block637 =null;


        Object FINALLY636_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1225:2: ( FINALLY ^ block )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1225:4: FINALLY ^ block
            {
            root_0 = (Object)adaptor.nil();


            FINALLY636=(Token)match(input,FINALLY,FOLLOW_FINALLY_in_finally_clause6084); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            FINALLY636_tree = 
            (Object)adaptor.create(FINALLY636)
            ;
            root_0 = (Object)adaptor.becomeRoot(FINALLY636_tree, root_0);
            }

            pushFollow(FOLLOW_block_in_finally_clause6087);
            block637=block();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, block637.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "finally_clause"


    public static class checked_statement_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "checked_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1227:1: checked_statement : CHECKED ^ block ;
    public final CSharp4AST.checked_statement_return checked_statement() throws RecognitionException {
        CSharp4AST.checked_statement_return retval = new CSharp4AST.checked_statement_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token CHECKED638=null;
        CSharp4AST.block_return block639 =null;


        Object CHECKED638_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1228:2: ( CHECKED ^ block )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1228:4: CHECKED ^ block
            {
            root_0 = (Object)adaptor.nil();


            CHECKED638=(Token)match(input,CHECKED,FOLLOW_CHECKED_in_checked_statement6098); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            CHECKED638_tree = 
            (Object)adaptor.create(CHECKED638)
            ;
            root_0 = (Object)adaptor.becomeRoot(CHECKED638_tree, root_0);
            }

            pushFollow(FOLLOW_block_in_checked_statement6101);
            block639=block();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, block639.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "checked_statement"


    public static class unchecked_statement_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "unchecked_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1230:1: unchecked_statement : UNCHECKED ^ block ;
    public final CSharp4AST.unchecked_statement_return unchecked_statement() throws RecognitionException {
        CSharp4AST.unchecked_statement_return retval = new CSharp4AST.unchecked_statement_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token UNCHECKED640=null;
        CSharp4AST.block_return block641 =null;


        Object UNCHECKED640_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1231:2: ( UNCHECKED ^ block )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1231:4: UNCHECKED ^ block
            {
            root_0 = (Object)adaptor.nil();


            UNCHECKED640=(Token)match(input,UNCHECKED,FOLLOW_UNCHECKED_in_unchecked_statement6112); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            UNCHECKED640_tree = 
            (Object)adaptor.create(UNCHECKED640)
            ;
            root_0 = (Object)adaptor.becomeRoot(UNCHECKED640_tree, root_0);
            }

            pushFollow(FOLLOW_block_in_unchecked_statement6115);
            block641=block();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, block641.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "unchecked_statement"


    public static class lock_statement_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "lock_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1233:1: lock_statement : LOCK ^ OPEN_PARENS expression CLOSE_PARENS embedded_statement ;
    public final CSharp4AST.lock_statement_return lock_statement() throws RecognitionException {
        CSharp4AST.lock_statement_return retval = new CSharp4AST.lock_statement_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token LOCK642=null;
        Token OPEN_PARENS643=null;
        Token CLOSE_PARENS645=null;
        CSharp4AST.expression_return expression644 =null;

        CSharp4AST.embedded_statement_return embedded_statement646 =null;


        Object LOCK642_tree=null;
        Object OPEN_PARENS643_tree=null;
        Object CLOSE_PARENS645_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1234:2: ( LOCK ^ OPEN_PARENS expression CLOSE_PARENS embedded_statement )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1234:4: LOCK ^ OPEN_PARENS expression CLOSE_PARENS embedded_statement
            {
            root_0 = (Object)adaptor.nil();


            LOCK642=(Token)match(input,LOCK,FOLLOW_LOCK_in_lock_statement6126); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            LOCK642_tree = 
            (Object)adaptor.create(LOCK642)
            ;
            root_0 = (Object)adaptor.becomeRoot(LOCK642_tree, root_0);
            }

            OPEN_PARENS643=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_lock_statement6129); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            OPEN_PARENS643_tree = 
            (Object)adaptor.create(OPEN_PARENS643)
            ;
            adaptor.addChild(root_0, OPEN_PARENS643_tree);
            }

            pushFollow(FOLLOW_expression_in_lock_statement6131);
            expression644=expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, expression644.getTree());

            CLOSE_PARENS645=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_lock_statement6133); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            CLOSE_PARENS645_tree = 
            (Object)adaptor.create(CLOSE_PARENS645)
            ;
            adaptor.addChild(root_0, CLOSE_PARENS645_tree);
            }

            pushFollow(FOLLOW_embedded_statement_in_lock_statement6135);
            embedded_statement646=embedded_statement();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, embedded_statement646.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "lock_statement"


    public static class using_statement_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "using_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1236:1: using_statement : USING ^ OPEN_PARENS resource_acquisition CLOSE_PARENS embedded_statement ;
    public final CSharp4AST.using_statement_return using_statement() throws RecognitionException {
        CSharp4AST.using_statement_return retval = new CSharp4AST.using_statement_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token USING647=null;
        Token OPEN_PARENS648=null;
        Token CLOSE_PARENS650=null;
        CSharp4AST.resource_acquisition_return resource_acquisition649 =null;

        CSharp4AST.embedded_statement_return embedded_statement651 =null;


        Object USING647_tree=null;
        Object OPEN_PARENS648_tree=null;
        Object CLOSE_PARENS650_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1237:2: ( USING ^ OPEN_PARENS resource_acquisition CLOSE_PARENS embedded_statement )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1237:4: USING ^ OPEN_PARENS resource_acquisition CLOSE_PARENS embedded_statement
            {
            root_0 = (Object)adaptor.nil();


            USING647=(Token)match(input,USING,FOLLOW_USING_in_using_statement6146); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            USING647_tree = 
            (Object)adaptor.create(USING647)
            ;
            root_0 = (Object)adaptor.becomeRoot(USING647_tree, root_0);
            }

            OPEN_PARENS648=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_using_statement6149); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            OPEN_PARENS648_tree = 
            (Object)adaptor.create(OPEN_PARENS648)
            ;
            adaptor.addChild(root_0, OPEN_PARENS648_tree);
            }

            pushFollow(FOLLOW_resource_acquisition_in_using_statement6151);
            resource_acquisition649=resource_acquisition();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, resource_acquisition649.getTree());

            CLOSE_PARENS650=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_using_statement6153); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            CLOSE_PARENS650_tree = 
            (Object)adaptor.create(CLOSE_PARENS650)
            ;
            adaptor.addChild(root_0, CLOSE_PARENS650_tree);
            }

            pushFollow(FOLLOW_embedded_statement_in_using_statement6155);
            embedded_statement651=embedded_statement();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, embedded_statement651.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "using_statement"


    public static class resource_acquisition_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "resource_acquisition"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1245:1: resource_acquisition : ( ( local_variable_declaration )=> local_variable_declaration | expression );
    public final CSharp4AST.resource_acquisition_return resource_acquisition() throws RecognitionException {
        CSharp4AST.resource_acquisition_return retval = new CSharp4AST.resource_acquisition_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.local_variable_declaration_return local_variable_declaration652 =null;

        CSharp4AST.expression_return expression653 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1246:2: ( ( local_variable_declaration )=> local_variable_declaration | expression )
            int alt125=2;
            int LA125_0 = input.LA(1);

            if ( (LA125_0==BYTE||LA125_0==CHAR||LA125_0==INT||LA125_0==LONG||LA125_0==SBYTE||LA125_0==SHORT||(LA125_0 >= UINT && LA125_0 <= ULONG)||LA125_0==USHORT) ) {
                int LA125_1 = input.LA(2);

                if ( (synpred18_CSharp4AST()) ) {
                    alt125=1;
                }
                else if ( (true) ) {
                    alt125=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 125, 1, input);

                    throw nvae;

                }
            }
            else if ( (LA125_0==DOUBLE||LA125_0==FLOAT) ) {
                int LA125_2 = input.LA(2);

                if ( (synpred18_CSharp4AST()) ) {
                    alt125=1;
                }
                else if ( (true) ) {
                    alt125=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 125, 2, input);

                    throw nvae;

                }
            }
            else if ( (LA125_0==DECIMAL) ) {
                int LA125_3 = input.LA(2);

                if ( (synpred18_CSharp4AST()) ) {
                    alt125=1;
                }
                else if ( (true) ) {
                    alt125=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 125, 3, input);

                    throw nvae;

                }
            }
            else if ( (LA125_0==BOOL) ) {
                int LA125_4 = input.LA(2);

                if ( (synpred18_CSharp4AST()) ) {
                    alt125=1;
                }
                else if ( (true) ) {
                    alt125=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 125, 4, input);

                    throw nvae;

                }
            }
            else if ( (LA125_0==IDENTIFIER) ) {
                int LA125_5 = input.LA(2);

                if ( (synpred18_CSharp4AST()) ) {
                    alt125=1;
                }
                else if ( (true) ) {
                    alt125=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 125, 5, input);

                    throw nvae;

                }
            }
            else if ( (LA125_0==OBJECT) ) {
                int LA125_6 = input.LA(2);

                if ( (synpred18_CSharp4AST()) ) {
                    alt125=1;
                }
                else if ( (true) ) {
                    alt125=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 125, 6, input);

                    throw nvae;

                }
            }
            else if ( (LA125_0==STRING) ) {
                int LA125_7 = input.LA(2);

                if ( (synpred18_CSharp4AST()) ) {
                    alt125=1;
                }
                else if ( (true) ) {
                    alt125=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 125, 7, input);

                    throw nvae;

                }
            }
            else if ( (LA125_0==VOID) && (synpred18_CSharp4AST())) {
                alt125=1;
            }
            else if ( (LA125_0==AMP||(LA125_0 >= BANG && LA125_0 <= BASE)||(LA125_0 >= CHARACTER_LITERAL && LA125_0 <= CHECKED)||(LA125_0 >= DEFAULT && LA125_0 <= DELEGATE)||LA125_0==FALSE||LA125_0==INTEGER_LITERAL||LA125_0==MINUS||LA125_0==NEW||LA125_0==NULL||LA125_0==OPEN_PARENS||LA125_0==OP_DEC||LA125_0==OP_INC||LA125_0==PLUS||LA125_0==REAL_LITERAL||LA125_0==SIZEOF||LA125_0==STAR||LA125_0==STRING_LITERAL||LA125_0==THIS||(LA125_0 >= TILDE && LA125_0 <= TRUE)||LA125_0==TYPEOF||LA125_0==UNCHECKED) ) {
                alt125=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 125, 0, input);

                throw nvae;

            }
            switch (alt125) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1246:4: ( local_variable_declaration )=> local_variable_declaration
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_local_variable_declaration_in_resource_acquisition6174);
                    local_variable_declaration652=local_variable_declaration();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, local_variable_declaration652.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1247:4: expression
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_expression_in_resource_acquisition6179);
                    expression653=expression();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, expression653.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "resource_acquisition"


    public static class yield_statement_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "yield_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1249:1: yield_statement : ( yield_contextual_keyword RETURN expression SEMICOLON | yield_contextual_keyword BREAK SEMICOLON );
    public final CSharp4AST.yield_statement_return yield_statement() throws RecognitionException {
        CSharp4AST.yield_statement_return retval = new CSharp4AST.yield_statement_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token RETURN655=null;
        Token SEMICOLON657=null;
        Token BREAK659=null;
        Token SEMICOLON660=null;
        CSharp4AST.yield_contextual_keyword_return yield_contextual_keyword654 =null;

        CSharp4AST.expression_return expression656 =null;

        CSharp4AST.yield_contextual_keyword_return yield_contextual_keyword658 =null;


        Object RETURN655_tree=null;
        Object SEMICOLON657_tree=null;
        Object BREAK659_tree=null;
        Object SEMICOLON660_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1250:2: ( yield_contextual_keyword RETURN expression SEMICOLON | yield_contextual_keyword BREAK SEMICOLON )
            int alt126=2;
            int LA126_0 = input.LA(1);

            if ( (LA126_0==IDENTIFIER) ) {
                int LA126_1 = input.LA(2);

                if ( (LA126_1==RETURN) ) {
                    alt126=1;
                }
                else if ( (LA126_1==BREAK) ) {
                    alt126=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 126, 1, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 126, 0, input);

                throw nvae;

            }
            switch (alt126) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1250:4: yield_contextual_keyword RETURN expression SEMICOLON
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_yield_contextual_keyword_in_yield_statement6190);
                    yield_contextual_keyword654=yield_contextual_keyword();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, yield_contextual_keyword654.getTree());

                    RETURN655=(Token)match(input,RETURN,FOLLOW_RETURN_in_yield_statement6192); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    RETURN655_tree = 
                    (Object)adaptor.create(RETURN655)
                    ;
                    adaptor.addChild(root_0, RETURN655_tree);
                    }

                    pushFollow(FOLLOW_expression_in_yield_statement6194);
                    expression656=expression();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, expression656.getTree());

                    SEMICOLON657=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_yield_statement6196); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    SEMICOLON657_tree = 
                    (Object)adaptor.create(SEMICOLON657)
                    ;
                    adaptor.addChild(root_0, SEMICOLON657_tree);
                    }

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1251:4: yield_contextual_keyword BREAK SEMICOLON
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_yield_contextual_keyword_in_yield_statement6201);
                    yield_contextual_keyword658=yield_contextual_keyword();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, yield_contextual_keyword658.getTree());

                    BREAK659=(Token)match(input,BREAK,FOLLOW_BREAK_in_yield_statement6203); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    BREAK659_tree = 
                    (Object)adaptor.create(BREAK659)
                    ;
                    adaptor.addChild(root_0, BREAK659_tree);
                    }

                    SEMICOLON660=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_yield_statement6205); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    SEMICOLON660_tree = 
                    (Object)adaptor.create(SEMICOLON660)
                    ;
                    adaptor.addChild(root_0, SEMICOLON660_tree);
                    }

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "yield_statement"


    public static class csharpSource_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "csharpSource"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1265:1: csharpSource : compilation_unit -> ^( CSHARP_SOURCE compilation_unit ) ;
    public final CSharp4AST.csharpSource_return csharpSource() throws RecognitionException {
        CSharp4AST.csharpSource_return retval = new CSharp4AST.csharpSource_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.compilation_unit_return compilation_unit661 =null;


        RewriteRuleSubtreeStream stream_compilation_unit=new RewriteRuleSubtreeStream(adaptor,"rule compilation_unit");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1266:5: ( compilation_unit -> ^( CSHARP_SOURCE compilation_unit ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1266:9: compilation_unit
            {
            pushFollow(FOLLOW_compilation_unit_in_csharpSource6229);
            compilation_unit661=compilation_unit();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_compilation_unit.add(compilation_unit661.getTree());

            // AST REWRITE
            // elements: compilation_unit
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 1267:9: -> ^( CSHARP_SOURCE compilation_unit )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1267:13: ^( CSHARP_SOURCE compilation_unit )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(CSHARP_SOURCE, "CSHARP_SOURCE")
                , root_1);

                adaptor.addChild(root_1, stream_compilation_unit.nextTree());

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "csharpSource"


    public static class compilation_unit_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "compilation_unit"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1270:1: compilation_unit : ( extern_alias_directives )? ( using_directives )? ( ( global_attribute_section )=> global_attribute_section )* ( namespace_member_declarations )? EOF !;
    public final CSharp4AST.compilation_unit_return compilation_unit() throws RecognitionException {
        CSharp4AST.compilation_unit_return retval = new CSharp4AST.compilation_unit_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token EOF666=null;
        CSharp4AST.extern_alias_directives_return extern_alias_directives662 =null;

        CSharp4AST.using_directives_return using_directives663 =null;

        CSharp4AST.global_attribute_section_return global_attribute_section664 =null;

        CSharp4AST.namespace_member_declarations_return namespace_member_declarations665 =null;


        Object EOF666_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1271:3: ( ( extern_alias_directives )? ( using_directives )? ( ( global_attribute_section )=> global_attribute_section )* ( namespace_member_declarations )? EOF !)
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1271:5: ( extern_alias_directives )? ( using_directives )? ( ( global_attribute_section )=> global_attribute_section )* ( namespace_member_declarations )? EOF !
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1271:5: ( extern_alias_directives )?
            int alt127=2;
            int LA127_0 = input.LA(1);

            if ( (LA127_0==EXTERN) ) {
                int LA127_1 = input.LA(2);

                if ( (LA127_1==IDENTIFIER) ) {
                    int LA127_3 = input.LA(3);

                    if ( (LA127_3==IDENTIFIER) ) {
                        int LA127_4 = input.LA(4);

                        if ( (LA127_4==SEMICOLON) ) {
                            alt127=1;
                        }
                    }
                }
            }
            switch (alt127) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1271:5: extern_alias_directives
                    {
                    pushFollow(FOLLOW_extern_alias_directives_in_compilation_unit6262);
                    extern_alias_directives662=extern_alias_directives();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, extern_alias_directives662.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1271:30: ( using_directives )?
            int alt128=2;
            int LA128_0 = input.LA(1);

            if ( (LA128_0==USING) ) {
                alt128=1;
            }
            switch (alt128) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1271:30: using_directives
                    {
                    pushFollow(FOLLOW_using_directives_in_compilation_unit6265);
                    using_directives663=using_directives();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, using_directives663.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1272:5: ( ( global_attribute_section )=> global_attribute_section )*
            loop129:
            do {
                int alt129=2;
                int LA129_0 = input.LA(1);

                if ( (LA129_0==OPEN_BRACKET) ) {
                    int LA129_2 = input.LA(2);

                    if ( (synpred19_CSharp4AST()) ) {
                        alt129=1;
                    }


                }


                switch (alt129) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1272:7: ( global_attribute_section )=> global_attribute_section
            	    {
            	    pushFollow(FOLLOW_global_attribute_section_in_compilation_unit6280);
            	    global_attribute_section664=global_attribute_section();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, global_attribute_section664.getTree());

            	    }
            	    break;

            	default :
            	    break loop129;
                }
            } while (true);


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1273:5: ( namespace_member_declarations )?
            int alt130=2;
            int LA130_0 = input.LA(1);

            if ( (LA130_0==ABSTRACT||LA130_0==CLASS||LA130_0==DELEGATE||LA130_0==ENUM||LA130_0==EXTERN||LA130_0==IDENTIFIER||(LA130_0 >= INTERFACE && LA130_0 <= INTERNAL)||(LA130_0 >= NAMESPACE && LA130_0 <= NEW)||LA130_0==OPEN_BRACKET||LA130_0==OVERRIDE||(LA130_0 >= PRIVATE && LA130_0 <= PUBLIC)||LA130_0==READONLY||LA130_0==SEALED||LA130_0==STATIC||LA130_0==STRUCT||LA130_0==UNSAFE||LA130_0==VIRTUAL||LA130_0==VOLATILE) ) {
                alt130=1;
            }
            switch (alt130) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1273:5: namespace_member_declarations
                    {
                    pushFollow(FOLLOW_namespace_member_declarations_in_compilation_unit6289);
                    namespace_member_declarations665=namespace_member_declarations();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, namespace_member_declarations665.getTree());

                    }
                    break;

            }


            EOF666=(Token)match(input,EOF,FOLLOW_EOF_in_compilation_unit6292); if (state.failed) return retval;

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "compilation_unit"


    public static class namespace_declaration_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "namespace_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1276:1: namespace_declaration : NAMESPACE ^ qualified_identifier namespace_body ( SEMICOLON !)? ;
    public final CSharp4AST.namespace_declaration_return namespace_declaration() throws RecognitionException {
        CSharp4AST.namespace_declaration_return retval = new CSharp4AST.namespace_declaration_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token NAMESPACE667=null;
        Token SEMICOLON670=null;
        CSharp4AST.qualified_identifier_return qualified_identifier668 =null;

        CSharp4AST.namespace_body_return namespace_body669 =null;


        Object NAMESPACE667_tree=null;
        Object SEMICOLON670_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1277:2: ( NAMESPACE ^ qualified_identifier namespace_body ( SEMICOLON !)? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1277:4: NAMESPACE ^ qualified_identifier namespace_body ( SEMICOLON !)?
            {
            root_0 = (Object)adaptor.nil();


            NAMESPACE667=(Token)match(input,NAMESPACE,FOLLOW_NAMESPACE_in_namespace_declaration6306); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            NAMESPACE667_tree = 
            (Object)adaptor.create(NAMESPACE667)
            ;
            root_0 = (Object)adaptor.becomeRoot(NAMESPACE667_tree, root_0);
            }

            pushFollow(FOLLOW_qualified_identifier_in_namespace_declaration6309);
            qualified_identifier668=qualified_identifier();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, qualified_identifier668.getTree());

            pushFollow(FOLLOW_namespace_body_in_namespace_declaration6311);
            namespace_body669=namespace_body();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, namespace_body669.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1277:60: ( SEMICOLON !)?
            int alt131=2;
            int LA131_0 = input.LA(1);

            if ( (LA131_0==SEMICOLON) ) {
                alt131=1;
            }
            switch (alt131) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1277:60: SEMICOLON !
                    {
                    SEMICOLON670=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_namespace_declaration6313); if (state.failed) return retval;

                    }
                    break;

            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "namespace_declaration"


    public static class qualified_identifier_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "qualified_identifier"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1279:1: qualified_identifier : IDENTIFIER ( DOT IDENTIFIER )* -> ^( QUALIFIED_IDENTIFIER ( IDENTIFIER )+ ) ;
    public final CSharp4AST.qualified_identifier_return qualified_identifier() throws RecognitionException {
        CSharp4AST.qualified_identifier_return retval = new CSharp4AST.qualified_identifier_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER671=null;
        Token DOT672=null;
        Token IDENTIFIER673=null;

        Object IDENTIFIER671_tree=null;
        Object DOT672_tree=null;
        Object IDENTIFIER673_tree=null;
        RewriteRuleTokenStream stream_DOT=new RewriteRuleTokenStream(adaptor,"token DOT");
        RewriteRuleTokenStream stream_IDENTIFIER=new RewriteRuleTokenStream(adaptor,"token IDENTIFIER");

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1280:2: ( IDENTIFIER ( DOT IDENTIFIER )* -> ^( QUALIFIED_IDENTIFIER ( IDENTIFIER )+ ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1280:4: IDENTIFIER ( DOT IDENTIFIER )*
            {
            IDENTIFIER671=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_qualified_identifier6326); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_IDENTIFIER.add(IDENTIFIER671);


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1280:15: ( DOT IDENTIFIER )*
            loop132:
            do {
                int alt132=2;
                int LA132_0 = input.LA(1);

                if ( (LA132_0==DOT) ) {
                    alt132=1;
                }


                switch (alt132) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1280:17: DOT IDENTIFIER
            	    {
            	    DOT672=(Token)match(input,DOT,FOLLOW_DOT_in_qualified_identifier6330); if (state.failed) return retval; 
            	    if ( state.backtracking==0 ) stream_DOT.add(DOT672);


            	    IDENTIFIER673=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_qualified_identifier6333); if (state.failed) return retval; 
            	    if ( state.backtracking==0 ) stream_IDENTIFIER.add(IDENTIFIER673);


            	    }
            	    break;

            	default :
            	    break loop132;
                }
            } while (true);


            // AST REWRITE
            // elements: IDENTIFIER
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 1281:4: -> ^( QUALIFIED_IDENTIFIER ( IDENTIFIER )+ )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1281:7: ^( QUALIFIED_IDENTIFIER ( IDENTIFIER )+ )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(QUALIFIED_IDENTIFIER, "QUALIFIED_IDENTIFIER")
                , root_1);

                if ( !(stream_IDENTIFIER.hasNext()) ) {
                    throw new RewriteEarlyExitException();
                }
                while ( stream_IDENTIFIER.hasNext() ) {
                    adaptor.addChild(root_1, 
                    stream_IDENTIFIER.nextNode()
                    );

                }
                stream_IDENTIFIER.reset();

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "qualified_identifier"


    public static class namespace_body_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "namespace_body"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1283:1: namespace_body : OPEN_BRACE ! ( extern_alias_directives )? ( using_directives )? ( namespace_member_declarations )? CLOSE_BRACE !;
    public final CSharp4AST.namespace_body_return namespace_body() throws RecognitionException {
        CSharp4AST.namespace_body_return retval = new CSharp4AST.namespace_body_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token OPEN_BRACE674=null;
        Token CLOSE_BRACE678=null;
        CSharp4AST.extern_alias_directives_return extern_alias_directives675 =null;

        CSharp4AST.using_directives_return using_directives676 =null;

        CSharp4AST.namespace_member_declarations_return namespace_member_declarations677 =null;


        Object OPEN_BRACE674_tree=null;
        Object CLOSE_BRACE678_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1284:2: ( OPEN_BRACE ! ( extern_alias_directives )? ( using_directives )? ( namespace_member_declarations )? CLOSE_BRACE !)
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1284:4: OPEN_BRACE ! ( extern_alias_directives )? ( using_directives )? ( namespace_member_declarations )? CLOSE_BRACE !
            {
            root_0 = (Object)adaptor.nil();


            OPEN_BRACE674=(Token)match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_namespace_body6359); if (state.failed) return retval;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1284:16: ( extern_alias_directives )?
            int alt133=2;
            int LA133_0 = input.LA(1);

            if ( (LA133_0==EXTERN) ) {
                int LA133_1 = input.LA(2);

                if ( (LA133_1==IDENTIFIER) ) {
                    int LA133_3 = input.LA(3);

                    if ( (LA133_3==IDENTIFIER) ) {
                        int LA133_4 = input.LA(4);

                        if ( (LA133_4==SEMICOLON) ) {
                            alt133=1;
                        }
                    }
                }
            }
            switch (alt133) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1284:16: extern_alias_directives
                    {
                    pushFollow(FOLLOW_extern_alias_directives_in_namespace_body6362);
                    extern_alias_directives675=extern_alias_directives();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, extern_alias_directives675.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1284:41: ( using_directives )?
            int alt134=2;
            int LA134_0 = input.LA(1);

            if ( (LA134_0==USING) ) {
                alt134=1;
            }
            switch (alt134) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1284:41: using_directives
                    {
                    pushFollow(FOLLOW_using_directives_in_namespace_body6365);
                    using_directives676=using_directives();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, using_directives676.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1284:59: ( namespace_member_declarations )?
            int alt135=2;
            int LA135_0 = input.LA(1);

            if ( (LA135_0==ABSTRACT||LA135_0==CLASS||LA135_0==DELEGATE||LA135_0==ENUM||LA135_0==EXTERN||LA135_0==IDENTIFIER||(LA135_0 >= INTERFACE && LA135_0 <= INTERNAL)||(LA135_0 >= NAMESPACE && LA135_0 <= NEW)||LA135_0==OPEN_BRACKET||LA135_0==OVERRIDE||(LA135_0 >= PRIVATE && LA135_0 <= PUBLIC)||LA135_0==READONLY||LA135_0==SEALED||LA135_0==STATIC||LA135_0==STRUCT||LA135_0==UNSAFE||LA135_0==VIRTUAL||LA135_0==VOLATILE) ) {
                alt135=1;
            }
            switch (alt135) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1284:59: namespace_member_declarations
                    {
                    pushFollow(FOLLOW_namespace_member_declarations_in_namespace_body6368);
                    namespace_member_declarations677=namespace_member_declarations();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, namespace_member_declarations677.getTree());

                    }
                    break;

            }


            CLOSE_BRACE678=(Token)match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_namespace_body6371); if (state.failed) return retval;

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "namespace_body"


    public static class extern_alias_directives_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "extern_alias_directives"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1286:1: extern_alias_directives : ( extern_alias_directive )+ -> ^( EXTERN_ALIAS_DIRECTIVES ( extern_alias_directive )+ ) ;
    public final CSharp4AST.extern_alias_directives_return extern_alias_directives() throws RecognitionException {
        CSharp4AST.extern_alias_directives_return retval = new CSharp4AST.extern_alias_directives_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.extern_alias_directive_return extern_alias_directive679 =null;


        RewriteRuleSubtreeStream stream_extern_alias_directive=new RewriteRuleSubtreeStream(adaptor,"rule extern_alias_directive");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1287:2: ( ( extern_alias_directive )+ -> ^( EXTERN_ALIAS_DIRECTIVES ( extern_alias_directive )+ ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1287:4: ( extern_alias_directive )+
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1287:4: ( extern_alias_directive )+
            int cnt136=0;
            loop136:
            do {
                int alt136=2;
                int LA136_0 = input.LA(1);

                if ( (LA136_0==EXTERN) ) {
                    int LA136_2 = input.LA(2);

                    if ( (LA136_2==IDENTIFIER) ) {
                        int LA136_3 = input.LA(3);

                        if ( (LA136_3==IDENTIFIER) ) {
                            int LA136_4 = input.LA(4);

                            if ( (LA136_4==SEMICOLON) ) {
                                alt136=1;
                            }


                        }


                    }


                }


                switch (alt136) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1287:4: extern_alias_directive
            	    {
            	    pushFollow(FOLLOW_extern_alias_directive_in_extern_alias_directives6382);
            	    extern_alias_directive679=extern_alias_directive();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) stream_extern_alias_directive.add(extern_alias_directive679.getTree());

            	    }
            	    break;

            	default :
            	    if ( cnt136 >= 1 ) break loop136;
            	    if (state.backtracking>0) {state.failed=true; return retval;}
                        EarlyExitException eee =
                            new EarlyExitException(136, input);
                        throw eee;
                }
                cnt136++;
            } while (true);


            // AST REWRITE
            // elements: extern_alias_directive
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 1288:4: -> ^( EXTERN_ALIAS_DIRECTIVES ( extern_alias_directive )+ )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1288:7: ^( EXTERN_ALIAS_DIRECTIVES ( extern_alias_directive )+ )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(EXTERN_ALIAS_DIRECTIVES, "EXTERN_ALIAS_DIRECTIVES")
                , root_1);

                if ( !(stream_extern_alias_directive.hasNext()) ) {
                    throw new RewriteEarlyExitException();
                }
                while ( stream_extern_alias_directive.hasNext() ) {
                    adaptor.addChild(root_1, stream_extern_alias_directive.nextTree());

                }
                stream_extern_alias_directive.reset();

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "extern_alias_directives"


    public static class extern_alias_directive_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "extern_alias_directive"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1290:1: extern_alias_directive : EXTERN ^ alias_contextual_keyword ! IDENTIFIER SEMICOLON !;
    public final CSharp4AST.extern_alias_directive_return extern_alias_directive() throws RecognitionException {
        CSharp4AST.extern_alias_directive_return retval = new CSharp4AST.extern_alias_directive_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token EXTERN680=null;
        Token IDENTIFIER682=null;
        Token SEMICOLON683=null;
        CSharp4AST.alias_contextual_keyword_return alias_contextual_keyword681 =null;


        Object EXTERN680_tree=null;
        Object IDENTIFIER682_tree=null;
        Object SEMICOLON683_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1291:2: ( EXTERN ^ alias_contextual_keyword ! IDENTIFIER SEMICOLON !)
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1291:4: EXTERN ^ alias_contextual_keyword ! IDENTIFIER SEMICOLON !
            {
            root_0 = (Object)adaptor.nil();


            EXTERN680=(Token)match(input,EXTERN,FOLLOW_EXTERN_in_extern_alias_directive6406); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            EXTERN680_tree = 
            (Object)adaptor.create(EXTERN680)
            ;
            root_0 = (Object)adaptor.becomeRoot(EXTERN680_tree, root_0);
            }

            pushFollow(FOLLOW_alias_contextual_keyword_in_extern_alias_directive6409);
            alias_contextual_keyword681=alias_contextual_keyword();

            state._fsp--;
            if (state.failed) return retval;

            IDENTIFIER682=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_extern_alias_directive6412); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER682_tree = 
            (Object)adaptor.create(IDENTIFIER682)
            ;
            adaptor.addChild(root_0, IDENTIFIER682_tree);
            }

            SEMICOLON683=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_extern_alias_directive6414); if (state.failed) return retval;

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "extern_alias_directive"


    public static class using_directives_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "using_directives"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1293:1: using_directives : ( using_directive )+ -> ^( USING_DIRECTIVES ( using_directive )+ ) ;
    public final CSharp4AST.using_directives_return using_directives() throws RecognitionException {
        CSharp4AST.using_directives_return retval = new CSharp4AST.using_directives_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.using_directive_return using_directive684 =null;


        RewriteRuleSubtreeStream stream_using_directive=new RewriteRuleSubtreeStream(adaptor,"rule using_directive");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1294:2: ( ( using_directive )+ -> ^( USING_DIRECTIVES ( using_directive )+ ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1294:4: ( using_directive )+
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1294:4: ( using_directive )+
            int cnt137=0;
            loop137:
            do {
                int alt137=2;
                int LA137_0 = input.LA(1);

                if ( (LA137_0==USING) ) {
                    alt137=1;
                }


                switch (alt137) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1294:4: using_directive
            	    {
            	    pushFollow(FOLLOW_using_directive_in_using_directives6426);
            	    using_directive684=using_directive();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) stream_using_directive.add(using_directive684.getTree());

            	    }
            	    break;

            	default :
            	    if ( cnt137 >= 1 ) break loop137;
            	    if (state.backtracking>0) {state.failed=true; return retval;}
                        EarlyExitException eee =
                            new EarlyExitException(137, input);
                        throw eee;
                }
                cnt137++;
            } while (true);


            // AST REWRITE
            // elements: using_directive
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 1295:4: -> ^( USING_DIRECTIVES ( using_directive )+ )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1295:7: ^( USING_DIRECTIVES ( using_directive )+ )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(USING_DIRECTIVES, "USING_DIRECTIVES")
                , root_1);

                if ( !(stream_using_directive.hasNext()) ) {
                    throw new RewriteEarlyExitException();
                }
                while ( stream_using_directive.hasNext() ) {
                    adaptor.addChild(root_1, stream_using_directive.nextTree());

                }
                stream_using_directive.reset();

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "using_directives"


    public static class using_directive_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "using_directive"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1297:1: using_directive : ( using_alias_directive | using_namespace_directive );
    public final CSharp4AST.using_directive_return using_directive() throws RecognitionException {
        CSharp4AST.using_directive_return retval = new CSharp4AST.using_directive_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.using_alias_directive_return using_alias_directive685 =null;

        CSharp4AST.using_namespace_directive_return using_namespace_directive686 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1298:2: ( using_alias_directive | using_namespace_directive )
            int alt138=2;
            int LA138_0 = input.LA(1);

            if ( (LA138_0==USING) ) {
                int LA138_1 = input.LA(2);

                if ( (LA138_1==IDENTIFIER) ) {
                    int LA138_2 = input.LA(3);

                    if ( (LA138_2==ASSIGNMENT) ) {
                        alt138=1;
                    }
                    else if ( (LA138_2==DOT||LA138_2==DOUBLE_COLON||LA138_2==LT||LA138_2==SEMICOLON) ) {
                        alt138=2;
                    }
                    else {
                        if (state.backtracking>0) {state.failed=true; return retval;}
                        NoViableAltException nvae =
                            new NoViableAltException("", 138, 2, input);

                        throw nvae;

                    }
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 138, 1, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 138, 0, input);

                throw nvae;

            }
            switch (alt138) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1298:4: using_alias_directive
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_using_alias_directive_in_using_directive6450);
                    using_alias_directive685=using_alias_directive();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, using_alias_directive685.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1299:4: using_namespace_directive
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_using_namespace_directive_in_using_directive6455);
                    using_namespace_directive686=using_namespace_directive();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, using_namespace_directive686.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "using_directive"


    public static class using_alias_directive_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "using_alias_directive"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1301:1: using_alias_directive : USING IDENTIFIER ASSIGNMENT namespace_or_type_name SEMICOLON -> ^( USING_ALIAS_DIRECTIVE IDENTIFIER namespace_or_type_name ) ;
    public final CSharp4AST.using_alias_directive_return using_alias_directive() throws RecognitionException {
        CSharp4AST.using_alias_directive_return retval = new CSharp4AST.using_alias_directive_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token USING687=null;
        Token IDENTIFIER688=null;
        Token ASSIGNMENT689=null;
        Token SEMICOLON691=null;
        CSharp4AST.namespace_or_type_name_return namespace_or_type_name690 =null;


        Object USING687_tree=null;
        Object IDENTIFIER688_tree=null;
        Object ASSIGNMENT689_tree=null;
        Object SEMICOLON691_tree=null;
        RewriteRuleTokenStream stream_ASSIGNMENT=new RewriteRuleTokenStream(adaptor,"token ASSIGNMENT");
        RewriteRuleTokenStream stream_SEMICOLON=new RewriteRuleTokenStream(adaptor,"token SEMICOLON");
        RewriteRuleTokenStream stream_USING=new RewriteRuleTokenStream(adaptor,"token USING");
        RewriteRuleTokenStream stream_IDENTIFIER=new RewriteRuleTokenStream(adaptor,"token IDENTIFIER");
        RewriteRuleSubtreeStream stream_namespace_or_type_name=new RewriteRuleSubtreeStream(adaptor,"rule namespace_or_type_name");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1302:2: ( USING IDENTIFIER ASSIGNMENT namespace_or_type_name SEMICOLON -> ^( USING_ALIAS_DIRECTIVE IDENTIFIER namespace_or_type_name ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1302:4: USING IDENTIFIER ASSIGNMENT namespace_or_type_name SEMICOLON
            {
            USING687=(Token)match(input,USING,FOLLOW_USING_in_using_alias_directive6466); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_USING.add(USING687);


            IDENTIFIER688=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_using_alias_directive6468); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_IDENTIFIER.add(IDENTIFIER688);


            ASSIGNMENT689=(Token)match(input,ASSIGNMENT,FOLLOW_ASSIGNMENT_in_using_alias_directive6470); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_ASSIGNMENT.add(ASSIGNMENT689);


            pushFollow(FOLLOW_namespace_or_type_name_in_using_alias_directive6472);
            namespace_or_type_name690=namespace_or_type_name();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_namespace_or_type_name.add(namespace_or_type_name690.getTree());

            SEMICOLON691=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_using_alias_directive6474); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_SEMICOLON.add(SEMICOLON691);


            // AST REWRITE
            // elements: IDENTIFIER, namespace_or_type_name
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 1303:4: -> ^( USING_ALIAS_DIRECTIVE IDENTIFIER namespace_or_type_name )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1303:7: ^( USING_ALIAS_DIRECTIVE IDENTIFIER namespace_or_type_name )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(USING_ALIAS_DIRECTIVE, "USING_ALIAS_DIRECTIVE")
                , root_1);

                adaptor.addChild(root_1, 
                stream_IDENTIFIER.nextNode()
                );

                adaptor.addChild(root_1, stream_namespace_or_type_name.nextTree());

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "using_alias_directive"


    public static class using_namespace_directive_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "using_namespace_directive"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1305:1: using_namespace_directive : USING namespace_name SEMICOLON -> ^( USING_NAMESPACE_DIRECTIVE namespace_name ) ;
    public final CSharp4AST.using_namespace_directive_return using_namespace_directive() throws RecognitionException {
        CSharp4AST.using_namespace_directive_return retval = new CSharp4AST.using_namespace_directive_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token USING692=null;
        Token SEMICOLON694=null;
        CSharp4AST.namespace_name_return namespace_name693 =null;


        Object USING692_tree=null;
        Object SEMICOLON694_tree=null;
        RewriteRuleTokenStream stream_SEMICOLON=new RewriteRuleTokenStream(adaptor,"token SEMICOLON");
        RewriteRuleTokenStream stream_USING=new RewriteRuleTokenStream(adaptor,"token USING");
        RewriteRuleSubtreeStream stream_namespace_name=new RewriteRuleSubtreeStream(adaptor,"rule namespace_name");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1306:2: ( USING namespace_name SEMICOLON -> ^( USING_NAMESPACE_DIRECTIVE namespace_name ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1306:4: USING namespace_name SEMICOLON
            {
            USING692=(Token)match(input,USING,FOLLOW_USING_in_using_namespace_directive6500); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_USING.add(USING692);


            pushFollow(FOLLOW_namespace_name_in_using_namespace_directive6502);
            namespace_name693=namespace_name();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_namespace_name.add(namespace_name693.getTree());

            SEMICOLON694=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_using_namespace_directive6504); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_SEMICOLON.add(SEMICOLON694);


            // AST REWRITE
            // elements: namespace_name
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 1307:4: -> ^( USING_NAMESPACE_DIRECTIVE namespace_name )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1307:7: ^( USING_NAMESPACE_DIRECTIVE namespace_name )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(USING_NAMESPACE_DIRECTIVE, "USING_NAMESPACE_DIRECTIVE")
                , root_1);

                adaptor.addChild(root_1, stream_namespace_name.nextTree());

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "using_namespace_directive"


    public static class namespace_member_declarations_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "namespace_member_declarations"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1309:1: namespace_member_declarations : ( namespace_member_declaration )+ -> ^( NAMESPACE_MEMBER_DECLARATIONS ( namespace_member_declaration )+ ) ;
    public final CSharp4AST.namespace_member_declarations_return namespace_member_declarations() throws RecognitionException {
        CSharp4AST.namespace_member_declarations_return retval = new CSharp4AST.namespace_member_declarations_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.namespace_member_declaration_return namespace_member_declaration695 =null;


        RewriteRuleSubtreeStream stream_namespace_member_declaration=new RewriteRuleSubtreeStream(adaptor,"rule namespace_member_declaration");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1310:2: ( ( namespace_member_declaration )+ -> ^( NAMESPACE_MEMBER_DECLARATIONS ( namespace_member_declaration )+ ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1310:4: ( namespace_member_declaration )+
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1310:4: ( namespace_member_declaration )+
            int cnt139=0;
            loop139:
            do {
                int alt139=2;
                int LA139_0 = input.LA(1);

                if ( (LA139_0==ABSTRACT||LA139_0==CLASS||LA139_0==DELEGATE||LA139_0==ENUM||LA139_0==EXTERN||LA139_0==IDENTIFIER||(LA139_0 >= INTERFACE && LA139_0 <= INTERNAL)||(LA139_0 >= NAMESPACE && LA139_0 <= NEW)||LA139_0==OPEN_BRACKET||LA139_0==OVERRIDE||(LA139_0 >= PRIVATE && LA139_0 <= PUBLIC)||LA139_0==READONLY||LA139_0==SEALED||LA139_0==STATIC||LA139_0==STRUCT||LA139_0==UNSAFE||LA139_0==VIRTUAL||LA139_0==VOLATILE) ) {
                    alt139=1;
                }


                switch (alt139) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1310:4: namespace_member_declaration
            	    {
            	    pushFollow(FOLLOW_namespace_member_declaration_in_namespace_member_declarations6527);
            	    namespace_member_declaration695=namespace_member_declaration();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) stream_namespace_member_declaration.add(namespace_member_declaration695.getTree());

            	    }
            	    break;

            	default :
            	    if ( cnt139 >= 1 ) break loop139;
            	    if (state.backtracking>0) {state.failed=true; return retval;}
                        EarlyExitException eee =
                            new EarlyExitException(139, input);
                        throw eee;
                }
                cnt139++;
            } while (true);


            // AST REWRITE
            // elements: namespace_member_declaration
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 1311:4: -> ^( NAMESPACE_MEMBER_DECLARATIONS ( namespace_member_declaration )+ )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1311:7: ^( NAMESPACE_MEMBER_DECLARATIONS ( namespace_member_declaration )+ )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(NAMESPACE_MEMBER_DECLARATIONS, "NAMESPACE_MEMBER_DECLARATIONS")
                , root_1);

                if ( !(stream_namespace_member_declaration.hasNext()) ) {
                    throw new RewriteEarlyExitException();
                }
                while ( stream_namespace_member_declaration.hasNext() ) {
                    adaptor.addChild(root_1, stream_namespace_member_declaration.nextTree());

                }
                stream_namespace_member_declaration.reset();

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "namespace_member_declarations"


    public static class namespace_member_declaration_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "namespace_member_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1313:1: namespace_member_declaration : ( namespace_declaration | type_declaration );
    public final CSharp4AST.namespace_member_declaration_return namespace_member_declaration() throws RecognitionException {
        CSharp4AST.namespace_member_declaration_return retval = new CSharp4AST.namespace_member_declaration_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.namespace_declaration_return namespace_declaration696 =null;

        CSharp4AST.type_declaration_return type_declaration697 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1314:2: ( namespace_declaration | type_declaration )
            int alt140=2;
            int LA140_0 = input.LA(1);

            if ( (LA140_0==NAMESPACE) ) {
                alt140=1;
            }
            else if ( (LA140_0==ABSTRACT||LA140_0==CLASS||LA140_0==DELEGATE||LA140_0==ENUM||LA140_0==EXTERN||LA140_0==IDENTIFIER||(LA140_0 >= INTERFACE && LA140_0 <= INTERNAL)||LA140_0==NEW||LA140_0==OPEN_BRACKET||LA140_0==OVERRIDE||(LA140_0 >= PRIVATE && LA140_0 <= PUBLIC)||LA140_0==READONLY||LA140_0==SEALED||LA140_0==STATIC||LA140_0==STRUCT||LA140_0==UNSAFE||LA140_0==VIRTUAL||LA140_0==VOLATILE) ) {
                alt140=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 140, 0, input);

                throw nvae;

            }
            switch (alt140) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1314:4: namespace_declaration
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_namespace_declaration_in_namespace_member_declaration6551);
                    namespace_declaration696=namespace_declaration();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, namespace_declaration696.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1315:4: type_declaration
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_type_declaration_in_namespace_member_declaration6556);
                    type_declaration697=type_declaration();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, type_declaration697.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "namespace_member_declaration"


    public static class type_declaration_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "type_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1326:1: type_declaration : ( attributes )? ( all_member_modifiers )? ( class_definition ^| struct_definition ^| interface_definition ^| enum_definition ^| delegate_definition ^) ;
    public final CSharp4AST.type_declaration_return type_declaration() throws RecognitionException {
        CSharp4AST.type_declaration_return retval = new CSharp4AST.type_declaration_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.attributes_return attributes698 =null;

        CSharp4AST.all_member_modifiers_return all_member_modifiers699 =null;

        CSharp4AST.class_definition_return class_definition700 =null;

        CSharp4AST.struct_definition_return struct_definition701 =null;

        CSharp4AST.interface_definition_return interface_definition702 =null;

        CSharp4AST.enum_definition_return enum_definition703 =null;

        CSharp4AST.delegate_definition_return delegate_definition704 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1327:3: ( ( attributes )? ( all_member_modifiers )? ( class_definition ^| struct_definition ^| interface_definition ^| enum_definition ^| delegate_definition ^) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1327:5: ( attributes )? ( all_member_modifiers )? ( class_definition ^| struct_definition ^| interface_definition ^| enum_definition ^| delegate_definition ^)
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1327:5: ( attributes )?
            int alt141=2;
            int LA141_0 = input.LA(1);

            if ( (LA141_0==OPEN_BRACKET) ) {
                alt141=1;
            }
            switch (alt141) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1327:5: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_type_declaration6570);
                    attributes698=attributes();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, attributes698.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1327:17: ( all_member_modifiers )?
            int alt142=2;
            int LA142_0 = input.LA(1);

            if ( (LA142_0==ABSTRACT||LA142_0==EXTERN||LA142_0==IDENTIFIER||LA142_0==INTERNAL||LA142_0==NEW||LA142_0==OVERRIDE||(LA142_0 >= PRIVATE && LA142_0 <= PUBLIC)||LA142_0==READONLY||LA142_0==SEALED||LA142_0==STATIC||LA142_0==UNSAFE||LA142_0==VIRTUAL||LA142_0==VOLATILE) ) {
                alt142=1;
            }
            switch (alt142) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1327:17: all_member_modifiers
                    {
                    pushFollow(FOLLOW_all_member_modifiers_in_type_declaration6573);
                    all_member_modifiers699=all_member_modifiers();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, all_member_modifiers699.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1328:5: ( class_definition ^| struct_definition ^| interface_definition ^| enum_definition ^| delegate_definition ^)
            int alt143=5;
            switch ( input.LA(1) ) {
            case CLASS:
                {
                alt143=1;
                }
                break;
            case STRUCT:
                {
                alt143=2;
                }
                break;
            case INTERFACE:
                {
                alt143=3;
                }
                break;
            case ENUM:
                {
                alt143=4;
                }
                break;
            case DELEGATE:
                {
                alt143=5;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 143, 0, input);

                throw nvae;

            }

            switch (alt143) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1328:7: class_definition ^
                    {
                    pushFollow(FOLLOW_class_definition_in_type_declaration6582);
                    class_definition700=class_definition();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(class_definition700.getTree(), root_0);

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1329:7: struct_definition ^
                    {
                    pushFollow(FOLLOW_struct_definition_in_type_declaration6591);
                    struct_definition701=struct_definition();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(struct_definition701.getTree(), root_0);

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1330:7: interface_definition ^
                    {
                    pushFollow(FOLLOW_interface_definition_in_type_declaration6600);
                    interface_definition702=interface_definition();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(interface_definition702.getTree(), root_0);

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1331:7: enum_definition ^
                    {
                    pushFollow(FOLLOW_enum_definition_in_type_declaration6609);
                    enum_definition703=enum_definition();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(enum_definition703.getTree(), root_0);

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1332:7: delegate_definition ^
                    {
                    pushFollow(FOLLOW_delegate_definition_in_type_declaration6618);
                    delegate_definition704=delegate_definition();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(delegate_definition704.getTree(), root_0);

                    }
                    break;

            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "type_declaration"


    public static class qualified_alias_member_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "qualified_alias_member"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1336:1: qualified_alias_member : id1= IDENTIFIER DOUBLE_COLON id2= IDENTIFIER type_argument_list_opt -> ^( QUALIFIED_ALIAS_MEMBER $id1 $id2 ( type_argument_list_opt )? ) ;
    public final CSharp4AST.qualified_alias_member_return qualified_alias_member() throws RecognitionException {
        CSharp4AST.qualified_alias_member_return retval = new CSharp4AST.qualified_alias_member_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token id1=null;
        Token id2=null;
        Token DOUBLE_COLON705=null;
        CSharp4AST.type_argument_list_opt_return type_argument_list_opt706 =null;


        Object id1_tree=null;
        Object id2_tree=null;
        Object DOUBLE_COLON705_tree=null;
        RewriteRuleTokenStream stream_DOUBLE_COLON=new RewriteRuleTokenStream(adaptor,"token DOUBLE_COLON");
        RewriteRuleTokenStream stream_IDENTIFIER=new RewriteRuleTokenStream(adaptor,"token IDENTIFIER");
        RewriteRuleSubtreeStream stream_type_argument_list_opt=new RewriteRuleSubtreeStream(adaptor,"rule type_argument_list_opt");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1337:2: (id1= IDENTIFIER DOUBLE_COLON id2= IDENTIFIER type_argument_list_opt -> ^( QUALIFIED_ALIAS_MEMBER $id1 $id2 ( type_argument_list_opt )? ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1337:4: id1= IDENTIFIER DOUBLE_COLON id2= IDENTIFIER type_argument_list_opt
            {
            id1=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_qualified_alias_member6641); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_IDENTIFIER.add(id1);


            DOUBLE_COLON705=(Token)match(input,DOUBLE_COLON,FOLLOW_DOUBLE_COLON_in_qualified_alias_member6643); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_DOUBLE_COLON.add(DOUBLE_COLON705);


            id2=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_qualified_alias_member6647); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_IDENTIFIER.add(id2);


            pushFollow(FOLLOW_type_argument_list_opt_in_qualified_alias_member6649);
            type_argument_list_opt706=type_argument_list_opt();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_type_argument_list_opt.add(type_argument_list_opt706.getTree());

            // AST REWRITE
            // elements: id2, type_argument_list_opt, id1
            // token labels: id2, id1
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleTokenStream stream_id2=new RewriteRuleTokenStream(adaptor,"token id2",id2);
            RewriteRuleTokenStream stream_id1=new RewriteRuleTokenStream(adaptor,"token id1",id1);
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 1338:4: -> ^( QUALIFIED_ALIAS_MEMBER $id1 $id2 ( type_argument_list_opt )? )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1338:7: ^( QUALIFIED_ALIAS_MEMBER $id1 $id2 ( type_argument_list_opt )? )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(QUALIFIED_ALIAS_MEMBER, "QUALIFIED_ALIAS_MEMBER")
                , root_1);

                adaptor.addChild(root_1, stream_id1.nextNode());

                adaptor.addChild(root_1, stream_id2.nextNode());

                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1338:42: ( type_argument_list_opt )?
                if ( stream_type_argument_list_opt.hasNext() ) {
                    adaptor.addChild(root_1, stream_type_argument_list_opt.nextTree());

                }
                stream_type_argument_list_opt.reset();

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "qualified_alias_member"


    public static class class_declaration_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "class_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1343:1: class_declaration : ( attributes )? ( class_modifiers )? ( partial_contextual_keyword )? CLASS IDENTIFIER ( type_parameter_list )? ( class_base )? ( type_parameter_constraints_clauses )? class_body ( SEMICOLON )? ;
    public final CSharp4AST.class_declaration_return class_declaration() throws RecognitionException {
        CSharp4AST.class_declaration_return retval = new CSharp4AST.class_declaration_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token CLASS710=null;
        Token IDENTIFIER711=null;
        Token SEMICOLON716=null;
        CSharp4AST.attributes_return attributes707 =null;

        CSharp4AST.class_modifiers_return class_modifiers708 =null;

        CSharp4AST.partial_contextual_keyword_return partial_contextual_keyword709 =null;

        CSharp4AST.type_parameter_list_return type_parameter_list712 =null;

        CSharp4AST.class_base_return class_base713 =null;

        CSharp4AST.type_parameter_constraints_clauses_return type_parameter_constraints_clauses714 =null;

        CSharp4AST.class_body_return class_body715 =null;


        Object CLASS710_tree=null;
        Object IDENTIFIER711_tree=null;
        Object SEMICOLON716_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1344:2: ( ( attributes )? ( class_modifiers )? ( partial_contextual_keyword )? CLASS IDENTIFIER ( type_parameter_list )? ( class_base )? ( type_parameter_constraints_clauses )? class_body ( SEMICOLON )? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1344:4: ( attributes )? ( class_modifiers )? ( partial_contextual_keyword )? CLASS IDENTIFIER ( type_parameter_list )? ( class_base )? ( type_parameter_constraints_clauses )? class_body ( SEMICOLON )?
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1344:4: ( attributes )?
            int alt144=2;
            int LA144_0 = input.LA(1);

            if ( (LA144_0==OPEN_BRACKET) ) {
                alt144=1;
            }
            switch (alt144) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1344:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_class_declaration6681);
                    attributes707=attributes();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, attributes707.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1344:16: ( class_modifiers )?
            int alt145=2;
            int LA145_0 = input.LA(1);

            if ( (LA145_0==ABSTRACT||LA145_0==INTERNAL||LA145_0==NEW||(LA145_0 >= PRIVATE && LA145_0 <= PUBLIC)||LA145_0==SEALED||LA145_0==STATIC||LA145_0==UNSAFE) ) {
                alt145=1;
            }
            switch (alt145) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1344:16: class_modifiers
                    {
                    pushFollow(FOLLOW_class_modifiers_in_class_declaration6684);
                    class_modifiers708=class_modifiers();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, class_modifiers708.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1344:33: ( partial_contextual_keyword )?
            int alt146=2;
            int LA146_0 = input.LA(1);

            if ( (LA146_0==IDENTIFIER) ) {
                alt146=1;
            }
            switch (alt146) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1344:33: partial_contextual_keyword
                    {
                    pushFollow(FOLLOW_partial_contextual_keyword_in_class_declaration6687);
                    partial_contextual_keyword709=partial_contextual_keyword();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, partial_contextual_keyword709.getTree());

                    }
                    break;

            }


            CLASS710=(Token)match(input,CLASS,FOLLOW_CLASS_in_class_declaration6690); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            CLASS710_tree = 
            (Object)adaptor.create(CLASS710)
            ;
            adaptor.addChild(root_0, CLASS710_tree);
            }

            IDENTIFIER711=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_class_declaration6692); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER711_tree = 
            (Object)adaptor.create(IDENTIFIER711)
            ;
            adaptor.addChild(root_0, IDENTIFIER711_tree);
            }

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1344:78: ( type_parameter_list )?
            int alt147=2;
            int LA147_0 = input.LA(1);

            if ( (LA147_0==LT) ) {
                alt147=1;
            }
            switch (alt147) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1344:78: type_parameter_list
                    {
                    pushFollow(FOLLOW_type_parameter_list_in_class_declaration6694);
                    type_parameter_list712=type_parameter_list();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, type_parameter_list712.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1345:6: ( class_base )?
            int alt148=2;
            int LA148_0 = input.LA(1);

            if ( (LA148_0==COLON) ) {
                alt148=1;
            }
            switch (alt148) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1345:6: class_base
                    {
                    pushFollow(FOLLOW_class_base_in_class_declaration6702);
                    class_base713=class_base();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, class_base713.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1345:18: ( type_parameter_constraints_clauses )?
            int alt149=2;
            int LA149_0 = input.LA(1);

            if ( (LA149_0==IDENTIFIER) ) {
                alt149=1;
            }
            switch (alt149) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1345:18: type_parameter_constraints_clauses
                    {
                    pushFollow(FOLLOW_type_parameter_constraints_clauses_in_class_declaration6705);
                    type_parameter_constraints_clauses714=type_parameter_constraints_clauses();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, type_parameter_constraints_clauses714.getTree());

                    }
                    break;

            }


            pushFollow(FOLLOW_class_body_in_class_declaration6708);
            class_body715=class_body();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, class_body715.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1345:65: ( SEMICOLON )?
            int alt150=2;
            int LA150_0 = input.LA(1);

            if ( (LA150_0==SEMICOLON) ) {
                alt150=1;
            }
            switch (alt150) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1345:65: SEMICOLON
                    {
                    SEMICOLON716=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_class_declaration6710); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    SEMICOLON716_tree = 
                    (Object)adaptor.create(SEMICOLON716)
                    ;
                    adaptor.addChild(root_0, SEMICOLON716_tree);
                    }

                    }
                    break;

            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "class_declaration"


    public static class class_modifiers_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "class_modifiers"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1347:1: class_modifiers : class_modifier ( class_modifier )* ;
    public final CSharp4AST.class_modifiers_return class_modifiers() throws RecognitionException {
        CSharp4AST.class_modifiers_return retval = new CSharp4AST.class_modifiers_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.class_modifier_return class_modifier717 =null;

        CSharp4AST.class_modifier_return class_modifier718 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1348:2: ( class_modifier ( class_modifier )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1348:4: class_modifier ( class_modifier )*
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_class_modifier_in_class_modifiers6722);
            class_modifier717=class_modifier();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, class_modifier717.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1348:19: ( class_modifier )*
            loop151:
            do {
                int alt151=2;
                int LA151_0 = input.LA(1);

                if ( (LA151_0==ABSTRACT||LA151_0==INTERNAL||LA151_0==NEW||(LA151_0 >= PRIVATE && LA151_0 <= PUBLIC)||LA151_0==SEALED||LA151_0==STATIC||LA151_0==UNSAFE) ) {
                    alt151=1;
                }


                switch (alt151) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1348:21: class_modifier
            	    {
            	    pushFollow(FOLLOW_class_modifier_in_class_modifiers6726);
            	    class_modifier718=class_modifier();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, class_modifier718.getTree());

            	    }
            	    break;

            	default :
            	    break loop151;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "class_modifiers"


    public static class class_modifier_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "class_modifier"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1350:1: class_modifier : ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | ABSTRACT | SEALED | STATIC | class_modifier_unsafe );
    public final CSharp4AST.class_modifier_return class_modifier() throws RecognitionException {
        CSharp4AST.class_modifier_return retval = new CSharp4AST.class_modifier_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token NEW719=null;
        Token PUBLIC720=null;
        Token PROTECTED721=null;
        Token INTERNAL722=null;
        Token PRIVATE723=null;
        Token ABSTRACT724=null;
        Token SEALED725=null;
        Token STATIC726=null;
        CSharp4AST.class_modifier_unsafe_return class_modifier_unsafe727 =null;


        Object NEW719_tree=null;
        Object PUBLIC720_tree=null;
        Object PROTECTED721_tree=null;
        Object INTERNAL722_tree=null;
        Object PRIVATE723_tree=null;
        Object ABSTRACT724_tree=null;
        Object SEALED725_tree=null;
        Object STATIC726_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1351:2: ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | ABSTRACT | SEALED | STATIC | class_modifier_unsafe )
            int alt152=9;
            switch ( input.LA(1) ) {
            case NEW:
                {
                alt152=1;
                }
                break;
            case PUBLIC:
                {
                alt152=2;
                }
                break;
            case PROTECTED:
                {
                alt152=3;
                }
                break;
            case INTERNAL:
                {
                alt152=4;
                }
                break;
            case PRIVATE:
                {
                alt152=5;
                }
                break;
            case ABSTRACT:
                {
                alt152=6;
                }
                break;
            case SEALED:
                {
                alt152=7;
                }
                break;
            case STATIC:
                {
                alt152=8;
                }
                break;
            case UNSAFE:
                {
                alt152=9;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 152, 0, input);

                throw nvae;

            }

            switch (alt152) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1351:4: NEW
                    {
                    root_0 = (Object)adaptor.nil();


                    NEW719=(Token)match(input,NEW,FOLLOW_NEW_in_class_modifier6740); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    NEW719_tree = 
                    (Object)adaptor.create(NEW719)
                    ;
                    adaptor.addChild(root_0, NEW719_tree);
                    }

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1352:4: PUBLIC
                    {
                    root_0 = (Object)adaptor.nil();


                    PUBLIC720=(Token)match(input,PUBLIC,FOLLOW_PUBLIC_in_class_modifier6745); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PUBLIC720_tree = 
                    (Object)adaptor.create(PUBLIC720)
                    ;
                    adaptor.addChild(root_0, PUBLIC720_tree);
                    }

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1353:4: PROTECTED
                    {
                    root_0 = (Object)adaptor.nil();


                    PROTECTED721=(Token)match(input,PROTECTED,FOLLOW_PROTECTED_in_class_modifier6750); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PROTECTED721_tree = 
                    (Object)adaptor.create(PROTECTED721)
                    ;
                    adaptor.addChild(root_0, PROTECTED721_tree);
                    }

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1354:4: INTERNAL
                    {
                    root_0 = (Object)adaptor.nil();


                    INTERNAL722=(Token)match(input,INTERNAL,FOLLOW_INTERNAL_in_class_modifier6755); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    INTERNAL722_tree = 
                    (Object)adaptor.create(INTERNAL722)
                    ;
                    adaptor.addChild(root_0, INTERNAL722_tree);
                    }

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1355:4: PRIVATE
                    {
                    root_0 = (Object)adaptor.nil();


                    PRIVATE723=(Token)match(input,PRIVATE,FOLLOW_PRIVATE_in_class_modifier6760); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PRIVATE723_tree = 
                    (Object)adaptor.create(PRIVATE723)
                    ;
                    adaptor.addChild(root_0, PRIVATE723_tree);
                    }

                    }
                    break;
                case 6 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1356:4: ABSTRACT
                    {
                    root_0 = (Object)adaptor.nil();


                    ABSTRACT724=(Token)match(input,ABSTRACT,FOLLOW_ABSTRACT_in_class_modifier6765); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    ABSTRACT724_tree = 
                    (Object)adaptor.create(ABSTRACT724)
                    ;
                    adaptor.addChild(root_0, ABSTRACT724_tree);
                    }

                    }
                    break;
                case 7 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1357:4: SEALED
                    {
                    root_0 = (Object)adaptor.nil();


                    SEALED725=(Token)match(input,SEALED,FOLLOW_SEALED_in_class_modifier6770); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    SEALED725_tree = 
                    (Object)adaptor.create(SEALED725)
                    ;
                    adaptor.addChild(root_0, SEALED725_tree);
                    }

                    }
                    break;
                case 8 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1358:4: STATIC
                    {
                    root_0 = (Object)adaptor.nil();


                    STATIC726=(Token)match(input,STATIC,FOLLOW_STATIC_in_class_modifier6775); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    STATIC726_tree = 
                    (Object)adaptor.create(STATIC726)
                    ;
                    adaptor.addChild(root_0, STATIC726_tree);
                    }

                    }
                    break;
                case 9 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1359:4: class_modifier_unsafe
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_class_modifier_unsafe_in_class_modifier6780);
                    class_modifier_unsafe727=class_modifier_unsafe();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, class_modifier_unsafe727.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "class_modifier"


    public static class type_parameter_list_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "type_parameter_list"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1361:1: type_parameter_list : LT ! type_parameters GT !;
    public final CSharp4AST.type_parameter_list_return type_parameter_list() throws RecognitionException {
        CSharp4AST.type_parameter_list_return retval = new CSharp4AST.type_parameter_list_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token LT728=null;
        Token GT730=null;
        CSharp4AST.type_parameters_return type_parameters729 =null;


        Object LT728_tree=null;
        Object GT730_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1362:2: ( LT ! type_parameters GT !)
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1362:4: LT ! type_parameters GT !
            {
            root_0 = (Object)adaptor.nil();


            LT728=(Token)match(input,LT,FOLLOW_LT_in_type_parameter_list6791); if (state.failed) return retval;

            pushFollow(FOLLOW_type_parameters_in_type_parameter_list6794);
            type_parameters729=type_parameters();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, type_parameters729.getTree());

            GT730=(Token)match(input,GT,FOLLOW_GT_in_type_parameter_list6796); if (state.failed) return retval;

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "type_parameter_list"


    public static class type_parameters_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "type_parameters"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1364:1: type_parameters : attributed_type_parameter ( COMMA attributed_type_parameter )* -> ^( TYPE_PARAMETERS ( attributed_type_parameter )+ ) ;
    public final CSharp4AST.type_parameters_return type_parameters() throws RecognitionException {
        CSharp4AST.type_parameters_return retval = new CSharp4AST.type_parameters_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token COMMA732=null;
        CSharp4AST.attributed_type_parameter_return attributed_type_parameter731 =null;

        CSharp4AST.attributed_type_parameter_return attributed_type_parameter733 =null;


        Object COMMA732_tree=null;
        RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
        RewriteRuleSubtreeStream stream_attributed_type_parameter=new RewriteRuleSubtreeStream(adaptor,"rule attributed_type_parameter");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1365:2: ( attributed_type_parameter ( COMMA attributed_type_parameter )* -> ^( TYPE_PARAMETERS ( attributed_type_parameter )+ ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1365:4: attributed_type_parameter ( COMMA attributed_type_parameter )*
            {
            pushFollow(FOLLOW_attributed_type_parameter_in_type_parameters6808);
            attributed_type_parameter731=attributed_type_parameter();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_attributed_type_parameter.add(attributed_type_parameter731.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1365:30: ( COMMA attributed_type_parameter )*
            loop153:
            do {
                int alt153=2;
                int LA153_0 = input.LA(1);

                if ( (LA153_0==COMMA) ) {
                    alt153=1;
                }


                switch (alt153) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1365:32: COMMA attributed_type_parameter
            	    {
            	    COMMA732=(Token)match(input,COMMA,FOLLOW_COMMA_in_type_parameters6812); if (state.failed) return retval; 
            	    if ( state.backtracking==0 ) stream_COMMA.add(COMMA732);


            	    pushFollow(FOLLOW_attributed_type_parameter_in_type_parameters6815);
            	    attributed_type_parameter733=attributed_type_parameter();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) stream_attributed_type_parameter.add(attributed_type_parameter733.getTree());

            	    }
            	    break;

            	default :
            	    break loop153;
                }
            } while (true);


            // AST REWRITE
            // elements: attributed_type_parameter
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 1366:4: -> ^( TYPE_PARAMETERS ( attributed_type_parameter )+ )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1366:7: ^( TYPE_PARAMETERS ( attributed_type_parameter )+ )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(TYPE_PARAMETERS, "TYPE_PARAMETERS")
                , root_1);

                if ( !(stream_attributed_type_parameter.hasNext()) ) {
                    throw new RewriteEarlyExitException();
                }
                while ( stream_attributed_type_parameter.hasNext() ) {
                    adaptor.addChild(root_1, stream_attributed_type_parameter.nextTree());

                }
                stream_attributed_type_parameter.reset();

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "type_parameters"


    public static class attributed_type_parameter_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "attributed_type_parameter"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1368:1: attributed_type_parameter : ( attributes )? type_parameter -> ^( TYPE_PARAM ( attributes )? type_parameter ) ;
    public final CSharp4AST.attributed_type_parameter_return attributed_type_parameter() throws RecognitionException {
        CSharp4AST.attributed_type_parameter_return retval = new CSharp4AST.attributed_type_parameter_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.attributes_return attributes734 =null;

        CSharp4AST.type_parameter_return type_parameter735 =null;


        RewriteRuleSubtreeStream stream_type_parameter=new RewriteRuleSubtreeStream(adaptor,"rule type_parameter");
        RewriteRuleSubtreeStream stream_attributes=new RewriteRuleSubtreeStream(adaptor,"rule attributes");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1369:3: ( ( attributes )? type_parameter -> ^( TYPE_PARAM ( attributes )? type_parameter ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1369:5: ( attributes )? type_parameter
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1369:5: ( attributes )?
            int alt154=2;
            int LA154_0 = input.LA(1);

            if ( (LA154_0==OPEN_BRACKET) ) {
                alt154=1;
            }
            switch (alt154) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1369:5: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_attributed_type_parameter6842);
                    attributes734=attributes();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) stream_attributes.add(attributes734.getTree());

                    }
                    break;

            }


            pushFollow(FOLLOW_type_parameter_in_attributed_type_parameter6845);
            type_parameter735=type_parameter();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_type_parameter.add(type_parameter735.getTree());

            // AST REWRITE
            // elements: type_parameter, attributes
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 1369:33: -> ^( TYPE_PARAM ( attributes )? type_parameter )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1369:36: ^( TYPE_PARAM ( attributes )? type_parameter )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(TYPE_PARAM, "TYPE_PARAM")
                , root_1);

                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1369:49: ( attributes )?
                if ( stream_attributes.hasNext() ) {
                    adaptor.addChild(root_1, stream_attributes.nextTree());

                }
                stream_attributes.reset();

                adaptor.addChild(root_1, stream_type_parameter.nextTree());

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "attributed_type_parameter"


    public static class type_parameter_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "type_parameter"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1372:1: type_parameter : IDENTIFIER ;
    public final CSharp4AST.type_parameter_return type_parameter() throws RecognitionException {
        CSharp4AST.type_parameter_return retval = new CSharp4AST.type_parameter_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER736=null;

        Object IDENTIFIER736_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1373:2: ( IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1373:4: IDENTIFIER
            {
            root_0 = (Object)adaptor.nil();


            IDENTIFIER736=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_type_parameter6871); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER736_tree = 
            (Object)adaptor.create(IDENTIFIER736)
            ;
            adaptor.addChild(root_0, IDENTIFIER736_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "type_parameter"


    public static class class_base_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "class_base"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1383:1: class_base : COLON class_type ( COMMA interface_type )* -> ^( EXTENDS_OR_IMPLEMENTS class_type ( interface_type )* ) ;
    public final CSharp4AST.class_base_return class_base() throws RecognitionException {
        CSharp4AST.class_base_return retval = new CSharp4AST.class_base_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token COLON737=null;
        Token COMMA739=null;
        CSharp4AST.class_type_return class_type738 =null;

        CSharp4AST.interface_type_return interface_type740 =null;


        Object COLON737_tree=null;
        Object COMMA739_tree=null;
        RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
        RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
        RewriteRuleSubtreeStream stream_interface_type=new RewriteRuleSubtreeStream(adaptor,"rule interface_type");
        RewriteRuleSubtreeStream stream_class_type=new RewriteRuleSubtreeStream(adaptor,"rule class_type");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1384:3: ( COLON class_type ( COMMA interface_type )* -> ^( EXTENDS_OR_IMPLEMENTS class_type ( interface_type )* ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1384:5: COLON class_type ( COMMA interface_type )*
            {
            COLON737=(Token)match(input,COLON,FOLLOW_COLON_in_class_base6886); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_COLON.add(COLON737);


            pushFollow(FOLLOW_class_type_in_class_base6888);
            class_type738=class_type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_class_type.add(class_type738.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1384:22: ( COMMA interface_type )*
            loop155:
            do {
                int alt155=2;
                int LA155_0 = input.LA(1);

                if ( (LA155_0==COMMA) ) {
                    alt155=1;
                }


                switch (alt155) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1384:24: COMMA interface_type
            	    {
            	    COMMA739=(Token)match(input,COMMA,FOLLOW_COMMA_in_class_base6892); if (state.failed) return retval; 
            	    if ( state.backtracking==0 ) stream_COMMA.add(COMMA739);


            	    pushFollow(FOLLOW_interface_type_in_class_base6895);
            	    interface_type740=interface_type();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) stream_interface_type.add(interface_type740.getTree());

            	    }
            	    break;

            	default :
            	    break loop155;
                }
            } while (true);


            // AST REWRITE
            // elements: class_type, interface_type
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 1385:5: -> ^( EXTENDS_OR_IMPLEMENTS class_type ( interface_type )* )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1385:8: ^( EXTENDS_OR_IMPLEMENTS class_type ( interface_type )* )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(EXTENDS_OR_IMPLEMENTS, "EXTENDS_OR_IMPLEMENTS")
                , root_1);

                adaptor.addChild(root_1, stream_class_type.nextTree());

                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1385:45: ( interface_type )*
                while ( stream_interface_type.hasNext() ) {
                    adaptor.addChild(root_1, stream_interface_type.nextTree());

                }
                stream_interface_type.reset();

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "class_base"


    public static class interface_type_list_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "interface_type_list"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1387:1: interface_type_list : interface_type ( COMMA interface_type )* -> ^( IMPLEMENTS ( interface_type )+ ) ;
    public final CSharp4AST.interface_type_list_return interface_type_list() throws RecognitionException {
        CSharp4AST.interface_type_list_return retval = new CSharp4AST.interface_type_list_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token COMMA742=null;
        CSharp4AST.interface_type_return interface_type741 =null;

        CSharp4AST.interface_type_return interface_type743 =null;


        Object COMMA742_tree=null;
        RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
        RewriteRuleSubtreeStream stream_interface_type=new RewriteRuleSubtreeStream(adaptor,"rule interface_type");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1388:2: ( interface_type ( COMMA interface_type )* -> ^( IMPLEMENTS ( interface_type )+ ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1388:4: interface_type ( COMMA interface_type )*
            {
            pushFollow(FOLLOW_interface_type_in_interface_type_list6927);
            interface_type741=interface_type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_interface_type.add(interface_type741.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1388:19: ( COMMA interface_type )*
            loop156:
            do {
                int alt156=2;
                int LA156_0 = input.LA(1);

                if ( (LA156_0==COMMA) ) {
                    alt156=1;
                }


                switch (alt156) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1388:21: COMMA interface_type
            	    {
            	    COMMA742=(Token)match(input,COMMA,FOLLOW_COMMA_in_interface_type_list6931); if (state.failed) return retval; 
            	    if ( state.backtracking==0 ) stream_COMMA.add(COMMA742);


            	    pushFollow(FOLLOW_interface_type_in_interface_type_list6934);
            	    interface_type743=interface_type();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) stream_interface_type.add(interface_type743.getTree());

            	    }
            	    break;

            	default :
            	    break loop156;
                }
            } while (true);


            // AST REWRITE
            // elements: interface_type
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 1389:4: -> ^( IMPLEMENTS ( interface_type )+ )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1389:7: ^( IMPLEMENTS ( interface_type )+ )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(IMPLEMENTS, "IMPLEMENTS")
                , root_1);

                if ( !(stream_interface_type.hasNext()) ) {
                    throw new RewriteEarlyExitException();
                }
                while ( stream_interface_type.hasNext() ) {
                    adaptor.addChild(root_1, stream_interface_type.nextTree());

                }
                stream_interface_type.reset();

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "interface_type_list"


    public static class type_parameter_constraints_clauses_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "type_parameter_constraints_clauses"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1391:1: type_parameter_constraints_clauses : ( type_parameter_constraints_clause )+ -> ^( TYPE_PARAMETER_CONSTRAINTS_CLAUSES ( type_parameter_constraints_clause )+ ) ;
    public final CSharp4AST.type_parameter_constraints_clauses_return type_parameter_constraints_clauses() throws RecognitionException {
        CSharp4AST.type_parameter_constraints_clauses_return retval = new CSharp4AST.type_parameter_constraints_clauses_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.type_parameter_constraints_clause_return type_parameter_constraints_clause744 =null;


        RewriteRuleSubtreeStream stream_type_parameter_constraints_clause=new RewriteRuleSubtreeStream(adaptor,"rule type_parameter_constraints_clause");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1392:2: ( ( type_parameter_constraints_clause )+ -> ^( TYPE_PARAMETER_CONSTRAINTS_CLAUSES ( type_parameter_constraints_clause )+ ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1392:4: ( type_parameter_constraints_clause )+
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1392:4: ( type_parameter_constraints_clause )+
            int cnt157=0;
            loop157:
            do {
                int alt157=2;
                int LA157_0 = input.LA(1);

                if ( (LA157_0==IDENTIFIER) ) {
                    alt157=1;
                }


                switch (alt157) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1392:4: type_parameter_constraints_clause
            	    {
            	    pushFollow(FOLLOW_type_parameter_constraints_clause_in_type_parameter_constraints_clauses6960);
            	    type_parameter_constraints_clause744=type_parameter_constraints_clause();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) stream_type_parameter_constraints_clause.add(type_parameter_constraints_clause744.getTree());

            	    }
            	    break;

            	default :
            	    if ( cnt157 >= 1 ) break loop157;
            	    if (state.backtracking>0) {state.failed=true; return retval;}
                        EarlyExitException eee =
                            new EarlyExitException(157, input);
                        throw eee;
                }
                cnt157++;
            } while (true);


            // AST REWRITE
            // elements: type_parameter_constraints_clause
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 1393:4: -> ^( TYPE_PARAMETER_CONSTRAINTS_CLAUSES ( type_parameter_constraints_clause )+ )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1393:7: ^( TYPE_PARAMETER_CONSTRAINTS_CLAUSES ( type_parameter_constraints_clause )+ )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(TYPE_PARAMETER_CONSTRAINTS_CLAUSES, "TYPE_PARAMETER_CONSTRAINTS_CLAUSES")
                , root_1);

                if ( !(stream_type_parameter_constraints_clause.hasNext()) ) {
                    throw new RewriteEarlyExitException();
                }
                while ( stream_type_parameter_constraints_clause.hasNext() ) {
                    adaptor.addChild(root_1, stream_type_parameter_constraints_clause.nextTree());

                }
                stream_type_parameter_constraints_clause.reset();

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "type_parameter_constraints_clauses"


    public static class type_parameter_constraints_clause_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "type_parameter_constraints_clause"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1395:1: type_parameter_constraints_clause : where_contextual_keyword type_parameter COLON type_parameter_constraints -> ^( TYPE_PARAMETER_CONSTRAINTS_CLAUSE type_parameter type_parameter_constraints ) ;
    public final CSharp4AST.type_parameter_constraints_clause_return type_parameter_constraints_clause() throws RecognitionException {
        CSharp4AST.type_parameter_constraints_clause_return retval = new CSharp4AST.type_parameter_constraints_clause_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token COLON747=null;
        CSharp4AST.where_contextual_keyword_return where_contextual_keyword745 =null;

        CSharp4AST.type_parameter_return type_parameter746 =null;

        CSharp4AST.type_parameter_constraints_return type_parameter_constraints748 =null;


        Object COLON747_tree=null;
        RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
        RewriteRuleSubtreeStream stream_where_contextual_keyword=new RewriteRuleSubtreeStream(adaptor,"rule where_contextual_keyword");
        RewriteRuleSubtreeStream stream_type_parameter=new RewriteRuleSubtreeStream(adaptor,"rule type_parameter");
        RewriteRuleSubtreeStream stream_type_parameter_constraints=new RewriteRuleSubtreeStream(adaptor,"rule type_parameter_constraints");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1396:2: ( where_contextual_keyword type_parameter COLON type_parameter_constraints -> ^( TYPE_PARAMETER_CONSTRAINTS_CLAUSE type_parameter type_parameter_constraints ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1396:4: where_contextual_keyword type_parameter COLON type_parameter_constraints
            {
            pushFollow(FOLLOW_where_contextual_keyword_in_type_parameter_constraints_clause6984);
            where_contextual_keyword745=where_contextual_keyword();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_where_contextual_keyword.add(where_contextual_keyword745.getTree());

            pushFollow(FOLLOW_type_parameter_in_type_parameter_constraints_clause6986);
            type_parameter746=type_parameter();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_type_parameter.add(type_parameter746.getTree());

            COLON747=(Token)match(input,COLON,FOLLOW_COLON_in_type_parameter_constraints_clause6988); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_COLON.add(COLON747);


            pushFollow(FOLLOW_type_parameter_constraints_in_type_parameter_constraints_clause6990);
            type_parameter_constraints748=type_parameter_constraints();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_type_parameter_constraints.add(type_parameter_constraints748.getTree());

            // AST REWRITE
            // elements: type_parameter_constraints, type_parameter
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 1397:4: -> ^( TYPE_PARAMETER_CONSTRAINTS_CLAUSE type_parameter type_parameter_constraints )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1397:7: ^( TYPE_PARAMETER_CONSTRAINTS_CLAUSE type_parameter type_parameter_constraints )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(TYPE_PARAMETER_CONSTRAINTS_CLAUSE, "TYPE_PARAMETER_CONSTRAINTS_CLAUSE")
                , root_1);

                adaptor.addChild(root_1, stream_type_parameter.nextTree());

                adaptor.addChild(root_1, stream_type_parameter_constraints.nextTree());

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "type_parameter_constraints_clause"


    public static class type_parameter_constraints_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "type_parameter_constraints"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1410:1: type_parameter_constraints : ( constructor_constraint | primary_constraint ( COMMA secondary_constraints )? ( COMMA constructor_constraint )? );
    public final CSharp4AST.type_parameter_constraints_return type_parameter_constraints() throws RecognitionException {
        CSharp4AST.type_parameter_constraints_return retval = new CSharp4AST.type_parameter_constraints_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token COMMA751=null;
        Token COMMA753=null;
        CSharp4AST.constructor_constraint_return constructor_constraint749 =null;

        CSharp4AST.primary_constraint_return primary_constraint750 =null;

        CSharp4AST.secondary_constraints_return secondary_constraints752 =null;

        CSharp4AST.constructor_constraint_return constructor_constraint754 =null;


        Object COMMA751_tree=null;
        Object COMMA753_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1411:3: ( constructor_constraint | primary_constraint ( COMMA secondary_constraints )? ( COMMA constructor_constraint )? )
            int alt160=2;
            int LA160_0 = input.LA(1);

            if ( (LA160_0==NEW) ) {
                alt160=1;
            }
            else if ( (LA160_0==CLASS||LA160_0==IDENTIFIER||LA160_0==OBJECT||LA160_0==STRING||LA160_0==STRUCT) ) {
                alt160=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 160, 0, input);

                throw nvae;

            }
            switch (alt160) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1411:5: constructor_constraint
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_constructor_constraint_in_type_parameter_constraints7019);
                    constructor_constraint749=constructor_constraint();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, constructor_constraint749.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1412:5: primary_constraint ( COMMA secondary_constraints )? ( COMMA constructor_constraint )?
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_primary_constraint_in_type_parameter_constraints7025);
                    primary_constraint750=primary_constraint();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, primary_constraint750.getTree());

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1412:24: ( COMMA secondary_constraints )?
                    int alt158=2;
                    int LA158_0 = input.LA(1);

                    if ( (LA158_0==COMMA) ) {
                        int LA158_1 = input.LA(2);

                        if ( (LA158_1==IDENTIFIER) ) {
                            alt158=1;
                        }
                    }
                    switch (alt158) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1412:25: COMMA secondary_constraints
                            {
                            COMMA751=(Token)match(input,COMMA,FOLLOW_COMMA_in_type_parameter_constraints7028); if (state.failed) return retval;
                            if ( state.backtracking==0 ) {
                            COMMA751_tree = 
                            (Object)adaptor.create(COMMA751)
                            ;
                            adaptor.addChild(root_0, COMMA751_tree);
                            }

                            pushFollow(FOLLOW_secondary_constraints_in_type_parameter_constraints7030);
                            secondary_constraints752=secondary_constraints();

                            state._fsp--;
                            if (state.failed) return retval;
                            if ( state.backtracking==0 ) adaptor.addChild(root_0, secondary_constraints752.getTree());

                            }
                            break;

                    }


                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1412:55: ( COMMA constructor_constraint )?
                    int alt159=2;
                    int LA159_0 = input.LA(1);

                    if ( (LA159_0==COMMA) ) {
                        alt159=1;
                    }
                    switch (alt159) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1412:56: COMMA constructor_constraint
                            {
                            COMMA753=(Token)match(input,COMMA,FOLLOW_COMMA_in_type_parameter_constraints7035); if (state.failed) return retval;
                            if ( state.backtracking==0 ) {
                            COMMA753_tree = 
                            (Object)adaptor.create(COMMA753)
                            ;
                            adaptor.addChild(root_0, COMMA753_tree);
                            }

                            pushFollow(FOLLOW_constructor_constraint_in_type_parameter_constraints7037);
                            constructor_constraint754=constructor_constraint();

                            state._fsp--;
                            if (state.failed) return retval;
                            if ( state.backtracking==0 ) adaptor.addChild(root_0, constructor_constraint754.getTree());

                            }
                            break;

                    }


                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "type_parameter_constraints"


    public static class primary_constraint_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "primary_constraint"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1414:1: primary_constraint : ( class_type | CLASS | STRUCT );
    public final CSharp4AST.primary_constraint_return primary_constraint() throws RecognitionException {
        CSharp4AST.primary_constraint_return retval = new CSharp4AST.primary_constraint_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token CLASS756=null;
        Token STRUCT757=null;
        CSharp4AST.class_type_return class_type755 =null;


        Object CLASS756_tree=null;
        Object STRUCT757_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1415:2: ( class_type | CLASS | STRUCT )
            int alt161=3;
            switch ( input.LA(1) ) {
            case IDENTIFIER:
            case OBJECT:
            case STRING:
                {
                alt161=1;
                }
                break;
            case CLASS:
                {
                alt161=2;
                }
                break;
            case STRUCT:
                {
                alt161=3;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 161, 0, input);

                throw nvae;

            }

            switch (alt161) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1415:4: class_type
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_class_type_in_primary_constraint7051);
                    class_type755=class_type();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, class_type755.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1416:4: CLASS
                    {
                    root_0 = (Object)adaptor.nil();


                    CLASS756=(Token)match(input,CLASS,FOLLOW_CLASS_in_primary_constraint7056); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    CLASS756_tree = 
                    (Object)adaptor.create(CLASS756)
                    ;
                    adaptor.addChild(root_0, CLASS756_tree);
                    }

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1417:4: STRUCT
                    {
                    root_0 = (Object)adaptor.nil();


                    STRUCT757=(Token)match(input,STRUCT,FOLLOW_STRUCT_in_primary_constraint7061); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    STRUCT757_tree = 
                    (Object)adaptor.create(STRUCT757)
                    ;
                    adaptor.addChild(root_0, STRUCT757_tree);
                    }

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "primary_constraint"


    public static class secondary_constraints_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "secondary_constraints"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1428:1: secondary_constraints : interface_type ( COMMA interface_type )* ;
    public final CSharp4AST.secondary_constraints_return secondary_constraints() throws RecognitionException {
        CSharp4AST.secondary_constraints_return retval = new CSharp4AST.secondary_constraints_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token COMMA759=null;
        CSharp4AST.interface_type_return interface_type758 =null;

        CSharp4AST.interface_type_return interface_type760 =null;


        Object COMMA759_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1429:3: ( interface_type ( COMMA interface_type )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1429:5: interface_type ( COMMA interface_type )*
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_interface_type_in_secondary_constraints7075);
            interface_type758=interface_type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, interface_type758.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1429:20: ( COMMA interface_type )*
            loop162:
            do {
                int alt162=2;
                int LA162_0 = input.LA(1);

                if ( (LA162_0==COMMA) ) {
                    int LA162_1 = input.LA(2);

                    if ( (LA162_1==IDENTIFIER) ) {
                        alt162=1;
                    }


                }


                switch (alt162) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1429:21: COMMA interface_type
            	    {
            	    COMMA759=(Token)match(input,COMMA,FOLLOW_COMMA_in_secondary_constraints7078); if (state.failed) return retval;
            	    if ( state.backtracking==0 ) {
            	    COMMA759_tree = 
            	    (Object)adaptor.create(COMMA759)
            	    ;
            	    adaptor.addChild(root_0, COMMA759_tree);
            	    }

            	    pushFollow(FOLLOW_interface_type_in_secondary_constraints7080);
            	    interface_type760=interface_type();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, interface_type760.getTree());

            	    }
            	    break;

            	default :
            	    break loop162;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "secondary_constraints"


    public static class constructor_constraint_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "constructor_constraint"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1431:1: constructor_constraint : NEW OPEN_PARENS CLOSE_PARENS ;
    public final CSharp4AST.constructor_constraint_return constructor_constraint() throws RecognitionException {
        CSharp4AST.constructor_constraint_return retval = new CSharp4AST.constructor_constraint_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token NEW761=null;
        Token OPEN_PARENS762=null;
        Token CLOSE_PARENS763=null;

        Object NEW761_tree=null;
        Object OPEN_PARENS762_tree=null;
        Object CLOSE_PARENS763_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1432:2: ( NEW OPEN_PARENS CLOSE_PARENS )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1432:4: NEW OPEN_PARENS CLOSE_PARENS
            {
            root_0 = (Object)adaptor.nil();


            NEW761=(Token)match(input,NEW,FOLLOW_NEW_in_constructor_constraint7094); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            NEW761_tree = 
            (Object)adaptor.create(NEW761)
            ;
            adaptor.addChild(root_0, NEW761_tree);
            }

            OPEN_PARENS762=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_constructor_constraint7096); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            OPEN_PARENS762_tree = 
            (Object)adaptor.create(OPEN_PARENS762)
            ;
            adaptor.addChild(root_0, OPEN_PARENS762_tree);
            }

            CLOSE_PARENS763=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_constructor_constraint7098); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            CLOSE_PARENS763_tree = 
            (Object)adaptor.create(CLOSE_PARENS763)
            ;
            adaptor.addChild(root_0, CLOSE_PARENS763_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "constructor_constraint"


    public static class class_body_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "class_body"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1434:1: class_body : OPEN_BRACE ! ( class_member_declarations )? CLOSE_BRACE !;
    public final CSharp4AST.class_body_return class_body() throws RecognitionException {
        CSharp4AST.class_body_return retval = new CSharp4AST.class_body_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token OPEN_BRACE764=null;
        Token CLOSE_BRACE766=null;
        CSharp4AST.class_member_declarations_return class_member_declarations765 =null;


        Object OPEN_BRACE764_tree=null;
        Object CLOSE_BRACE766_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1435:2: ( OPEN_BRACE ! ( class_member_declarations )? CLOSE_BRACE !)
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1435:4: OPEN_BRACE ! ( class_member_declarations )? CLOSE_BRACE !
            {
            root_0 = (Object)adaptor.nil();


            OPEN_BRACE764=(Token)match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_class_body7109); if (state.failed) return retval;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1435:16: ( class_member_declarations )?
            int alt163=2;
            int LA163_0 = input.LA(1);

            if ( (LA163_0==ABSTRACT||LA163_0==BOOL||LA163_0==BYTE||LA163_0==CHAR||LA163_0==CLASS||LA163_0==CONST||LA163_0==DECIMAL||LA163_0==DELEGATE||LA163_0==DOUBLE||(LA163_0 >= ENUM && LA163_0 <= EXTERN)||LA163_0==FLOAT||LA163_0==IDENTIFIER||LA163_0==IMPLICIT||LA163_0==INT||(LA163_0 >= INTERFACE && LA163_0 <= INTERNAL)||LA163_0==LONG||LA163_0==NEW||LA163_0==OBJECT||LA163_0==OPEN_BRACKET||LA163_0==OVERRIDE||(LA163_0 >= PRIVATE && LA163_0 <= PUBLIC)||LA163_0==READONLY||(LA163_0 >= SBYTE && LA163_0 <= SEALED)||LA163_0==SHORT||(LA163_0 >= STATIC && LA163_0 <= STRING)||LA163_0==STRUCT||LA163_0==TILDE||(LA163_0 >= UINT && LA163_0 <= ULONG)||(LA163_0 >= UNSAFE && LA163_0 <= USHORT)||(LA163_0 >= VIRTUAL && LA163_0 <= VOLATILE)) ) {
                alt163=1;
            }
            switch (alt163) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1435:16: class_member_declarations
                    {
                    pushFollow(FOLLOW_class_member_declarations_in_class_body7112);
                    class_member_declarations765=class_member_declarations();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, class_member_declarations765.getTree());

                    }
                    break;

            }


            CLOSE_BRACE766=(Token)match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_class_body7115); if (state.failed) return retval;

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "class_body"


    public static class class_member_declarations_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "class_member_declarations"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1437:1: class_member_declarations : ( class_member_declaration )+ -> ^( CLASS_MEMBER_DECLARATIONS ( class_member_declaration )+ ) ;
    public final CSharp4AST.class_member_declarations_return class_member_declarations() throws RecognitionException {
        CSharp4AST.class_member_declarations_return retval = new CSharp4AST.class_member_declarations_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.class_member_declaration_return class_member_declaration767 =null;


        RewriteRuleSubtreeStream stream_class_member_declaration=new RewriteRuleSubtreeStream(adaptor,"rule class_member_declaration");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1438:2: ( ( class_member_declaration )+ -> ^( CLASS_MEMBER_DECLARATIONS ( class_member_declaration )+ ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1438:4: ( class_member_declaration )+
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1438:4: ( class_member_declaration )+
            int cnt164=0;
            loop164:
            do {
                int alt164=2;
                int LA164_0 = input.LA(1);

                if ( (LA164_0==ABSTRACT||LA164_0==BOOL||LA164_0==BYTE||LA164_0==CHAR||LA164_0==CLASS||LA164_0==CONST||LA164_0==DECIMAL||LA164_0==DELEGATE||LA164_0==DOUBLE||(LA164_0 >= ENUM && LA164_0 <= EXTERN)||LA164_0==FLOAT||LA164_0==IDENTIFIER||LA164_0==IMPLICIT||LA164_0==INT||(LA164_0 >= INTERFACE && LA164_0 <= INTERNAL)||LA164_0==LONG||LA164_0==NEW||LA164_0==OBJECT||LA164_0==OPEN_BRACKET||LA164_0==OVERRIDE||(LA164_0 >= PRIVATE && LA164_0 <= PUBLIC)||LA164_0==READONLY||(LA164_0 >= SBYTE && LA164_0 <= SEALED)||LA164_0==SHORT||(LA164_0 >= STATIC && LA164_0 <= STRING)||LA164_0==STRUCT||LA164_0==TILDE||(LA164_0 >= UINT && LA164_0 <= ULONG)||(LA164_0 >= UNSAFE && LA164_0 <= USHORT)||(LA164_0 >= VIRTUAL && LA164_0 <= VOLATILE)) ) {
                    alt164=1;
                }


                switch (alt164) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1438:4: class_member_declaration
            	    {
            	    pushFollow(FOLLOW_class_member_declaration_in_class_member_declarations7127);
            	    class_member_declaration767=class_member_declaration();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) stream_class_member_declaration.add(class_member_declaration767.getTree());

            	    }
            	    break;

            	default :
            	    if ( cnt164 >= 1 ) break loop164;
            	    if (state.backtracking>0) {state.failed=true; return retval;}
                        EarlyExitException eee =
                            new EarlyExitException(164, input);
                        throw eee;
                }
                cnt164++;
            } while (true);


            // AST REWRITE
            // elements: class_member_declaration
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 1439:4: -> ^( CLASS_MEMBER_DECLARATIONS ( class_member_declaration )+ )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1439:7: ^( CLASS_MEMBER_DECLARATIONS ( class_member_declaration )+ )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(CLASS_MEMBER_DECLARATIONS, "CLASS_MEMBER_DECLARATIONS")
                , root_1);

                if ( !(stream_class_member_declaration.hasNext()) ) {
                    throw new RewriteEarlyExitException();
                }
                while ( stream_class_member_declaration.hasNext() ) {
                    adaptor.addChild(root_1, stream_class_member_declaration.nextTree());

                }
                stream_class_member_declaration.reset();

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "class_member_declarations"


    public static class class_member_declaration_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "class_member_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1456:1: class_member_declaration : ( attributes )? ( all_member_modifiers )? ( common_member_declaration ^| destructor_definition ^) ;
    public final CSharp4AST.class_member_declaration_return class_member_declaration() throws RecognitionException {
        CSharp4AST.class_member_declaration_return retval = new CSharp4AST.class_member_declaration_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.attributes_return attributes768 =null;

        CSharp4AST.all_member_modifiers_return all_member_modifiers769 =null;

        CSharp4AST.common_member_declaration_return common_member_declaration770 =null;

        CSharp4AST.destructor_definition_return destructor_definition771 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1457:3: ( ( attributes )? ( all_member_modifiers )? ( common_member_declaration ^| destructor_definition ^) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1457:5: ( attributes )? ( all_member_modifiers )? ( common_member_declaration ^| destructor_definition ^)
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1457:5: ( attributes )?
            int alt165=2;
            int LA165_0 = input.LA(1);

            if ( (LA165_0==OPEN_BRACKET) ) {
                alt165=1;
            }
            switch (alt165) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1457:6: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_class_member_declaration7156);
                    attributes768=attributes();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, attributes768.getTree());

                    if ( state.backtracking==0 ) {attrs = (attributes768!=null?((Object)attributes768.tree):null);}

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1458:5: ( all_member_modifiers )?
            int alt166=2;
            int LA166_0 = input.LA(1);

            if ( (LA166_0==ABSTRACT||LA166_0==EXTERN||LA166_0==INTERNAL||LA166_0==NEW||LA166_0==OVERRIDE||(LA166_0 >= PRIVATE && LA166_0 <= PUBLIC)||LA166_0==READONLY||LA166_0==SEALED||LA166_0==STATIC||LA166_0==UNSAFE||LA166_0==VIRTUAL||LA166_0==VOLATILE) ) {
                alt166=1;
            }
            else if ( (LA166_0==IDENTIFIER) ) {
                int LA166_15 = input.LA(2);

                if ( ((input.LT(1).getText().equals("partial"))) ) {
                    alt166=1;
                }
            }
            switch (alt166) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1458:6: all_member_modifiers
                    {
                    pushFollow(FOLLOW_all_member_modifiers_in_class_member_declaration7167);
                    all_member_modifiers769=all_member_modifiers();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, all_member_modifiers769.getTree());

                    if ( state.backtracking==0 ) {members = (all_member_modifiers769!=null?((Object)all_member_modifiers769.tree):null);}

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1459:4: ( common_member_declaration ^| destructor_definition ^)
            int alt167=2;
            int LA167_0 = input.LA(1);

            if ( (LA167_0==BOOL||LA167_0==BYTE||LA167_0==CHAR||LA167_0==CLASS||LA167_0==CONST||LA167_0==DECIMAL||LA167_0==DELEGATE||LA167_0==DOUBLE||(LA167_0 >= ENUM && LA167_0 <= EXPLICIT)||LA167_0==FLOAT||LA167_0==IDENTIFIER||LA167_0==IMPLICIT||LA167_0==INT||LA167_0==INTERFACE||LA167_0==LONG||LA167_0==OBJECT||LA167_0==SBYTE||LA167_0==SHORT||LA167_0==STRING||LA167_0==STRUCT||(LA167_0 >= UINT && LA167_0 <= ULONG)||LA167_0==USHORT||LA167_0==VOID) ) {
                alt167=1;
            }
            else if ( (LA167_0==TILDE) ) {
                alt167=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 167, 0, input);

                throw nvae;

            }
            switch (alt167) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1459:6: common_member_declaration ^
                    {
                    pushFollow(FOLLOW_common_member_declaration_in_class_member_declaration7178);
                    common_member_declaration770=common_member_declaration();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(common_member_declaration770.getTree(), root_0);

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1460:6: destructor_definition ^
                    {
                    pushFollow(FOLLOW_destructor_definition_in_class_member_declaration7186);
                    destructor_definition771=destructor_definition();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(destructor_definition771.getTree(), root_0);

                    }
                    break;

            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "class_member_declaration"


    public static class all_member_modifiers_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "all_member_modifiers"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1465:1: all_member_modifiers : ( all_member_modifier )+ -> ^( MODIFIERS ( all_member_modifier )+ ) ;
    public final CSharp4AST.all_member_modifiers_return all_member_modifiers() throws RecognitionException {
        CSharp4AST.all_member_modifiers_return retval = new CSharp4AST.all_member_modifiers_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.all_member_modifier_return all_member_modifier772 =null;


        RewriteRuleSubtreeStream stream_all_member_modifier=new RewriteRuleSubtreeStream(adaptor,"rule all_member_modifier");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1466:3: ( ( all_member_modifier )+ -> ^( MODIFIERS ( all_member_modifier )+ ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1466:5: ( all_member_modifier )+
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1466:5: ( all_member_modifier )+
            int cnt168=0;
            loop168:
            do {
                int alt168=2;
                int LA168_0 = input.LA(1);

                if ( (LA168_0==IDENTIFIER) ) {
                    int LA168_11 = input.LA(2);

                    if ( ((input.LT(1).getText().equals("partial"))) ) {
                        alt168=1;
                    }


                }
                else if ( (LA168_0==ABSTRACT||LA168_0==EXTERN||LA168_0==INTERNAL||LA168_0==NEW||LA168_0==OVERRIDE||(LA168_0 >= PRIVATE && LA168_0 <= PUBLIC)||LA168_0==READONLY||LA168_0==SEALED||LA168_0==STATIC||LA168_0==UNSAFE||LA168_0==VIRTUAL||LA168_0==VOLATILE) ) {
                    alt168=1;
                }


                switch (alt168) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1466:5: all_member_modifier
            	    {
            	    pushFollow(FOLLOW_all_member_modifier_in_all_member_modifiers7206);
            	    all_member_modifier772=all_member_modifier();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) stream_all_member_modifier.add(all_member_modifier772.getTree());

            	    }
            	    break;

            	default :
            	    if ( cnt168 >= 1 ) break loop168;
            	    if (state.backtracking>0) {state.failed=true; return retval;}
                        EarlyExitException eee =
                            new EarlyExitException(168, input);
                        throw eee;
                }
                cnt168++;
            } while (true);


            // AST REWRITE
            // elements: all_member_modifier
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 1467:5: -> ^( MODIFIERS ( all_member_modifier )+ )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1467:8: ^( MODIFIERS ( all_member_modifier )+ )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(MODIFIERS, "MODIFIERS")
                , root_1);

                if ( !(stream_all_member_modifier.hasNext()) ) {
                    throw new RewriteEarlyExitException();
                }
                while ( stream_all_member_modifier.hasNext() ) {
                    adaptor.addChild(root_1, stream_all_member_modifier.nextTree());

                }
                stream_all_member_modifier.reset();

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "all_member_modifiers"


    public static class all_member_modifier_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "all_member_modifier"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1469:1: all_member_modifier : ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | READONLY | VOLATILE | VIRTUAL | SEALED | OVERRIDE | ABSTRACT | STATIC | UNSAFE | EXTERN | partial_contextual_keyword );
    public final CSharp4AST.all_member_modifier_return all_member_modifier() throws RecognitionException {
        CSharp4AST.all_member_modifier_return retval = new CSharp4AST.all_member_modifier_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token NEW773=null;
        Token PUBLIC774=null;
        Token PROTECTED775=null;
        Token INTERNAL776=null;
        Token PRIVATE777=null;
        Token READONLY778=null;
        Token VOLATILE779=null;
        Token VIRTUAL780=null;
        Token SEALED781=null;
        Token OVERRIDE782=null;
        Token ABSTRACT783=null;
        Token STATIC784=null;
        Token UNSAFE785=null;
        Token EXTERN786=null;
        CSharp4AST.partial_contextual_keyword_return partial_contextual_keyword787 =null;


        Object NEW773_tree=null;
        Object PUBLIC774_tree=null;
        Object PROTECTED775_tree=null;
        Object INTERNAL776_tree=null;
        Object PRIVATE777_tree=null;
        Object READONLY778_tree=null;
        Object VOLATILE779_tree=null;
        Object VIRTUAL780_tree=null;
        Object SEALED781_tree=null;
        Object OVERRIDE782_tree=null;
        Object ABSTRACT783_tree=null;
        Object STATIC784_tree=null;
        Object UNSAFE785_tree=null;
        Object EXTERN786_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1470:3: ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | READONLY | VOLATILE | VIRTUAL | SEALED | OVERRIDE | ABSTRACT | STATIC | UNSAFE | EXTERN | partial_contextual_keyword )
            int alt169=15;
            switch ( input.LA(1) ) {
            case NEW:
                {
                alt169=1;
                }
                break;
            case PUBLIC:
                {
                alt169=2;
                }
                break;
            case PROTECTED:
                {
                alt169=3;
                }
                break;
            case INTERNAL:
                {
                alt169=4;
                }
                break;
            case PRIVATE:
                {
                alt169=5;
                }
                break;
            case READONLY:
                {
                alt169=6;
                }
                break;
            case VOLATILE:
                {
                alt169=7;
                }
                break;
            case VIRTUAL:
                {
                alt169=8;
                }
                break;
            case SEALED:
                {
                alt169=9;
                }
                break;
            case OVERRIDE:
                {
                alt169=10;
                }
                break;
            case ABSTRACT:
                {
                alt169=11;
                }
                break;
            case STATIC:
                {
                alt169=12;
                }
                break;
            case UNSAFE:
                {
                alt169=13;
                }
                break;
            case EXTERN:
                {
                alt169=14;
                }
                break;
            case IDENTIFIER:
                {
                alt169=15;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 169, 0, input);

                throw nvae;

            }

            switch (alt169) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1470:5: NEW
                    {
                    root_0 = (Object)adaptor.nil();


                    NEW773=(Token)match(input,NEW,FOLLOW_NEW_in_all_member_modifier7232); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    NEW773_tree = 
                    (Object)adaptor.create(NEW773)
                    ;
                    adaptor.addChild(root_0, NEW773_tree);
                    }

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1471:5: PUBLIC
                    {
                    root_0 = (Object)adaptor.nil();


                    PUBLIC774=(Token)match(input,PUBLIC,FOLLOW_PUBLIC_in_all_member_modifier7238); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PUBLIC774_tree = 
                    (Object)adaptor.create(PUBLIC774)
                    ;
                    adaptor.addChild(root_0, PUBLIC774_tree);
                    }

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1472:5: PROTECTED
                    {
                    root_0 = (Object)adaptor.nil();


                    PROTECTED775=(Token)match(input,PROTECTED,FOLLOW_PROTECTED_in_all_member_modifier7244); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PROTECTED775_tree = 
                    (Object)adaptor.create(PROTECTED775)
                    ;
                    adaptor.addChild(root_0, PROTECTED775_tree);
                    }

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1473:5: INTERNAL
                    {
                    root_0 = (Object)adaptor.nil();


                    INTERNAL776=(Token)match(input,INTERNAL,FOLLOW_INTERNAL_in_all_member_modifier7250); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    INTERNAL776_tree = 
                    (Object)adaptor.create(INTERNAL776)
                    ;
                    adaptor.addChild(root_0, INTERNAL776_tree);
                    }

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1474:5: PRIVATE
                    {
                    root_0 = (Object)adaptor.nil();


                    PRIVATE777=(Token)match(input,PRIVATE,FOLLOW_PRIVATE_in_all_member_modifier7256); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PRIVATE777_tree = 
                    (Object)adaptor.create(PRIVATE777)
                    ;
                    adaptor.addChild(root_0, PRIVATE777_tree);
                    }

                    }
                    break;
                case 6 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1475:5: READONLY
                    {
                    root_0 = (Object)adaptor.nil();


                    READONLY778=(Token)match(input,READONLY,FOLLOW_READONLY_in_all_member_modifier7262); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    READONLY778_tree = 
                    (Object)adaptor.create(READONLY778)
                    ;
                    adaptor.addChild(root_0, READONLY778_tree);
                    }

                    }
                    break;
                case 7 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1476:5: VOLATILE
                    {
                    root_0 = (Object)adaptor.nil();


                    VOLATILE779=(Token)match(input,VOLATILE,FOLLOW_VOLATILE_in_all_member_modifier7268); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    VOLATILE779_tree = 
                    (Object)adaptor.create(VOLATILE779)
                    ;
                    adaptor.addChild(root_0, VOLATILE779_tree);
                    }

                    }
                    break;
                case 8 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1477:5: VIRTUAL
                    {
                    root_0 = (Object)adaptor.nil();


                    VIRTUAL780=(Token)match(input,VIRTUAL,FOLLOW_VIRTUAL_in_all_member_modifier7274); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    VIRTUAL780_tree = 
                    (Object)adaptor.create(VIRTUAL780)
                    ;
                    adaptor.addChild(root_0, VIRTUAL780_tree);
                    }

                    }
                    break;
                case 9 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1478:5: SEALED
                    {
                    root_0 = (Object)adaptor.nil();


                    SEALED781=(Token)match(input,SEALED,FOLLOW_SEALED_in_all_member_modifier7280); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    SEALED781_tree = 
                    (Object)adaptor.create(SEALED781)
                    ;
                    adaptor.addChild(root_0, SEALED781_tree);
                    }

                    }
                    break;
                case 10 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1479:5: OVERRIDE
                    {
                    root_0 = (Object)adaptor.nil();


                    OVERRIDE782=(Token)match(input,OVERRIDE,FOLLOW_OVERRIDE_in_all_member_modifier7286); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OVERRIDE782_tree = 
                    (Object)adaptor.create(OVERRIDE782)
                    ;
                    adaptor.addChild(root_0, OVERRIDE782_tree);
                    }

                    }
                    break;
                case 11 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1480:5: ABSTRACT
                    {
                    root_0 = (Object)adaptor.nil();


                    ABSTRACT783=(Token)match(input,ABSTRACT,FOLLOW_ABSTRACT_in_all_member_modifier7292); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    ABSTRACT783_tree = 
                    (Object)adaptor.create(ABSTRACT783)
                    ;
                    adaptor.addChild(root_0, ABSTRACT783_tree);
                    }

                    }
                    break;
                case 12 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1481:5: STATIC
                    {
                    root_0 = (Object)adaptor.nil();


                    STATIC784=(Token)match(input,STATIC,FOLLOW_STATIC_in_all_member_modifier7298); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    STATIC784_tree = 
                    (Object)adaptor.create(STATIC784)
                    ;
                    adaptor.addChild(root_0, STATIC784_tree);
                    }

                    }
                    break;
                case 13 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1482:5: UNSAFE
                    {
                    root_0 = (Object)adaptor.nil();


                    UNSAFE785=(Token)match(input,UNSAFE,FOLLOW_UNSAFE_in_all_member_modifier7304); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    UNSAFE785_tree = 
                    (Object)adaptor.create(UNSAFE785)
                    ;
                    adaptor.addChild(root_0, UNSAFE785_tree);
                    }

                    }
                    break;
                case 14 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1483:5: EXTERN
                    {
                    root_0 = (Object)adaptor.nil();


                    EXTERN786=(Token)match(input,EXTERN,FOLLOW_EXTERN_in_all_member_modifier7310); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    EXTERN786_tree = 
                    (Object)adaptor.create(EXTERN786)
                    ;
                    adaptor.addChild(root_0, EXTERN786_tree);
                    }

                    }
                    break;
                case 15 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1484:5: partial_contextual_keyword
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_partial_contextual_keyword_in_all_member_modifier7316);
                    partial_contextual_keyword787=partial_contextual_keyword();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, partial_contextual_keyword787.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "all_member_modifier"


    protected static class common_member_declaration_scope {
        Object type;
    }
    protected Stack common_member_declaration_stack = new Stack();


    public static class common_member_declaration_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "common_member_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1501:1: common_member_declaration : ( constant_declaration2 | typed_member_declaration | event_declaration2 | conversion_operator_declarator ^ operator_body | constructor_declaration2 | type_void method_declaration2 ^| class_definition | struct_definition | interface_definition | enum_definition | delegate_definition );
    public final CSharp4AST.common_member_declaration_return common_member_declaration() throws RecognitionException {
        common_member_declaration_stack.push(new common_member_declaration_scope());
        CSharp4AST.common_member_declaration_return retval = new CSharp4AST.common_member_declaration_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.constant_declaration2_return constant_declaration2788 =null;

        CSharp4AST.typed_member_declaration_return typed_member_declaration789 =null;

        CSharp4AST.event_declaration2_return event_declaration2790 =null;

        CSharp4AST.conversion_operator_declarator_return conversion_operator_declarator791 =null;

        CSharp4AST.operator_body_return operator_body792 =null;

        CSharp4AST.constructor_declaration2_return constructor_declaration2793 =null;

        CSharp4AST.type_void_return type_void794 =null;

        CSharp4AST.method_declaration2_return method_declaration2795 =null;

        CSharp4AST.class_definition_return class_definition796 =null;

        CSharp4AST.struct_definition_return struct_definition797 =null;

        CSharp4AST.interface_definition_return interface_definition798 =null;

        CSharp4AST.enum_definition_return enum_definition799 =null;

        CSharp4AST.delegate_definition_return delegate_definition800 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1505:3: ( constant_declaration2 | typed_member_declaration | event_declaration2 | conversion_operator_declarator ^ operator_body | constructor_declaration2 | type_void method_declaration2 ^| class_definition | struct_definition | interface_definition | enum_definition | delegate_definition )
            int alt170=11;
            switch ( input.LA(1) ) {
            case CONST:
                {
                alt170=1;
                }
                break;
            case BOOL:
            case BYTE:
            case CHAR:
            case DECIMAL:
            case DOUBLE:
            case FLOAT:
            case INT:
            case LONG:
            case OBJECT:
            case SBYTE:
            case SHORT:
            case STRING:
            case UINT:
            case ULONG:
            case USHORT:
                {
                alt170=2;
                }
                break;
            case IDENTIFIER:
                {
                int LA170_3 = input.LA(2);

                if ( (LA170_3==DOT||LA170_3==DOUBLE_COLON||LA170_3==IDENTIFIER||LA170_3==INTERR||LA170_3==LT||LA170_3==OPEN_BRACKET||LA170_3==OPERATOR||LA170_3==STAR||LA170_3==THIS) ) {
                    alt170=2;
                }
                else if ( (LA170_3==OPEN_PARENS) ) {
                    alt170=5;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 170, 3, input);

                    throw nvae;

                }
                }
                break;
            case VOID:
                {
                int LA170_4 = input.LA(2);

                if ( (LA170_4==STAR) ) {
                    alt170=2;
                }
                else if ( (LA170_4==IDENTIFIER) ) {
                    alt170=6;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 170, 4, input);

                    throw nvae;

                }
                }
                break;
            case EVENT:
                {
                alt170=3;
                }
                break;
            case EXPLICIT:
            case IMPLICIT:
                {
                alt170=4;
                }
                break;
            case CLASS:
                {
                alt170=7;
                }
                break;
            case STRUCT:
                {
                alt170=8;
                }
                break;
            case INTERFACE:
                {
                alt170=9;
                }
                break;
            case ENUM:
                {
                alt170=10;
                }
                break;
            case DELEGATE:
                {
                alt170=11;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 170, 0, input);

                throw nvae;

            }

            switch (alt170) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1505:5: constant_declaration2
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_constant_declaration2_in_common_member_declaration7337);
                    constant_declaration2788=constant_declaration2();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, constant_declaration2788.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1506:5: typed_member_declaration
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_typed_member_declaration_in_common_member_declaration7343);
                    typed_member_declaration789=typed_member_declaration();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, typed_member_declaration789.getTree());

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1507:5: event_declaration2
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_event_declaration2_in_common_member_declaration7349);
                    event_declaration2790=event_declaration2();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, event_declaration2790.getTree());

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1508:5: conversion_operator_declarator ^ operator_body
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_conversion_operator_declarator_in_common_member_declaration7355);
                    conversion_operator_declarator791=conversion_operator_declarator();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(conversion_operator_declarator791.getTree(), root_0);

                    pushFollow(FOLLOW_operator_body_in_common_member_declaration7358);
                    operator_body792=operator_body();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, operator_body792.getTree());

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1510:5: constructor_declaration2
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_constructor_declaration2_in_common_member_declaration7367);
                    constructor_declaration2793=constructor_declaration2();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, constructor_declaration2793.getTree());

                    }
                    break;
                case 6 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1511:5: type_void method_declaration2 ^
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_type_void_in_common_member_declaration7373);
                    type_void794=type_void();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, type_void794.getTree());

                    pushFollow(FOLLOW_method_declaration2_in_common_member_declaration7377);
                    method_declaration2795=method_declaration2();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(method_declaration2795.getTree(), root_0);

                    }
                    break;
                case 7 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1512:5: class_definition
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_class_definition_in_common_member_declaration7386);
                    class_definition796=class_definition();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, class_definition796.getTree());

                    }
                    break;
                case 8 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1513:5: struct_definition
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_struct_definition_in_common_member_declaration7392);
                    struct_definition797=struct_definition();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, struct_definition797.getTree());

                    }
                    break;
                case 9 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1514:5: interface_definition
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_interface_definition_in_common_member_declaration7398);
                    interface_definition798=interface_definition();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, interface_definition798.getTree());

                    }
                    break;
                case 10 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1515:5: enum_definition
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_enum_definition_in_common_member_declaration7404);
                    enum_definition799=enum_definition();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, enum_definition799.getTree());

                    }
                    break;
                case 11 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1516:5: delegate_definition
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_delegate_definition_in_common_member_declaration7410);
                    delegate_definition800=delegate_definition();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, delegate_definition800.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
            common_member_declaration_stack.pop();
        }
        return retval;
    }
    // $ANTLR end "common_member_declaration"


    public static class typed_member_declaration_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "typed_member_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1519:1: typed_member_declaration : type ( ( interface_type DOT THIS )=> interface_type DOT ! indexer_declaration2 ^| ( member_name ( type_parameter_list )? OPEN_PARENS )=> method_declaration2 ^| ( member_name OPEN_BRACE )=> property_declaration2 ^| indexer_declaration2 ^| operator_declaration2 ^| field_declaration2 ^) ;
    public final CSharp4AST.typed_member_declaration_return typed_member_declaration() throws RecognitionException {
        CSharp4AST.typed_member_declaration_return retval = new CSharp4AST.typed_member_declaration_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token DOT803=null;
        CSharp4AST.type_return type801 =null;

        CSharp4AST.interface_type_return interface_type802 =null;

        CSharp4AST.indexer_declaration2_return indexer_declaration2804 =null;

        CSharp4AST.method_declaration2_return method_declaration2805 =null;

        CSharp4AST.property_declaration2_return property_declaration2806 =null;

        CSharp4AST.indexer_declaration2_return indexer_declaration2807 =null;

        CSharp4AST.operator_declaration2_return operator_declaration2808 =null;

        CSharp4AST.field_declaration2_return field_declaration2809 =null;


        Object DOT803_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1520:3: ( type ( ( interface_type DOT THIS )=> interface_type DOT ! indexer_declaration2 ^| ( member_name ( type_parameter_list )? OPEN_PARENS )=> method_declaration2 ^| ( member_name OPEN_BRACE )=> property_declaration2 ^| indexer_declaration2 ^| operator_declaration2 ^| field_declaration2 ^) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1520:5: type ( ( interface_type DOT THIS )=> interface_type DOT ! indexer_declaration2 ^| ( member_name ( type_parameter_list )? OPEN_PARENS )=> method_declaration2 ^| ( member_name OPEN_BRACE )=> property_declaration2 ^| indexer_declaration2 ^| operator_declaration2 ^| field_declaration2 ^)
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_type_in_typed_member_declaration7423);
            type801=type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, type801.getTree());

            if ( state.backtracking==0 ) {((common_member_declaration_scope)common_member_declaration_stack.peek()).type = (type801!=null?((Object)type801.tree):null);}

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1521:5: ( ( interface_type DOT THIS )=> interface_type DOT ! indexer_declaration2 ^| ( member_name ( type_parameter_list )? OPEN_PARENS )=> method_declaration2 ^| ( member_name OPEN_BRACE )=> property_declaration2 ^| indexer_declaration2 ^| operator_declaration2 ^| field_declaration2 ^)
            int alt171=6;
            switch ( input.LA(1) ) {
            case IDENTIFIER:
                {
                int LA171_1 = input.LA(2);

                if ( (synpred20_CSharp4AST()) ) {
                    alt171=1;
                }
                else if ( (synpred21_CSharp4AST()) ) {
                    alt171=2;
                }
                else if ( (synpred22_CSharp4AST()) ) {
                    alt171=3;
                }
                else if ( (true) ) {
                    alt171=6;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 171, 1, input);

                    throw nvae;

                }
                }
                break;
            case THIS:
                {
                alt171=4;
                }
                break;
            case OPERATOR:
                {
                alt171=5;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 171, 0, input);

                throw nvae;

            }

            switch (alt171) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1521:7: ( interface_type DOT THIS )=> interface_type DOT ! indexer_declaration2 ^
                    {
                    pushFollow(FOLLOW_interface_type_in_typed_member_declaration7443);
                    interface_type802=interface_type();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, interface_type802.getTree());

                    DOT803=(Token)match(input,DOT,FOLLOW_DOT_in_typed_member_declaration7445); if (state.failed) return retval;

                    pushFollow(FOLLOW_indexer_declaration2_in_typed_member_declaration7448);
                    indexer_declaration2804=indexer_declaration2();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(indexer_declaration2804.getTree(), root_0);

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1522:7: ( member_name ( type_parameter_list )? OPEN_PARENS )=> method_declaration2 ^
                    {
                    pushFollow(FOLLOW_method_declaration2_in_typed_member_declaration7468);
                    method_declaration2805=method_declaration2();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(method_declaration2805.getTree(), root_0);

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1523:7: ( member_name OPEN_BRACE )=> property_declaration2 ^
                    {
                    pushFollow(FOLLOW_property_declaration2_in_typed_member_declaration7485);
                    property_declaration2806=property_declaration2();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(property_declaration2806.getTree(), root_0);

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1524:7: indexer_declaration2 ^
                    {
                    pushFollow(FOLLOW_indexer_declaration2_in_typed_member_declaration7494);
                    indexer_declaration2807=indexer_declaration2();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(indexer_declaration2807.getTree(), root_0);

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1525:7: operator_declaration2 ^
                    {
                    pushFollow(FOLLOW_operator_declaration2_in_typed_member_declaration7503);
                    operator_declaration2808=operator_declaration2();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(operator_declaration2808.getTree(), root_0);

                    }
                    break;
                case 6 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1526:7: field_declaration2 ^
                    {
                    pushFollow(FOLLOW_field_declaration2_in_typed_member_declaration7512);
                    field_declaration2809=field_declaration2();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(field_declaration2809.getTree(), root_0);

                    }
                    break;

            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "typed_member_declaration"


    public static class constant_declarators_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "constant_declarators"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1544:1: constant_declarators[Object type] : constant_declarator[type] ( COMMA constant_declarator[type] )* -> ^( CONSTANT_DECLARATORS ( constant_declarator )+ ) ;
    public final CSharp4AST.constant_declarators_return constant_declarators(Object type) throws RecognitionException {
        CSharp4AST.constant_declarators_return retval = new CSharp4AST.constant_declarators_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token COMMA811=null;
        CSharp4AST.constant_declarator_return constant_declarator810 =null;

        CSharp4AST.constant_declarator_return constant_declarator812 =null;


        Object COMMA811_tree=null;
        RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
        RewriteRuleSubtreeStream stream_constant_declarator=new RewriteRuleSubtreeStream(adaptor,"rule constant_declarator");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1545:2: ( constant_declarator[type] ( COMMA constant_declarator[type] )* -> ^( CONSTANT_DECLARATORS ( constant_declarator )+ ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1545:4: constant_declarator[type] ( COMMA constant_declarator[type] )*
            {
            pushFollow(FOLLOW_constant_declarator_in_constant_declarators7533);
            constant_declarator810=constant_declarator(type);

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_constant_declarator.add(constant_declarator810.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1545:30: ( COMMA constant_declarator[type] )*
            loop172:
            do {
                int alt172=2;
                int LA172_0 = input.LA(1);

                if ( (LA172_0==COMMA) ) {
                    alt172=1;
                }


                switch (alt172) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1545:32: COMMA constant_declarator[type]
            	    {
            	    COMMA811=(Token)match(input,COMMA,FOLLOW_COMMA_in_constant_declarators7538); if (state.failed) return retval; 
            	    if ( state.backtracking==0 ) stream_COMMA.add(COMMA811);


            	    pushFollow(FOLLOW_constant_declarator_in_constant_declarators7541);
            	    constant_declarator812=constant_declarator(type);

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) stream_constant_declarator.add(constant_declarator812.getTree());

            	    }
            	    break;

            	default :
            	    break loop172;
                }
            } while (true);


            // AST REWRITE
            // elements: constant_declarator
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 1546:4: -> ^( CONSTANT_DECLARATORS ( constant_declarator )+ )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1546:7: ^( CONSTANT_DECLARATORS ( constant_declarator )+ )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(CONSTANT_DECLARATORS, "CONSTANT_DECLARATORS")
                , root_1);

                if ( !(stream_constant_declarator.hasNext()) ) {
                    throw new RewriteEarlyExitException();
                }
                while ( stream_constant_declarator.hasNext() ) {
                    adaptor.addChild(root_1, stream_constant_declarator.nextTree());

                }
                stream_constant_declarator.reset();

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "constant_declarators"


    public static class constant_declarator_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "constant_declarator"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1548:1: constant_declarator[Object type] : IDENTIFIER ASSIGNMENT constant_expression -> ^( CONSTANT_DECLARATOR IDENTIFIER ^( CONSTANT_INITIALIZER constant_expression ) ) ;
    public final CSharp4AST.constant_declarator_return constant_declarator(Object type) throws RecognitionException {
        CSharp4AST.constant_declarator_return retval = new CSharp4AST.constant_declarator_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER813=null;
        Token ASSIGNMENT814=null;
        CSharp4AST.constant_expression_return constant_expression815 =null;


        Object IDENTIFIER813_tree=null;
        Object ASSIGNMENT814_tree=null;
        RewriteRuleTokenStream stream_ASSIGNMENT=new RewriteRuleTokenStream(adaptor,"token ASSIGNMENT");
        RewriteRuleTokenStream stream_IDENTIFIER=new RewriteRuleTokenStream(adaptor,"token IDENTIFIER");
        RewriteRuleSubtreeStream stream_constant_expression=new RewriteRuleSubtreeStream(adaptor,"rule constant_expression");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1549:2: ( IDENTIFIER ASSIGNMENT constant_expression -> ^( CONSTANT_DECLARATOR IDENTIFIER ^( CONSTANT_INITIALIZER constant_expression ) ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1549:4: IDENTIFIER ASSIGNMENT constant_expression
            {
            IDENTIFIER813=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_constant_declarator7569); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_IDENTIFIER.add(IDENTIFIER813);


            ASSIGNMENT814=(Token)match(input,ASSIGNMENT,FOLLOW_ASSIGNMENT_in_constant_declarator7571); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_ASSIGNMENT.add(ASSIGNMENT814);


            pushFollow(FOLLOW_constant_expression_in_constant_declarator7573);
            constant_expression815=constant_expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_constant_expression.add(constant_expression815.getTree());

            // AST REWRITE
            // elements: IDENTIFIER, constant_expression
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 1550:4: -> ^( CONSTANT_DECLARATOR IDENTIFIER ^( CONSTANT_INITIALIZER constant_expression ) )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1550:7: ^( CONSTANT_DECLARATOR IDENTIFIER ^( CONSTANT_INITIALIZER constant_expression ) )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(CONSTANT_DECLARATOR, "CONSTANT_DECLARATOR")
                , root_1);

                adaptor.addChild(root_1, attrs);

                adaptor.addChild(root_1, members);

                adaptor.addChild(root_1, type);

                adaptor.addChild(root_1, 
                stream_IDENTIFIER.nextNode()
                );

                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1550:65: ^( CONSTANT_INITIALIZER constant_expression )
                {
                Object root_2 = (Object)adaptor.nil();
                root_2 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(CONSTANT_INITIALIZER, "CONSTANT_INITIALIZER")
                , root_2);

                adaptor.addChild(root_2, stream_constant_expression.nextTree());

                adaptor.addChild(root_1, root_2);
                }

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "constant_declarator"


    public static class variable_declarators_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "variable_declarators"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1572:1: variable_declarators : variable_declarator ( COMMA ! variable_declarator )* ;
    public final CSharp4AST.variable_declarators_return variable_declarators() throws RecognitionException {
        CSharp4AST.variable_declarators_return retval = new CSharp4AST.variable_declarators_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token COMMA817=null;
        CSharp4AST.variable_declarator_return variable_declarator816 =null;

        CSharp4AST.variable_declarator_return variable_declarator818 =null;


        Object COMMA817_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1573:2: ( variable_declarator ( COMMA ! variable_declarator )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1573:4: variable_declarator ( COMMA ! variable_declarator )*
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_variable_declarator_in_variable_declarators7610);
            variable_declarator816=variable_declarator();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, variable_declarator816.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1573:24: ( COMMA ! variable_declarator )*
            loop173:
            do {
                int alt173=2;
                int LA173_0 = input.LA(1);

                if ( (LA173_0==COMMA) ) {
                    alt173=1;
                }


                switch (alt173) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1573:26: COMMA ! variable_declarator
            	    {
            	    COMMA817=(Token)match(input,COMMA,FOLLOW_COMMA_in_variable_declarators7614); if (state.failed) return retval;

            	    pushFollow(FOLLOW_variable_declarator_in_variable_declarators7618);
            	    variable_declarator818=variable_declarator();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, variable_declarator818.getTree());

            	    }
            	    break;

            	default :
            	    break loop173;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "variable_declarators"


    public static class variable_declarator_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "variable_declarator"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1575:1: variable_declarator : variable_declarator2 -> ^( VARIABLE_DECLARATOR variable_declarator2 ) ;
    public final CSharp4AST.variable_declarator_return variable_declarator() throws RecognitionException {
        CSharp4AST.variable_declarator_return retval = new CSharp4AST.variable_declarator_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.variable_declarator2_return variable_declarator2819 =null;


        RewriteRuleSubtreeStream stream_variable_declarator2=new RewriteRuleSubtreeStream(adaptor,"rule variable_declarator2");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1576:3: ( variable_declarator2 -> ^( VARIABLE_DECLARATOR variable_declarator2 ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1576:5: variable_declarator2
            {
            pushFollow(FOLLOW_variable_declarator2_in_variable_declarator7632);
            variable_declarator2819=variable_declarator2();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_variable_declarator2.add(variable_declarator2819.getTree());

            // AST REWRITE
            // elements: variable_declarator2
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 1577:5: -> ^( VARIABLE_DECLARATOR variable_declarator2 )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1577:8: ^( VARIABLE_DECLARATOR variable_declarator2 )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(VARIABLE_DECLARATOR, "VARIABLE_DECLARATOR")
                , root_1);

                adaptor.addChild(root_1, attrs);

                adaptor.addChild(root_1, members);

                adaptor.addChild(root_1, ((common_member_declaration_scope)common_member_declaration_stack.peek()).type);

                adaptor.addChild(root_1, stream_variable_declarator2.nextTree());

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "variable_declarator"


    public static class variable_declarator2_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "variable_declarator2"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1579:1: variable_declarator2 : IDENTIFIER ( ASSIGNMENT ! variable_initializer )? ;
    public final CSharp4AST.variable_declarator2_return variable_declarator2() throws RecognitionException {
        CSharp4AST.variable_declarator2_return retval = new CSharp4AST.variable_declarator2_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER820=null;
        Token ASSIGNMENT821=null;
        CSharp4AST.variable_initializer_return variable_initializer822 =null;


        Object IDENTIFIER820_tree=null;
        Object ASSIGNMENT821_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1580:2: ( IDENTIFIER ( ASSIGNMENT ! variable_initializer )? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1580:4: IDENTIFIER ( ASSIGNMENT ! variable_initializer )?
            {
            root_0 = (Object)adaptor.nil();


            IDENTIFIER820=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_variable_declarator27662); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER820_tree = 
            (Object)adaptor.create(IDENTIFIER820)
            ;
            adaptor.addChild(root_0, IDENTIFIER820_tree);
            }

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1580:15: ( ASSIGNMENT ! variable_initializer )?
            int alt174=2;
            int LA174_0 = input.LA(1);

            if ( (LA174_0==ASSIGNMENT) ) {
                alt174=1;
            }
            switch (alt174) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1580:16: ASSIGNMENT ! variable_initializer
                    {
                    ASSIGNMENT821=(Token)match(input,ASSIGNMENT,FOLLOW_ASSIGNMENT_in_variable_declarator27665); if (state.failed) return retval;

                    pushFollow(FOLLOW_variable_initializer_in_variable_declarator27668);
                    variable_initializer822=variable_initializer();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, variable_initializer822.getTree());

                    }
                    break;

            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "variable_declarator2"


    public static class variable_initializer_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "variable_initializer"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1582:1: variable_initializer : variable_initializer2 -> ^( VARIABLE_INITIALIZER variable_initializer2 ) ;
    public final CSharp4AST.variable_initializer_return variable_initializer() throws RecognitionException {
        CSharp4AST.variable_initializer_return retval = new CSharp4AST.variable_initializer_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.variable_initializer2_return variable_initializer2823 =null;


        RewriteRuleSubtreeStream stream_variable_initializer2=new RewriteRuleSubtreeStream(adaptor,"rule variable_initializer2");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1583:3: ( variable_initializer2 -> ^( VARIABLE_INITIALIZER variable_initializer2 ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1583:5: variable_initializer2
            {
            pushFollow(FOLLOW_variable_initializer2_in_variable_initializer7681);
            variable_initializer2823=variable_initializer2();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_variable_initializer2.add(variable_initializer2823.getTree());

            // AST REWRITE
            // elements: variable_initializer2
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 1583:27: -> ^( VARIABLE_INITIALIZER variable_initializer2 )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1583:30: ^( VARIABLE_INITIALIZER variable_initializer2 )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(VARIABLE_INITIALIZER, "VARIABLE_INITIALIZER")
                , root_1);

                adaptor.addChild(root_1, stream_variable_initializer2.nextTree());

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "variable_initializer"


    public static class variable_initializer2_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "variable_initializer2"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1585:1: variable_initializer2 : ( expression | array_initializer );
    public final CSharp4AST.variable_initializer2_return variable_initializer2() throws RecognitionException {
        CSharp4AST.variable_initializer2_return retval = new CSharp4AST.variable_initializer2_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.expression_return expression824 =null;

        CSharp4AST.array_initializer_return array_initializer825 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1586:2: ( expression | array_initializer )
            int alt175=2;
            int LA175_0 = input.LA(1);

            if ( (LA175_0==AMP||(LA175_0 >= BANG && LA175_0 <= BASE)||LA175_0==BOOL||LA175_0==BYTE||(LA175_0 >= CHAR && LA175_0 <= CHECKED)||LA175_0==DECIMAL||(LA175_0 >= DEFAULT && LA175_0 <= DELEGATE)||LA175_0==DOUBLE||LA175_0==FALSE||LA175_0==FLOAT||LA175_0==IDENTIFIER||(LA175_0 >= INT && LA175_0 <= INTEGER_LITERAL)||LA175_0==LONG||LA175_0==MINUS||LA175_0==NEW||LA175_0==NULL||LA175_0==OBJECT||LA175_0==OPEN_PARENS||LA175_0==OP_DEC||LA175_0==OP_INC||LA175_0==PLUS||LA175_0==REAL_LITERAL||LA175_0==SBYTE||LA175_0==SHORT||LA175_0==SIZEOF||LA175_0==STAR||(LA175_0 >= STRING && LA175_0 <= STRING_LITERAL)||LA175_0==THIS||(LA175_0 >= TILDE && LA175_0 <= TRUE)||LA175_0==TYPEOF||(LA175_0 >= UINT && LA175_0 <= UNCHECKED)||LA175_0==USHORT) ) {
                alt175=1;
            }
            else if ( (LA175_0==OPEN_BRACE) ) {
                alt175=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 175, 0, input);

                throw nvae;

            }
            switch (alt175) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1586:4: expression
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_expression_in_variable_initializer27701);
                    expression824=expression();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, expression824.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1587:4: array_initializer
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_array_initializer_in_variable_initializer27706);
                    array_initializer825=array_initializer();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, array_initializer825.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "variable_initializer2"


    public static class method_declaration_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "method_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1589:1: method_declaration : method_header method_body ;
    public final CSharp4AST.method_declaration_return method_declaration() throws RecognitionException {
        CSharp4AST.method_declaration_return retval = new CSharp4AST.method_declaration_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.method_header_return method_header826 =null;

        CSharp4AST.method_body_return method_body827 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1590:2: ( method_header method_body )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1590:4: method_header method_body
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_method_header_in_method_declaration7717);
            method_header826=method_header();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, method_header826.getTree());

            pushFollow(FOLLOW_method_body_in_method_declaration7719);
            method_body827=method_body();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, method_body827.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "method_declaration"


    public static class method_header_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "method_header"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1592:1: method_header : ( attributes )? ( method_modifiers )? ( partial_contextual_keyword )? return_type member_name ( type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? ;
    public final CSharp4AST.method_header_return method_header() throws RecognitionException {
        CSharp4AST.method_header_return retval = new CSharp4AST.method_header_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token OPEN_PARENS834=null;
        Token CLOSE_PARENS836=null;
        CSharp4AST.attributes_return attributes828 =null;

        CSharp4AST.method_modifiers_return method_modifiers829 =null;

        CSharp4AST.partial_contextual_keyword_return partial_contextual_keyword830 =null;

        CSharp4AST.return_type_return return_type831 =null;

        CSharp4AST.member_name_return member_name832 =null;

        CSharp4AST.type_parameter_list_return type_parameter_list833 =null;

        CSharp4AST.formal_parameter_list_return formal_parameter_list835 =null;

        CSharp4AST.type_parameter_constraints_clauses_return type_parameter_constraints_clauses837 =null;


        Object OPEN_PARENS834_tree=null;
        Object CLOSE_PARENS836_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1593:2: ( ( attributes )? ( method_modifiers )? ( partial_contextual_keyword )? return_type member_name ( type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1593:4: ( attributes )? ( method_modifiers )? ( partial_contextual_keyword )? return_type member_name ( type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )?
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1593:4: ( attributes )?
            int alt176=2;
            int LA176_0 = input.LA(1);

            if ( (LA176_0==OPEN_BRACKET) ) {
                alt176=1;
            }
            switch (alt176) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1593:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_method_header7730);
                    attributes828=attributes();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, attributes828.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1593:16: ( method_modifiers )?
            int alt177=2;
            int LA177_0 = input.LA(1);

            if ( (LA177_0==ABSTRACT||LA177_0==EXTERN||LA177_0==INTERNAL||LA177_0==NEW||LA177_0==OVERRIDE||(LA177_0 >= PRIVATE && LA177_0 <= PUBLIC)||LA177_0==SEALED||LA177_0==STATIC||LA177_0==UNSAFE||LA177_0==VIRTUAL) ) {
                alt177=1;
            }
            switch (alt177) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1593:16: method_modifiers
                    {
                    pushFollow(FOLLOW_method_modifiers_in_method_header7733);
                    method_modifiers829=method_modifiers();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, method_modifiers829.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1593:34: ( partial_contextual_keyword )?
            int alt178=2;
            int LA178_0 = input.LA(1);

            if ( (LA178_0==IDENTIFIER) ) {
                int LA178_1 = input.LA(2);

                if ( ((input.LT(1).getText().equals("partial"))) ) {
                    alt178=1;
                }
            }
            switch (alt178) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1593:34: partial_contextual_keyword
                    {
                    pushFollow(FOLLOW_partial_contextual_keyword_in_method_header7736);
                    partial_contextual_keyword830=partial_contextual_keyword();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, partial_contextual_keyword830.getTree());

                    }
                    break;

            }


            pushFollow(FOLLOW_return_type_in_method_header7739);
            return_type831=return_type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, return_type831.getTree());

            pushFollow(FOLLOW_member_name_in_method_header7741);
            member_name832=member_name();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, member_name832.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1593:86: ( type_parameter_list )?
            int alt179=2;
            int LA179_0 = input.LA(1);

            if ( (LA179_0==LT) ) {
                alt179=1;
            }
            switch (alt179) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1593:86: type_parameter_list
                    {
                    pushFollow(FOLLOW_type_parameter_list_in_method_header7743);
                    type_parameter_list833=type_parameter_list();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, type_parameter_list833.getTree());

                    }
                    break;

            }


            OPEN_PARENS834=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_method_header7746); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            OPEN_PARENS834_tree = 
            (Object)adaptor.create(OPEN_PARENS834)
            ;
            adaptor.addChild(root_0, OPEN_PARENS834_tree);
            }

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1593:119: ( formal_parameter_list )?
            int alt180=2;
            int LA180_0 = input.LA(1);

            if ( (LA180_0==BOOL||LA180_0==BYTE||LA180_0==CHAR||LA180_0==DECIMAL||LA180_0==DOUBLE||LA180_0==FLOAT||LA180_0==IDENTIFIER||LA180_0==INT||LA180_0==LONG||LA180_0==OBJECT||LA180_0==OPEN_BRACKET||LA180_0==OUT||LA180_0==PARAMS||LA180_0==REF||LA180_0==SBYTE||LA180_0==SHORT||LA180_0==STRING||LA180_0==THIS||(LA180_0 >= UINT && LA180_0 <= ULONG)||LA180_0==USHORT||LA180_0==VOID) ) {
                alt180=1;
            }
            switch (alt180) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1593:119: formal_parameter_list
                    {
                    pushFollow(FOLLOW_formal_parameter_list_in_method_header7748);
                    formal_parameter_list835=formal_parameter_list();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, formal_parameter_list835.getTree());

                    }
                    break;

            }


            CLOSE_PARENS836=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_method_header7751); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            CLOSE_PARENS836_tree = 
            (Object)adaptor.create(CLOSE_PARENS836)
            ;
            adaptor.addChild(root_0, CLOSE_PARENS836_tree);
            }

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1593:155: ( type_parameter_constraints_clauses )?
            int alt181=2;
            int LA181_0 = input.LA(1);

            if ( (LA181_0==IDENTIFIER) ) {
                alt181=1;
            }
            switch (alt181) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1593:155: type_parameter_constraints_clauses
                    {
                    pushFollow(FOLLOW_type_parameter_constraints_clauses_in_method_header7753);
                    type_parameter_constraints_clauses837=type_parameter_constraints_clauses();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, type_parameter_constraints_clauses837.getTree());

                    }
                    break;

            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "method_header"


    public static class method_modifiers_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "method_modifiers"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1595:1: method_modifiers : ( method_modifier )+ ;
    public final CSharp4AST.method_modifiers_return method_modifiers() throws RecognitionException {
        CSharp4AST.method_modifiers_return retval = new CSharp4AST.method_modifiers_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.method_modifier_return method_modifier838 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1596:2: ( ( method_modifier )+ )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1596:4: ( method_modifier )+
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1596:4: ( method_modifier )+
            int cnt182=0;
            loop182:
            do {
                int alt182=2;
                int LA182_0 = input.LA(1);

                if ( (LA182_0==ABSTRACT||LA182_0==EXTERN||LA182_0==INTERNAL||LA182_0==NEW||LA182_0==OVERRIDE||(LA182_0 >= PRIVATE && LA182_0 <= PUBLIC)||LA182_0==SEALED||LA182_0==STATIC||LA182_0==UNSAFE||LA182_0==VIRTUAL) ) {
                    alt182=1;
                }


                switch (alt182) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1596:4: method_modifier
            	    {
            	    pushFollow(FOLLOW_method_modifier_in_method_modifiers7765);
            	    method_modifier838=method_modifier();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, method_modifier838.getTree());

            	    }
            	    break;

            	default :
            	    if ( cnt182 >= 1 ) break loop182;
            	    if (state.backtracking>0) {state.failed=true; return retval;}
                        EarlyExitException eee =
                            new EarlyExitException(182, input);
                        throw eee;
                }
                cnt182++;
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "method_modifiers"


    public static class method_modifier_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "method_modifier"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1598:1: method_modifier : ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | STATIC | VIRTUAL | SEALED | OVERRIDE | ABSTRACT | EXTERN | method_modifier_unsafe );
    public final CSharp4AST.method_modifier_return method_modifier() throws RecognitionException {
        CSharp4AST.method_modifier_return retval = new CSharp4AST.method_modifier_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token NEW839=null;
        Token PUBLIC840=null;
        Token PROTECTED841=null;
        Token INTERNAL842=null;
        Token PRIVATE843=null;
        Token STATIC844=null;
        Token VIRTUAL845=null;
        Token SEALED846=null;
        Token OVERRIDE847=null;
        Token ABSTRACT848=null;
        Token EXTERN849=null;
        CSharp4AST.method_modifier_unsafe_return method_modifier_unsafe850 =null;


        Object NEW839_tree=null;
        Object PUBLIC840_tree=null;
        Object PROTECTED841_tree=null;
        Object INTERNAL842_tree=null;
        Object PRIVATE843_tree=null;
        Object STATIC844_tree=null;
        Object VIRTUAL845_tree=null;
        Object SEALED846_tree=null;
        Object OVERRIDE847_tree=null;
        Object ABSTRACT848_tree=null;
        Object EXTERN849_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1599:2: ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | STATIC | VIRTUAL | SEALED | OVERRIDE | ABSTRACT | EXTERN | method_modifier_unsafe )
            int alt183=12;
            switch ( input.LA(1) ) {
            case NEW:
                {
                alt183=1;
                }
                break;
            case PUBLIC:
                {
                alt183=2;
                }
                break;
            case PROTECTED:
                {
                alt183=3;
                }
                break;
            case INTERNAL:
                {
                alt183=4;
                }
                break;
            case PRIVATE:
                {
                alt183=5;
                }
                break;
            case STATIC:
                {
                alt183=6;
                }
                break;
            case VIRTUAL:
                {
                alt183=7;
                }
                break;
            case SEALED:
                {
                alt183=8;
                }
                break;
            case OVERRIDE:
                {
                alt183=9;
                }
                break;
            case ABSTRACT:
                {
                alt183=10;
                }
                break;
            case EXTERN:
                {
                alt183=11;
                }
                break;
            case UNSAFE:
                {
                alt183=12;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 183, 0, input);

                throw nvae;

            }

            switch (alt183) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1599:4: NEW
                    {
                    root_0 = (Object)adaptor.nil();


                    NEW839=(Token)match(input,NEW,FOLLOW_NEW_in_method_modifier7777); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    NEW839_tree = 
                    (Object)adaptor.create(NEW839)
                    ;
                    adaptor.addChild(root_0, NEW839_tree);
                    }

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1600:4: PUBLIC
                    {
                    root_0 = (Object)adaptor.nil();


                    PUBLIC840=(Token)match(input,PUBLIC,FOLLOW_PUBLIC_in_method_modifier7782); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PUBLIC840_tree = 
                    (Object)adaptor.create(PUBLIC840)
                    ;
                    adaptor.addChild(root_0, PUBLIC840_tree);
                    }

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1601:4: PROTECTED
                    {
                    root_0 = (Object)adaptor.nil();


                    PROTECTED841=(Token)match(input,PROTECTED,FOLLOW_PROTECTED_in_method_modifier7787); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PROTECTED841_tree = 
                    (Object)adaptor.create(PROTECTED841)
                    ;
                    adaptor.addChild(root_0, PROTECTED841_tree);
                    }

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1602:4: INTERNAL
                    {
                    root_0 = (Object)adaptor.nil();


                    INTERNAL842=(Token)match(input,INTERNAL,FOLLOW_INTERNAL_in_method_modifier7792); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    INTERNAL842_tree = 
                    (Object)adaptor.create(INTERNAL842)
                    ;
                    adaptor.addChild(root_0, INTERNAL842_tree);
                    }

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1603:4: PRIVATE
                    {
                    root_0 = (Object)adaptor.nil();


                    PRIVATE843=(Token)match(input,PRIVATE,FOLLOW_PRIVATE_in_method_modifier7797); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PRIVATE843_tree = 
                    (Object)adaptor.create(PRIVATE843)
                    ;
                    adaptor.addChild(root_0, PRIVATE843_tree);
                    }

                    }
                    break;
                case 6 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1604:4: STATIC
                    {
                    root_0 = (Object)adaptor.nil();


                    STATIC844=(Token)match(input,STATIC,FOLLOW_STATIC_in_method_modifier7802); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    STATIC844_tree = 
                    (Object)adaptor.create(STATIC844)
                    ;
                    adaptor.addChild(root_0, STATIC844_tree);
                    }

                    }
                    break;
                case 7 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1605:4: VIRTUAL
                    {
                    root_0 = (Object)adaptor.nil();


                    VIRTUAL845=(Token)match(input,VIRTUAL,FOLLOW_VIRTUAL_in_method_modifier7807); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    VIRTUAL845_tree = 
                    (Object)adaptor.create(VIRTUAL845)
                    ;
                    adaptor.addChild(root_0, VIRTUAL845_tree);
                    }

                    }
                    break;
                case 8 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1606:4: SEALED
                    {
                    root_0 = (Object)adaptor.nil();


                    SEALED846=(Token)match(input,SEALED,FOLLOW_SEALED_in_method_modifier7812); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    SEALED846_tree = 
                    (Object)adaptor.create(SEALED846)
                    ;
                    adaptor.addChild(root_0, SEALED846_tree);
                    }

                    }
                    break;
                case 9 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1607:4: OVERRIDE
                    {
                    root_0 = (Object)adaptor.nil();


                    OVERRIDE847=(Token)match(input,OVERRIDE,FOLLOW_OVERRIDE_in_method_modifier7817); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OVERRIDE847_tree = 
                    (Object)adaptor.create(OVERRIDE847)
                    ;
                    adaptor.addChild(root_0, OVERRIDE847_tree);
                    }

                    }
                    break;
                case 10 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1608:4: ABSTRACT
                    {
                    root_0 = (Object)adaptor.nil();


                    ABSTRACT848=(Token)match(input,ABSTRACT,FOLLOW_ABSTRACT_in_method_modifier7822); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    ABSTRACT848_tree = 
                    (Object)adaptor.create(ABSTRACT848)
                    ;
                    adaptor.addChild(root_0, ABSTRACT848_tree);
                    }

                    }
                    break;
                case 11 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1609:4: EXTERN
                    {
                    root_0 = (Object)adaptor.nil();


                    EXTERN849=(Token)match(input,EXTERN,FOLLOW_EXTERN_in_method_modifier7827); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    EXTERN849_tree = 
                    (Object)adaptor.create(EXTERN849)
                    ;
                    adaptor.addChild(root_0, EXTERN849_tree);
                    }

                    }
                    break;
                case 12 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1610:4: method_modifier_unsafe
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_method_modifier_unsafe_in_method_modifier7832);
                    method_modifier_unsafe850=method_modifier_unsafe();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, method_modifier_unsafe850.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "method_modifier"


    public static class return_type_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "return_type"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1613:1: return_type : ( type | VOID );
    public final CSharp4AST.return_type_return return_type() throws RecognitionException {
        CSharp4AST.return_type_return retval = new CSharp4AST.return_type_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token VOID852=null;
        CSharp4AST.type_return type851 =null;


        Object VOID852_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1614:2: ( type | VOID )
            int alt184=2;
            int LA184_0 = input.LA(1);

            if ( (LA184_0==BOOL||LA184_0==BYTE||LA184_0==CHAR||LA184_0==DECIMAL||LA184_0==DOUBLE||LA184_0==FLOAT||LA184_0==IDENTIFIER||LA184_0==INT||LA184_0==LONG||LA184_0==OBJECT||LA184_0==SBYTE||LA184_0==SHORT||LA184_0==STRING||(LA184_0 >= UINT && LA184_0 <= ULONG)||LA184_0==USHORT) ) {
                alt184=1;
            }
            else if ( (LA184_0==VOID) ) {
                int LA184_2 = input.LA(2);

                if ( (LA184_2==STAR) ) {
                    alt184=1;
                }
                else if ( (LA184_2==IDENTIFIER) ) {
                    alt184=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 184, 2, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 184, 0, input);

                throw nvae;

            }
            switch (alt184) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1614:4: type
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_type_in_return_type7845);
                    type851=type();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, type851.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1615:4: VOID
                    {
                    root_0 = (Object)adaptor.nil();


                    VOID852=(Token)match(input,VOID,FOLLOW_VOID_in_return_type7850); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    VOID852_tree = 
                    (Object)adaptor.create(VOID852)
                    ;
                    adaptor.addChild(root_0, VOID852_tree);
                    }

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "return_type"


    public static class member_name_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "member_name"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1624:1: member_name : interface_type -> ^( MEMBER_NAME interface_type ) ;
    public final CSharp4AST.member_name_return member_name() throws RecognitionException {
        CSharp4AST.member_name_return retval = new CSharp4AST.member_name_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.interface_type_return interface_type853 =null;


        RewriteRuleSubtreeStream stream_interface_type=new RewriteRuleSubtreeStream(adaptor,"rule interface_type");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1625:3: ( interface_type -> ^( MEMBER_NAME interface_type ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1625:5: interface_type
            {
            pushFollow(FOLLOW_interface_type_in_member_name7866);
            interface_type853=interface_type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_interface_type.add(interface_type853.getTree());

            // AST REWRITE
            // elements: interface_type
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 1625:20: -> ^( MEMBER_NAME interface_type )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1625:23: ^( MEMBER_NAME interface_type )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(MEMBER_NAME, "MEMBER_NAME")
                , root_1);

                adaptor.addChild(root_1, stream_interface_type.nextTree());

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "member_name"


    public static class method_body_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "method_body"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1627:1: method_body : ( block | SEMICOLON !);
    public final CSharp4AST.method_body_return method_body() throws RecognitionException {
        CSharp4AST.method_body_return retval = new CSharp4AST.method_body_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token SEMICOLON855=null;
        CSharp4AST.block_return block854 =null;


        Object SEMICOLON855_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1628:2: ( block | SEMICOLON !)
            int alt185=2;
            int LA185_0 = input.LA(1);

            if ( (LA185_0==OPEN_BRACE) ) {
                alt185=1;
            }
            else if ( (LA185_0==SEMICOLON) ) {
                alt185=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 185, 0, input);

                throw nvae;

            }
            switch (alt185) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1628:4: block
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_block_in_method_body7886);
                    block854=block();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, block854.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1629:4: SEMICOLON !
                    {
                    root_0 = (Object)adaptor.nil();


                    SEMICOLON855=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_method_body7891); if (state.failed) return retval;

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "method_body"


    public static class formal_parameter_list_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "formal_parameter_list"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1638:1: formal_parameter_list : ( ( ( attributes )? PARAMS )=> parameter_array -> ^( FORMAL_PARAMETER_LIST parameter_array ) | fixed_parameters ( ( COMMA parameter_array )=> COMMA parameter_array )? -> ^( FORMAL_PARAMETER_LIST fixed_parameters ( parameter_array )? ) );
    public final CSharp4AST.formal_parameter_list_return formal_parameter_list() throws RecognitionException {
        CSharp4AST.formal_parameter_list_return retval = new CSharp4AST.formal_parameter_list_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token COMMA858=null;
        CSharp4AST.parameter_array_return parameter_array856 =null;

        CSharp4AST.fixed_parameters_return fixed_parameters857 =null;

        CSharp4AST.parameter_array_return parameter_array859 =null;


        Object COMMA858_tree=null;
        RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
        RewriteRuleSubtreeStream stream_parameter_array=new RewriteRuleSubtreeStream(adaptor,"rule parameter_array");
        RewriteRuleSubtreeStream stream_fixed_parameters=new RewriteRuleSubtreeStream(adaptor,"rule fixed_parameters");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1639:3: ( ( ( attributes )? PARAMS )=> parameter_array -> ^( FORMAL_PARAMETER_LIST parameter_array ) | fixed_parameters ( ( COMMA parameter_array )=> COMMA parameter_array )? -> ^( FORMAL_PARAMETER_LIST fixed_parameters ( parameter_array )? ) )
            int alt187=2;
            int LA187_0 = input.LA(1);

            if ( (LA187_0==OPEN_BRACKET) ) {
                int LA187_1 = input.LA(2);

                if ( (synpred23_CSharp4AST()) ) {
                    alt187=1;
                }
                else if ( (true) ) {
                    alt187=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 187, 1, input);

                    throw nvae;

                }
            }
            else if ( (LA187_0==PARAMS) && (synpred23_CSharp4AST())) {
                alt187=1;
            }
            else if ( (LA187_0==BOOL||LA187_0==BYTE||LA187_0==CHAR||LA187_0==DECIMAL||LA187_0==DOUBLE||LA187_0==FLOAT||LA187_0==IDENTIFIER||LA187_0==INT||LA187_0==LONG||LA187_0==OBJECT||LA187_0==OUT||LA187_0==REF||LA187_0==SBYTE||LA187_0==SHORT||LA187_0==STRING||LA187_0==THIS||(LA187_0 >= UINT && LA187_0 <= ULONG)||LA187_0==USHORT||LA187_0==VOID) ) {
                alt187=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 187, 0, input);

                throw nvae;

            }
            switch (alt187) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1639:5: ( ( attributes )? PARAMS )=> parameter_array
                    {
                    pushFollow(FOLLOW_parameter_array_in_formal_parameter_list7915);
                    parameter_array856=parameter_array();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) stream_parameter_array.add(parameter_array856.getTree());

                    // AST REWRITE
                    // elements: parameter_array
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    // wildcard labels: 
                    if ( state.backtracking==0 ) {

                    retval.tree = root_0;
                    RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

                    root_0 = (Object)adaptor.nil();
                    // 1640:5: -> ^( FORMAL_PARAMETER_LIST parameter_array )
                    {
                        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1640:8: ^( FORMAL_PARAMETER_LIST parameter_array )
                        {
                        Object root_1 = (Object)adaptor.nil();
                        root_1 = (Object)adaptor.becomeRoot(
                        (Object)adaptor.create(FORMAL_PARAMETER_LIST, "FORMAL_PARAMETER_LIST")
                        , root_1);

                        adaptor.addChild(root_1, stream_parameter_array.nextTree());

                        adaptor.addChild(root_0, root_1);
                        }

                    }


                    retval.tree = root_0;
                    }

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1641:5: fixed_parameters ( ( COMMA parameter_array )=> COMMA parameter_array )?
                    {
                    pushFollow(FOLLOW_fixed_parameters_in_formal_parameter_list7934);
                    fixed_parameters857=fixed_parameters();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) stream_fixed_parameters.add(fixed_parameters857.getTree());

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1641:22: ( ( COMMA parameter_array )=> COMMA parameter_array )?
                    int alt186=2;
                    int LA186_0 = input.LA(1);

                    if ( (LA186_0==COMMA) && (synpred24_CSharp4AST())) {
                        alt186=1;
                    }
                    switch (alt186) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1641:24: ( COMMA parameter_array )=> COMMA parameter_array
                            {
                            COMMA858=(Token)match(input,COMMA,FOLLOW_COMMA_in_formal_parameter_list7946); if (state.failed) return retval; 
                            if ( state.backtracking==0 ) stream_COMMA.add(COMMA858);


                            pushFollow(FOLLOW_parameter_array_in_formal_parameter_list7948);
                            parameter_array859=parameter_array();

                            state._fsp--;
                            if (state.failed) return retval;
                            if ( state.backtracking==0 ) stream_parameter_array.add(parameter_array859.getTree());

                            }
                            break;

                    }


                    // AST REWRITE
                    // elements: parameter_array, fixed_parameters
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    // wildcard labels: 
                    if ( state.backtracking==0 ) {

                    retval.tree = root_0;
                    RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

                    root_0 = (Object)adaptor.nil();
                    // 1642:5: -> ^( FORMAL_PARAMETER_LIST fixed_parameters ( parameter_array )? )
                    {
                        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1642:8: ^( FORMAL_PARAMETER_LIST fixed_parameters ( parameter_array )? )
                        {
                        Object root_1 = (Object)adaptor.nil();
                        root_1 = (Object)adaptor.becomeRoot(
                        (Object)adaptor.create(FORMAL_PARAMETER_LIST, "FORMAL_PARAMETER_LIST")
                        , root_1);

                        adaptor.addChild(root_1, stream_fixed_parameters.nextTree());

                        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1642:51: ( parameter_array )?
                        if ( stream_parameter_array.hasNext() ) {
                            adaptor.addChild(root_1, stream_parameter_array.nextTree());

                        }
                        stream_parameter_array.reset();

                        adaptor.addChild(root_0, root_1);
                        }

                    }


                    retval.tree = root_0;
                    }

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "formal_parameter_list"


    public static class fixed_parameters_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "fixed_parameters"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1644:1: fixed_parameters : fixed_parameter ( ( COMMA fixed_parameter )=> COMMA ! fixed_parameter )* ;
    public final CSharp4AST.fixed_parameters_return fixed_parameters() throws RecognitionException {
        CSharp4AST.fixed_parameters_return retval = new CSharp4AST.fixed_parameters_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token COMMA861=null;
        CSharp4AST.fixed_parameter_return fixed_parameter860 =null;

        CSharp4AST.fixed_parameter_return fixed_parameter862 =null;


        Object COMMA861_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1645:3: ( fixed_parameter ( ( COMMA fixed_parameter )=> COMMA ! fixed_parameter )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1645:5: fixed_parameter ( ( COMMA fixed_parameter )=> COMMA ! fixed_parameter )*
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_fixed_parameter_in_fixed_parameters7980);
            fixed_parameter860=fixed_parameter();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, fixed_parameter860.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1645:21: ( ( COMMA fixed_parameter )=> COMMA ! fixed_parameter )*
            loop188:
            do {
                int alt188=2;
                int LA188_0 = input.LA(1);

                if ( (LA188_0==COMMA) ) {
                    int LA188_1 = input.LA(2);

                    if ( (synpred25_CSharp4AST()) ) {
                        alt188=1;
                    }


                }


                switch (alt188) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1645:23: ( COMMA fixed_parameter )=> COMMA ! fixed_parameter
            	    {
            	    COMMA861=(Token)match(input,COMMA,FOLLOW_COMMA_in_fixed_parameters7992); if (state.failed) return retval;

            	    pushFollow(FOLLOW_fixed_parameter_in_fixed_parameters7995);
            	    fixed_parameter862=fixed_parameter();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, fixed_parameter862.getTree());

            	    }
            	    break;

            	default :
            	    break loop188;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "fixed_parameters"


    public static class fixed_parameter_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "fixed_parameter"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1653:1: fixed_parameter : ( ( attributes )? ( parameter_modifier )? type IDENTIFIER ( default_argument )? -> ^( FIXED_PARAMETER ( attributes )? ( parameter_modifier )? type IDENTIFIER ( default_argument )? ) | arglist -> ^( FIXED_PARAMETER arglist ) );
    public final CSharp4AST.fixed_parameter_return fixed_parameter() throws RecognitionException {
        CSharp4AST.fixed_parameter_return retval = new CSharp4AST.fixed_parameter_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER866=null;
        CSharp4AST.attributes_return attributes863 =null;

        CSharp4AST.parameter_modifier_return parameter_modifier864 =null;

        CSharp4AST.type_return type865 =null;

        CSharp4AST.default_argument_return default_argument867 =null;

        CSharp4AST.arglist_return arglist868 =null;


        Object IDENTIFIER866_tree=null;
        RewriteRuleTokenStream stream_IDENTIFIER=new RewriteRuleTokenStream(adaptor,"token IDENTIFIER");
        RewriteRuleSubtreeStream stream_arglist=new RewriteRuleSubtreeStream(adaptor,"rule arglist");
        RewriteRuleSubtreeStream stream_attributes=new RewriteRuleSubtreeStream(adaptor,"rule attributes");
        RewriteRuleSubtreeStream stream_default_argument=new RewriteRuleSubtreeStream(adaptor,"rule default_argument");
        RewriteRuleSubtreeStream stream_type=new RewriteRuleSubtreeStream(adaptor,"rule type");
        RewriteRuleSubtreeStream stream_parameter_modifier=new RewriteRuleSubtreeStream(adaptor,"rule parameter_modifier");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1654:3: ( ( attributes )? ( parameter_modifier )? type IDENTIFIER ( default_argument )? -> ^( FIXED_PARAMETER ( attributes )? ( parameter_modifier )? type IDENTIFIER ( default_argument )? ) | arglist -> ^( FIXED_PARAMETER arglist ) )
            int alt192=2;
            int LA192_0 = input.LA(1);

            if ( (LA192_0==BOOL||LA192_0==BYTE||LA192_0==CHAR||LA192_0==DECIMAL||LA192_0==DOUBLE||LA192_0==FLOAT||LA192_0==INT||LA192_0==LONG||LA192_0==OBJECT||LA192_0==OPEN_BRACKET||LA192_0==OUT||LA192_0==REF||LA192_0==SBYTE||LA192_0==SHORT||LA192_0==STRING||LA192_0==THIS||(LA192_0 >= UINT && LA192_0 <= ULONG)||LA192_0==USHORT||LA192_0==VOID) ) {
                alt192=1;
            }
            else if ( (LA192_0==IDENTIFIER) ) {
                int LA192_2 = input.LA(2);

                if ( (LA192_2==DOT||LA192_2==DOUBLE_COLON||LA192_2==IDENTIFIER||LA192_2==INTERR||LA192_2==LT||LA192_2==OPEN_BRACKET||LA192_2==STAR) ) {
                    alt192=1;
                }
                else if ( (LA192_2==EOF||(LA192_2 >= CLOSE_BRACKET && LA192_2 <= CLOSE_PARENS)||LA192_2==COMMA) ) {
                    alt192=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 192, 2, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 192, 0, input);

                throw nvae;

            }
            switch (alt192) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1654:5: ( attributes )? ( parameter_modifier )? type IDENTIFIER ( default_argument )?
                    {
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1654:5: ( attributes )?
                    int alt189=2;
                    int LA189_0 = input.LA(1);

                    if ( (LA189_0==OPEN_BRACKET) ) {
                        alt189=1;
                    }
                    switch (alt189) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1654:5: attributes
                            {
                            pushFollow(FOLLOW_attributes_in_fixed_parameter8013);
                            attributes863=attributes();

                            state._fsp--;
                            if (state.failed) return retval;
                            if ( state.backtracking==0 ) stream_attributes.add(attributes863.getTree());

                            }
                            break;

                    }


                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1654:17: ( parameter_modifier )?
                    int alt190=2;
                    int LA190_0 = input.LA(1);

                    if ( (LA190_0==OUT||LA190_0==REF||LA190_0==THIS) ) {
                        alt190=1;
                    }
                    switch (alt190) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1654:17: parameter_modifier
                            {
                            pushFollow(FOLLOW_parameter_modifier_in_fixed_parameter8016);
                            parameter_modifier864=parameter_modifier();

                            state._fsp--;
                            if (state.failed) return retval;
                            if ( state.backtracking==0 ) stream_parameter_modifier.add(parameter_modifier864.getTree());

                            }
                            break;

                    }


                    pushFollow(FOLLOW_type_in_fixed_parameter8019);
                    type865=type();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) stream_type.add(type865.getTree());

                    IDENTIFIER866=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_fixed_parameter8021); if (state.failed) return retval; 
                    if ( state.backtracking==0 ) stream_IDENTIFIER.add(IDENTIFIER866);


                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1654:53: ( default_argument )?
                    int alt191=2;
                    int LA191_0 = input.LA(1);

                    if ( (LA191_0==ASSIGNMENT) ) {
                        alt191=1;
                    }
                    switch (alt191) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1654:53: default_argument
                            {
                            pushFollow(FOLLOW_default_argument_in_fixed_parameter8023);
                            default_argument867=default_argument();

                            state._fsp--;
                            if (state.failed) return retval;
                            if ( state.backtracking==0 ) stream_default_argument.add(default_argument867.getTree());

                            }
                            break;

                    }


                    // AST REWRITE
                    // elements: parameter_modifier, attributes, IDENTIFIER, type, default_argument
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    // wildcard labels: 
                    if ( state.backtracking==0 ) {

                    retval.tree = root_0;
                    RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

                    root_0 = (Object)adaptor.nil();
                    // 1655:5: -> ^( FIXED_PARAMETER ( attributes )? ( parameter_modifier )? type IDENTIFIER ( default_argument )? )
                    {
                        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1655:8: ^( FIXED_PARAMETER ( attributes )? ( parameter_modifier )? type IDENTIFIER ( default_argument )? )
                        {
                        Object root_1 = (Object)adaptor.nil();
                        root_1 = (Object)adaptor.becomeRoot(
                        (Object)adaptor.create(FIXED_PARAMETER, "FIXED_PARAMETER")
                        , root_1);

                        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1655:26: ( attributes )?
                        if ( stream_attributes.hasNext() ) {
                            adaptor.addChild(root_1, stream_attributes.nextTree());

                        }
                        stream_attributes.reset();

                        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1655:38: ( parameter_modifier )?
                        if ( stream_parameter_modifier.hasNext() ) {
                            adaptor.addChild(root_1, stream_parameter_modifier.nextTree());

                        }
                        stream_parameter_modifier.reset();

                        adaptor.addChild(root_1, stream_type.nextTree());

                        adaptor.addChild(root_1, 
                        stream_IDENTIFIER.nextNode()
                        );

                        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1655:74: ( default_argument )?
                        if ( stream_default_argument.hasNext() ) {
                            adaptor.addChild(root_1, stream_default_argument.nextTree());

                        }
                        stream_default_argument.reset();

                        adaptor.addChild(root_0, root_1);
                        }

                    }


                    retval.tree = root_0;
                    }

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1656:5: arglist
                    {
                    pushFollow(FOLLOW_arglist_in_fixed_parameter8053);
                    arglist868=arglist();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) stream_arglist.add(arglist868.getTree());

                    // AST REWRITE
                    // elements: arglist
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    // wildcard labels: 
                    if ( state.backtracking==0 ) {

                    retval.tree = root_0;
                    RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

                    root_0 = (Object)adaptor.nil();
                    // 1657:5: -> ^( FIXED_PARAMETER arglist )
                    {
                        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1657:8: ^( FIXED_PARAMETER arglist )
                        {
                        Object root_1 = (Object)adaptor.nil();
                        root_1 = (Object)adaptor.becomeRoot(
                        (Object)adaptor.create(FIXED_PARAMETER, "FIXED_PARAMETER")
                        , root_1);

                        adaptor.addChild(root_1, stream_arglist.nextTree());

                        adaptor.addChild(root_0, root_1);
                        }

                    }


                    retval.tree = root_0;
                    }

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "fixed_parameter"


    public static class default_argument_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "default_argument"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1659:1: default_argument : ASSIGNMENT ! expression ;
    public final CSharp4AST.default_argument_return default_argument() throws RecognitionException {
        CSharp4AST.default_argument_return retval = new CSharp4AST.default_argument_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token ASSIGNMENT869=null;
        CSharp4AST.expression_return expression870 =null;


        Object ASSIGNMENT869_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1660:2: ( ASSIGNMENT ! expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1660:4: ASSIGNMENT ! expression
            {
            root_0 = (Object)adaptor.nil();


            ASSIGNMENT869=(Token)match(input,ASSIGNMENT,FOLLOW_ASSIGNMENT_in_default_argument8077); if (state.failed) return retval;

            pushFollow(FOLLOW_expression_in_default_argument8080);
            expression870=expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, expression870.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "default_argument"


    public static class parameter_modifier_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "parameter_modifier"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1662:1: parameter_modifier : parameter_modifier2 -> ^( PARAMETER_MODIFIER parameter_modifier2 ) ;
    public final CSharp4AST.parameter_modifier_return parameter_modifier() throws RecognitionException {
        CSharp4AST.parameter_modifier_return retval = new CSharp4AST.parameter_modifier_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.parameter_modifier2_return parameter_modifier2871 =null;


        RewriteRuleSubtreeStream stream_parameter_modifier2=new RewriteRuleSubtreeStream(adaptor,"rule parameter_modifier2");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1663:3: ( parameter_modifier2 -> ^( PARAMETER_MODIFIER parameter_modifier2 ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1663:5: parameter_modifier2
            {
            pushFollow(FOLLOW_parameter_modifier2_in_parameter_modifier8092);
            parameter_modifier2871=parameter_modifier2();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_parameter_modifier2.add(parameter_modifier2871.getTree());

            // AST REWRITE
            // elements: parameter_modifier2
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 1663:25: -> ^( PARAMETER_MODIFIER parameter_modifier2 )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1663:28: ^( PARAMETER_MODIFIER parameter_modifier2 )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(PARAMETER_MODIFIER, "PARAMETER_MODIFIER")
                , root_1);

                adaptor.addChild(root_1, stream_parameter_modifier2.nextTree());

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "parameter_modifier"


    public static class parameter_modifier2_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "parameter_modifier2"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1665:1: parameter_modifier2 : ( REF | OUT | THIS );
    public final CSharp4AST.parameter_modifier2_return parameter_modifier2() throws RecognitionException {
        CSharp4AST.parameter_modifier2_return retval = new CSharp4AST.parameter_modifier2_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token set872=null;

        Object set872_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1666:2: ( REF | OUT | THIS )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:
            {
            root_0 = (Object)adaptor.nil();


            set872=(Token)input.LT(1);

            if ( input.LA(1)==OUT||input.LA(1)==REF||input.LA(1)==THIS ) {
                input.consume();
                if ( state.backtracking==0 ) adaptor.addChild(root_0, 
                (Object)adaptor.create(set872)
                );
                state.errorRecovery=false;
                state.failed=false;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                MismatchedSetException mse = new MismatchedSetException(null,input);
                throw mse;
            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "parameter_modifier2"


    public static class parameter_array_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "parameter_array"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1670:1: parameter_array : ( attributes )? PARAMS array_type IDENTIFIER -> ^( PARAMETER_ARRAY ( attributes )? array_type IDENTIFIER ) ;
    public final CSharp4AST.parameter_array_return parameter_array() throws RecognitionException {
        CSharp4AST.parameter_array_return retval = new CSharp4AST.parameter_array_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token PARAMS874=null;
        Token IDENTIFIER876=null;
        CSharp4AST.attributes_return attributes873 =null;

        CSharp4AST.array_type_return array_type875 =null;


        Object PARAMS874_tree=null;
        Object IDENTIFIER876_tree=null;
        RewriteRuleTokenStream stream_IDENTIFIER=new RewriteRuleTokenStream(adaptor,"token IDENTIFIER");
        RewriteRuleTokenStream stream_PARAMS=new RewriteRuleTokenStream(adaptor,"token PARAMS");
        RewriteRuleSubtreeStream stream_attributes=new RewriteRuleSubtreeStream(adaptor,"rule attributes");
        RewriteRuleSubtreeStream stream_array_type=new RewriteRuleSubtreeStream(adaptor,"rule array_type");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1671:2: ( ( attributes )? PARAMS array_type IDENTIFIER -> ^( PARAMETER_ARRAY ( attributes )? array_type IDENTIFIER ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1671:4: ( attributes )? PARAMS array_type IDENTIFIER
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1671:4: ( attributes )?
            int alt193=2;
            int LA193_0 = input.LA(1);

            if ( (LA193_0==OPEN_BRACKET) ) {
                alt193=1;
            }
            switch (alt193) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1671:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_parameter_array8132);
                    attributes873=attributes();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) stream_attributes.add(attributes873.getTree());

                    }
                    break;

            }


            PARAMS874=(Token)match(input,PARAMS,FOLLOW_PARAMS_in_parameter_array8135); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_PARAMS.add(PARAMS874);


            pushFollow(FOLLOW_array_type_in_parameter_array8137);
            array_type875=array_type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_array_type.add(array_type875.getTree());

            IDENTIFIER876=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_parameter_array8139); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_IDENTIFIER.add(IDENTIFIER876);


            // AST REWRITE
            // elements: array_type, IDENTIFIER, attributes
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 1672:4: -> ^( PARAMETER_ARRAY ( attributes )? array_type IDENTIFIER )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1672:7: ^( PARAMETER_ARRAY ( attributes )? array_type IDENTIFIER )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(PARAMETER_ARRAY, "PARAMETER_ARRAY")
                , root_1);

                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1672:25: ( attributes )?
                if ( stream_attributes.hasNext() ) {
                    adaptor.addChild(root_1, stream_attributes.nextTree());

                }
                stream_attributes.reset();

                adaptor.addChild(root_1, stream_array_type.nextTree());

                adaptor.addChild(root_1, 
                stream_IDENTIFIER.nextNode()
                );

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "parameter_array"


    public static class property_declaration_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "property_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1674:1: property_declaration : ( attributes )? ( property_modifiers )? type member_name OPEN_BRACE accessor_declarations CLOSE_BRACE ;
    public final CSharp4AST.property_declaration_return property_declaration() throws RecognitionException {
        CSharp4AST.property_declaration_return retval = new CSharp4AST.property_declaration_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token OPEN_BRACE881=null;
        Token CLOSE_BRACE883=null;
        CSharp4AST.attributes_return attributes877 =null;

        CSharp4AST.property_modifiers_return property_modifiers878 =null;

        CSharp4AST.type_return type879 =null;

        CSharp4AST.member_name_return member_name880 =null;

        CSharp4AST.accessor_declarations_return accessor_declarations882 =null;


        Object OPEN_BRACE881_tree=null;
        Object CLOSE_BRACE883_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1675:2: ( ( attributes )? ( property_modifiers )? type member_name OPEN_BRACE accessor_declarations CLOSE_BRACE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1675:4: ( attributes )? ( property_modifiers )? type member_name OPEN_BRACE accessor_declarations CLOSE_BRACE
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1675:4: ( attributes )?
            int alt194=2;
            int LA194_0 = input.LA(1);

            if ( (LA194_0==OPEN_BRACKET) ) {
                alt194=1;
            }
            switch (alt194) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1675:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_property_declaration8166);
                    attributes877=attributes();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, attributes877.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1675:16: ( property_modifiers )?
            int alt195=2;
            int LA195_0 = input.LA(1);

            if ( (LA195_0==ABSTRACT||LA195_0==EXTERN||LA195_0==INTERNAL||LA195_0==NEW||LA195_0==OVERRIDE||(LA195_0 >= PRIVATE && LA195_0 <= PUBLIC)||LA195_0==SEALED||LA195_0==STATIC||LA195_0==UNSAFE||LA195_0==VIRTUAL) ) {
                alt195=1;
            }
            switch (alt195) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1675:16: property_modifiers
                    {
                    pushFollow(FOLLOW_property_modifiers_in_property_declaration8169);
                    property_modifiers878=property_modifiers();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, property_modifiers878.getTree());

                    }
                    break;

            }


            pushFollow(FOLLOW_type_in_property_declaration8172);
            type879=type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, type879.getTree());

            pushFollow(FOLLOW_member_name_in_property_declaration8174);
            member_name880=member_name();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, member_name880.getTree());

            OPEN_BRACE881=(Token)match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_property_declaration8176); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            OPEN_BRACE881_tree = 
            (Object)adaptor.create(OPEN_BRACE881)
            ;
            adaptor.addChild(root_0, OPEN_BRACE881_tree);
            }

            pushFollow(FOLLOW_accessor_declarations_in_property_declaration8178);
            accessor_declarations882=accessor_declarations();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, accessor_declarations882.getTree());

            CLOSE_BRACE883=(Token)match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_property_declaration8180); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            CLOSE_BRACE883_tree = 
            (Object)adaptor.create(CLOSE_BRACE883)
            ;
            adaptor.addChild(root_0, CLOSE_BRACE883_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "property_declaration"


    public static class property_modifiers_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "property_modifiers"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1677:1: property_modifiers : ( property_modifier )+ ;
    public final CSharp4AST.property_modifiers_return property_modifiers() throws RecognitionException {
        CSharp4AST.property_modifiers_return retval = new CSharp4AST.property_modifiers_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.property_modifier_return property_modifier884 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1678:2: ( ( property_modifier )+ )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1678:4: ( property_modifier )+
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1678:4: ( property_modifier )+
            int cnt196=0;
            loop196:
            do {
                int alt196=2;
                int LA196_0 = input.LA(1);

                if ( (LA196_0==ABSTRACT||LA196_0==EXTERN||LA196_0==INTERNAL||LA196_0==NEW||LA196_0==OVERRIDE||(LA196_0 >= PRIVATE && LA196_0 <= PUBLIC)||LA196_0==SEALED||LA196_0==STATIC||LA196_0==UNSAFE||LA196_0==VIRTUAL) ) {
                    alt196=1;
                }


                switch (alt196) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1678:4: property_modifier
            	    {
            	    pushFollow(FOLLOW_property_modifier_in_property_modifiers8191);
            	    property_modifier884=property_modifier();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, property_modifier884.getTree());

            	    }
            	    break;

            	default :
            	    if ( cnt196 >= 1 ) break loop196;
            	    if (state.backtracking>0) {state.failed=true; return retval;}
                        EarlyExitException eee =
                            new EarlyExitException(196, input);
                        throw eee;
                }
                cnt196++;
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "property_modifiers"


    public static class property_modifier_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "property_modifier"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1680:1: property_modifier : ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | STATIC | VIRTUAL | SEALED | OVERRIDE | ABSTRACT | EXTERN | property_modifier_unsafe );
    public final CSharp4AST.property_modifier_return property_modifier() throws RecognitionException {
        CSharp4AST.property_modifier_return retval = new CSharp4AST.property_modifier_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token NEW885=null;
        Token PUBLIC886=null;
        Token PROTECTED887=null;
        Token INTERNAL888=null;
        Token PRIVATE889=null;
        Token STATIC890=null;
        Token VIRTUAL891=null;
        Token SEALED892=null;
        Token OVERRIDE893=null;
        Token ABSTRACT894=null;
        Token EXTERN895=null;
        CSharp4AST.property_modifier_unsafe_return property_modifier_unsafe896 =null;


        Object NEW885_tree=null;
        Object PUBLIC886_tree=null;
        Object PROTECTED887_tree=null;
        Object INTERNAL888_tree=null;
        Object PRIVATE889_tree=null;
        Object STATIC890_tree=null;
        Object VIRTUAL891_tree=null;
        Object SEALED892_tree=null;
        Object OVERRIDE893_tree=null;
        Object ABSTRACT894_tree=null;
        Object EXTERN895_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1681:2: ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | STATIC | VIRTUAL | SEALED | OVERRIDE | ABSTRACT | EXTERN | property_modifier_unsafe )
            int alt197=12;
            switch ( input.LA(1) ) {
            case NEW:
                {
                alt197=1;
                }
                break;
            case PUBLIC:
                {
                alt197=2;
                }
                break;
            case PROTECTED:
                {
                alt197=3;
                }
                break;
            case INTERNAL:
                {
                alt197=4;
                }
                break;
            case PRIVATE:
                {
                alt197=5;
                }
                break;
            case STATIC:
                {
                alt197=6;
                }
                break;
            case VIRTUAL:
                {
                alt197=7;
                }
                break;
            case SEALED:
                {
                alt197=8;
                }
                break;
            case OVERRIDE:
                {
                alt197=9;
                }
                break;
            case ABSTRACT:
                {
                alt197=10;
                }
                break;
            case EXTERN:
                {
                alt197=11;
                }
                break;
            case UNSAFE:
                {
                alt197=12;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 197, 0, input);

                throw nvae;

            }

            switch (alt197) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1681:4: NEW
                    {
                    root_0 = (Object)adaptor.nil();


                    NEW885=(Token)match(input,NEW,FOLLOW_NEW_in_property_modifier8203); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    NEW885_tree = 
                    (Object)adaptor.create(NEW885)
                    ;
                    adaptor.addChild(root_0, NEW885_tree);
                    }

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1682:4: PUBLIC
                    {
                    root_0 = (Object)adaptor.nil();


                    PUBLIC886=(Token)match(input,PUBLIC,FOLLOW_PUBLIC_in_property_modifier8208); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PUBLIC886_tree = 
                    (Object)adaptor.create(PUBLIC886)
                    ;
                    adaptor.addChild(root_0, PUBLIC886_tree);
                    }

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1683:4: PROTECTED
                    {
                    root_0 = (Object)adaptor.nil();


                    PROTECTED887=(Token)match(input,PROTECTED,FOLLOW_PROTECTED_in_property_modifier8213); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PROTECTED887_tree = 
                    (Object)adaptor.create(PROTECTED887)
                    ;
                    adaptor.addChild(root_0, PROTECTED887_tree);
                    }

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1684:4: INTERNAL
                    {
                    root_0 = (Object)adaptor.nil();


                    INTERNAL888=(Token)match(input,INTERNAL,FOLLOW_INTERNAL_in_property_modifier8218); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    INTERNAL888_tree = 
                    (Object)adaptor.create(INTERNAL888)
                    ;
                    adaptor.addChild(root_0, INTERNAL888_tree);
                    }

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1685:4: PRIVATE
                    {
                    root_0 = (Object)adaptor.nil();


                    PRIVATE889=(Token)match(input,PRIVATE,FOLLOW_PRIVATE_in_property_modifier8223); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PRIVATE889_tree = 
                    (Object)adaptor.create(PRIVATE889)
                    ;
                    adaptor.addChild(root_0, PRIVATE889_tree);
                    }

                    }
                    break;
                case 6 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1686:4: STATIC
                    {
                    root_0 = (Object)adaptor.nil();


                    STATIC890=(Token)match(input,STATIC,FOLLOW_STATIC_in_property_modifier8228); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    STATIC890_tree = 
                    (Object)adaptor.create(STATIC890)
                    ;
                    adaptor.addChild(root_0, STATIC890_tree);
                    }

                    }
                    break;
                case 7 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1687:4: VIRTUAL
                    {
                    root_0 = (Object)adaptor.nil();


                    VIRTUAL891=(Token)match(input,VIRTUAL,FOLLOW_VIRTUAL_in_property_modifier8233); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    VIRTUAL891_tree = 
                    (Object)adaptor.create(VIRTUAL891)
                    ;
                    adaptor.addChild(root_0, VIRTUAL891_tree);
                    }

                    }
                    break;
                case 8 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1688:4: SEALED
                    {
                    root_0 = (Object)adaptor.nil();


                    SEALED892=(Token)match(input,SEALED,FOLLOW_SEALED_in_property_modifier8238); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    SEALED892_tree = 
                    (Object)adaptor.create(SEALED892)
                    ;
                    adaptor.addChild(root_0, SEALED892_tree);
                    }

                    }
                    break;
                case 9 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1689:4: OVERRIDE
                    {
                    root_0 = (Object)adaptor.nil();


                    OVERRIDE893=(Token)match(input,OVERRIDE,FOLLOW_OVERRIDE_in_property_modifier8243); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OVERRIDE893_tree = 
                    (Object)adaptor.create(OVERRIDE893)
                    ;
                    adaptor.addChild(root_0, OVERRIDE893_tree);
                    }

                    }
                    break;
                case 10 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1690:4: ABSTRACT
                    {
                    root_0 = (Object)adaptor.nil();


                    ABSTRACT894=(Token)match(input,ABSTRACT,FOLLOW_ABSTRACT_in_property_modifier8248); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    ABSTRACT894_tree = 
                    (Object)adaptor.create(ABSTRACT894)
                    ;
                    adaptor.addChild(root_0, ABSTRACT894_tree);
                    }

                    }
                    break;
                case 11 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1691:4: EXTERN
                    {
                    root_0 = (Object)adaptor.nil();


                    EXTERN895=(Token)match(input,EXTERN,FOLLOW_EXTERN_in_property_modifier8253); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    EXTERN895_tree = 
                    (Object)adaptor.create(EXTERN895)
                    ;
                    adaptor.addChild(root_0, EXTERN895_tree);
                    }

                    }
                    break;
                case 12 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1692:4: property_modifier_unsafe
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_property_modifier_unsafe_in_property_modifier8258);
                    property_modifier_unsafe896=property_modifier_unsafe();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, property_modifier_unsafe896.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "property_modifier"


    public static class accessor_declarations_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "accessor_declarations"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1700:1: accessor_declarations : (attrs= attributes )? (mods= accessor_modifier )? ( get_contextual_keyword accessor_body ( set_accessor_declaration )? | set_contextual_keyword accessor_body ( get_accessor_declaration )? ) ;
    public final CSharp4AST.accessor_declarations_return accessor_declarations() throws RecognitionException {
        CSharp4AST.accessor_declarations_return retval = new CSharp4AST.accessor_declarations_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.attributes_return attrs =null;

        CSharp4AST.accessor_modifier_return mods =null;

        CSharp4AST.get_contextual_keyword_return get_contextual_keyword897 =null;

        CSharp4AST.accessor_body_return accessor_body898 =null;

        CSharp4AST.set_accessor_declaration_return set_accessor_declaration899 =null;

        CSharp4AST.set_contextual_keyword_return set_contextual_keyword900 =null;

        CSharp4AST.accessor_body_return accessor_body901 =null;

        CSharp4AST.get_accessor_declaration_return get_accessor_declaration902 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1701:3: ( (attrs= attributes )? (mods= accessor_modifier )? ( get_contextual_keyword accessor_body ( set_accessor_declaration )? | set_contextual_keyword accessor_body ( get_accessor_declaration )? ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1701:5: (attrs= attributes )? (mods= accessor_modifier )? ( get_contextual_keyword accessor_body ( set_accessor_declaration )? | set_contextual_keyword accessor_body ( get_accessor_declaration )? )
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1701:10: (attrs= attributes )?
            int alt198=2;
            int LA198_0 = input.LA(1);

            if ( (LA198_0==OPEN_BRACKET) ) {
                alt198=1;
            }
            switch (alt198) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1701:10: attrs= attributes
                    {
                    pushFollow(FOLLOW_attributes_in_accessor_declarations8274);
                    attrs=attributes();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, attrs.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1702:9: (mods= accessor_modifier )?
            int alt199=2;
            int LA199_0 = input.LA(1);

            if ( (LA199_0==INTERNAL||(LA199_0 >= PRIVATE && LA199_0 <= PROTECTED)) ) {
                alt199=1;
            }
            switch (alt199) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1702:9: mods= accessor_modifier
                    {
                    pushFollow(FOLLOW_accessor_modifier_in_accessor_declarations8283);
                    mods=accessor_modifier();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, mods.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1703:5: ( get_contextual_keyword accessor_body ( set_accessor_declaration )? | set_contextual_keyword accessor_body ( get_accessor_declaration )? )
            int alt202=2;
            int LA202_0 = input.LA(1);

            if ( (LA202_0==IDENTIFIER) ) {
                int LA202_1 = input.LA(2);

                if ( ((input.LT(1).getText().equals("get"))) ) {
                    alt202=1;
                }
                else if ( ((input.LT(1).getText().equals("set"))) ) {
                    alt202=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 202, 1, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 202, 0, input);

                throw nvae;

            }
            switch (alt202) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1703:7: get_contextual_keyword accessor_body ( set_accessor_declaration )?
                    {
                    pushFollow(FOLLOW_get_contextual_keyword_in_accessor_declarations8293);
                    get_contextual_keyword897=get_contextual_keyword();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, get_contextual_keyword897.getTree());

                    pushFollow(FOLLOW_accessor_body_in_accessor_declarations8295);
                    accessor_body898=accessor_body();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, accessor_body898.getTree());

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1703:44: ( set_accessor_declaration )?
                    int alt200=2;
                    int LA200_0 = input.LA(1);

                    if ( (LA200_0==IDENTIFIER||LA200_0==INTERNAL||LA200_0==OPEN_BRACKET||(LA200_0 >= PRIVATE && LA200_0 <= PROTECTED)) ) {
                        alt200=1;
                    }
                    switch (alt200) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1703:44: set_accessor_declaration
                            {
                            pushFollow(FOLLOW_set_accessor_declaration_in_accessor_declarations8297);
                            set_accessor_declaration899=set_accessor_declaration();

                            state._fsp--;
                            if (state.failed) return retval;
                            if ( state.backtracking==0 ) adaptor.addChild(root_0, set_accessor_declaration899.getTree());

                            }
                            break;

                    }


                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1704:7: set_contextual_keyword accessor_body ( get_accessor_declaration )?
                    {
                    pushFollow(FOLLOW_set_contextual_keyword_in_accessor_declarations8306);
                    set_contextual_keyword900=set_contextual_keyword();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, set_contextual_keyword900.getTree());

                    pushFollow(FOLLOW_accessor_body_in_accessor_declarations8308);
                    accessor_body901=accessor_body();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, accessor_body901.getTree());

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1704:44: ( get_accessor_declaration )?
                    int alt201=2;
                    int LA201_0 = input.LA(1);

                    if ( (LA201_0==IDENTIFIER||LA201_0==INTERNAL||LA201_0==OPEN_BRACKET||(LA201_0 >= PRIVATE && LA201_0 <= PROTECTED)) ) {
                        alt201=1;
                    }
                    switch (alt201) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1704:44: get_accessor_declaration
                            {
                            pushFollow(FOLLOW_get_accessor_declaration_in_accessor_declarations8310);
                            get_accessor_declaration902=get_accessor_declaration();

                            state._fsp--;
                            if (state.failed) return retval;
                            if ( state.backtracking==0 ) adaptor.addChild(root_0, get_accessor_declaration902.getTree());

                            }
                            break;

                    }


                    }
                    break;

            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "accessor_declarations"


    public static class get_accessor_declaration_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "get_accessor_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1707:1: get_accessor_declaration : ( attributes )? ( accessor_modifier )? get_contextual_keyword accessor_body ;
    public final CSharp4AST.get_accessor_declaration_return get_accessor_declaration() throws RecognitionException {
        CSharp4AST.get_accessor_declaration_return retval = new CSharp4AST.get_accessor_declaration_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.attributes_return attributes903 =null;

        CSharp4AST.accessor_modifier_return accessor_modifier904 =null;

        CSharp4AST.get_contextual_keyword_return get_contextual_keyword905 =null;

        CSharp4AST.accessor_body_return accessor_body906 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1708:2: ( ( attributes )? ( accessor_modifier )? get_contextual_keyword accessor_body )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1708:4: ( attributes )? ( accessor_modifier )? get_contextual_keyword accessor_body
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1708:4: ( attributes )?
            int alt203=2;
            int LA203_0 = input.LA(1);

            if ( (LA203_0==OPEN_BRACKET) ) {
                alt203=1;
            }
            switch (alt203) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1708:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_get_accessor_declaration8329);
                    attributes903=attributes();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, attributes903.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1708:16: ( accessor_modifier )?
            int alt204=2;
            int LA204_0 = input.LA(1);

            if ( (LA204_0==INTERNAL||(LA204_0 >= PRIVATE && LA204_0 <= PROTECTED)) ) {
                alt204=1;
            }
            switch (alt204) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1708:16: accessor_modifier
                    {
                    pushFollow(FOLLOW_accessor_modifier_in_get_accessor_declaration8332);
                    accessor_modifier904=accessor_modifier();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, accessor_modifier904.getTree());

                    }
                    break;

            }


            pushFollow(FOLLOW_get_contextual_keyword_in_get_accessor_declaration8335);
            get_contextual_keyword905=get_contextual_keyword();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, get_contextual_keyword905.getTree());

            pushFollow(FOLLOW_accessor_body_in_get_accessor_declaration8337);
            accessor_body906=accessor_body();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, accessor_body906.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "get_accessor_declaration"


    public static class set_accessor_declaration_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "set_accessor_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1710:1: set_accessor_declaration : ( attributes )? ( accessor_modifier )? set_contextual_keyword accessor_body ;
    public final CSharp4AST.set_accessor_declaration_return set_accessor_declaration() throws RecognitionException {
        CSharp4AST.set_accessor_declaration_return retval = new CSharp4AST.set_accessor_declaration_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.attributes_return attributes907 =null;

        CSharp4AST.accessor_modifier_return accessor_modifier908 =null;

        CSharp4AST.set_contextual_keyword_return set_contextual_keyword909 =null;

        CSharp4AST.accessor_body_return accessor_body910 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1711:2: ( ( attributes )? ( accessor_modifier )? set_contextual_keyword accessor_body )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1711:4: ( attributes )? ( accessor_modifier )? set_contextual_keyword accessor_body
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1711:4: ( attributes )?
            int alt205=2;
            int LA205_0 = input.LA(1);

            if ( (LA205_0==OPEN_BRACKET) ) {
                alt205=1;
            }
            switch (alt205) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1711:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_set_accessor_declaration8348);
                    attributes907=attributes();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, attributes907.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1711:16: ( accessor_modifier )?
            int alt206=2;
            int LA206_0 = input.LA(1);

            if ( (LA206_0==INTERNAL||(LA206_0 >= PRIVATE && LA206_0 <= PROTECTED)) ) {
                alt206=1;
            }
            switch (alt206) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1711:16: accessor_modifier
                    {
                    pushFollow(FOLLOW_accessor_modifier_in_set_accessor_declaration8351);
                    accessor_modifier908=accessor_modifier();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, accessor_modifier908.getTree());

                    }
                    break;

            }


            pushFollow(FOLLOW_set_contextual_keyword_in_set_accessor_declaration8354);
            set_contextual_keyword909=set_contextual_keyword();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, set_contextual_keyword909.getTree());

            pushFollow(FOLLOW_accessor_body_in_set_accessor_declaration8356);
            accessor_body910=accessor_body();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, accessor_body910.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "set_accessor_declaration"


    public static class accessor_modifier_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "accessor_modifier"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1713:1: accessor_modifier : ( PROTECTED | INTERNAL | PRIVATE | PROTECTED INTERNAL | INTERNAL PROTECTED );
    public final CSharp4AST.accessor_modifier_return accessor_modifier() throws RecognitionException {
        CSharp4AST.accessor_modifier_return retval = new CSharp4AST.accessor_modifier_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token PROTECTED911=null;
        Token INTERNAL912=null;
        Token PRIVATE913=null;
        Token PROTECTED914=null;
        Token INTERNAL915=null;
        Token INTERNAL916=null;
        Token PROTECTED917=null;

        Object PROTECTED911_tree=null;
        Object INTERNAL912_tree=null;
        Object PRIVATE913_tree=null;
        Object PROTECTED914_tree=null;
        Object INTERNAL915_tree=null;
        Object INTERNAL916_tree=null;
        Object PROTECTED917_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1714:2: ( PROTECTED | INTERNAL | PRIVATE | PROTECTED INTERNAL | INTERNAL PROTECTED )
            int alt207=5;
            switch ( input.LA(1) ) {
            case PROTECTED:
                {
                int LA207_1 = input.LA(2);

                if ( (LA207_1==INTERNAL) ) {
                    alt207=4;
                }
                else if ( (LA207_1==IDENTIFIER) ) {
                    alt207=1;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 207, 1, input);

                    throw nvae;

                }
                }
                break;
            case INTERNAL:
                {
                int LA207_2 = input.LA(2);

                if ( (LA207_2==PROTECTED) ) {
                    alt207=5;
                }
                else if ( (LA207_2==IDENTIFIER) ) {
                    alt207=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 207, 2, input);

                    throw nvae;

                }
                }
                break;
            case PRIVATE:
                {
                alt207=3;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 207, 0, input);

                throw nvae;

            }

            switch (alt207) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1714:4: PROTECTED
                    {
                    root_0 = (Object)adaptor.nil();


                    PROTECTED911=(Token)match(input,PROTECTED,FOLLOW_PROTECTED_in_accessor_modifier8367); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PROTECTED911_tree = 
                    (Object)adaptor.create(PROTECTED911)
                    ;
                    adaptor.addChild(root_0, PROTECTED911_tree);
                    }

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1715:4: INTERNAL
                    {
                    root_0 = (Object)adaptor.nil();


                    INTERNAL912=(Token)match(input,INTERNAL,FOLLOW_INTERNAL_in_accessor_modifier8372); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    INTERNAL912_tree = 
                    (Object)adaptor.create(INTERNAL912)
                    ;
                    adaptor.addChild(root_0, INTERNAL912_tree);
                    }

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1716:4: PRIVATE
                    {
                    root_0 = (Object)adaptor.nil();


                    PRIVATE913=(Token)match(input,PRIVATE,FOLLOW_PRIVATE_in_accessor_modifier8377); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PRIVATE913_tree = 
                    (Object)adaptor.create(PRIVATE913)
                    ;
                    adaptor.addChild(root_0, PRIVATE913_tree);
                    }

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1717:4: PROTECTED INTERNAL
                    {
                    root_0 = (Object)adaptor.nil();


                    PROTECTED914=(Token)match(input,PROTECTED,FOLLOW_PROTECTED_in_accessor_modifier8382); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PROTECTED914_tree = 
                    (Object)adaptor.create(PROTECTED914)
                    ;
                    adaptor.addChild(root_0, PROTECTED914_tree);
                    }

                    INTERNAL915=(Token)match(input,INTERNAL,FOLLOW_INTERNAL_in_accessor_modifier8384); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    INTERNAL915_tree = 
                    (Object)adaptor.create(INTERNAL915)
                    ;
                    adaptor.addChild(root_0, INTERNAL915_tree);
                    }

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1718:4: INTERNAL PROTECTED
                    {
                    root_0 = (Object)adaptor.nil();


                    INTERNAL916=(Token)match(input,INTERNAL,FOLLOW_INTERNAL_in_accessor_modifier8389); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    INTERNAL916_tree = 
                    (Object)adaptor.create(INTERNAL916)
                    ;
                    adaptor.addChild(root_0, INTERNAL916_tree);
                    }

                    PROTECTED917=(Token)match(input,PROTECTED,FOLLOW_PROTECTED_in_accessor_modifier8391); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PROTECTED917_tree = 
                    (Object)adaptor.create(PROTECTED917)
                    ;
                    adaptor.addChild(root_0, PROTECTED917_tree);
                    }

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "accessor_modifier"


    public static class accessor_body_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "accessor_body"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1720:1: accessor_body : ( block | SEMICOLON );
    public final CSharp4AST.accessor_body_return accessor_body() throws RecognitionException {
        CSharp4AST.accessor_body_return retval = new CSharp4AST.accessor_body_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token SEMICOLON919=null;
        CSharp4AST.block_return block918 =null;


        Object SEMICOLON919_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1721:2: ( block | SEMICOLON )
            int alt208=2;
            int LA208_0 = input.LA(1);

            if ( (LA208_0==OPEN_BRACE) ) {
                alt208=1;
            }
            else if ( (LA208_0==SEMICOLON) ) {
                alt208=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 208, 0, input);

                throw nvae;

            }
            switch (alt208) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1721:4: block
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_block_in_accessor_body8402);
                    block918=block();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, block918.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1722:4: SEMICOLON
                    {
                    root_0 = (Object)adaptor.nil();


                    SEMICOLON919=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_accessor_body8407); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    SEMICOLON919_tree = 
                    (Object)adaptor.create(SEMICOLON919)
                    ;
                    adaptor.addChild(root_0, SEMICOLON919_tree);
                    }

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "accessor_body"


    public static class event_modifiers_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "event_modifiers"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1738:1: event_modifiers : ( event_modifier )+ ;
    public final CSharp4AST.event_modifiers_return event_modifiers() throws RecognitionException {
        CSharp4AST.event_modifiers_return retval = new CSharp4AST.event_modifiers_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.event_modifier_return event_modifier920 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1739:2: ( ( event_modifier )+ )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1739:4: ( event_modifier )+
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1739:4: ( event_modifier )+
            int cnt209=0;
            loop209:
            do {
                int alt209=2;
                int LA209_0 = input.LA(1);

                if ( (LA209_0==ABSTRACT||LA209_0==EXTERN||LA209_0==INTERNAL||LA209_0==NEW||LA209_0==OVERRIDE||(LA209_0 >= PRIVATE && LA209_0 <= PUBLIC)||LA209_0==SEALED||LA209_0==STATIC||LA209_0==UNSAFE||LA209_0==VIRTUAL) ) {
                    alt209=1;
                }


                switch (alt209) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1739:4: event_modifier
            	    {
            	    pushFollow(FOLLOW_event_modifier_in_event_modifiers8422);
            	    event_modifier920=event_modifier();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, event_modifier920.getTree());

            	    }
            	    break;

            	default :
            	    if ( cnt209 >= 1 ) break loop209;
            	    if (state.backtracking>0) {state.failed=true; return retval;}
                        EarlyExitException eee =
                            new EarlyExitException(209, input);
                        throw eee;
                }
                cnt209++;
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "event_modifiers"


    public static class event_modifier_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "event_modifier"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1741:1: event_modifier : ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | STATIC | VIRTUAL | SEALED | OVERRIDE | ABSTRACT | EXTERN | event_modifier_unsafe );
    public final CSharp4AST.event_modifier_return event_modifier() throws RecognitionException {
        CSharp4AST.event_modifier_return retval = new CSharp4AST.event_modifier_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token NEW921=null;
        Token PUBLIC922=null;
        Token PROTECTED923=null;
        Token INTERNAL924=null;
        Token PRIVATE925=null;
        Token STATIC926=null;
        Token VIRTUAL927=null;
        Token SEALED928=null;
        Token OVERRIDE929=null;
        Token ABSTRACT930=null;
        Token EXTERN931=null;
        CSharp4AST.event_modifier_unsafe_return event_modifier_unsafe932 =null;


        Object NEW921_tree=null;
        Object PUBLIC922_tree=null;
        Object PROTECTED923_tree=null;
        Object INTERNAL924_tree=null;
        Object PRIVATE925_tree=null;
        Object STATIC926_tree=null;
        Object VIRTUAL927_tree=null;
        Object SEALED928_tree=null;
        Object OVERRIDE929_tree=null;
        Object ABSTRACT930_tree=null;
        Object EXTERN931_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1742:2: ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | STATIC | VIRTUAL | SEALED | OVERRIDE | ABSTRACT | EXTERN | event_modifier_unsafe )
            int alt210=12;
            switch ( input.LA(1) ) {
            case NEW:
                {
                alt210=1;
                }
                break;
            case PUBLIC:
                {
                alt210=2;
                }
                break;
            case PROTECTED:
                {
                alt210=3;
                }
                break;
            case INTERNAL:
                {
                alt210=4;
                }
                break;
            case PRIVATE:
                {
                alt210=5;
                }
                break;
            case STATIC:
                {
                alt210=6;
                }
                break;
            case VIRTUAL:
                {
                alt210=7;
                }
                break;
            case SEALED:
                {
                alt210=8;
                }
                break;
            case OVERRIDE:
                {
                alt210=9;
                }
                break;
            case ABSTRACT:
                {
                alt210=10;
                }
                break;
            case EXTERN:
                {
                alt210=11;
                }
                break;
            case UNSAFE:
                {
                alt210=12;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 210, 0, input);

                throw nvae;

            }

            switch (alt210) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1742:4: NEW
                    {
                    root_0 = (Object)adaptor.nil();


                    NEW921=(Token)match(input,NEW,FOLLOW_NEW_in_event_modifier8434); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    NEW921_tree = 
                    (Object)adaptor.create(NEW921)
                    ;
                    adaptor.addChild(root_0, NEW921_tree);
                    }

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1743:4: PUBLIC
                    {
                    root_0 = (Object)adaptor.nil();


                    PUBLIC922=(Token)match(input,PUBLIC,FOLLOW_PUBLIC_in_event_modifier8439); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PUBLIC922_tree = 
                    (Object)adaptor.create(PUBLIC922)
                    ;
                    adaptor.addChild(root_0, PUBLIC922_tree);
                    }

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1744:4: PROTECTED
                    {
                    root_0 = (Object)adaptor.nil();


                    PROTECTED923=(Token)match(input,PROTECTED,FOLLOW_PROTECTED_in_event_modifier8444); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PROTECTED923_tree = 
                    (Object)adaptor.create(PROTECTED923)
                    ;
                    adaptor.addChild(root_0, PROTECTED923_tree);
                    }

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1745:4: INTERNAL
                    {
                    root_0 = (Object)adaptor.nil();


                    INTERNAL924=(Token)match(input,INTERNAL,FOLLOW_INTERNAL_in_event_modifier8449); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    INTERNAL924_tree = 
                    (Object)adaptor.create(INTERNAL924)
                    ;
                    adaptor.addChild(root_0, INTERNAL924_tree);
                    }

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1746:4: PRIVATE
                    {
                    root_0 = (Object)adaptor.nil();


                    PRIVATE925=(Token)match(input,PRIVATE,FOLLOW_PRIVATE_in_event_modifier8454); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PRIVATE925_tree = 
                    (Object)adaptor.create(PRIVATE925)
                    ;
                    adaptor.addChild(root_0, PRIVATE925_tree);
                    }

                    }
                    break;
                case 6 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1747:4: STATIC
                    {
                    root_0 = (Object)adaptor.nil();


                    STATIC926=(Token)match(input,STATIC,FOLLOW_STATIC_in_event_modifier8459); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    STATIC926_tree = 
                    (Object)adaptor.create(STATIC926)
                    ;
                    adaptor.addChild(root_0, STATIC926_tree);
                    }

                    }
                    break;
                case 7 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1748:4: VIRTUAL
                    {
                    root_0 = (Object)adaptor.nil();


                    VIRTUAL927=(Token)match(input,VIRTUAL,FOLLOW_VIRTUAL_in_event_modifier8464); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    VIRTUAL927_tree = 
                    (Object)adaptor.create(VIRTUAL927)
                    ;
                    adaptor.addChild(root_0, VIRTUAL927_tree);
                    }

                    }
                    break;
                case 8 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1749:4: SEALED
                    {
                    root_0 = (Object)adaptor.nil();


                    SEALED928=(Token)match(input,SEALED,FOLLOW_SEALED_in_event_modifier8469); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    SEALED928_tree = 
                    (Object)adaptor.create(SEALED928)
                    ;
                    adaptor.addChild(root_0, SEALED928_tree);
                    }

                    }
                    break;
                case 9 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1750:4: OVERRIDE
                    {
                    root_0 = (Object)adaptor.nil();


                    OVERRIDE929=(Token)match(input,OVERRIDE,FOLLOW_OVERRIDE_in_event_modifier8474); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OVERRIDE929_tree = 
                    (Object)adaptor.create(OVERRIDE929)
                    ;
                    adaptor.addChild(root_0, OVERRIDE929_tree);
                    }

                    }
                    break;
                case 10 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1751:4: ABSTRACT
                    {
                    root_0 = (Object)adaptor.nil();


                    ABSTRACT930=(Token)match(input,ABSTRACT,FOLLOW_ABSTRACT_in_event_modifier8479); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    ABSTRACT930_tree = 
                    (Object)adaptor.create(ABSTRACT930)
                    ;
                    adaptor.addChild(root_0, ABSTRACT930_tree);
                    }

                    }
                    break;
                case 11 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1752:4: EXTERN
                    {
                    root_0 = (Object)adaptor.nil();


                    EXTERN931=(Token)match(input,EXTERN,FOLLOW_EXTERN_in_event_modifier8484); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    EXTERN931_tree = 
                    (Object)adaptor.create(EXTERN931)
                    ;
                    adaptor.addChild(root_0, EXTERN931_tree);
                    }

                    }
                    break;
                case 12 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1753:4: event_modifier_unsafe
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_event_modifier_unsafe_in_event_modifier8489);
                    event_modifier_unsafe932=event_modifier_unsafe();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, event_modifier_unsafe932.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "event_modifier"


    public static class event_accessor_declarations_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "event_accessor_declarations"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1755:1: event_accessor_declarations : ( attributes )? ( add_contextual_keyword block remove_accessor_declaration | remove_contextual_keyword block add_accessor_declaration ) ;
    public final CSharp4AST.event_accessor_declarations_return event_accessor_declarations() throws RecognitionException {
        CSharp4AST.event_accessor_declarations_return retval = new CSharp4AST.event_accessor_declarations_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.attributes_return attributes933 =null;

        CSharp4AST.add_contextual_keyword_return add_contextual_keyword934 =null;

        CSharp4AST.block_return block935 =null;

        CSharp4AST.remove_accessor_declaration_return remove_accessor_declaration936 =null;

        CSharp4AST.remove_contextual_keyword_return remove_contextual_keyword937 =null;

        CSharp4AST.block_return block938 =null;

        CSharp4AST.add_accessor_declaration_return add_accessor_declaration939 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1756:2: ( ( attributes )? ( add_contextual_keyword block remove_accessor_declaration | remove_contextual_keyword block add_accessor_declaration ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1756:4: ( attributes )? ( add_contextual_keyword block remove_accessor_declaration | remove_contextual_keyword block add_accessor_declaration )
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1756:4: ( attributes )?
            int alt211=2;
            int LA211_0 = input.LA(1);

            if ( (LA211_0==OPEN_BRACKET) ) {
                alt211=1;
            }
            switch (alt211) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1756:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_event_accessor_declarations8500);
                    attributes933=attributes();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, attributes933.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1757:4: ( add_contextual_keyword block remove_accessor_declaration | remove_contextual_keyword block add_accessor_declaration )
            int alt212=2;
            int LA212_0 = input.LA(1);

            if ( (LA212_0==IDENTIFIER) ) {
                int LA212_1 = input.LA(2);

                if ( ((input.LT(1).getText().equals("add"))) ) {
                    alt212=1;
                }
                else if ( ((input.LT(1).getText().equals("remove"))) ) {
                    alt212=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 212, 1, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 212, 0, input);

                throw nvae;

            }
            switch (alt212) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1757:6: add_contextual_keyword block remove_accessor_declaration
                    {
                    pushFollow(FOLLOW_add_contextual_keyword_in_event_accessor_declarations8508);
                    add_contextual_keyword934=add_contextual_keyword();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, add_contextual_keyword934.getTree());

                    pushFollow(FOLLOW_block_in_event_accessor_declarations8510);
                    block935=block();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, block935.getTree());

                    pushFollow(FOLLOW_remove_accessor_declaration_in_event_accessor_declarations8512);
                    remove_accessor_declaration936=remove_accessor_declaration();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, remove_accessor_declaration936.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1758:6: remove_contextual_keyword block add_accessor_declaration
                    {
                    pushFollow(FOLLOW_remove_contextual_keyword_in_event_accessor_declarations8519);
                    remove_contextual_keyword937=remove_contextual_keyword();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, remove_contextual_keyword937.getTree());

                    pushFollow(FOLLOW_block_in_event_accessor_declarations8521);
                    block938=block();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, block938.getTree());

                    pushFollow(FOLLOW_add_accessor_declaration_in_event_accessor_declarations8523);
                    add_accessor_declaration939=add_accessor_declaration();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, add_accessor_declaration939.getTree());

                    }
                    break;

            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "event_accessor_declarations"


    public static class add_accessor_declaration_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "add_accessor_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1761:1: add_accessor_declaration : ( attributes )? add_contextual_keyword block ;
    public final CSharp4AST.add_accessor_declaration_return add_accessor_declaration() throws RecognitionException {
        CSharp4AST.add_accessor_declaration_return retval = new CSharp4AST.add_accessor_declaration_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.attributes_return attributes940 =null;

        CSharp4AST.add_contextual_keyword_return add_contextual_keyword941 =null;

        CSharp4AST.block_return block942 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1762:2: ( ( attributes )? add_contextual_keyword block )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1762:4: ( attributes )? add_contextual_keyword block
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1762:4: ( attributes )?
            int alt213=2;
            int LA213_0 = input.LA(1);

            if ( (LA213_0==OPEN_BRACKET) ) {
                alt213=1;
            }
            switch (alt213) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1762:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_add_accessor_declaration8539);
                    attributes940=attributes();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, attributes940.getTree());

                    }
                    break;

            }


            pushFollow(FOLLOW_add_contextual_keyword_in_add_accessor_declaration8542);
            add_contextual_keyword941=add_contextual_keyword();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, add_contextual_keyword941.getTree());

            pushFollow(FOLLOW_block_in_add_accessor_declaration8544);
            block942=block();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, block942.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "add_accessor_declaration"


    public static class remove_accessor_declaration_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "remove_accessor_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1764:1: remove_accessor_declaration : ( attributes )? remove_contextual_keyword block ;
    public final CSharp4AST.remove_accessor_declaration_return remove_accessor_declaration() throws RecognitionException {
        CSharp4AST.remove_accessor_declaration_return retval = new CSharp4AST.remove_accessor_declaration_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.attributes_return attributes943 =null;

        CSharp4AST.remove_contextual_keyword_return remove_contextual_keyword944 =null;

        CSharp4AST.block_return block945 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1765:2: ( ( attributes )? remove_contextual_keyword block )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1765:4: ( attributes )? remove_contextual_keyword block
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1765:4: ( attributes )?
            int alt214=2;
            int LA214_0 = input.LA(1);

            if ( (LA214_0==OPEN_BRACKET) ) {
                alt214=1;
            }
            switch (alt214) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1765:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_remove_accessor_declaration8555);
                    attributes943=attributes();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, attributes943.getTree());

                    }
                    break;

            }


            pushFollow(FOLLOW_remove_contextual_keyword_in_remove_accessor_declaration8558);
            remove_contextual_keyword944=remove_contextual_keyword();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, remove_contextual_keyword944.getTree());

            pushFollow(FOLLOW_block_in_remove_accessor_declaration8560);
            block945=block();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, block945.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "remove_accessor_declaration"


    public static class indexer_declaration_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "indexer_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1767:1: indexer_declaration : ( attributes )? ( indexer_modifiers )? indexer_declarator OPEN_BRACE accessor_declarations CLOSE_BRACE ;
    public final CSharp4AST.indexer_declaration_return indexer_declaration() throws RecognitionException {
        CSharp4AST.indexer_declaration_return retval = new CSharp4AST.indexer_declaration_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token OPEN_BRACE949=null;
        Token CLOSE_BRACE951=null;
        CSharp4AST.attributes_return attributes946 =null;

        CSharp4AST.indexer_modifiers_return indexer_modifiers947 =null;

        CSharp4AST.indexer_declarator_return indexer_declarator948 =null;

        CSharp4AST.accessor_declarations_return accessor_declarations950 =null;


        Object OPEN_BRACE949_tree=null;
        Object CLOSE_BRACE951_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1768:2: ( ( attributes )? ( indexer_modifiers )? indexer_declarator OPEN_BRACE accessor_declarations CLOSE_BRACE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1768:4: ( attributes )? ( indexer_modifiers )? indexer_declarator OPEN_BRACE accessor_declarations CLOSE_BRACE
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1768:4: ( attributes )?
            int alt215=2;
            int LA215_0 = input.LA(1);

            if ( (LA215_0==OPEN_BRACKET) ) {
                alt215=1;
            }
            switch (alt215) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1768:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_indexer_declaration8571);
                    attributes946=attributes();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, attributes946.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1768:16: ( indexer_modifiers )?
            int alt216=2;
            int LA216_0 = input.LA(1);

            if ( (LA216_0==ABSTRACT||LA216_0==EXTERN||LA216_0==INTERNAL||LA216_0==NEW||LA216_0==OVERRIDE||(LA216_0 >= PRIVATE && LA216_0 <= PUBLIC)||LA216_0==SEALED||LA216_0==UNSAFE||LA216_0==VIRTUAL) ) {
                alt216=1;
            }
            switch (alt216) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1768:16: indexer_modifiers
                    {
                    pushFollow(FOLLOW_indexer_modifiers_in_indexer_declaration8574);
                    indexer_modifiers947=indexer_modifiers();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, indexer_modifiers947.getTree());

                    }
                    break;

            }


            pushFollow(FOLLOW_indexer_declarator_in_indexer_declaration8577);
            indexer_declarator948=indexer_declarator();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, indexer_declarator948.getTree());

            OPEN_BRACE949=(Token)match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_indexer_declaration8579); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            OPEN_BRACE949_tree = 
            (Object)adaptor.create(OPEN_BRACE949)
            ;
            adaptor.addChild(root_0, OPEN_BRACE949_tree);
            }

            pushFollow(FOLLOW_accessor_declarations_in_indexer_declaration8581);
            accessor_declarations950=accessor_declarations();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, accessor_declarations950.getTree());

            CLOSE_BRACE951=(Token)match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_indexer_declaration8583); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            CLOSE_BRACE951_tree = 
            (Object)adaptor.create(CLOSE_BRACE951)
            ;
            adaptor.addChild(root_0, CLOSE_BRACE951_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "indexer_declaration"


    public static class indexer_modifiers_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "indexer_modifiers"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1770:1: indexer_modifiers : indexer_modifier ( indexer_modifier )* ;
    public final CSharp4AST.indexer_modifiers_return indexer_modifiers() throws RecognitionException {
        CSharp4AST.indexer_modifiers_return retval = new CSharp4AST.indexer_modifiers_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.indexer_modifier_return indexer_modifier952 =null;

        CSharp4AST.indexer_modifier_return indexer_modifier953 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1771:2: ( indexer_modifier ( indexer_modifier )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1771:4: indexer_modifier ( indexer_modifier )*
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_indexer_modifier_in_indexer_modifiers8594);
            indexer_modifier952=indexer_modifier();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, indexer_modifier952.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1771:21: ( indexer_modifier )*
            loop217:
            do {
                int alt217=2;
                int LA217_0 = input.LA(1);

                if ( (LA217_0==ABSTRACT||LA217_0==EXTERN||LA217_0==INTERNAL||LA217_0==NEW||LA217_0==OVERRIDE||(LA217_0 >= PRIVATE && LA217_0 <= PUBLIC)||LA217_0==SEALED||LA217_0==UNSAFE||LA217_0==VIRTUAL) ) {
                    alt217=1;
                }


                switch (alt217) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1771:23: indexer_modifier
            	    {
            	    pushFollow(FOLLOW_indexer_modifier_in_indexer_modifiers8598);
            	    indexer_modifier953=indexer_modifier();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, indexer_modifier953.getTree());

            	    }
            	    break;

            	default :
            	    break loop217;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "indexer_modifiers"


    public static class indexer_modifier_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "indexer_modifier"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1773:1: indexer_modifier : ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | VIRTUAL | SEALED | OVERRIDE | ABSTRACT | EXTERN | indexer_modifier_unsafe );
    public final CSharp4AST.indexer_modifier_return indexer_modifier() throws RecognitionException {
        CSharp4AST.indexer_modifier_return retval = new CSharp4AST.indexer_modifier_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token NEW954=null;
        Token PUBLIC955=null;
        Token PROTECTED956=null;
        Token INTERNAL957=null;
        Token PRIVATE958=null;
        Token VIRTUAL959=null;
        Token SEALED960=null;
        Token OVERRIDE961=null;
        Token ABSTRACT962=null;
        Token EXTERN963=null;
        CSharp4AST.indexer_modifier_unsafe_return indexer_modifier_unsafe964 =null;


        Object NEW954_tree=null;
        Object PUBLIC955_tree=null;
        Object PROTECTED956_tree=null;
        Object INTERNAL957_tree=null;
        Object PRIVATE958_tree=null;
        Object VIRTUAL959_tree=null;
        Object SEALED960_tree=null;
        Object OVERRIDE961_tree=null;
        Object ABSTRACT962_tree=null;
        Object EXTERN963_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1774:2: ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | VIRTUAL | SEALED | OVERRIDE | ABSTRACT | EXTERN | indexer_modifier_unsafe )
            int alt218=11;
            switch ( input.LA(1) ) {
            case NEW:
                {
                alt218=1;
                }
                break;
            case PUBLIC:
                {
                alt218=2;
                }
                break;
            case PROTECTED:
                {
                alt218=3;
                }
                break;
            case INTERNAL:
                {
                alt218=4;
                }
                break;
            case PRIVATE:
                {
                alt218=5;
                }
                break;
            case VIRTUAL:
                {
                alt218=6;
                }
                break;
            case SEALED:
                {
                alt218=7;
                }
                break;
            case OVERRIDE:
                {
                alt218=8;
                }
                break;
            case ABSTRACT:
                {
                alt218=9;
                }
                break;
            case EXTERN:
                {
                alt218=10;
                }
                break;
            case UNSAFE:
                {
                alt218=11;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 218, 0, input);

                throw nvae;

            }

            switch (alt218) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1774:4: NEW
                    {
                    root_0 = (Object)adaptor.nil();


                    NEW954=(Token)match(input,NEW,FOLLOW_NEW_in_indexer_modifier8612); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    NEW954_tree = 
                    (Object)adaptor.create(NEW954)
                    ;
                    adaptor.addChild(root_0, NEW954_tree);
                    }

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1775:4: PUBLIC
                    {
                    root_0 = (Object)adaptor.nil();


                    PUBLIC955=(Token)match(input,PUBLIC,FOLLOW_PUBLIC_in_indexer_modifier8617); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PUBLIC955_tree = 
                    (Object)adaptor.create(PUBLIC955)
                    ;
                    adaptor.addChild(root_0, PUBLIC955_tree);
                    }

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1776:4: PROTECTED
                    {
                    root_0 = (Object)adaptor.nil();


                    PROTECTED956=(Token)match(input,PROTECTED,FOLLOW_PROTECTED_in_indexer_modifier8622); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PROTECTED956_tree = 
                    (Object)adaptor.create(PROTECTED956)
                    ;
                    adaptor.addChild(root_0, PROTECTED956_tree);
                    }

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1777:4: INTERNAL
                    {
                    root_0 = (Object)adaptor.nil();


                    INTERNAL957=(Token)match(input,INTERNAL,FOLLOW_INTERNAL_in_indexer_modifier8627); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    INTERNAL957_tree = 
                    (Object)adaptor.create(INTERNAL957)
                    ;
                    adaptor.addChild(root_0, INTERNAL957_tree);
                    }

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1778:4: PRIVATE
                    {
                    root_0 = (Object)adaptor.nil();


                    PRIVATE958=(Token)match(input,PRIVATE,FOLLOW_PRIVATE_in_indexer_modifier8632); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PRIVATE958_tree = 
                    (Object)adaptor.create(PRIVATE958)
                    ;
                    adaptor.addChild(root_0, PRIVATE958_tree);
                    }

                    }
                    break;
                case 6 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1779:4: VIRTUAL
                    {
                    root_0 = (Object)adaptor.nil();


                    VIRTUAL959=(Token)match(input,VIRTUAL,FOLLOW_VIRTUAL_in_indexer_modifier8637); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    VIRTUAL959_tree = 
                    (Object)adaptor.create(VIRTUAL959)
                    ;
                    adaptor.addChild(root_0, VIRTUAL959_tree);
                    }

                    }
                    break;
                case 7 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1780:4: SEALED
                    {
                    root_0 = (Object)adaptor.nil();


                    SEALED960=(Token)match(input,SEALED,FOLLOW_SEALED_in_indexer_modifier8642); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    SEALED960_tree = 
                    (Object)adaptor.create(SEALED960)
                    ;
                    adaptor.addChild(root_0, SEALED960_tree);
                    }

                    }
                    break;
                case 8 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1781:4: OVERRIDE
                    {
                    root_0 = (Object)adaptor.nil();


                    OVERRIDE961=(Token)match(input,OVERRIDE,FOLLOW_OVERRIDE_in_indexer_modifier8647); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OVERRIDE961_tree = 
                    (Object)adaptor.create(OVERRIDE961)
                    ;
                    adaptor.addChild(root_0, OVERRIDE961_tree);
                    }

                    }
                    break;
                case 9 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1782:4: ABSTRACT
                    {
                    root_0 = (Object)adaptor.nil();


                    ABSTRACT962=(Token)match(input,ABSTRACT,FOLLOW_ABSTRACT_in_indexer_modifier8652); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    ABSTRACT962_tree = 
                    (Object)adaptor.create(ABSTRACT962)
                    ;
                    adaptor.addChild(root_0, ABSTRACT962_tree);
                    }

                    }
                    break;
                case 10 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1783:4: EXTERN
                    {
                    root_0 = (Object)adaptor.nil();


                    EXTERN963=(Token)match(input,EXTERN,FOLLOW_EXTERN_in_indexer_modifier8657); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    EXTERN963_tree = 
                    (Object)adaptor.create(EXTERN963)
                    ;
                    adaptor.addChild(root_0, EXTERN963_tree);
                    }

                    }
                    break;
                case 11 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1784:4: indexer_modifier_unsafe
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_indexer_modifier_unsafe_in_indexer_modifier8662);
                    indexer_modifier_unsafe964=indexer_modifier_unsafe();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, indexer_modifier_unsafe964.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "indexer_modifier"


    public static class indexer_declarator_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "indexer_declarator"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1792:1: indexer_declarator : type ( interface_type DOT )? THIS OPEN_BRACKET formal_parameter_list CLOSE_BRACKET ;
    public final CSharp4AST.indexer_declarator_return indexer_declarator() throws RecognitionException {
        CSharp4AST.indexer_declarator_return retval = new CSharp4AST.indexer_declarator_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token DOT967=null;
        Token THIS968=null;
        Token OPEN_BRACKET969=null;
        Token CLOSE_BRACKET971=null;
        CSharp4AST.type_return type965 =null;

        CSharp4AST.interface_type_return interface_type966 =null;

        CSharp4AST.formal_parameter_list_return formal_parameter_list970 =null;


        Object DOT967_tree=null;
        Object THIS968_tree=null;
        Object OPEN_BRACKET969_tree=null;
        Object CLOSE_BRACKET971_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1793:3: ( type ( interface_type DOT )? THIS OPEN_BRACKET formal_parameter_list CLOSE_BRACKET )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1793:5: type ( interface_type DOT )? THIS OPEN_BRACKET formal_parameter_list CLOSE_BRACKET
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_type_in_indexer_declarator8676);
            type965=type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, type965.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1793:10: ( interface_type DOT )?
            int alt219=2;
            int LA219_0 = input.LA(1);

            if ( (LA219_0==IDENTIFIER) ) {
                alt219=1;
            }
            switch (alt219) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1793:11: interface_type DOT
                    {
                    pushFollow(FOLLOW_interface_type_in_indexer_declarator8679);
                    interface_type966=interface_type();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, interface_type966.getTree());

                    DOT967=(Token)match(input,DOT,FOLLOW_DOT_in_indexer_declarator8681); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    DOT967_tree = 
                    (Object)adaptor.create(DOT967)
                    ;
                    adaptor.addChild(root_0, DOT967_tree);
                    }

                    }
                    break;

            }


            THIS968=(Token)match(input,THIS,FOLLOW_THIS_in_indexer_declarator8685); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            THIS968_tree = 
            (Object)adaptor.create(THIS968)
            ;
            adaptor.addChild(root_0, THIS968_tree);
            }

            OPEN_BRACKET969=(Token)match(input,OPEN_BRACKET,FOLLOW_OPEN_BRACKET_in_indexer_declarator8687); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            OPEN_BRACKET969_tree = 
            (Object)adaptor.create(OPEN_BRACKET969)
            ;
            adaptor.addChild(root_0, OPEN_BRACKET969_tree);
            }

            pushFollow(FOLLOW_formal_parameter_list_in_indexer_declarator8689);
            formal_parameter_list970=formal_parameter_list();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, formal_parameter_list970.getTree());

            CLOSE_BRACKET971=(Token)match(input,CLOSE_BRACKET,FOLLOW_CLOSE_BRACKET_in_indexer_declarator8691); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            CLOSE_BRACKET971_tree = 
            (Object)adaptor.create(CLOSE_BRACKET971)
            ;
            adaptor.addChild(root_0, CLOSE_BRACKET971_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "indexer_declarator"


    public static class operator_declaration_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "operator_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1795:1: operator_declaration : ( attributes )? operator_modifiers operator_declarator operator_body ;
    public final CSharp4AST.operator_declaration_return operator_declaration() throws RecognitionException {
        CSharp4AST.operator_declaration_return retval = new CSharp4AST.operator_declaration_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.attributes_return attributes972 =null;

        CSharp4AST.operator_modifiers_return operator_modifiers973 =null;

        CSharp4AST.operator_declarator_return operator_declarator974 =null;

        CSharp4AST.operator_body_return operator_body975 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1796:2: ( ( attributes )? operator_modifiers operator_declarator operator_body )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1796:4: ( attributes )? operator_modifiers operator_declarator operator_body
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1796:4: ( attributes )?
            int alt220=2;
            int LA220_0 = input.LA(1);

            if ( (LA220_0==OPEN_BRACKET) ) {
                alt220=1;
            }
            switch (alt220) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1796:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_operator_declaration8703);
                    attributes972=attributes();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, attributes972.getTree());

                    }
                    break;

            }


            pushFollow(FOLLOW_operator_modifiers_in_operator_declaration8706);
            operator_modifiers973=operator_modifiers();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, operator_modifiers973.getTree());

            pushFollow(FOLLOW_operator_declarator_in_operator_declaration8708);
            operator_declarator974=operator_declarator();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, operator_declarator974.getTree());

            pushFollow(FOLLOW_operator_body_in_operator_declaration8710);
            operator_body975=operator_body();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, operator_body975.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "operator_declaration"


    public static class operator_modifiers_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "operator_modifiers"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1798:1: operator_modifiers : operator_modifier ( operator_modifier )* ;
    public final CSharp4AST.operator_modifiers_return operator_modifiers() throws RecognitionException {
        CSharp4AST.operator_modifiers_return retval = new CSharp4AST.operator_modifiers_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.operator_modifier_return operator_modifier976 =null;

        CSharp4AST.operator_modifier_return operator_modifier977 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1799:2: ( operator_modifier ( operator_modifier )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1799:4: operator_modifier ( operator_modifier )*
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_operator_modifier_in_operator_modifiers8721);
            operator_modifier976=operator_modifier();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, operator_modifier976.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1799:22: ( operator_modifier )*
            loop221:
            do {
                int alt221=2;
                int LA221_0 = input.LA(1);

                if ( (LA221_0==EXTERN||LA221_0==PUBLIC||LA221_0==STATIC||LA221_0==UNSAFE) ) {
                    alt221=1;
                }


                switch (alt221) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1799:24: operator_modifier
            	    {
            	    pushFollow(FOLLOW_operator_modifier_in_operator_modifiers8725);
            	    operator_modifier977=operator_modifier();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, operator_modifier977.getTree());

            	    }
            	    break;

            	default :
            	    break loop221;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "operator_modifiers"


    public static class operator_modifier_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "operator_modifier"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1801:1: operator_modifier : ( PUBLIC | STATIC | EXTERN | operator_modifier_unsafe );
    public final CSharp4AST.operator_modifier_return operator_modifier() throws RecognitionException {
        CSharp4AST.operator_modifier_return retval = new CSharp4AST.operator_modifier_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token PUBLIC978=null;
        Token STATIC979=null;
        Token EXTERN980=null;
        CSharp4AST.operator_modifier_unsafe_return operator_modifier_unsafe981 =null;


        Object PUBLIC978_tree=null;
        Object STATIC979_tree=null;
        Object EXTERN980_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1802:2: ( PUBLIC | STATIC | EXTERN | operator_modifier_unsafe )
            int alt222=4;
            switch ( input.LA(1) ) {
            case PUBLIC:
                {
                alt222=1;
                }
                break;
            case STATIC:
                {
                alt222=2;
                }
                break;
            case EXTERN:
                {
                alt222=3;
                }
                break;
            case UNSAFE:
                {
                alt222=4;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 222, 0, input);

                throw nvae;

            }

            switch (alt222) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1802:4: PUBLIC
                    {
                    root_0 = (Object)adaptor.nil();


                    PUBLIC978=(Token)match(input,PUBLIC,FOLLOW_PUBLIC_in_operator_modifier8739); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PUBLIC978_tree = 
                    (Object)adaptor.create(PUBLIC978)
                    ;
                    adaptor.addChild(root_0, PUBLIC978_tree);
                    }

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1803:4: STATIC
                    {
                    root_0 = (Object)adaptor.nil();


                    STATIC979=(Token)match(input,STATIC,FOLLOW_STATIC_in_operator_modifier8744); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    STATIC979_tree = 
                    (Object)adaptor.create(STATIC979)
                    ;
                    adaptor.addChild(root_0, STATIC979_tree);
                    }

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1804:4: EXTERN
                    {
                    root_0 = (Object)adaptor.nil();


                    EXTERN980=(Token)match(input,EXTERN,FOLLOW_EXTERN_in_operator_modifier8749); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    EXTERN980_tree = 
                    (Object)adaptor.create(EXTERN980)
                    ;
                    adaptor.addChild(root_0, EXTERN980_tree);
                    }

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1805:4: operator_modifier_unsafe
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_operator_modifier_unsafe_in_operator_modifier8754);
                    operator_modifier_unsafe981=operator_modifier_unsafe();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, operator_modifier_unsafe981.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "operator_modifier"


    public static class operator_declarator_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "operator_declarator"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1814:1: operator_declarator : ( ( unary_operator_declarator )=> unary_operator_declarator | binary_operator_declarator | conversion_operator_declarator );
    public final CSharp4AST.operator_declarator_return operator_declarator() throws RecognitionException {
        CSharp4AST.operator_declarator_return retval = new CSharp4AST.operator_declarator_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.unary_operator_declarator_return unary_operator_declarator982 =null;

        CSharp4AST.binary_operator_declarator_return binary_operator_declarator983 =null;

        CSharp4AST.conversion_operator_declarator_return conversion_operator_declarator984 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1815:3: ( ( unary_operator_declarator )=> unary_operator_declarator | binary_operator_declarator | conversion_operator_declarator )
            int alt223=3;
            switch ( input.LA(1) ) {
            case BYTE:
            case CHAR:
            case INT:
            case LONG:
            case SBYTE:
            case SHORT:
            case UINT:
            case ULONG:
            case USHORT:
                {
                int LA223_1 = input.LA(2);

                if ( (synpred26_CSharp4AST()) ) {
                    alt223=1;
                }
                else if ( (true) ) {
                    alt223=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 223, 1, input);

                    throw nvae;

                }
                }
                break;
            case DOUBLE:
            case FLOAT:
                {
                int LA223_2 = input.LA(2);

                if ( (synpred26_CSharp4AST()) ) {
                    alt223=1;
                }
                else if ( (true) ) {
                    alt223=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 223, 2, input);

                    throw nvae;

                }
                }
                break;
            case DECIMAL:
                {
                int LA223_3 = input.LA(2);

                if ( (synpred26_CSharp4AST()) ) {
                    alt223=1;
                }
                else if ( (true) ) {
                    alt223=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 223, 3, input);

                    throw nvae;

                }
                }
                break;
            case BOOL:
                {
                int LA223_4 = input.LA(2);

                if ( (synpred26_CSharp4AST()) ) {
                    alt223=1;
                }
                else if ( (true) ) {
                    alt223=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 223, 4, input);

                    throw nvae;

                }
                }
                break;
            case IDENTIFIER:
                {
                int LA223_5 = input.LA(2);

                if ( (synpred26_CSharp4AST()) ) {
                    alt223=1;
                }
                else if ( (true) ) {
                    alt223=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 223, 5, input);

                    throw nvae;

                }
                }
                break;
            case OBJECT:
                {
                int LA223_6 = input.LA(2);

                if ( (synpred26_CSharp4AST()) ) {
                    alt223=1;
                }
                else if ( (true) ) {
                    alt223=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 223, 6, input);

                    throw nvae;

                }
                }
                break;
            case STRING:
                {
                int LA223_7 = input.LA(2);

                if ( (synpred26_CSharp4AST()) ) {
                    alt223=1;
                }
                else if ( (true) ) {
                    alt223=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 223, 7, input);

                    throw nvae;

                }
                }
                break;
            case VOID:
                {
                int LA223_8 = input.LA(2);

                if ( (synpred26_CSharp4AST()) ) {
                    alt223=1;
                }
                else if ( (true) ) {
                    alt223=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 223, 8, input);

                    throw nvae;

                }
                }
                break;
            case EXPLICIT:
            case IMPLICIT:
                {
                alt223=3;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 223, 0, input);

                throw nvae;

            }

            switch (alt223) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1815:5: ( unary_operator_declarator )=> unary_operator_declarator
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_unary_operator_declarator_in_operator_declarator8774);
                    unary_operator_declarator982=unary_operator_declarator();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, unary_operator_declarator982.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1816:5: binary_operator_declarator
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_binary_operator_declarator_in_operator_declarator8780);
                    binary_operator_declarator983=binary_operator_declarator();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, binary_operator_declarator983.getTree());

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1817:5: conversion_operator_declarator
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_conversion_operator_declarator_in_operator_declarator8786);
                    conversion_operator_declarator984=conversion_operator_declarator();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, conversion_operator_declarator984.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "operator_declarator"


    public static class unary_operator_declarator_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "unary_operator_declarator"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1819:1: unary_operator_declarator : type OPERATOR overloadable_unary_operator OPEN_PARENS type IDENTIFIER CLOSE_PARENS ;
    public final CSharp4AST.unary_operator_declarator_return unary_operator_declarator() throws RecognitionException {
        CSharp4AST.unary_operator_declarator_return retval = new CSharp4AST.unary_operator_declarator_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token OPERATOR986=null;
        Token OPEN_PARENS988=null;
        Token IDENTIFIER990=null;
        Token CLOSE_PARENS991=null;
        CSharp4AST.type_return type985 =null;

        CSharp4AST.overloadable_unary_operator_return overloadable_unary_operator987 =null;

        CSharp4AST.type_return type989 =null;


        Object OPERATOR986_tree=null;
        Object OPEN_PARENS988_tree=null;
        Object IDENTIFIER990_tree=null;
        Object CLOSE_PARENS991_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1820:2: ( type OPERATOR overloadable_unary_operator OPEN_PARENS type IDENTIFIER CLOSE_PARENS )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1820:4: type OPERATOR overloadable_unary_operator OPEN_PARENS type IDENTIFIER CLOSE_PARENS
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_type_in_unary_operator_declarator8798);
            type985=type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, type985.getTree());

            OPERATOR986=(Token)match(input,OPERATOR,FOLLOW_OPERATOR_in_unary_operator_declarator8800); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            OPERATOR986_tree = 
            (Object)adaptor.create(OPERATOR986)
            ;
            adaptor.addChild(root_0, OPERATOR986_tree);
            }

            pushFollow(FOLLOW_overloadable_unary_operator_in_unary_operator_declarator8802);
            overloadable_unary_operator987=overloadable_unary_operator();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, overloadable_unary_operator987.getTree());

            OPEN_PARENS988=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_unary_operator_declarator8804); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            OPEN_PARENS988_tree = 
            (Object)adaptor.create(OPEN_PARENS988)
            ;
            adaptor.addChild(root_0, OPEN_PARENS988_tree);
            }

            pushFollow(FOLLOW_type_in_unary_operator_declarator8806);
            type989=type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, type989.getTree());

            IDENTIFIER990=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_unary_operator_declarator8808); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER990_tree = 
            (Object)adaptor.create(IDENTIFIER990)
            ;
            adaptor.addChild(root_0, IDENTIFIER990_tree);
            }

            CLOSE_PARENS991=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_unary_operator_declarator8810); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            CLOSE_PARENS991_tree = 
            (Object)adaptor.create(CLOSE_PARENS991)
            ;
            adaptor.addChild(root_0, CLOSE_PARENS991_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "unary_operator_declarator"


    public static class overloadable_unary_operator_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "overloadable_unary_operator"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1822:1: overloadable_unary_operator : ( PLUS | MINUS | BANG | TILDE | OP_INC | OP_DEC | TRUE | FALSE );
    public final CSharp4AST.overloadable_unary_operator_return overloadable_unary_operator() throws RecognitionException {
        CSharp4AST.overloadable_unary_operator_return retval = new CSharp4AST.overloadable_unary_operator_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token set992=null;

        Object set992_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1823:2: ( PLUS | MINUS | BANG | TILDE | OP_INC | OP_DEC | TRUE | FALSE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:
            {
            root_0 = (Object)adaptor.nil();


            set992=(Token)input.LT(1);

            if ( input.LA(1)==BANG||input.LA(1)==FALSE||input.LA(1)==MINUS||input.LA(1)==OP_DEC||input.LA(1)==OP_INC||input.LA(1)==PLUS||(input.LA(1) >= TILDE && input.LA(1) <= TRUE) ) {
                input.consume();
                if ( state.backtracking==0 ) adaptor.addChild(root_0, 
                (Object)adaptor.create(set992)
                );
                state.errorRecovery=false;
                state.failed=false;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                MismatchedSetException mse = new MismatchedSetException(null,input);
                throw mse;
            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "overloadable_unary_operator"


    public static class binary_operator_declarator_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "binary_operator_declarator"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1832:1: binary_operator_declarator : type OPERATOR overloadable_binary_operator OPEN_PARENS type IDENTIFIER COMMA type IDENTIFIER CLOSE_PARENS ;
    public final CSharp4AST.binary_operator_declarator_return binary_operator_declarator() throws RecognitionException {
        CSharp4AST.binary_operator_declarator_return retval = new CSharp4AST.binary_operator_declarator_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token OPERATOR994=null;
        Token OPEN_PARENS996=null;
        Token IDENTIFIER998=null;
        Token COMMA999=null;
        Token IDENTIFIER1001=null;
        Token CLOSE_PARENS1002=null;
        CSharp4AST.type_return type993 =null;

        CSharp4AST.overloadable_binary_operator_return overloadable_binary_operator995 =null;

        CSharp4AST.type_return type997 =null;

        CSharp4AST.type_return type1000 =null;


        Object OPERATOR994_tree=null;
        Object OPEN_PARENS996_tree=null;
        Object IDENTIFIER998_tree=null;
        Object COMMA999_tree=null;
        Object IDENTIFIER1001_tree=null;
        Object CLOSE_PARENS1002_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1833:2: ( type OPERATOR overloadable_binary_operator OPEN_PARENS type IDENTIFIER COMMA type IDENTIFIER CLOSE_PARENS )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1833:4: type OPERATOR overloadable_binary_operator OPEN_PARENS type IDENTIFIER COMMA type IDENTIFIER CLOSE_PARENS
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_type_in_binary_operator_declarator8867);
            type993=type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, type993.getTree());

            OPERATOR994=(Token)match(input,OPERATOR,FOLLOW_OPERATOR_in_binary_operator_declarator8869); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            OPERATOR994_tree = 
            (Object)adaptor.create(OPERATOR994)
            ;
            adaptor.addChild(root_0, OPERATOR994_tree);
            }

            pushFollow(FOLLOW_overloadable_binary_operator_in_binary_operator_declarator8871);
            overloadable_binary_operator995=overloadable_binary_operator();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, overloadable_binary_operator995.getTree());

            OPEN_PARENS996=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_binary_operator_declarator8873); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            OPEN_PARENS996_tree = 
            (Object)adaptor.create(OPEN_PARENS996)
            ;
            adaptor.addChild(root_0, OPEN_PARENS996_tree);
            }

            pushFollow(FOLLOW_type_in_binary_operator_declarator8875);
            type997=type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, type997.getTree());

            IDENTIFIER998=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_binary_operator_declarator8877); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER998_tree = 
            (Object)adaptor.create(IDENTIFIER998)
            ;
            adaptor.addChild(root_0, IDENTIFIER998_tree);
            }

            COMMA999=(Token)match(input,COMMA,FOLLOW_COMMA_in_binary_operator_declarator8879); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            COMMA999_tree = 
            (Object)adaptor.create(COMMA999)
            ;
            adaptor.addChild(root_0, COMMA999_tree);
            }

            pushFollow(FOLLOW_type_in_binary_operator_declarator8881);
            type1000=type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, type1000.getTree());

            IDENTIFIER1001=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_binary_operator_declarator8883); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1001_tree = 
            (Object)adaptor.create(IDENTIFIER1001)
            ;
            adaptor.addChild(root_0, IDENTIFIER1001_tree);
            }

            CLOSE_PARENS1002=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_binary_operator_declarator8885); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            CLOSE_PARENS1002_tree = 
            (Object)adaptor.create(CLOSE_PARENS1002)
            ;
            adaptor.addChild(root_0, CLOSE_PARENS1002_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "binary_operator_declarator"


    public static class overloadable_binary_operator_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "overloadable_binary_operator"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1835:1: overloadable_binary_operator : ( PLUS | MINUS | STAR | DIV | PERCENT | AMP | BITWISE_OR | CARET | OP_LEFT_SHIFT | right_shift | OP_EQ | OP_NE | GT | LT | OP_GE | OP_LE );
    public final CSharp4AST.overloadable_binary_operator_return overloadable_binary_operator() throws RecognitionException {
        CSharp4AST.overloadable_binary_operator_return retval = new CSharp4AST.overloadable_binary_operator_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token PLUS1003=null;
        Token MINUS1004=null;
        Token STAR1005=null;
        Token DIV1006=null;
        Token PERCENT1007=null;
        Token AMP1008=null;
        Token BITWISE_OR1009=null;
        Token CARET1010=null;
        Token OP_LEFT_SHIFT1011=null;
        Token OP_EQ1013=null;
        Token OP_NE1014=null;
        Token GT1015=null;
        Token LT1016=null;
        Token OP_GE1017=null;
        Token OP_LE1018=null;
        CSharp4AST.right_shift_return right_shift1012 =null;


        Object PLUS1003_tree=null;
        Object MINUS1004_tree=null;
        Object STAR1005_tree=null;
        Object DIV1006_tree=null;
        Object PERCENT1007_tree=null;
        Object AMP1008_tree=null;
        Object BITWISE_OR1009_tree=null;
        Object CARET1010_tree=null;
        Object OP_LEFT_SHIFT1011_tree=null;
        Object OP_EQ1013_tree=null;
        Object OP_NE1014_tree=null;
        Object GT1015_tree=null;
        Object LT1016_tree=null;
        Object OP_GE1017_tree=null;
        Object OP_LE1018_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1836:2: ( PLUS | MINUS | STAR | DIV | PERCENT | AMP | BITWISE_OR | CARET | OP_LEFT_SHIFT | right_shift | OP_EQ | OP_NE | GT | LT | OP_GE | OP_LE )
            int alt224=16;
            switch ( input.LA(1) ) {
            case PLUS:
                {
                alt224=1;
                }
                break;
            case MINUS:
                {
                alt224=2;
                }
                break;
            case STAR:
                {
                alt224=3;
                }
                break;
            case DIV:
                {
                alt224=4;
                }
                break;
            case PERCENT:
                {
                alt224=5;
                }
                break;
            case AMP:
                {
                alt224=6;
                }
                break;
            case BITWISE_OR:
                {
                alt224=7;
                }
                break;
            case CARET:
                {
                alt224=8;
                }
                break;
            case OP_LEFT_SHIFT:
                {
                alt224=9;
                }
                break;
            case GT:
                {
                int LA224_10 = input.LA(2);

                if ( (LA224_10==GT) ) {
                    alt224=10;
                }
                else if ( (LA224_10==OPEN_PARENS) ) {
                    alt224=13;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 224, 10, input);

                    throw nvae;

                }
                }
                break;
            case OP_EQ:
                {
                alt224=11;
                }
                break;
            case OP_NE:
                {
                alt224=12;
                }
                break;
            case LT:
                {
                alt224=14;
                }
                break;
            case OP_GE:
                {
                alt224=15;
                }
                break;
            case OP_LE:
                {
                alt224=16;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 224, 0, input);

                throw nvae;

            }

            switch (alt224) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1836:4: PLUS
                    {
                    root_0 = (Object)adaptor.nil();


                    PLUS1003=(Token)match(input,PLUS,FOLLOW_PLUS_in_overloadable_binary_operator8896); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PLUS1003_tree = 
                    (Object)adaptor.create(PLUS1003)
                    ;
                    adaptor.addChild(root_0, PLUS1003_tree);
                    }

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1837:4: MINUS
                    {
                    root_0 = (Object)adaptor.nil();


                    MINUS1004=(Token)match(input,MINUS,FOLLOW_MINUS_in_overloadable_binary_operator8901); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    MINUS1004_tree = 
                    (Object)adaptor.create(MINUS1004)
                    ;
                    adaptor.addChild(root_0, MINUS1004_tree);
                    }

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1838:4: STAR
                    {
                    root_0 = (Object)adaptor.nil();


                    STAR1005=(Token)match(input,STAR,FOLLOW_STAR_in_overloadable_binary_operator8906); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    STAR1005_tree = 
                    (Object)adaptor.create(STAR1005)
                    ;
                    adaptor.addChild(root_0, STAR1005_tree);
                    }

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1839:4: DIV
                    {
                    root_0 = (Object)adaptor.nil();


                    DIV1006=(Token)match(input,DIV,FOLLOW_DIV_in_overloadable_binary_operator8911); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    DIV1006_tree = 
                    (Object)adaptor.create(DIV1006)
                    ;
                    adaptor.addChild(root_0, DIV1006_tree);
                    }

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1840:4: PERCENT
                    {
                    root_0 = (Object)adaptor.nil();


                    PERCENT1007=(Token)match(input,PERCENT,FOLLOW_PERCENT_in_overloadable_binary_operator8916); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PERCENT1007_tree = 
                    (Object)adaptor.create(PERCENT1007)
                    ;
                    adaptor.addChild(root_0, PERCENT1007_tree);
                    }

                    }
                    break;
                case 6 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1841:4: AMP
                    {
                    root_0 = (Object)adaptor.nil();


                    AMP1008=(Token)match(input,AMP,FOLLOW_AMP_in_overloadable_binary_operator8921); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    AMP1008_tree = 
                    (Object)adaptor.create(AMP1008)
                    ;
                    adaptor.addChild(root_0, AMP1008_tree);
                    }

                    }
                    break;
                case 7 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1842:4: BITWISE_OR
                    {
                    root_0 = (Object)adaptor.nil();


                    BITWISE_OR1009=(Token)match(input,BITWISE_OR,FOLLOW_BITWISE_OR_in_overloadable_binary_operator8926); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    BITWISE_OR1009_tree = 
                    (Object)adaptor.create(BITWISE_OR1009)
                    ;
                    adaptor.addChild(root_0, BITWISE_OR1009_tree);
                    }

                    }
                    break;
                case 8 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1843:4: CARET
                    {
                    root_0 = (Object)adaptor.nil();


                    CARET1010=(Token)match(input,CARET,FOLLOW_CARET_in_overloadable_binary_operator8931); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    CARET1010_tree = 
                    (Object)adaptor.create(CARET1010)
                    ;
                    adaptor.addChild(root_0, CARET1010_tree);
                    }

                    }
                    break;
                case 9 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1844:4: OP_LEFT_SHIFT
                    {
                    root_0 = (Object)adaptor.nil();


                    OP_LEFT_SHIFT1011=(Token)match(input,OP_LEFT_SHIFT,FOLLOW_OP_LEFT_SHIFT_in_overloadable_binary_operator8936); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OP_LEFT_SHIFT1011_tree = 
                    (Object)adaptor.create(OP_LEFT_SHIFT1011)
                    ;
                    adaptor.addChild(root_0, OP_LEFT_SHIFT1011_tree);
                    }

                    }
                    break;
                case 10 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1845:4: right_shift
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_right_shift_in_overloadable_binary_operator8941);
                    right_shift1012=right_shift();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, right_shift1012.getTree());

                    }
                    break;
                case 11 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1846:4: OP_EQ
                    {
                    root_0 = (Object)adaptor.nil();


                    OP_EQ1013=(Token)match(input,OP_EQ,FOLLOW_OP_EQ_in_overloadable_binary_operator8946); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OP_EQ1013_tree = 
                    (Object)adaptor.create(OP_EQ1013)
                    ;
                    adaptor.addChild(root_0, OP_EQ1013_tree);
                    }

                    }
                    break;
                case 12 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1847:4: OP_NE
                    {
                    root_0 = (Object)adaptor.nil();


                    OP_NE1014=(Token)match(input,OP_NE,FOLLOW_OP_NE_in_overloadable_binary_operator8951); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OP_NE1014_tree = 
                    (Object)adaptor.create(OP_NE1014)
                    ;
                    adaptor.addChild(root_0, OP_NE1014_tree);
                    }

                    }
                    break;
                case 13 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1848:4: GT
                    {
                    root_0 = (Object)adaptor.nil();


                    GT1015=(Token)match(input,GT,FOLLOW_GT_in_overloadable_binary_operator8956); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    GT1015_tree = 
                    (Object)adaptor.create(GT1015)
                    ;
                    adaptor.addChild(root_0, GT1015_tree);
                    }

                    }
                    break;
                case 14 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1849:4: LT
                    {
                    root_0 = (Object)adaptor.nil();


                    LT1016=(Token)match(input,LT,FOLLOW_LT_in_overloadable_binary_operator8961); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    LT1016_tree = 
                    (Object)adaptor.create(LT1016)
                    ;
                    adaptor.addChild(root_0, LT1016_tree);
                    }

                    }
                    break;
                case 15 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1850:4: OP_GE
                    {
                    root_0 = (Object)adaptor.nil();


                    OP_GE1017=(Token)match(input,OP_GE,FOLLOW_OP_GE_in_overloadable_binary_operator8966); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OP_GE1017_tree = 
                    (Object)adaptor.create(OP_GE1017)
                    ;
                    adaptor.addChild(root_0, OP_GE1017_tree);
                    }

                    }
                    break;
                case 16 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1851:4: OP_LE
                    {
                    root_0 = (Object)adaptor.nil();


                    OP_LE1018=(Token)match(input,OP_LE,FOLLOW_OP_LE_in_overloadable_binary_operator8971); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OP_LE1018_tree = 
                    (Object)adaptor.create(OP_LE1018)
                    ;
                    adaptor.addChild(root_0, OP_LE1018_tree);
                    }

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "overloadable_binary_operator"


    public static class overloadable_operator_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "overloadable_operator"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1855:1: overloadable_operator : ( PLUS | MINUS | BANG | TILDE | OP_INC | OP_DEC | TRUE | FALSE | STAR | DIV | PERCENT | AMP | BITWISE_OR | CARET | OP_LEFT_SHIFT | right_shift | OP_EQ | OP_NE | GT | LT | OP_GE | OP_LE );
    public final CSharp4AST.overloadable_operator_return overloadable_operator() throws RecognitionException {
        CSharp4AST.overloadable_operator_return retval = new CSharp4AST.overloadable_operator_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token PLUS1019=null;
        Token MINUS1020=null;
        Token BANG1021=null;
        Token TILDE1022=null;
        Token OP_INC1023=null;
        Token OP_DEC1024=null;
        Token TRUE1025=null;
        Token FALSE1026=null;
        Token STAR1027=null;
        Token DIV1028=null;
        Token PERCENT1029=null;
        Token AMP1030=null;
        Token BITWISE_OR1031=null;
        Token CARET1032=null;
        Token OP_LEFT_SHIFT1033=null;
        Token OP_EQ1035=null;
        Token OP_NE1036=null;
        Token GT1037=null;
        Token LT1038=null;
        Token OP_GE1039=null;
        Token OP_LE1040=null;
        CSharp4AST.right_shift_return right_shift1034 =null;


        Object PLUS1019_tree=null;
        Object MINUS1020_tree=null;
        Object BANG1021_tree=null;
        Object TILDE1022_tree=null;
        Object OP_INC1023_tree=null;
        Object OP_DEC1024_tree=null;
        Object TRUE1025_tree=null;
        Object FALSE1026_tree=null;
        Object STAR1027_tree=null;
        Object DIV1028_tree=null;
        Object PERCENT1029_tree=null;
        Object AMP1030_tree=null;
        Object BITWISE_OR1031_tree=null;
        Object CARET1032_tree=null;
        Object OP_LEFT_SHIFT1033_tree=null;
        Object OP_EQ1035_tree=null;
        Object OP_NE1036_tree=null;
        Object GT1037_tree=null;
        Object LT1038_tree=null;
        Object OP_GE1039_tree=null;
        Object OP_LE1040_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1856:3: ( PLUS | MINUS | BANG | TILDE | OP_INC | OP_DEC | TRUE | FALSE | STAR | DIV | PERCENT | AMP | BITWISE_OR | CARET | OP_LEFT_SHIFT | right_shift | OP_EQ | OP_NE | GT | LT | OP_GE | OP_LE )
            int alt225=22;
            switch ( input.LA(1) ) {
            case PLUS:
                {
                alt225=1;
                }
                break;
            case MINUS:
                {
                alt225=2;
                }
                break;
            case BANG:
                {
                alt225=3;
                }
                break;
            case TILDE:
                {
                alt225=4;
                }
                break;
            case OP_INC:
                {
                alt225=5;
                }
                break;
            case OP_DEC:
                {
                alt225=6;
                }
                break;
            case TRUE:
                {
                alt225=7;
                }
                break;
            case FALSE:
                {
                alt225=8;
                }
                break;
            case STAR:
                {
                alt225=9;
                }
                break;
            case DIV:
                {
                alt225=10;
                }
                break;
            case PERCENT:
                {
                alt225=11;
                }
                break;
            case AMP:
                {
                alt225=12;
                }
                break;
            case BITWISE_OR:
                {
                alt225=13;
                }
                break;
            case CARET:
                {
                alt225=14;
                }
                break;
            case OP_LEFT_SHIFT:
                {
                alt225=15;
                }
                break;
            case GT:
                {
                int LA225_16 = input.LA(2);

                if ( (LA225_16==GT) ) {
                    alt225=16;
                }
                else if ( (LA225_16==OPEN_PARENS) ) {
                    alt225=19;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 225, 16, input);

                    throw nvae;

                }
                }
                break;
            case OP_EQ:
                {
                alt225=17;
                }
                break;
            case OP_NE:
                {
                alt225=18;
                }
                break;
            case LT:
                {
                alt225=20;
                }
                break;
            case OP_GE:
                {
                alt225=21;
                }
                break;
            case OP_LE:
                {
                alt225=22;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 225, 0, input);

                throw nvae;

            }

            switch (alt225) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1856:5: PLUS
                    {
                    root_0 = (Object)adaptor.nil();


                    PLUS1019=(Token)match(input,PLUS,FOLLOW_PLUS_in_overloadable_operator8985); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PLUS1019_tree = 
                    (Object)adaptor.create(PLUS1019)
                    ;
                    adaptor.addChild(root_0, PLUS1019_tree);
                    }

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1857:5: MINUS
                    {
                    root_0 = (Object)adaptor.nil();


                    MINUS1020=(Token)match(input,MINUS,FOLLOW_MINUS_in_overloadable_operator8991); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    MINUS1020_tree = 
                    (Object)adaptor.create(MINUS1020)
                    ;
                    adaptor.addChild(root_0, MINUS1020_tree);
                    }

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1858:5: BANG
                    {
                    root_0 = (Object)adaptor.nil();


                    BANG1021=(Token)match(input,BANG,FOLLOW_BANG_in_overloadable_operator8997); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    BANG1021_tree = 
                    (Object)adaptor.create(BANG1021)
                    ;
                    adaptor.addChild(root_0, BANG1021_tree);
                    }

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1859:5: TILDE
                    {
                    root_0 = (Object)adaptor.nil();


                    TILDE1022=(Token)match(input,TILDE,FOLLOW_TILDE_in_overloadable_operator9003); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    TILDE1022_tree = 
                    (Object)adaptor.create(TILDE1022)
                    ;
                    adaptor.addChild(root_0, TILDE1022_tree);
                    }

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1860:5: OP_INC
                    {
                    root_0 = (Object)adaptor.nil();


                    OP_INC1023=(Token)match(input,OP_INC,FOLLOW_OP_INC_in_overloadable_operator9009); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OP_INC1023_tree = 
                    (Object)adaptor.create(OP_INC1023)
                    ;
                    adaptor.addChild(root_0, OP_INC1023_tree);
                    }

                    }
                    break;
                case 6 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1861:5: OP_DEC
                    {
                    root_0 = (Object)adaptor.nil();


                    OP_DEC1024=(Token)match(input,OP_DEC,FOLLOW_OP_DEC_in_overloadable_operator9015); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OP_DEC1024_tree = 
                    (Object)adaptor.create(OP_DEC1024)
                    ;
                    adaptor.addChild(root_0, OP_DEC1024_tree);
                    }

                    }
                    break;
                case 7 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1862:5: TRUE
                    {
                    root_0 = (Object)adaptor.nil();


                    TRUE1025=(Token)match(input,TRUE,FOLLOW_TRUE_in_overloadable_operator9021); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    TRUE1025_tree = 
                    (Object)adaptor.create(TRUE1025)
                    ;
                    adaptor.addChild(root_0, TRUE1025_tree);
                    }

                    }
                    break;
                case 8 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1863:5: FALSE
                    {
                    root_0 = (Object)adaptor.nil();


                    FALSE1026=(Token)match(input,FALSE,FOLLOW_FALSE_in_overloadable_operator9027); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    FALSE1026_tree = 
                    (Object)adaptor.create(FALSE1026)
                    ;
                    adaptor.addChild(root_0, FALSE1026_tree);
                    }

                    }
                    break;
                case 9 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1864:5: STAR
                    {
                    root_0 = (Object)adaptor.nil();


                    STAR1027=(Token)match(input,STAR,FOLLOW_STAR_in_overloadable_operator9033); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    STAR1027_tree = 
                    (Object)adaptor.create(STAR1027)
                    ;
                    adaptor.addChild(root_0, STAR1027_tree);
                    }

                    }
                    break;
                case 10 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1865:5: DIV
                    {
                    root_0 = (Object)adaptor.nil();


                    DIV1028=(Token)match(input,DIV,FOLLOW_DIV_in_overloadable_operator9039); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    DIV1028_tree = 
                    (Object)adaptor.create(DIV1028)
                    ;
                    adaptor.addChild(root_0, DIV1028_tree);
                    }

                    }
                    break;
                case 11 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1866:5: PERCENT
                    {
                    root_0 = (Object)adaptor.nil();


                    PERCENT1029=(Token)match(input,PERCENT,FOLLOW_PERCENT_in_overloadable_operator9045); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PERCENT1029_tree = 
                    (Object)adaptor.create(PERCENT1029)
                    ;
                    adaptor.addChild(root_0, PERCENT1029_tree);
                    }

                    }
                    break;
                case 12 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1867:5: AMP
                    {
                    root_0 = (Object)adaptor.nil();


                    AMP1030=(Token)match(input,AMP,FOLLOW_AMP_in_overloadable_operator9051); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    AMP1030_tree = 
                    (Object)adaptor.create(AMP1030)
                    ;
                    adaptor.addChild(root_0, AMP1030_tree);
                    }

                    }
                    break;
                case 13 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1868:5: BITWISE_OR
                    {
                    root_0 = (Object)adaptor.nil();


                    BITWISE_OR1031=(Token)match(input,BITWISE_OR,FOLLOW_BITWISE_OR_in_overloadable_operator9057); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    BITWISE_OR1031_tree = 
                    (Object)adaptor.create(BITWISE_OR1031)
                    ;
                    adaptor.addChild(root_0, BITWISE_OR1031_tree);
                    }

                    }
                    break;
                case 14 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1869:5: CARET
                    {
                    root_0 = (Object)adaptor.nil();


                    CARET1032=(Token)match(input,CARET,FOLLOW_CARET_in_overloadable_operator9063); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    CARET1032_tree = 
                    (Object)adaptor.create(CARET1032)
                    ;
                    adaptor.addChild(root_0, CARET1032_tree);
                    }

                    }
                    break;
                case 15 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1870:5: OP_LEFT_SHIFT
                    {
                    root_0 = (Object)adaptor.nil();


                    OP_LEFT_SHIFT1033=(Token)match(input,OP_LEFT_SHIFT,FOLLOW_OP_LEFT_SHIFT_in_overloadable_operator9069); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OP_LEFT_SHIFT1033_tree = 
                    (Object)adaptor.create(OP_LEFT_SHIFT1033)
                    ;
                    adaptor.addChild(root_0, OP_LEFT_SHIFT1033_tree);
                    }

                    }
                    break;
                case 16 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1871:5: right_shift
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_right_shift_in_overloadable_operator9075);
                    right_shift1034=right_shift();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, right_shift1034.getTree());

                    }
                    break;
                case 17 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1872:5: OP_EQ
                    {
                    root_0 = (Object)adaptor.nil();


                    OP_EQ1035=(Token)match(input,OP_EQ,FOLLOW_OP_EQ_in_overloadable_operator9081); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OP_EQ1035_tree = 
                    (Object)adaptor.create(OP_EQ1035)
                    ;
                    adaptor.addChild(root_0, OP_EQ1035_tree);
                    }

                    }
                    break;
                case 18 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1873:5: OP_NE
                    {
                    root_0 = (Object)adaptor.nil();


                    OP_NE1036=(Token)match(input,OP_NE,FOLLOW_OP_NE_in_overloadable_operator9087); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OP_NE1036_tree = 
                    (Object)adaptor.create(OP_NE1036)
                    ;
                    adaptor.addChild(root_0, OP_NE1036_tree);
                    }

                    }
                    break;
                case 19 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1874:5: GT
                    {
                    root_0 = (Object)adaptor.nil();


                    GT1037=(Token)match(input,GT,FOLLOW_GT_in_overloadable_operator9093); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    GT1037_tree = 
                    (Object)adaptor.create(GT1037)
                    ;
                    adaptor.addChild(root_0, GT1037_tree);
                    }

                    }
                    break;
                case 20 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1875:5: LT
                    {
                    root_0 = (Object)adaptor.nil();


                    LT1038=(Token)match(input,LT,FOLLOW_LT_in_overloadable_operator9099); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    LT1038_tree = 
                    (Object)adaptor.create(LT1038)
                    ;
                    adaptor.addChild(root_0, LT1038_tree);
                    }

                    }
                    break;
                case 21 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1876:5: OP_GE
                    {
                    root_0 = (Object)adaptor.nil();


                    OP_GE1039=(Token)match(input,OP_GE,FOLLOW_OP_GE_in_overloadable_operator9105); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OP_GE1039_tree = 
                    (Object)adaptor.create(OP_GE1039)
                    ;
                    adaptor.addChild(root_0, OP_GE1039_tree);
                    }

                    }
                    break;
                case 22 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1877:5: OP_LE
                    {
                    root_0 = (Object)adaptor.nil();


                    OP_LE1040=(Token)match(input,OP_LE,FOLLOW_OP_LE_in_overloadable_operator9111); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OP_LE1040_tree = 
                    (Object)adaptor.create(OP_LE1040)
                    ;
                    adaptor.addChild(root_0, OP_LE1040_tree);
                    }

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "overloadable_operator"


    public static class conversion_operator_declarator_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "conversion_operator_declarator"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1880:1: conversion_operator_declarator : ( IMPLICIT ^ OPERATOR type OPEN_PARENS type IDENTIFIER CLOSE_PARENS | EXPLICIT ^ OPERATOR type OPEN_PARENS type IDENTIFIER CLOSE_PARENS );
    public final CSharp4AST.conversion_operator_declarator_return conversion_operator_declarator() throws RecognitionException {
        CSharp4AST.conversion_operator_declarator_return retval = new CSharp4AST.conversion_operator_declarator_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IMPLICIT1041=null;
        Token OPERATOR1042=null;
        Token OPEN_PARENS1044=null;
        Token IDENTIFIER1046=null;
        Token CLOSE_PARENS1047=null;
        Token EXPLICIT1048=null;
        Token OPERATOR1049=null;
        Token OPEN_PARENS1051=null;
        Token IDENTIFIER1053=null;
        Token CLOSE_PARENS1054=null;
        CSharp4AST.type_return type1043 =null;

        CSharp4AST.type_return type1045 =null;

        CSharp4AST.type_return type1050 =null;

        CSharp4AST.type_return type1052 =null;


        Object IMPLICIT1041_tree=null;
        Object OPERATOR1042_tree=null;
        Object OPEN_PARENS1044_tree=null;
        Object IDENTIFIER1046_tree=null;
        Object CLOSE_PARENS1047_tree=null;
        Object EXPLICIT1048_tree=null;
        Object OPERATOR1049_tree=null;
        Object OPEN_PARENS1051_tree=null;
        Object IDENTIFIER1053_tree=null;
        Object CLOSE_PARENS1054_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1881:2: ( IMPLICIT ^ OPERATOR type OPEN_PARENS type IDENTIFIER CLOSE_PARENS | EXPLICIT ^ OPERATOR type OPEN_PARENS type IDENTIFIER CLOSE_PARENS )
            int alt226=2;
            int LA226_0 = input.LA(1);

            if ( (LA226_0==IMPLICIT) ) {
                alt226=1;
            }
            else if ( (LA226_0==EXPLICIT) ) {
                alt226=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 226, 0, input);

                throw nvae;

            }
            switch (alt226) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1881:4: IMPLICIT ^ OPERATOR type OPEN_PARENS type IDENTIFIER CLOSE_PARENS
                    {
                    root_0 = (Object)adaptor.nil();


                    IMPLICIT1041=(Token)match(input,IMPLICIT,FOLLOW_IMPLICIT_in_conversion_operator_declarator9124); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    IMPLICIT1041_tree = 
                    (Object)adaptor.create(IMPLICIT1041)
                    ;
                    root_0 = (Object)adaptor.becomeRoot(IMPLICIT1041_tree, root_0);
                    }

                    OPERATOR1042=(Token)match(input,OPERATOR,FOLLOW_OPERATOR_in_conversion_operator_declarator9127); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OPERATOR1042_tree = 
                    (Object)adaptor.create(OPERATOR1042)
                    ;
                    adaptor.addChild(root_0, OPERATOR1042_tree);
                    }

                    pushFollow(FOLLOW_type_in_conversion_operator_declarator9129);
                    type1043=type();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, type1043.getTree());

                    OPEN_PARENS1044=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_conversion_operator_declarator9131); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OPEN_PARENS1044_tree = 
                    (Object)adaptor.create(OPEN_PARENS1044)
                    ;
                    adaptor.addChild(root_0, OPEN_PARENS1044_tree);
                    }

                    pushFollow(FOLLOW_type_in_conversion_operator_declarator9133);
                    type1045=type();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, type1045.getTree());

                    IDENTIFIER1046=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_conversion_operator_declarator9135); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    IDENTIFIER1046_tree = 
                    (Object)adaptor.create(IDENTIFIER1046)
                    ;
                    adaptor.addChild(root_0, IDENTIFIER1046_tree);
                    }

                    CLOSE_PARENS1047=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_conversion_operator_declarator9137); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    CLOSE_PARENS1047_tree = 
                    (Object)adaptor.create(CLOSE_PARENS1047)
                    ;
                    adaptor.addChild(root_0, CLOSE_PARENS1047_tree);
                    }

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1882:4: EXPLICIT ^ OPERATOR type OPEN_PARENS type IDENTIFIER CLOSE_PARENS
                    {
                    root_0 = (Object)adaptor.nil();


                    EXPLICIT1048=(Token)match(input,EXPLICIT,FOLLOW_EXPLICIT_in_conversion_operator_declarator9142); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    EXPLICIT1048_tree = 
                    (Object)adaptor.create(EXPLICIT1048)
                    ;
                    root_0 = (Object)adaptor.becomeRoot(EXPLICIT1048_tree, root_0);
                    }

                    OPERATOR1049=(Token)match(input,OPERATOR,FOLLOW_OPERATOR_in_conversion_operator_declarator9145); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OPERATOR1049_tree = 
                    (Object)adaptor.create(OPERATOR1049)
                    ;
                    adaptor.addChild(root_0, OPERATOR1049_tree);
                    }

                    pushFollow(FOLLOW_type_in_conversion_operator_declarator9147);
                    type1050=type();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, type1050.getTree());

                    OPEN_PARENS1051=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_conversion_operator_declarator9149); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OPEN_PARENS1051_tree = 
                    (Object)adaptor.create(OPEN_PARENS1051)
                    ;
                    adaptor.addChild(root_0, OPEN_PARENS1051_tree);
                    }

                    pushFollow(FOLLOW_type_in_conversion_operator_declarator9151);
                    type1052=type();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, type1052.getTree());

                    IDENTIFIER1053=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_conversion_operator_declarator9153); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    IDENTIFIER1053_tree = 
                    (Object)adaptor.create(IDENTIFIER1053)
                    ;
                    adaptor.addChild(root_0, IDENTIFIER1053_tree);
                    }

                    CLOSE_PARENS1054=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_conversion_operator_declarator9155); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    CLOSE_PARENS1054_tree = 
                    (Object)adaptor.create(CLOSE_PARENS1054)
                    ;
                    adaptor.addChild(root_0, CLOSE_PARENS1054_tree);
                    }

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "conversion_operator_declarator"


    public static class operator_body_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "operator_body"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1884:1: operator_body : ( block | SEMICOLON );
    public final CSharp4AST.operator_body_return operator_body() throws RecognitionException {
        CSharp4AST.operator_body_return retval = new CSharp4AST.operator_body_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token SEMICOLON1056=null;
        CSharp4AST.block_return block1055 =null;


        Object SEMICOLON1056_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1885:2: ( block | SEMICOLON )
            int alt227=2;
            int LA227_0 = input.LA(1);

            if ( (LA227_0==OPEN_BRACE) ) {
                alt227=1;
            }
            else if ( (LA227_0==SEMICOLON) ) {
                alt227=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 227, 0, input);

                throw nvae;

            }
            switch (alt227) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1885:4: block
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_block_in_operator_body9166);
                    block1055=block();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, block1055.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1886:4: SEMICOLON
                    {
                    root_0 = (Object)adaptor.nil();


                    SEMICOLON1056=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_operator_body9171); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    SEMICOLON1056_tree = 
                    (Object)adaptor.create(SEMICOLON1056)
                    ;
                    adaptor.addChild(root_0, SEMICOLON1056_tree);
                    }

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "operator_body"


    public static class constructor_declaration_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "constructor_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1888:1: constructor_declaration : ( attributes )? ( constructor_modifiers )? constructor_declarator constructor_body ;
    public final CSharp4AST.constructor_declaration_return constructor_declaration() throws RecognitionException {
        CSharp4AST.constructor_declaration_return retval = new CSharp4AST.constructor_declaration_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.attributes_return attributes1057 =null;

        CSharp4AST.constructor_modifiers_return constructor_modifiers1058 =null;

        CSharp4AST.constructor_declarator_return constructor_declarator1059 =null;

        CSharp4AST.constructor_body_return constructor_body1060 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1889:2: ( ( attributes )? ( constructor_modifiers )? constructor_declarator constructor_body )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1889:4: ( attributes )? ( constructor_modifiers )? constructor_declarator constructor_body
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1889:4: ( attributes )?
            int alt228=2;
            int LA228_0 = input.LA(1);

            if ( (LA228_0==OPEN_BRACKET) ) {
                alt228=1;
            }
            switch (alt228) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1889:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_constructor_declaration9182);
                    attributes1057=attributes();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, attributes1057.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1889:16: ( constructor_modifiers )?
            int alt229=2;
            int LA229_0 = input.LA(1);

            if ( (LA229_0==EXTERN||LA229_0==INTERNAL||(LA229_0 >= PRIVATE && LA229_0 <= PUBLIC)||LA229_0==UNSAFE) ) {
                alt229=1;
            }
            switch (alt229) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1889:16: constructor_modifiers
                    {
                    pushFollow(FOLLOW_constructor_modifiers_in_constructor_declaration9185);
                    constructor_modifiers1058=constructor_modifiers();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, constructor_modifiers1058.getTree());

                    }
                    break;

            }


            pushFollow(FOLLOW_constructor_declarator_in_constructor_declaration9188);
            constructor_declarator1059=constructor_declarator();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, constructor_declarator1059.getTree());

            pushFollow(FOLLOW_constructor_body_in_constructor_declaration9190);
            constructor_body1060=constructor_body();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, constructor_body1060.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "constructor_declaration"


    public static class constructor_modifiers_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "constructor_modifiers"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1891:1: constructor_modifiers : ( constructor_modifier )+ ;
    public final CSharp4AST.constructor_modifiers_return constructor_modifiers() throws RecognitionException {
        CSharp4AST.constructor_modifiers_return retval = new CSharp4AST.constructor_modifiers_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.constructor_modifier_return constructor_modifier1061 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1892:2: ( ( constructor_modifier )+ )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1892:4: ( constructor_modifier )+
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1892:4: ( constructor_modifier )+
            int cnt230=0;
            loop230:
            do {
                int alt230=2;
                int LA230_0 = input.LA(1);

                if ( (LA230_0==EXTERN||LA230_0==INTERNAL||(LA230_0 >= PRIVATE && LA230_0 <= PUBLIC)||LA230_0==UNSAFE) ) {
                    alt230=1;
                }


                switch (alt230) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1892:4: constructor_modifier
            	    {
            	    pushFollow(FOLLOW_constructor_modifier_in_constructor_modifiers9201);
            	    constructor_modifier1061=constructor_modifier();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, constructor_modifier1061.getTree());

            	    }
            	    break;

            	default :
            	    if ( cnt230 >= 1 ) break loop230;
            	    if (state.backtracking>0) {state.failed=true; return retval;}
                        EarlyExitException eee =
                            new EarlyExitException(230, input);
                        throw eee;
                }
                cnt230++;
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "constructor_modifiers"


    public static class constructor_modifier_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "constructor_modifier"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1894:1: constructor_modifier : ( PUBLIC | PROTECTED | INTERNAL | PRIVATE | EXTERN | constructor_modifier_unsafe );
    public final CSharp4AST.constructor_modifier_return constructor_modifier() throws RecognitionException {
        CSharp4AST.constructor_modifier_return retval = new CSharp4AST.constructor_modifier_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token PUBLIC1062=null;
        Token PROTECTED1063=null;
        Token INTERNAL1064=null;
        Token PRIVATE1065=null;
        Token EXTERN1066=null;
        CSharp4AST.constructor_modifier_unsafe_return constructor_modifier_unsafe1067 =null;


        Object PUBLIC1062_tree=null;
        Object PROTECTED1063_tree=null;
        Object INTERNAL1064_tree=null;
        Object PRIVATE1065_tree=null;
        Object EXTERN1066_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1895:2: ( PUBLIC | PROTECTED | INTERNAL | PRIVATE | EXTERN | constructor_modifier_unsafe )
            int alt231=6;
            switch ( input.LA(1) ) {
            case PUBLIC:
                {
                alt231=1;
                }
                break;
            case PROTECTED:
                {
                alt231=2;
                }
                break;
            case INTERNAL:
                {
                alt231=3;
                }
                break;
            case PRIVATE:
                {
                alt231=4;
                }
                break;
            case EXTERN:
                {
                alt231=5;
                }
                break;
            case UNSAFE:
                {
                alt231=6;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 231, 0, input);

                throw nvae;

            }

            switch (alt231) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1895:4: PUBLIC
                    {
                    root_0 = (Object)adaptor.nil();


                    PUBLIC1062=(Token)match(input,PUBLIC,FOLLOW_PUBLIC_in_constructor_modifier9213); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PUBLIC1062_tree = 
                    (Object)adaptor.create(PUBLIC1062)
                    ;
                    adaptor.addChild(root_0, PUBLIC1062_tree);
                    }

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1896:4: PROTECTED
                    {
                    root_0 = (Object)adaptor.nil();


                    PROTECTED1063=(Token)match(input,PROTECTED,FOLLOW_PROTECTED_in_constructor_modifier9218); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PROTECTED1063_tree = 
                    (Object)adaptor.create(PROTECTED1063)
                    ;
                    adaptor.addChild(root_0, PROTECTED1063_tree);
                    }

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1897:4: INTERNAL
                    {
                    root_0 = (Object)adaptor.nil();


                    INTERNAL1064=(Token)match(input,INTERNAL,FOLLOW_INTERNAL_in_constructor_modifier9223); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    INTERNAL1064_tree = 
                    (Object)adaptor.create(INTERNAL1064)
                    ;
                    adaptor.addChild(root_0, INTERNAL1064_tree);
                    }

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1898:4: PRIVATE
                    {
                    root_0 = (Object)adaptor.nil();


                    PRIVATE1065=(Token)match(input,PRIVATE,FOLLOW_PRIVATE_in_constructor_modifier9228); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PRIVATE1065_tree = 
                    (Object)adaptor.create(PRIVATE1065)
                    ;
                    adaptor.addChild(root_0, PRIVATE1065_tree);
                    }

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1899:4: EXTERN
                    {
                    root_0 = (Object)adaptor.nil();


                    EXTERN1066=(Token)match(input,EXTERN,FOLLOW_EXTERN_in_constructor_modifier9233); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    EXTERN1066_tree = 
                    (Object)adaptor.create(EXTERN1066)
                    ;
                    adaptor.addChild(root_0, EXTERN1066_tree);
                    }

                    }
                    break;
                case 6 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1900:4: constructor_modifier_unsafe
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_constructor_modifier_unsafe_in_constructor_modifier9238);
                    constructor_modifier_unsafe1067=constructor_modifier_unsafe();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, constructor_modifier_unsafe1067.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "constructor_modifier"


    public static class constructor_declarator_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "constructor_declarator"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1902:1: constructor_declarator : IDENTIFIER OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( constructor_initializer )? ;
    public final CSharp4AST.constructor_declarator_return constructor_declarator() throws RecognitionException {
        CSharp4AST.constructor_declarator_return retval = new CSharp4AST.constructor_declarator_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER1068=null;
        Token OPEN_PARENS1069=null;
        Token CLOSE_PARENS1071=null;
        CSharp4AST.formal_parameter_list_return formal_parameter_list1070 =null;

        CSharp4AST.constructor_initializer_return constructor_initializer1072 =null;


        Object IDENTIFIER1068_tree=null;
        Object OPEN_PARENS1069_tree=null;
        Object CLOSE_PARENS1071_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1903:2: ( IDENTIFIER OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( constructor_initializer )? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1903:4: IDENTIFIER OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( constructor_initializer )?
            {
            root_0 = (Object)adaptor.nil();


            IDENTIFIER1068=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_constructor_declarator9249); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1068_tree = 
            (Object)adaptor.create(IDENTIFIER1068)
            ;
            adaptor.addChild(root_0, IDENTIFIER1068_tree);
            }

            OPEN_PARENS1069=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_constructor_declarator9251); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            OPEN_PARENS1069_tree = 
            (Object)adaptor.create(OPEN_PARENS1069)
            ;
            adaptor.addChild(root_0, OPEN_PARENS1069_tree);
            }

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1903:27: ( formal_parameter_list )?
            int alt232=2;
            int LA232_0 = input.LA(1);

            if ( (LA232_0==BOOL||LA232_0==BYTE||LA232_0==CHAR||LA232_0==DECIMAL||LA232_0==DOUBLE||LA232_0==FLOAT||LA232_0==IDENTIFIER||LA232_0==INT||LA232_0==LONG||LA232_0==OBJECT||LA232_0==OPEN_BRACKET||LA232_0==OUT||LA232_0==PARAMS||LA232_0==REF||LA232_0==SBYTE||LA232_0==SHORT||LA232_0==STRING||LA232_0==THIS||(LA232_0 >= UINT && LA232_0 <= ULONG)||LA232_0==USHORT||LA232_0==VOID) ) {
                alt232=1;
            }
            switch (alt232) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1903:27: formal_parameter_list
                    {
                    pushFollow(FOLLOW_formal_parameter_list_in_constructor_declarator9253);
                    formal_parameter_list1070=formal_parameter_list();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, formal_parameter_list1070.getTree());

                    }
                    break;

            }


            CLOSE_PARENS1071=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_constructor_declarator9256); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            CLOSE_PARENS1071_tree = 
            (Object)adaptor.create(CLOSE_PARENS1071)
            ;
            adaptor.addChild(root_0, CLOSE_PARENS1071_tree);
            }

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1903:63: ( constructor_initializer )?
            int alt233=2;
            int LA233_0 = input.LA(1);

            if ( (LA233_0==COLON) ) {
                alt233=1;
            }
            switch (alt233) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1903:63: constructor_initializer
                    {
                    pushFollow(FOLLOW_constructor_initializer_in_constructor_declarator9258);
                    constructor_initializer1072=constructor_initializer();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, constructor_initializer1072.getTree());

                    }
                    break;

            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "constructor_declarator"


    public static class constructor_initializer_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "constructor_initializer"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1905:1: constructor_initializer : ( COLON BASE OPEN_PARENS ( argument_list )? CLOSE_PARENS | COLON THIS OPEN_PARENS ( argument_list )? CLOSE_PARENS );
    public final CSharp4AST.constructor_initializer_return constructor_initializer() throws RecognitionException {
        CSharp4AST.constructor_initializer_return retval = new CSharp4AST.constructor_initializer_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token COLON1073=null;
        Token BASE1074=null;
        Token OPEN_PARENS1075=null;
        Token CLOSE_PARENS1077=null;
        Token COLON1078=null;
        Token THIS1079=null;
        Token OPEN_PARENS1080=null;
        Token CLOSE_PARENS1082=null;
        CSharp4AST.argument_list_return argument_list1076 =null;

        CSharp4AST.argument_list_return argument_list1081 =null;


        Object COLON1073_tree=null;
        Object BASE1074_tree=null;
        Object OPEN_PARENS1075_tree=null;
        Object CLOSE_PARENS1077_tree=null;
        Object COLON1078_tree=null;
        Object THIS1079_tree=null;
        Object OPEN_PARENS1080_tree=null;
        Object CLOSE_PARENS1082_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1906:2: ( COLON BASE OPEN_PARENS ( argument_list )? CLOSE_PARENS | COLON THIS OPEN_PARENS ( argument_list )? CLOSE_PARENS )
            int alt236=2;
            int LA236_0 = input.LA(1);

            if ( (LA236_0==COLON) ) {
                int LA236_1 = input.LA(2);

                if ( (LA236_1==BASE) ) {
                    alt236=1;
                }
                else if ( (LA236_1==THIS) ) {
                    alt236=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 236, 1, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 236, 0, input);

                throw nvae;

            }
            switch (alt236) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1906:4: COLON BASE OPEN_PARENS ( argument_list )? CLOSE_PARENS
                    {
                    root_0 = (Object)adaptor.nil();


                    COLON1073=(Token)match(input,COLON,FOLLOW_COLON_in_constructor_initializer9270); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    COLON1073_tree = 
                    (Object)adaptor.create(COLON1073)
                    ;
                    adaptor.addChild(root_0, COLON1073_tree);
                    }

                    BASE1074=(Token)match(input,BASE,FOLLOW_BASE_in_constructor_initializer9272); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    BASE1074_tree = 
                    (Object)adaptor.create(BASE1074)
                    ;
                    adaptor.addChild(root_0, BASE1074_tree);
                    }

                    OPEN_PARENS1075=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_constructor_initializer9274); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OPEN_PARENS1075_tree = 
                    (Object)adaptor.create(OPEN_PARENS1075)
                    ;
                    adaptor.addChild(root_0, OPEN_PARENS1075_tree);
                    }

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1906:27: ( argument_list )?
                    int alt234=2;
                    int LA234_0 = input.LA(1);

                    if ( (LA234_0==AMP||(LA234_0 >= BANG && LA234_0 <= BASE)||LA234_0==BOOL||LA234_0==BYTE||(LA234_0 >= CHAR && LA234_0 <= CHECKED)||LA234_0==DECIMAL||(LA234_0 >= DEFAULT && LA234_0 <= DELEGATE)||LA234_0==DOUBLE||LA234_0==FALSE||LA234_0==FLOAT||LA234_0==IDENTIFIER||(LA234_0 >= INT && LA234_0 <= INTEGER_LITERAL)||LA234_0==LONG||LA234_0==MINUS||LA234_0==NEW||LA234_0==NULL||LA234_0==OBJECT||LA234_0==OPEN_PARENS||LA234_0==OP_DEC||LA234_0==OP_INC||LA234_0==OUT||LA234_0==PLUS||(LA234_0 >= REAL_LITERAL && LA234_0 <= REF)||LA234_0==SBYTE||LA234_0==SHORT||LA234_0==SIZEOF||LA234_0==STAR||(LA234_0 >= STRING && LA234_0 <= STRING_LITERAL)||LA234_0==THIS||(LA234_0 >= TILDE && LA234_0 <= TRUE)||LA234_0==TYPEOF||(LA234_0 >= UINT && LA234_0 <= UNCHECKED)||LA234_0==USHORT) ) {
                        alt234=1;
                    }
                    switch (alt234) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1906:27: argument_list
                            {
                            pushFollow(FOLLOW_argument_list_in_constructor_initializer9276);
                            argument_list1076=argument_list();

                            state._fsp--;
                            if (state.failed) return retval;
                            if ( state.backtracking==0 ) adaptor.addChild(root_0, argument_list1076.getTree());

                            }
                            break;

                    }


                    CLOSE_PARENS1077=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_constructor_initializer9279); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    CLOSE_PARENS1077_tree = 
                    (Object)adaptor.create(CLOSE_PARENS1077)
                    ;
                    adaptor.addChild(root_0, CLOSE_PARENS1077_tree);
                    }

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1907:4: COLON THIS OPEN_PARENS ( argument_list )? CLOSE_PARENS
                    {
                    root_0 = (Object)adaptor.nil();


                    COLON1078=(Token)match(input,COLON,FOLLOW_COLON_in_constructor_initializer9284); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    COLON1078_tree = 
                    (Object)adaptor.create(COLON1078)
                    ;
                    adaptor.addChild(root_0, COLON1078_tree);
                    }

                    THIS1079=(Token)match(input,THIS,FOLLOW_THIS_in_constructor_initializer9286); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    THIS1079_tree = 
                    (Object)adaptor.create(THIS1079)
                    ;
                    adaptor.addChild(root_0, THIS1079_tree);
                    }

                    OPEN_PARENS1080=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_constructor_initializer9288); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OPEN_PARENS1080_tree = 
                    (Object)adaptor.create(OPEN_PARENS1080)
                    ;
                    adaptor.addChild(root_0, OPEN_PARENS1080_tree);
                    }

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1907:27: ( argument_list )?
                    int alt235=2;
                    int LA235_0 = input.LA(1);

                    if ( (LA235_0==AMP||(LA235_0 >= BANG && LA235_0 <= BASE)||LA235_0==BOOL||LA235_0==BYTE||(LA235_0 >= CHAR && LA235_0 <= CHECKED)||LA235_0==DECIMAL||(LA235_0 >= DEFAULT && LA235_0 <= DELEGATE)||LA235_0==DOUBLE||LA235_0==FALSE||LA235_0==FLOAT||LA235_0==IDENTIFIER||(LA235_0 >= INT && LA235_0 <= INTEGER_LITERAL)||LA235_0==LONG||LA235_0==MINUS||LA235_0==NEW||LA235_0==NULL||LA235_0==OBJECT||LA235_0==OPEN_PARENS||LA235_0==OP_DEC||LA235_0==OP_INC||LA235_0==OUT||LA235_0==PLUS||(LA235_0 >= REAL_LITERAL && LA235_0 <= REF)||LA235_0==SBYTE||LA235_0==SHORT||LA235_0==SIZEOF||LA235_0==STAR||(LA235_0 >= STRING && LA235_0 <= STRING_LITERAL)||LA235_0==THIS||(LA235_0 >= TILDE && LA235_0 <= TRUE)||LA235_0==TYPEOF||(LA235_0 >= UINT && LA235_0 <= UNCHECKED)||LA235_0==USHORT) ) {
                        alt235=1;
                    }
                    switch (alt235) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1907:27: argument_list
                            {
                            pushFollow(FOLLOW_argument_list_in_constructor_initializer9290);
                            argument_list1081=argument_list();

                            state._fsp--;
                            if (state.failed) return retval;
                            if ( state.backtracking==0 ) adaptor.addChild(root_0, argument_list1081.getTree());

                            }
                            break;

                    }


                    CLOSE_PARENS1082=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_constructor_initializer9293); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    CLOSE_PARENS1082_tree = 
                    (Object)adaptor.create(CLOSE_PARENS1082)
                    ;
                    adaptor.addChild(root_0, CLOSE_PARENS1082_tree);
                    }

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "constructor_initializer"


    public static class constructor_body_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "constructor_body"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1909:1: constructor_body : ( block | SEMICOLON );
    public final CSharp4AST.constructor_body_return constructor_body() throws RecognitionException {
        CSharp4AST.constructor_body_return retval = new CSharp4AST.constructor_body_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token SEMICOLON1084=null;
        CSharp4AST.block_return block1083 =null;


        Object SEMICOLON1084_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1910:2: ( block | SEMICOLON )
            int alt237=2;
            int LA237_0 = input.LA(1);

            if ( (LA237_0==OPEN_BRACE) ) {
                alt237=1;
            }
            else if ( (LA237_0==SEMICOLON) ) {
                alt237=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 237, 0, input);

                throw nvae;

            }
            switch (alt237) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1910:4: block
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_block_in_constructor_body9304);
                    block1083=block();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, block1083.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1911:4: SEMICOLON
                    {
                    root_0 = (Object)adaptor.nil();


                    SEMICOLON1084=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_constructor_body9309); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    SEMICOLON1084_tree = 
                    (Object)adaptor.create(SEMICOLON1084)
                    ;
                    adaptor.addChild(root_0, SEMICOLON1084_tree);
                    }

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "constructor_body"


    public static class static_constructor_declaration_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "static_constructor_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1913:1: static_constructor_declaration : ( attributes )? static_constructor_modifiers IDENTIFIER OPEN_PARENS CLOSE_PARENS static_constructor_body ;
    public final CSharp4AST.static_constructor_declaration_return static_constructor_declaration() throws RecognitionException {
        CSharp4AST.static_constructor_declaration_return retval = new CSharp4AST.static_constructor_declaration_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER1087=null;
        Token OPEN_PARENS1088=null;
        Token CLOSE_PARENS1089=null;
        CSharp4AST.attributes_return attributes1085 =null;

        CSharp4AST.static_constructor_modifiers_return static_constructor_modifiers1086 =null;

        CSharp4AST.static_constructor_body_return static_constructor_body1090 =null;


        Object IDENTIFIER1087_tree=null;
        Object OPEN_PARENS1088_tree=null;
        Object CLOSE_PARENS1089_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1914:2: ( ( attributes )? static_constructor_modifiers IDENTIFIER OPEN_PARENS CLOSE_PARENS static_constructor_body )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1914:4: ( attributes )? static_constructor_modifiers IDENTIFIER OPEN_PARENS CLOSE_PARENS static_constructor_body
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1914:4: ( attributes )?
            int alt238=2;
            int LA238_0 = input.LA(1);

            if ( (LA238_0==OPEN_BRACKET) ) {
                alt238=1;
            }
            switch (alt238) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1914:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_static_constructor_declaration9320);
                    attributes1085=attributes();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, attributes1085.getTree());

                    }
                    break;

            }


            pushFollow(FOLLOW_static_constructor_modifiers_in_static_constructor_declaration9323);
            static_constructor_modifiers1086=static_constructor_modifiers();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, static_constructor_modifiers1086.getTree());

            IDENTIFIER1087=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_static_constructor_declaration9325); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1087_tree = 
            (Object)adaptor.create(IDENTIFIER1087)
            ;
            adaptor.addChild(root_0, IDENTIFIER1087_tree);
            }

            OPEN_PARENS1088=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_static_constructor_declaration9327); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            OPEN_PARENS1088_tree = 
            (Object)adaptor.create(OPEN_PARENS1088)
            ;
            adaptor.addChild(root_0, OPEN_PARENS1088_tree);
            }

            CLOSE_PARENS1089=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_static_constructor_declaration9329); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            CLOSE_PARENS1089_tree = 
            (Object)adaptor.create(CLOSE_PARENS1089)
            ;
            adaptor.addChild(root_0, CLOSE_PARENS1089_tree);
            }

            pushFollow(FOLLOW_static_constructor_body_in_static_constructor_declaration9331);
            static_constructor_body1090=static_constructor_body();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, static_constructor_body1090.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "static_constructor_declaration"


    public static class static_constructor_modifiers_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "static_constructor_modifiers"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1923:1: static_constructor_modifiers : static_constructor_modifiers_unsafe ;
    public final CSharp4AST.static_constructor_modifiers_return static_constructor_modifiers() throws RecognitionException {
        CSharp4AST.static_constructor_modifiers_return retval = new CSharp4AST.static_constructor_modifiers_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.static_constructor_modifiers_unsafe_return static_constructor_modifiers_unsafe1091 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1924:3: ( static_constructor_modifiers_unsafe )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1924:5: static_constructor_modifiers_unsafe
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_static_constructor_modifiers_unsafe_in_static_constructor_modifiers9345);
            static_constructor_modifiers_unsafe1091=static_constructor_modifiers_unsafe();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, static_constructor_modifiers_unsafe1091.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "static_constructor_modifiers"


    public static class static_constructor_body_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "static_constructor_body"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1926:1: static_constructor_body : ( block | SEMICOLON );
    public final CSharp4AST.static_constructor_body_return static_constructor_body() throws RecognitionException {
        CSharp4AST.static_constructor_body_return retval = new CSharp4AST.static_constructor_body_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token SEMICOLON1093=null;
        CSharp4AST.block_return block1092 =null;


        Object SEMICOLON1093_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1927:2: ( block | SEMICOLON )
            int alt239=2;
            int LA239_0 = input.LA(1);

            if ( (LA239_0==OPEN_BRACE) ) {
                alt239=1;
            }
            else if ( (LA239_0==SEMICOLON) ) {
                alt239=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 239, 0, input);

                throw nvae;

            }
            switch (alt239) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1927:4: block
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_block_in_static_constructor_body9357);
                    block1092=block();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, block1092.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1928:4: SEMICOLON
                    {
                    root_0 = (Object)adaptor.nil();


                    SEMICOLON1093=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_static_constructor_body9362); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    SEMICOLON1093_tree = 
                    (Object)adaptor.create(SEMICOLON1093)
                    ;
                    adaptor.addChild(root_0, SEMICOLON1093_tree);
                    }

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "static_constructor_body"


    public static class destructor_declaration_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "destructor_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1936:1: destructor_declaration : destructor_declaration_unsafe ;
    public final CSharp4AST.destructor_declaration_return destructor_declaration() throws RecognitionException {
        CSharp4AST.destructor_declaration_return retval = new CSharp4AST.destructor_declaration_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.destructor_declaration_unsafe_return destructor_declaration_unsafe1094 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1937:2: ( destructor_declaration_unsafe )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1937:4: destructor_declaration_unsafe
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_destructor_declaration_unsafe_in_destructor_declaration9375);
            destructor_declaration_unsafe1094=destructor_declaration_unsafe();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, destructor_declaration_unsafe1094.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "destructor_declaration"


    public static class destructor_body_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "destructor_body"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1939:1: destructor_body : ( block | SEMICOLON );
    public final CSharp4AST.destructor_body_return destructor_body() throws RecognitionException {
        CSharp4AST.destructor_body_return retval = new CSharp4AST.destructor_body_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token SEMICOLON1096=null;
        CSharp4AST.block_return block1095 =null;


        Object SEMICOLON1096_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1940:2: ( block | SEMICOLON )
            int alt240=2;
            int LA240_0 = input.LA(1);

            if ( (LA240_0==OPEN_BRACE) ) {
                alt240=1;
            }
            else if ( (LA240_0==SEMICOLON) ) {
                alt240=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 240, 0, input);

                throw nvae;

            }
            switch (alt240) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1940:4: block
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_block_in_destructor_body9386);
                    block1095=block();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, block1095.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1941:4: SEMICOLON
                    {
                    root_0 = (Object)adaptor.nil();


                    SEMICOLON1096=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_destructor_body9391); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    SEMICOLON1096_tree = 
                    (Object)adaptor.create(SEMICOLON1096)
                    ;
                    adaptor.addChild(root_0, SEMICOLON1096_tree);
                    }

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "destructor_body"


    public static class body_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "body"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1944:1: body : ( block | SEMICOLON );
    public final CSharp4AST.body_return body() throws RecognitionException {
        CSharp4AST.body_return retval = new CSharp4AST.body_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token SEMICOLON1098=null;
        CSharp4AST.block_return block1097 =null;


        Object SEMICOLON1098_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1945:3: ( block | SEMICOLON )
            int alt241=2;
            int LA241_0 = input.LA(1);

            if ( (LA241_0==OPEN_BRACE) ) {
                alt241=1;
            }
            else if ( (LA241_0==SEMICOLON) ) {
                alt241=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 241, 0, input);

                throw nvae;

            }
            switch (alt241) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1945:5: block
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_block_in_body9403);
                    block1097=block();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, block1097.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1946:5: SEMICOLON
                    {
                    root_0 = (Object)adaptor.nil();


                    SEMICOLON1098=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_body9409); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    SEMICOLON1098_tree = 
                    (Object)adaptor.create(SEMICOLON1098)
                    ;
                    adaptor.addChild(root_0, SEMICOLON1098_tree);
                    }

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "body"


    public static class struct_declaration_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "struct_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1951:1: struct_declaration : ( attributes )? ( struct_modifiers )? ( partial_contextual_keyword )? STRUCT IDENTIFIER ( type_parameter_list )? ( struct_interfaces )? ( type_parameter_constraints_clauses )? struct_body ( SEMICOLON )? ;
    public final CSharp4AST.struct_declaration_return struct_declaration() throws RecognitionException {
        CSharp4AST.struct_declaration_return retval = new CSharp4AST.struct_declaration_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token STRUCT1102=null;
        Token IDENTIFIER1103=null;
        Token SEMICOLON1108=null;
        CSharp4AST.attributes_return attributes1099 =null;

        CSharp4AST.struct_modifiers_return struct_modifiers1100 =null;

        CSharp4AST.partial_contextual_keyword_return partial_contextual_keyword1101 =null;

        CSharp4AST.type_parameter_list_return type_parameter_list1104 =null;

        CSharp4AST.struct_interfaces_return struct_interfaces1105 =null;

        CSharp4AST.type_parameter_constraints_clauses_return type_parameter_constraints_clauses1106 =null;

        CSharp4AST.struct_body_return struct_body1107 =null;


        Object STRUCT1102_tree=null;
        Object IDENTIFIER1103_tree=null;
        Object SEMICOLON1108_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1952:2: ( ( attributes )? ( struct_modifiers )? ( partial_contextual_keyword )? STRUCT IDENTIFIER ( type_parameter_list )? ( struct_interfaces )? ( type_parameter_constraints_clauses )? struct_body ( SEMICOLON )? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1952:4: ( attributes )? ( struct_modifiers )? ( partial_contextual_keyword )? STRUCT IDENTIFIER ( type_parameter_list )? ( struct_interfaces )? ( type_parameter_constraints_clauses )? struct_body ( SEMICOLON )?
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1952:4: ( attributes )?
            int alt242=2;
            int LA242_0 = input.LA(1);

            if ( (LA242_0==OPEN_BRACKET) ) {
                alt242=1;
            }
            switch (alt242) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1952:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_struct_declaration9425);
                    attributes1099=attributes();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, attributes1099.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1952:16: ( struct_modifiers )?
            int alt243=2;
            int LA243_0 = input.LA(1);

            if ( (LA243_0==INTERNAL||LA243_0==NEW||(LA243_0 >= PRIVATE && LA243_0 <= PUBLIC)||LA243_0==UNSAFE) ) {
                alt243=1;
            }
            switch (alt243) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1952:16: struct_modifiers
                    {
                    pushFollow(FOLLOW_struct_modifiers_in_struct_declaration9428);
                    struct_modifiers1100=struct_modifiers();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, struct_modifiers1100.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1952:34: ( partial_contextual_keyword )?
            int alt244=2;
            int LA244_0 = input.LA(1);

            if ( (LA244_0==IDENTIFIER) ) {
                alt244=1;
            }
            switch (alt244) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1952:34: partial_contextual_keyword
                    {
                    pushFollow(FOLLOW_partial_contextual_keyword_in_struct_declaration9431);
                    partial_contextual_keyword1101=partial_contextual_keyword();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, partial_contextual_keyword1101.getTree());

                    }
                    break;

            }


            STRUCT1102=(Token)match(input,STRUCT,FOLLOW_STRUCT_in_struct_declaration9438); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            STRUCT1102_tree = 
            (Object)adaptor.create(STRUCT1102)
            ;
            adaptor.addChild(root_0, STRUCT1102_tree);
            }

            IDENTIFIER1103=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_struct_declaration9440); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1103_tree = 
            (Object)adaptor.create(IDENTIFIER1103)
            ;
            adaptor.addChild(root_0, IDENTIFIER1103_tree);
            }

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1953:22: ( type_parameter_list )?
            int alt245=2;
            int LA245_0 = input.LA(1);

            if ( (LA245_0==LT) ) {
                alt245=1;
            }
            switch (alt245) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1953:22: type_parameter_list
                    {
                    pushFollow(FOLLOW_type_parameter_list_in_struct_declaration9442);
                    type_parameter_list1104=type_parameter_list();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, type_parameter_list1104.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1953:43: ( struct_interfaces )?
            int alt246=2;
            int LA246_0 = input.LA(1);

            if ( (LA246_0==COLON) ) {
                alt246=1;
            }
            switch (alt246) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1953:43: struct_interfaces
                    {
                    pushFollow(FOLLOW_struct_interfaces_in_struct_declaration9445);
                    struct_interfaces1105=struct_interfaces();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, struct_interfaces1105.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1953:62: ( type_parameter_constraints_clauses )?
            int alt247=2;
            int LA247_0 = input.LA(1);

            if ( (LA247_0==IDENTIFIER) ) {
                alt247=1;
            }
            switch (alt247) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1953:62: type_parameter_constraints_clauses
                    {
                    pushFollow(FOLLOW_type_parameter_constraints_clauses_in_struct_declaration9448);
                    type_parameter_constraints_clauses1106=type_parameter_constraints_clauses();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, type_parameter_constraints_clauses1106.getTree());

                    }
                    break;

            }


            pushFollow(FOLLOW_struct_body_in_struct_declaration9451);
            struct_body1107=struct_body();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, struct_body1107.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1953:110: ( SEMICOLON )?
            int alt248=2;
            int LA248_0 = input.LA(1);

            if ( (LA248_0==SEMICOLON) ) {
                alt248=1;
            }
            switch (alt248) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1953:110: SEMICOLON
                    {
                    SEMICOLON1108=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_struct_declaration9453); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    SEMICOLON1108_tree = 
                    (Object)adaptor.create(SEMICOLON1108)
                    ;
                    adaptor.addChild(root_0, SEMICOLON1108_tree);
                    }

                    }
                    break;

            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "struct_declaration"


    public static class struct_modifiers_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "struct_modifiers"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1955:1: struct_modifiers : struct_modifier ( struct_modifier )* ;
    public final CSharp4AST.struct_modifiers_return struct_modifiers() throws RecognitionException {
        CSharp4AST.struct_modifiers_return retval = new CSharp4AST.struct_modifiers_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.struct_modifier_return struct_modifier1109 =null;

        CSharp4AST.struct_modifier_return struct_modifier1110 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1956:2: ( struct_modifier ( struct_modifier )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1956:4: struct_modifier ( struct_modifier )*
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_struct_modifier_in_struct_modifiers9465);
            struct_modifier1109=struct_modifier();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, struct_modifier1109.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1956:20: ( struct_modifier )*
            loop249:
            do {
                int alt249=2;
                int LA249_0 = input.LA(1);

                if ( (LA249_0==INTERNAL||LA249_0==NEW||(LA249_0 >= PRIVATE && LA249_0 <= PUBLIC)||LA249_0==UNSAFE) ) {
                    alt249=1;
                }


                switch (alt249) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1956:22: struct_modifier
            	    {
            	    pushFollow(FOLLOW_struct_modifier_in_struct_modifiers9469);
            	    struct_modifier1110=struct_modifier();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, struct_modifier1110.getTree());

            	    }
            	    break;

            	default :
            	    break loop249;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "struct_modifiers"


    public static class struct_modifier_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "struct_modifier"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1958:1: struct_modifier : ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | struct_modifier_unsafe );
    public final CSharp4AST.struct_modifier_return struct_modifier() throws RecognitionException {
        CSharp4AST.struct_modifier_return retval = new CSharp4AST.struct_modifier_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token NEW1111=null;
        Token PUBLIC1112=null;
        Token PROTECTED1113=null;
        Token INTERNAL1114=null;
        Token PRIVATE1115=null;
        CSharp4AST.struct_modifier_unsafe_return struct_modifier_unsafe1116 =null;


        Object NEW1111_tree=null;
        Object PUBLIC1112_tree=null;
        Object PROTECTED1113_tree=null;
        Object INTERNAL1114_tree=null;
        Object PRIVATE1115_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1959:2: ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | struct_modifier_unsafe )
            int alt250=6;
            switch ( input.LA(1) ) {
            case NEW:
                {
                alt250=1;
                }
                break;
            case PUBLIC:
                {
                alt250=2;
                }
                break;
            case PROTECTED:
                {
                alt250=3;
                }
                break;
            case INTERNAL:
                {
                alt250=4;
                }
                break;
            case PRIVATE:
                {
                alt250=5;
                }
                break;
            case UNSAFE:
                {
                alt250=6;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 250, 0, input);

                throw nvae;

            }

            switch (alt250) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1959:4: NEW
                    {
                    root_0 = (Object)adaptor.nil();


                    NEW1111=(Token)match(input,NEW,FOLLOW_NEW_in_struct_modifier9483); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    NEW1111_tree = 
                    (Object)adaptor.create(NEW1111)
                    ;
                    adaptor.addChild(root_0, NEW1111_tree);
                    }

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1960:4: PUBLIC
                    {
                    root_0 = (Object)adaptor.nil();


                    PUBLIC1112=(Token)match(input,PUBLIC,FOLLOW_PUBLIC_in_struct_modifier9488); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PUBLIC1112_tree = 
                    (Object)adaptor.create(PUBLIC1112)
                    ;
                    adaptor.addChild(root_0, PUBLIC1112_tree);
                    }

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1961:4: PROTECTED
                    {
                    root_0 = (Object)adaptor.nil();


                    PROTECTED1113=(Token)match(input,PROTECTED,FOLLOW_PROTECTED_in_struct_modifier9493); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PROTECTED1113_tree = 
                    (Object)adaptor.create(PROTECTED1113)
                    ;
                    adaptor.addChild(root_0, PROTECTED1113_tree);
                    }

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1962:4: INTERNAL
                    {
                    root_0 = (Object)adaptor.nil();


                    INTERNAL1114=(Token)match(input,INTERNAL,FOLLOW_INTERNAL_in_struct_modifier9498); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    INTERNAL1114_tree = 
                    (Object)adaptor.create(INTERNAL1114)
                    ;
                    adaptor.addChild(root_0, INTERNAL1114_tree);
                    }

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1963:4: PRIVATE
                    {
                    root_0 = (Object)adaptor.nil();


                    PRIVATE1115=(Token)match(input,PRIVATE,FOLLOW_PRIVATE_in_struct_modifier9503); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PRIVATE1115_tree = 
                    (Object)adaptor.create(PRIVATE1115)
                    ;
                    adaptor.addChild(root_0, PRIVATE1115_tree);
                    }

                    }
                    break;
                case 6 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1964:4: struct_modifier_unsafe
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_struct_modifier_unsafe_in_struct_modifier9508);
                    struct_modifier_unsafe1116=struct_modifier_unsafe();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, struct_modifier_unsafe1116.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "struct_modifier"


    public static class struct_interfaces_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "struct_interfaces"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1966:1: struct_interfaces : COLON ! interface_type_list ;
    public final CSharp4AST.struct_interfaces_return struct_interfaces() throws RecognitionException {
        CSharp4AST.struct_interfaces_return retval = new CSharp4AST.struct_interfaces_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token COLON1117=null;
        CSharp4AST.interface_type_list_return interface_type_list1118 =null;


        Object COLON1117_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1967:2: ( COLON ! interface_type_list )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1967:4: COLON ! interface_type_list
            {
            root_0 = (Object)adaptor.nil();


            COLON1117=(Token)match(input,COLON,FOLLOW_COLON_in_struct_interfaces9519); if (state.failed) return retval;

            pushFollow(FOLLOW_interface_type_list_in_struct_interfaces9522);
            interface_type_list1118=interface_type_list();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, interface_type_list1118.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "struct_interfaces"


    public static class struct_body_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "struct_body"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1969:1: struct_body : OPEN_BRACE ! ( struct_member_declarations )? CLOSE_BRACE !;
    public final CSharp4AST.struct_body_return struct_body() throws RecognitionException {
        CSharp4AST.struct_body_return retval = new CSharp4AST.struct_body_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token OPEN_BRACE1119=null;
        Token CLOSE_BRACE1121=null;
        CSharp4AST.struct_member_declarations_return struct_member_declarations1120 =null;


        Object OPEN_BRACE1119_tree=null;
        Object CLOSE_BRACE1121_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1970:2: ( OPEN_BRACE ! ( struct_member_declarations )? CLOSE_BRACE !)
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1970:4: OPEN_BRACE ! ( struct_member_declarations )? CLOSE_BRACE !
            {
            root_0 = (Object)adaptor.nil();


            OPEN_BRACE1119=(Token)match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_struct_body9533); if (state.failed) return retval;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1970:16: ( struct_member_declarations )?
            int alt251=2;
            int LA251_0 = input.LA(1);

            if ( (LA251_0==ABSTRACT||LA251_0==BOOL||LA251_0==BYTE||LA251_0==CHAR||LA251_0==CLASS||LA251_0==CONST||LA251_0==DECIMAL||LA251_0==DELEGATE||LA251_0==DOUBLE||(LA251_0 >= ENUM && LA251_0 <= EXTERN)||(LA251_0 >= FIXED && LA251_0 <= FLOAT)||LA251_0==IDENTIFIER||LA251_0==IMPLICIT||LA251_0==INT||(LA251_0 >= INTERFACE && LA251_0 <= INTERNAL)||LA251_0==LONG||LA251_0==NEW||LA251_0==OBJECT||LA251_0==OPEN_BRACKET||LA251_0==OVERRIDE||(LA251_0 >= PRIVATE && LA251_0 <= PUBLIC)||LA251_0==READONLY||(LA251_0 >= SBYTE && LA251_0 <= SEALED)||LA251_0==SHORT||(LA251_0 >= STATIC && LA251_0 <= STRING)||LA251_0==STRUCT||(LA251_0 >= UINT && LA251_0 <= ULONG)||(LA251_0 >= UNSAFE && LA251_0 <= USHORT)||(LA251_0 >= VIRTUAL && LA251_0 <= VOLATILE)) ) {
                alt251=1;
            }
            switch (alt251) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1970:16: struct_member_declarations
                    {
                    pushFollow(FOLLOW_struct_member_declarations_in_struct_body9536);
                    struct_member_declarations1120=struct_member_declarations();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, struct_member_declarations1120.getTree());

                    }
                    break;

            }


            CLOSE_BRACE1121=(Token)match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_struct_body9539); if (state.failed) return retval;

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "struct_body"


    public static class struct_member_declarations_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "struct_member_declarations"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1972:1: struct_member_declarations : struct_member_declaration ( struct_member_declaration )* -> ^( STRUCT_MEMBER_DECLARATIONS ( struct_member_declaration )+ ) ;
    public final CSharp4AST.struct_member_declarations_return struct_member_declarations() throws RecognitionException {
        CSharp4AST.struct_member_declarations_return retval = new CSharp4AST.struct_member_declarations_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.struct_member_declaration_return struct_member_declaration1122 =null;

        CSharp4AST.struct_member_declaration_return struct_member_declaration1123 =null;


        RewriteRuleSubtreeStream stream_struct_member_declaration=new RewriteRuleSubtreeStream(adaptor,"rule struct_member_declaration");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1973:2: ( struct_member_declaration ( struct_member_declaration )* -> ^( STRUCT_MEMBER_DECLARATIONS ( struct_member_declaration )+ ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1973:4: struct_member_declaration ( struct_member_declaration )*
            {
            pushFollow(FOLLOW_struct_member_declaration_in_struct_member_declarations9551);
            struct_member_declaration1122=struct_member_declaration();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_struct_member_declaration.add(struct_member_declaration1122.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1973:30: ( struct_member_declaration )*
            loop252:
            do {
                int alt252=2;
                int LA252_0 = input.LA(1);

                if ( (LA252_0==ABSTRACT||LA252_0==BOOL||LA252_0==BYTE||LA252_0==CHAR||LA252_0==CLASS||LA252_0==CONST||LA252_0==DECIMAL||LA252_0==DELEGATE||LA252_0==DOUBLE||(LA252_0 >= ENUM && LA252_0 <= EXTERN)||(LA252_0 >= FIXED && LA252_0 <= FLOAT)||LA252_0==IDENTIFIER||LA252_0==IMPLICIT||LA252_0==INT||(LA252_0 >= INTERFACE && LA252_0 <= INTERNAL)||LA252_0==LONG||LA252_0==NEW||LA252_0==OBJECT||LA252_0==OPEN_BRACKET||LA252_0==OVERRIDE||(LA252_0 >= PRIVATE && LA252_0 <= PUBLIC)||LA252_0==READONLY||(LA252_0 >= SBYTE && LA252_0 <= SEALED)||LA252_0==SHORT||(LA252_0 >= STATIC && LA252_0 <= STRING)||LA252_0==STRUCT||(LA252_0 >= UINT && LA252_0 <= ULONG)||(LA252_0 >= UNSAFE && LA252_0 <= USHORT)||(LA252_0 >= VIRTUAL && LA252_0 <= VOLATILE)) ) {
                    alt252=1;
                }


                switch (alt252) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1973:32: struct_member_declaration
            	    {
            	    pushFollow(FOLLOW_struct_member_declaration_in_struct_member_declarations9555);
            	    struct_member_declaration1123=struct_member_declaration();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) stream_struct_member_declaration.add(struct_member_declaration1123.getTree());

            	    }
            	    break;

            	default :
            	    break loop252;
                }
            } while (true);


            // AST REWRITE
            // elements: struct_member_declaration
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 1974:4: -> ^( STRUCT_MEMBER_DECLARATIONS ( struct_member_declaration )+ )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1974:7: ^( STRUCT_MEMBER_DECLARATIONS ( struct_member_declaration )+ )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(STRUCT_MEMBER_DECLARATIONS, "STRUCT_MEMBER_DECLARATIONS")
                , root_1);

                if ( !(stream_struct_member_declaration.hasNext()) ) {
                    throw new RewriteEarlyExitException();
                }
                while ( stream_struct_member_declaration.hasNext() ) {
                    adaptor.addChild(root_1, stream_struct_member_declaration.nextTree());

                }
                stream_struct_member_declaration.reset();

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "struct_member_declarations"


    public static class struct_member_declaration_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "struct_member_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1991:1: struct_member_declaration : ( attributes )? ( all_member_modifiers )? ( common_member_declaration ^| FIXED ^ buffer_element_type fixed_size_buffer_declarators SEMICOLON !) ;
    public final CSharp4AST.struct_member_declaration_return struct_member_declaration() throws RecognitionException {
        CSharp4AST.struct_member_declaration_return retval = new CSharp4AST.struct_member_declaration_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token FIXED1127=null;
        Token SEMICOLON1130=null;
        CSharp4AST.attributes_return attributes1124 =null;

        CSharp4AST.all_member_modifiers_return all_member_modifiers1125 =null;

        CSharp4AST.common_member_declaration_return common_member_declaration1126 =null;

        CSharp4AST.buffer_element_type_return buffer_element_type1128 =null;

        CSharp4AST.fixed_size_buffer_declarators_return fixed_size_buffer_declarators1129 =null;


        Object FIXED1127_tree=null;
        Object SEMICOLON1130_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1992:2: ( ( attributes )? ( all_member_modifiers )? ( common_member_declaration ^| FIXED ^ buffer_element_type fixed_size_buffer_declarators SEMICOLON !) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1992:4: ( attributes )? ( all_member_modifiers )? ( common_member_declaration ^| FIXED ^ buffer_element_type fixed_size_buffer_declarators SEMICOLON !)
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1992:4: ( attributes )?
            int alt253=2;
            int LA253_0 = input.LA(1);

            if ( (LA253_0==OPEN_BRACKET) ) {
                alt253=1;
            }
            switch (alt253) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1992:5: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_struct_member_declaration9583);
                    attributes1124=attributes();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, attributes1124.getTree());

                    if ( state.backtracking==0 ) {attrs = (attributes1124!=null?((Object)attributes1124.tree):null);}

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1993:4: ( all_member_modifiers )?
            int alt254=2;
            int LA254_0 = input.LA(1);

            if ( (LA254_0==ABSTRACT||LA254_0==EXTERN||LA254_0==INTERNAL||LA254_0==NEW||LA254_0==OVERRIDE||(LA254_0 >= PRIVATE && LA254_0 <= PUBLIC)||LA254_0==READONLY||LA254_0==SEALED||LA254_0==STATIC||LA254_0==UNSAFE||LA254_0==VIRTUAL||LA254_0==VOLATILE) ) {
                alt254=1;
            }
            else if ( (LA254_0==IDENTIFIER) ) {
                int LA254_15 = input.LA(2);

                if ( ((input.LT(1).getText().equals("partial"))) ) {
                    alt254=1;
                }
            }
            switch (alt254) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1993:5: all_member_modifiers
                    {
                    pushFollow(FOLLOW_all_member_modifiers_in_struct_member_declaration9593);
                    all_member_modifiers1125=all_member_modifiers();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, all_member_modifiers1125.getTree());

                    if ( state.backtracking==0 ) {members = (all_member_modifiers1125!=null?((Object)all_member_modifiers1125.tree):null);}

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1994:3: ( common_member_declaration ^| FIXED ^ buffer_element_type fixed_size_buffer_declarators SEMICOLON !)
            int alt255=2;
            int LA255_0 = input.LA(1);

            if ( (LA255_0==BOOL||LA255_0==BYTE||LA255_0==CHAR||LA255_0==CLASS||LA255_0==CONST||LA255_0==DECIMAL||LA255_0==DELEGATE||LA255_0==DOUBLE||(LA255_0 >= ENUM && LA255_0 <= EXPLICIT)||LA255_0==FLOAT||LA255_0==IDENTIFIER||LA255_0==IMPLICIT||LA255_0==INT||LA255_0==INTERFACE||LA255_0==LONG||LA255_0==OBJECT||LA255_0==SBYTE||LA255_0==SHORT||LA255_0==STRING||LA255_0==STRUCT||(LA255_0 >= UINT && LA255_0 <= ULONG)||LA255_0==USHORT||LA255_0==VOID) ) {
                alt255=1;
            }
            else if ( (LA255_0==FIXED) ) {
                alt255=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 255, 0, input);

                throw nvae;

            }
            switch (alt255) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1994:5: common_member_declaration ^
                    {
                    pushFollow(FOLLOW_common_member_declaration_in_struct_member_declaration9603);
                    common_member_declaration1126=common_member_declaration();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(common_member_declaration1126.getTree(), root_0);

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1995:5: FIXED ^ buffer_element_type fixed_size_buffer_declarators SEMICOLON !
                    {
                    FIXED1127=(Token)match(input,FIXED,FOLLOW_FIXED_in_struct_member_declaration9610); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    FIXED1127_tree = 
                    (Object)adaptor.create(FIXED1127)
                    ;
                    root_0 = (Object)adaptor.becomeRoot(FIXED1127_tree, root_0);
                    }

                    pushFollow(FOLLOW_buffer_element_type_in_struct_member_declaration9613);
                    buffer_element_type1128=buffer_element_type();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, buffer_element_type1128.getTree());

                    pushFollow(FOLLOW_fixed_size_buffer_declarators_in_struct_member_declaration9615);
                    fixed_size_buffer_declarators1129=fixed_size_buffer_declarators();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, fixed_size_buffer_declarators1129.getTree());

                    SEMICOLON1130=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_struct_member_declaration9617); if (state.failed) return retval;

                    }
                    break;

            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "struct_member_declaration"


    public static class array_type_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "array_type"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2005:1: array_type : array_type2 -> ^( TYPE array_type2 ) ;
    public final CSharp4AST.array_type_return array_type() throws RecognitionException {
        CSharp4AST.array_type_return retval = new CSharp4AST.array_type_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.array_type2_return array_type21131 =null;


        RewriteRuleSubtreeStream stream_array_type2=new RewriteRuleSubtreeStream(adaptor,"rule array_type2");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2006:3: ( array_type2 -> ^( TYPE array_type2 ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2006:5: array_type2
            {
            pushFollow(FOLLOW_array_type2_in_array_type9639);
            array_type21131=array_type2();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_array_type2.add(array_type21131.getTree());

            // AST REWRITE
            // elements: array_type2
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 2006:17: -> ^( TYPE array_type2 )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2006:20: ^( TYPE array_type2 )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(TYPE, "TYPE")
                , root_1);

                adaptor.addChild(root_1, stream_array_type2.nextTree());

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "array_type"


    public static class array_type2_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "array_type2"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2008:1: array_type2 : base_type ( ( STAR | INTERR )* rank_specifier )+ ;
    public final CSharp4AST.array_type2_return array_type2() throws RecognitionException {
        CSharp4AST.array_type2_return retval = new CSharp4AST.array_type2_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token set1133=null;
        CSharp4AST.base_type_return base_type1132 =null;

        CSharp4AST.rank_specifier_return rank_specifier1134 =null;


        Object set1133_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2009:2: ( base_type ( ( STAR | INTERR )* rank_specifier )+ )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2009:4: base_type ( ( STAR | INTERR )* rank_specifier )+
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_base_type_in_array_type29658);
            base_type1132=base_type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, base_type1132.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2009:14: ( ( STAR | INTERR )* rank_specifier )+
            int cnt257=0;
            loop257:
            do {
                int alt257=2;
                int LA257_0 = input.LA(1);

                if ( (LA257_0==OPEN_BRACKET) ) {
                    int LA257_2 = input.LA(2);

                    if ( (LA257_2==CLOSE_BRACKET||LA257_2==COMMA) ) {
                        alt257=1;
                    }


                }
                else if ( (LA257_0==INTERR||LA257_0==STAR) ) {
                    alt257=1;
                }


                switch (alt257) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2009:15: ( STAR | INTERR )* rank_specifier
            	    {
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2009:15: ( STAR | INTERR )*
            	    loop256:
            	    do {
            	        int alt256=2;
            	        int LA256_0 = input.LA(1);

            	        if ( (LA256_0==INTERR||LA256_0==STAR) ) {
            	            alt256=1;
            	        }


            	        switch (alt256) {
            	    	case 1 :
            	    	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:
            	    	    {
            	    	    set1133=(Token)input.LT(1);

            	    	    if ( input.LA(1)==INTERR||input.LA(1)==STAR ) {
            	    	        input.consume();
            	    	        if ( state.backtracking==0 ) adaptor.addChild(root_0, 
            	    	        (Object)adaptor.create(set1133)
            	    	        );
            	    	        state.errorRecovery=false;
            	    	        state.failed=false;
            	    	    }
            	    	    else {
            	    	        if (state.backtracking>0) {state.failed=true; return retval;}
            	    	        MismatchedSetException mse = new MismatchedSetException(null,input);
            	    	        throw mse;
            	    	    }


            	    	    }
            	    	    break;

            	    	default :
            	    	    break loop256;
            	        }
            	    } while (true);


            	    pushFollow(FOLLOW_rank_specifier_in_array_type29670);
            	    rank_specifier1134=rank_specifier();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, rank_specifier1134.getTree());

            	    }
            	    break;

            	default :
            	    if ( cnt257 >= 1 ) break loop257;
            	    if (state.backtracking>0) {state.failed=true; return retval;}
                        EarlyExitException eee =
                            new EarlyExitException(257, input);
                        throw eee;
                }
                cnt257++;
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "array_type2"


    public static class non_array_type_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "non_array_type"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2017:1: non_array_type : non_array_type2 -> ^( TYPE non_array_type2 ) ;
    public final CSharp4AST.non_array_type_return non_array_type() throws RecognitionException {
        CSharp4AST.non_array_type_return retval = new CSharp4AST.non_array_type_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.non_array_type2_return non_array_type21135 =null;


        RewriteRuleSubtreeStream stream_non_array_type2=new RewriteRuleSubtreeStream(adaptor,"rule non_array_type2");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2018:3: ( non_array_type2 -> ^( TYPE non_array_type2 ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2018:5: non_array_type2
            {
            pushFollow(FOLLOW_non_array_type2_in_non_array_type9688);
            non_array_type21135=non_array_type2();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_non_array_type2.add(non_array_type21135.getTree());

            // AST REWRITE
            // elements: non_array_type2
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 2018:21: -> ^( TYPE non_array_type2 )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2018:24: ^( TYPE non_array_type2 )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(TYPE, "TYPE")
                , root_1);

                adaptor.addChild(root_1, stream_non_array_type2.nextTree());

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "non_array_type"


    public static class non_array_type2_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "non_array_type2"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2020:1: non_array_type2 : base_type ( rank_specifier | INTERR | STAR )* ;
    public final CSharp4AST.non_array_type2_return non_array_type2() throws RecognitionException {
        CSharp4AST.non_array_type2_return retval = new CSharp4AST.non_array_type2_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token INTERR1138=null;
        Token STAR1139=null;
        CSharp4AST.base_type_return base_type1136 =null;

        CSharp4AST.rank_specifier_return rank_specifier1137 =null;


        Object INTERR1138_tree=null;
        Object STAR1139_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2021:2: ( base_type ( rank_specifier | INTERR | STAR )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2021:4: base_type ( rank_specifier | INTERR | STAR )*
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_base_type_in_non_array_type29708);
            base_type1136=base_type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, base_type1136.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2021:14: ( rank_specifier | INTERR | STAR )*
            loop258:
            do {
                int alt258=4;
                switch ( input.LA(1) ) {
                case OPEN_BRACKET:
                    {
                    int LA258_1 = input.LA(2);

                    if ( (LA258_1==CLOSE_BRACKET||LA258_1==COMMA) ) {
                        alt258=1;
                    }


                    }
                    break;
                case INTERR:
                    {
                    alt258=2;
                    }
                    break;
                case STAR:
                    {
                    alt258=3;
                    }
                    break;

                }

                switch (alt258) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2021:15: rank_specifier
            	    {
            	    pushFollow(FOLLOW_rank_specifier_in_non_array_type29711);
            	    rank_specifier1137=rank_specifier();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, rank_specifier1137.getTree());

            	    }
            	    break;
            	case 2 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2021:32: INTERR
            	    {
            	    INTERR1138=(Token)match(input,INTERR,FOLLOW_INTERR_in_non_array_type29715); if (state.failed) return retval;
            	    if ( state.backtracking==0 ) {
            	    INTERR1138_tree = 
            	    (Object)adaptor.create(INTERR1138)
            	    ;
            	    adaptor.addChild(root_0, INTERR1138_tree);
            	    }

            	    }
            	    break;
            	case 3 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2021:41: STAR
            	    {
            	    STAR1139=(Token)match(input,STAR,FOLLOW_STAR_in_non_array_type29719); if (state.failed) return retval;
            	    if ( state.backtracking==0 ) {
            	    STAR1139_tree = 
            	    (Object)adaptor.create(STAR1139)
            	    ;
            	    adaptor.addChild(root_0, STAR1139_tree);
            	    }

            	    }
            	    break;

            	default :
            	    break loop258;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "non_array_type2"


    public static class rank_specifiers_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "rank_specifiers"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2029:1: rank_specifiers : ( rank_specifier )+ ;
    public final CSharp4AST.rank_specifiers_return rank_specifiers() throws RecognitionException {
        CSharp4AST.rank_specifiers_return retval = new CSharp4AST.rank_specifiers_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.rank_specifier_return rank_specifier1140 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2030:3: ( ( rank_specifier )+ )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2030:5: ( rank_specifier )+
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2030:5: ( rank_specifier )+
            int cnt259=0;
            loop259:
            do {
                int alt259=2;
                int LA259_0 = input.LA(1);

                if ( (LA259_0==OPEN_BRACKET) ) {
                    int LA259_2 = input.LA(2);

                    if ( (LA259_2==CLOSE_BRACKET||LA259_2==COMMA) ) {
                        alt259=1;
                    }


                }


                switch (alt259) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2030:5: rank_specifier
            	    {
            	    pushFollow(FOLLOW_rank_specifier_in_rank_specifiers9737);
            	    rank_specifier1140=rank_specifier();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, rank_specifier1140.getTree());

            	    }
            	    break;

            	default :
            	    if ( cnt259 >= 1 ) break loop259;
            	    if (state.backtracking>0) {state.failed=true; return retval;}
                        EarlyExitException eee =
                            new EarlyExitException(259, input);
                        throw eee;
                }
                cnt259++;
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "rank_specifiers"


    public static class rank_specifier_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "rank_specifier"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2033:1: rank_specifier : OPEN_BRACKET ( dim_separators )? CLOSE_BRACKET -> ^( RANK_SPECIFIER ( dim_separators )? ) ;
    public final CSharp4AST.rank_specifier_return rank_specifier() throws RecognitionException {
        CSharp4AST.rank_specifier_return retval = new CSharp4AST.rank_specifier_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token OPEN_BRACKET1141=null;
        Token CLOSE_BRACKET1143=null;
        CSharp4AST.dim_separators_return dim_separators1142 =null;


        Object OPEN_BRACKET1141_tree=null;
        Object CLOSE_BRACKET1143_tree=null;
        RewriteRuleTokenStream stream_OPEN_BRACKET=new RewriteRuleTokenStream(adaptor,"token OPEN_BRACKET");
        RewriteRuleTokenStream stream_CLOSE_BRACKET=new RewriteRuleTokenStream(adaptor,"token CLOSE_BRACKET");
        RewriteRuleSubtreeStream stream_dim_separators=new RewriteRuleSubtreeStream(adaptor,"rule dim_separators");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2034:2: ( OPEN_BRACKET ( dim_separators )? CLOSE_BRACKET -> ^( RANK_SPECIFIER ( dim_separators )? ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2034:4: OPEN_BRACKET ( dim_separators )? CLOSE_BRACKET
            {
            OPEN_BRACKET1141=(Token)match(input,OPEN_BRACKET,FOLLOW_OPEN_BRACKET_in_rank_specifier9752); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_OPEN_BRACKET.add(OPEN_BRACKET1141);


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2034:17: ( dim_separators )?
            int alt260=2;
            int LA260_0 = input.LA(1);

            if ( (LA260_0==COMMA) ) {
                alt260=1;
            }
            switch (alt260) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2034:17: dim_separators
                    {
                    pushFollow(FOLLOW_dim_separators_in_rank_specifier9754);
                    dim_separators1142=dim_separators();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) stream_dim_separators.add(dim_separators1142.getTree());

                    }
                    break;

            }


            CLOSE_BRACKET1143=(Token)match(input,CLOSE_BRACKET,FOLLOW_CLOSE_BRACKET_in_rank_specifier9757); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_CLOSE_BRACKET.add(CLOSE_BRACKET1143);


            // AST REWRITE
            // elements: dim_separators
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 2035:4: -> ^( RANK_SPECIFIER ( dim_separators )? )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2035:7: ^( RANK_SPECIFIER ( dim_separators )? )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(RANK_SPECIFIER, "RANK_SPECIFIER")
                , root_1);

                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2035:24: ( dim_separators )?
                if ( stream_dim_separators.hasNext() ) {
                    adaptor.addChild(root_1, stream_dim_separators.nextTree());

                }
                stream_dim_separators.reset();

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "rank_specifier"


    public static class dim_separators_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "dim_separators"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2037:1: dim_separators : ( COMMA )+ ;
    public final CSharp4AST.dim_separators_return dim_separators() throws RecognitionException {
        CSharp4AST.dim_separators_return retval = new CSharp4AST.dim_separators_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token COMMA1144=null;

        Object COMMA1144_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2038:2: ( ( COMMA )+ )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2038:4: ( COMMA )+
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2038:4: ( COMMA )+
            int cnt261=0;
            loop261:
            do {
                int alt261=2;
                int LA261_0 = input.LA(1);

                if ( (LA261_0==COMMA) ) {
                    alt261=1;
                }


                switch (alt261) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2038:4: COMMA
            	    {
            	    COMMA1144=(Token)match(input,COMMA,FOLLOW_COMMA_in_dim_separators9780); if (state.failed) return retval;
            	    if ( state.backtracking==0 ) {
            	    COMMA1144_tree = 
            	    (Object)adaptor.create(COMMA1144)
            	    ;
            	    adaptor.addChild(root_0, COMMA1144_tree);
            	    }

            	    }
            	    break;

            	default :
            	    if ( cnt261 >= 1 ) break loop261;
            	    if (state.backtracking>0) {state.failed=true; return retval;}
                        EarlyExitException eee =
                            new EarlyExitException(261, input);
                        throw eee;
                }
                cnt261++;
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "dim_separators"


    public static class array_initializer_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "array_initializer"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2047:1: array_initializer : ( OPEN_BRACE CLOSE_BRACE | OPEN_BRACE variable_initializer_list ( COMMA )? CLOSE_BRACE );
    public final CSharp4AST.array_initializer_return array_initializer() throws RecognitionException {
        CSharp4AST.array_initializer_return retval = new CSharp4AST.array_initializer_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token OPEN_BRACE1145=null;
        Token CLOSE_BRACE1146=null;
        Token OPEN_BRACE1147=null;
        Token COMMA1149=null;
        Token CLOSE_BRACE1150=null;
        CSharp4AST.variable_initializer_list_return variable_initializer_list1148 =null;


        Object OPEN_BRACE1145_tree=null;
        Object CLOSE_BRACE1146_tree=null;
        Object OPEN_BRACE1147_tree=null;
        Object COMMA1149_tree=null;
        Object CLOSE_BRACE1150_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2048:3: ( OPEN_BRACE CLOSE_BRACE | OPEN_BRACE variable_initializer_list ( COMMA )? CLOSE_BRACE )
            int alt263=2;
            int LA263_0 = input.LA(1);

            if ( (LA263_0==OPEN_BRACE) ) {
                int LA263_1 = input.LA(2);

                if ( (LA263_1==CLOSE_BRACE) ) {
                    alt263=1;
                }
                else if ( (LA263_1==AMP||(LA263_1 >= BANG && LA263_1 <= BASE)||LA263_1==BOOL||LA263_1==BYTE||(LA263_1 >= CHAR && LA263_1 <= CHECKED)||LA263_1==DECIMAL||(LA263_1 >= DEFAULT && LA263_1 <= DELEGATE)||LA263_1==DOUBLE||LA263_1==FALSE||LA263_1==FLOAT||LA263_1==IDENTIFIER||(LA263_1 >= INT && LA263_1 <= INTEGER_LITERAL)||LA263_1==LONG||LA263_1==MINUS||LA263_1==NEW||LA263_1==NULL||(LA263_1 >= OBJECT && LA263_1 <= OPEN_BRACE)||LA263_1==OPEN_PARENS||LA263_1==OP_DEC||LA263_1==OP_INC||LA263_1==PLUS||LA263_1==REAL_LITERAL||LA263_1==SBYTE||LA263_1==SHORT||LA263_1==SIZEOF||LA263_1==STAR||(LA263_1 >= STRING && LA263_1 <= STRING_LITERAL)||LA263_1==THIS||(LA263_1 >= TILDE && LA263_1 <= TRUE)||LA263_1==TYPEOF||(LA263_1 >= UINT && LA263_1 <= UNCHECKED)||LA263_1==USHORT) ) {
                    alt263=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 263, 1, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 263, 0, input);

                throw nvae;

            }
            switch (alt263) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2048:5: OPEN_BRACE CLOSE_BRACE
                    {
                    root_0 = (Object)adaptor.nil();


                    OPEN_BRACE1145=(Token)match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_array_initializer9797); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OPEN_BRACE1145_tree = 
                    (Object)adaptor.create(OPEN_BRACE1145)
                    ;
                    adaptor.addChild(root_0, OPEN_BRACE1145_tree);
                    }

                    CLOSE_BRACE1146=(Token)match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_array_initializer9799); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    CLOSE_BRACE1146_tree = 
                    (Object)adaptor.create(CLOSE_BRACE1146)
                    ;
                    adaptor.addChild(root_0, CLOSE_BRACE1146_tree);
                    }

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2049:5: OPEN_BRACE variable_initializer_list ( COMMA )? CLOSE_BRACE
                    {
                    root_0 = (Object)adaptor.nil();


                    OPEN_BRACE1147=(Token)match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_array_initializer9805); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    OPEN_BRACE1147_tree = 
                    (Object)adaptor.create(OPEN_BRACE1147)
                    ;
                    adaptor.addChild(root_0, OPEN_BRACE1147_tree);
                    }

                    pushFollow(FOLLOW_variable_initializer_list_in_array_initializer9807);
                    variable_initializer_list1148=variable_initializer_list();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, variable_initializer_list1148.getTree());

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2049:42: ( COMMA )?
                    int alt262=2;
                    int LA262_0 = input.LA(1);

                    if ( (LA262_0==COMMA) ) {
                        alt262=1;
                    }
                    switch (alt262) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2049:42: COMMA
                            {
                            COMMA1149=(Token)match(input,COMMA,FOLLOW_COMMA_in_array_initializer9809); if (state.failed) return retval;
                            if ( state.backtracking==0 ) {
                            COMMA1149_tree = 
                            (Object)adaptor.create(COMMA1149)
                            ;
                            adaptor.addChild(root_0, COMMA1149_tree);
                            }

                            }
                            break;

                    }


                    CLOSE_BRACE1150=(Token)match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_array_initializer9812); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    CLOSE_BRACE1150_tree = 
                    (Object)adaptor.create(CLOSE_BRACE1150)
                    ;
                    adaptor.addChild(root_0, CLOSE_BRACE1150_tree);
                    }

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "array_initializer"


    public static class variable_initializer_list_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "variable_initializer_list"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2051:1: variable_initializer_list : variable_initializer ( COMMA variable_initializer )* ;
    public final CSharp4AST.variable_initializer_list_return variable_initializer_list() throws RecognitionException {
        CSharp4AST.variable_initializer_list_return retval = new CSharp4AST.variable_initializer_list_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token COMMA1152=null;
        CSharp4AST.variable_initializer_return variable_initializer1151 =null;

        CSharp4AST.variable_initializer_return variable_initializer1153 =null;


        Object COMMA1152_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2052:2: ( variable_initializer ( COMMA variable_initializer )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2052:4: variable_initializer ( COMMA variable_initializer )*
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_variable_initializer_in_variable_initializer_list9824);
            variable_initializer1151=variable_initializer();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, variable_initializer1151.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2052:25: ( COMMA variable_initializer )*
            loop264:
            do {
                int alt264=2;
                int LA264_0 = input.LA(1);

                if ( (LA264_0==COMMA) ) {
                    int LA264_1 = input.LA(2);

                    if ( (LA264_1==AMP||(LA264_1 >= BANG && LA264_1 <= BASE)||LA264_1==BOOL||LA264_1==BYTE||(LA264_1 >= CHAR && LA264_1 <= CHECKED)||LA264_1==DECIMAL||(LA264_1 >= DEFAULT && LA264_1 <= DELEGATE)||LA264_1==DOUBLE||LA264_1==FALSE||LA264_1==FLOAT||LA264_1==IDENTIFIER||(LA264_1 >= INT && LA264_1 <= INTEGER_LITERAL)||LA264_1==LONG||LA264_1==MINUS||LA264_1==NEW||LA264_1==NULL||(LA264_1 >= OBJECT && LA264_1 <= OPEN_BRACE)||LA264_1==OPEN_PARENS||LA264_1==OP_DEC||LA264_1==OP_INC||LA264_1==PLUS||LA264_1==REAL_LITERAL||LA264_1==SBYTE||LA264_1==SHORT||LA264_1==SIZEOF||LA264_1==STAR||(LA264_1 >= STRING && LA264_1 <= STRING_LITERAL)||LA264_1==THIS||(LA264_1 >= TILDE && LA264_1 <= TRUE)||LA264_1==TYPEOF||(LA264_1 >= UINT && LA264_1 <= UNCHECKED)||LA264_1==USHORT) ) {
                        alt264=1;
                    }


                }


                switch (alt264) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2052:27: COMMA variable_initializer
            	    {
            	    COMMA1152=(Token)match(input,COMMA,FOLLOW_COMMA_in_variable_initializer_list9828); if (state.failed) return retval;
            	    if ( state.backtracking==0 ) {
            	    COMMA1152_tree = 
            	    (Object)adaptor.create(COMMA1152)
            	    ;
            	    adaptor.addChild(root_0, COMMA1152_tree);
            	    }

            	    pushFollow(FOLLOW_variable_initializer_in_variable_initializer_list9831);
            	    variable_initializer1153=variable_initializer();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, variable_initializer1153.getTree());

            	    }
            	    break;

            	default :
            	    break loop264;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "variable_initializer_list"


    public static class interface_declaration_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "interface_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2055:1: interface_declaration : ( attributes )? ( interface_modifiers )? ( partial_contextual_keyword )? INTERFACE IDENTIFIER ( variant_type_parameter_list )? ( interface_base )? ( type_parameter_constraints_clauses )? interface_body ( SEMICOLON )? ;
    public final CSharp4AST.interface_declaration_return interface_declaration() throws RecognitionException {
        CSharp4AST.interface_declaration_return retval = new CSharp4AST.interface_declaration_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token INTERFACE1157=null;
        Token IDENTIFIER1158=null;
        Token SEMICOLON1163=null;
        CSharp4AST.attributes_return attributes1154 =null;

        CSharp4AST.interface_modifiers_return interface_modifiers1155 =null;

        CSharp4AST.partial_contextual_keyword_return partial_contextual_keyword1156 =null;

        CSharp4AST.variant_type_parameter_list_return variant_type_parameter_list1159 =null;

        CSharp4AST.interface_base_return interface_base1160 =null;

        CSharp4AST.type_parameter_constraints_clauses_return type_parameter_constraints_clauses1161 =null;

        CSharp4AST.interface_body_return interface_body1162 =null;


        Object INTERFACE1157_tree=null;
        Object IDENTIFIER1158_tree=null;
        Object SEMICOLON1163_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2056:2: ( ( attributes )? ( interface_modifiers )? ( partial_contextual_keyword )? INTERFACE IDENTIFIER ( variant_type_parameter_list )? ( interface_base )? ( type_parameter_constraints_clauses )? interface_body ( SEMICOLON )? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2056:4: ( attributes )? ( interface_modifiers )? ( partial_contextual_keyword )? INTERFACE IDENTIFIER ( variant_type_parameter_list )? ( interface_base )? ( type_parameter_constraints_clauses )? interface_body ( SEMICOLON )?
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2056:4: ( attributes )?
            int alt265=2;
            int LA265_0 = input.LA(1);

            if ( (LA265_0==OPEN_BRACKET) ) {
                alt265=1;
            }
            switch (alt265) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2056:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_interface_declaration9846);
                    attributes1154=attributes();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, attributes1154.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2056:16: ( interface_modifiers )?
            int alt266=2;
            int LA266_0 = input.LA(1);

            if ( (LA266_0==INTERNAL||LA266_0==NEW||(LA266_0 >= PRIVATE && LA266_0 <= PUBLIC)||LA266_0==UNSAFE) ) {
                alt266=1;
            }
            switch (alt266) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2056:16: interface_modifiers
                    {
                    pushFollow(FOLLOW_interface_modifiers_in_interface_declaration9849);
                    interface_modifiers1155=interface_modifiers();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, interface_modifiers1155.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2056:37: ( partial_contextual_keyword )?
            int alt267=2;
            int LA267_0 = input.LA(1);

            if ( (LA267_0==IDENTIFIER) ) {
                alt267=1;
            }
            switch (alt267) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2056:37: partial_contextual_keyword
                    {
                    pushFollow(FOLLOW_partial_contextual_keyword_in_interface_declaration9852);
                    partial_contextual_keyword1156=partial_contextual_keyword();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, partial_contextual_keyword1156.getTree());

                    }
                    break;

            }


            INTERFACE1157=(Token)match(input,INTERFACE,FOLLOW_INTERFACE_in_interface_declaration9855); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            INTERFACE1157_tree = 
            (Object)adaptor.create(INTERFACE1157)
            ;
            adaptor.addChild(root_0, INTERFACE1157_tree);
            }

            IDENTIFIER1158=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_interface_declaration9857); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1158_tree = 
            (Object)adaptor.create(IDENTIFIER1158)
            ;
            adaptor.addChild(root_0, IDENTIFIER1158_tree);
            }

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2056:86: ( variant_type_parameter_list )?
            int alt268=2;
            int LA268_0 = input.LA(1);

            if ( (LA268_0==LT) ) {
                alt268=1;
            }
            switch (alt268) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2056:86: variant_type_parameter_list
                    {
                    pushFollow(FOLLOW_variant_type_parameter_list_in_interface_declaration9859);
                    variant_type_parameter_list1159=variant_type_parameter_list();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, variant_type_parameter_list1159.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2056:115: ( interface_base )?
            int alt269=2;
            int LA269_0 = input.LA(1);

            if ( (LA269_0==COLON) ) {
                alt269=1;
            }
            switch (alt269) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2056:115: interface_base
                    {
                    pushFollow(FOLLOW_interface_base_in_interface_declaration9862);
                    interface_base1160=interface_base();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, interface_base1160.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2056:131: ( type_parameter_constraints_clauses )?
            int alt270=2;
            int LA270_0 = input.LA(1);

            if ( (LA270_0==IDENTIFIER) ) {
                alt270=1;
            }
            switch (alt270) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2056:131: type_parameter_constraints_clauses
                    {
                    pushFollow(FOLLOW_type_parameter_constraints_clauses_in_interface_declaration9865);
                    type_parameter_constraints_clauses1161=type_parameter_constraints_clauses();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, type_parameter_constraints_clauses1161.getTree());

                    }
                    break;

            }


            pushFollow(FOLLOW_interface_body_in_interface_declaration9868);
            interface_body1162=interface_body();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, interface_body1162.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2056:182: ( SEMICOLON )?
            int alt271=2;
            int LA271_0 = input.LA(1);

            if ( (LA271_0==SEMICOLON) ) {
                alt271=1;
            }
            switch (alt271) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2056:182: SEMICOLON
                    {
                    SEMICOLON1163=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_interface_declaration9870); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    SEMICOLON1163_tree = 
                    (Object)adaptor.create(SEMICOLON1163)
                    ;
                    adaptor.addChild(root_0, SEMICOLON1163_tree);
                    }

                    }
                    break;

            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "interface_declaration"


    public static class interface_modifiers_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "interface_modifiers"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2058:1: interface_modifiers : interface_modifier ( interface_modifier )* ;
    public final CSharp4AST.interface_modifiers_return interface_modifiers() throws RecognitionException {
        CSharp4AST.interface_modifiers_return retval = new CSharp4AST.interface_modifiers_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.interface_modifier_return interface_modifier1164 =null;

        CSharp4AST.interface_modifier_return interface_modifier1165 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2059:2: ( interface_modifier ( interface_modifier )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2059:4: interface_modifier ( interface_modifier )*
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_interface_modifier_in_interface_modifiers9882);
            interface_modifier1164=interface_modifier();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, interface_modifier1164.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2059:23: ( interface_modifier )*
            loop272:
            do {
                int alt272=2;
                int LA272_0 = input.LA(1);

                if ( (LA272_0==INTERNAL||LA272_0==NEW||(LA272_0 >= PRIVATE && LA272_0 <= PUBLIC)||LA272_0==UNSAFE) ) {
                    alt272=1;
                }


                switch (alt272) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2059:25: interface_modifier
            	    {
            	    pushFollow(FOLLOW_interface_modifier_in_interface_modifiers9886);
            	    interface_modifier1165=interface_modifier();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, interface_modifier1165.getTree());

            	    }
            	    break;

            	default :
            	    break loop272;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "interface_modifiers"


    public static class interface_modifier_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "interface_modifier"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2061:1: interface_modifier : ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | interface_modifier_unsafe );
    public final CSharp4AST.interface_modifier_return interface_modifier() throws RecognitionException {
        CSharp4AST.interface_modifier_return retval = new CSharp4AST.interface_modifier_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token NEW1166=null;
        Token PUBLIC1167=null;
        Token PROTECTED1168=null;
        Token INTERNAL1169=null;
        Token PRIVATE1170=null;
        CSharp4AST.interface_modifier_unsafe_return interface_modifier_unsafe1171 =null;


        Object NEW1166_tree=null;
        Object PUBLIC1167_tree=null;
        Object PROTECTED1168_tree=null;
        Object INTERNAL1169_tree=null;
        Object PRIVATE1170_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2062:2: ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | interface_modifier_unsafe )
            int alt273=6;
            switch ( input.LA(1) ) {
            case NEW:
                {
                alt273=1;
                }
                break;
            case PUBLIC:
                {
                alt273=2;
                }
                break;
            case PROTECTED:
                {
                alt273=3;
                }
                break;
            case INTERNAL:
                {
                alt273=4;
                }
                break;
            case PRIVATE:
                {
                alt273=5;
                }
                break;
            case UNSAFE:
                {
                alt273=6;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 273, 0, input);

                throw nvae;

            }

            switch (alt273) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2062:4: NEW
                    {
                    root_0 = (Object)adaptor.nil();


                    NEW1166=(Token)match(input,NEW,FOLLOW_NEW_in_interface_modifier9900); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    NEW1166_tree = 
                    (Object)adaptor.create(NEW1166)
                    ;
                    adaptor.addChild(root_0, NEW1166_tree);
                    }

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2063:4: PUBLIC
                    {
                    root_0 = (Object)adaptor.nil();


                    PUBLIC1167=(Token)match(input,PUBLIC,FOLLOW_PUBLIC_in_interface_modifier9905); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PUBLIC1167_tree = 
                    (Object)adaptor.create(PUBLIC1167)
                    ;
                    adaptor.addChild(root_0, PUBLIC1167_tree);
                    }

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2064:4: PROTECTED
                    {
                    root_0 = (Object)adaptor.nil();


                    PROTECTED1168=(Token)match(input,PROTECTED,FOLLOW_PROTECTED_in_interface_modifier9910); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PROTECTED1168_tree = 
                    (Object)adaptor.create(PROTECTED1168)
                    ;
                    adaptor.addChild(root_0, PROTECTED1168_tree);
                    }

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2065:4: INTERNAL
                    {
                    root_0 = (Object)adaptor.nil();


                    INTERNAL1169=(Token)match(input,INTERNAL,FOLLOW_INTERNAL_in_interface_modifier9915); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    INTERNAL1169_tree = 
                    (Object)adaptor.create(INTERNAL1169)
                    ;
                    adaptor.addChild(root_0, INTERNAL1169_tree);
                    }

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2066:4: PRIVATE
                    {
                    root_0 = (Object)adaptor.nil();


                    PRIVATE1170=(Token)match(input,PRIVATE,FOLLOW_PRIVATE_in_interface_modifier9920); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PRIVATE1170_tree = 
                    (Object)adaptor.create(PRIVATE1170)
                    ;
                    adaptor.addChild(root_0, PRIVATE1170_tree);
                    }

                    }
                    break;
                case 6 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2067:4: interface_modifier_unsafe
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_interface_modifier_unsafe_in_interface_modifier9925);
                    interface_modifier_unsafe1171=interface_modifier_unsafe();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, interface_modifier_unsafe1171.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "interface_modifier"


    public static class variant_type_parameter_list_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "variant_type_parameter_list"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2069:1: variant_type_parameter_list : LT ! variant_type_parameters GT !;
    public final CSharp4AST.variant_type_parameter_list_return variant_type_parameter_list() throws RecognitionException {
        CSharp4AST.variant_type_parameter_list_return retval = new CSharp4AST.variant_type_parameter_list_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token LT1172=null;
        Token GT1174=null;
        CSharp4AST.variant_type_parameters_return variant_type_parameters1173 =null;


        Object LT1172_tree=null;
        Object GT1174_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2070:2: ( LT ! variant_type_parameters GT !)
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2070:4: LT ! variant_type_parameters GT !
            {
            root_0 = (Object)adaptor.nil();


            LT1172=(Token)match(input,LT,FOLLOW_LT_in_variant_type_parameter_list9936); if (state.failed) return retval;

            pushFollow(FOLLOW_variant_type_parameters_in_variant_type_parameter_list9939);
            variant_type_parameters1173=variant_type_parameters();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, variant_type_parameters1173.getTree());

            GT1174=(Token)match(input,GT,FOLLOW_GT_in_variant_type_parameter_list9941); if (state.failed) return retval;

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "variant_type_parameter_list"


    public static class variant_type_parameters_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "variant_type_parameters"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2072:1: variant_type_parameters : attributed_variance_type_parameter ( COMMA attributed_variance_type_parameter )* -> ^( VARIANT_TYPE_PARAMETERS ( attributed_variance_type_parameter )+ ) ;
    public final CSharp4AST.variant_type_parameters_return variant_type_parameters() throws RecognitionException {
        CSharp4AST.variant_type_parameters_return retval = new CSharp4AST.variant_type_parameters_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token COMMA1176=null;
        CSharp4AST.attributed_variance_type_parameter_return attributed_variance_type_parameter1175 =null;

        CSharp4AST.attributed_variance_type_parameter_return attributed_variance_type_parameter1177 =null;


        Object COMMA1176_tree=null;
        RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
        RewriteRuleSubtreeStream stream_attributed_variance_type_parameter=new RewriteRuleSubtreeStream(adaptor,"rule attributed_variance_type_parameter");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2073:2: ( attributed_variance_type_parameter ( COMMA attributed_variance_type_parameter )* -> ^( VARIANT_TYPE_PARAMETERS ( attributed_variance_type_parameter )+ ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2073:4: attributed_variance_type_parameter ( COMMA attributed_variance_type_parameter )*
            {
            pushFollow(FOLLOW_attributed_variance_type_parameter_in_variant_type_parameters9953);
            attributed_variance_type_parameter1175=attributed_variance_type_parameter();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_attributed_variance_type_parameter.add(attributed_variance_type_parameter1175.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2073:39: ( COMMA attributed_variance_type_parameter )*
            loop274:
            do {
                int alt274=2;
                int LA274_0 = input.LA(1);

                if ( (LA274_0==COMMA) ) {
                    alt274=1;
                }


                switch (alt274) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2073:41: COMMA attributed_variance_type_parameter
            	    {
            	    COMMA1176=(Token)match(input,COMMA,FOLLOW_COMMA_in_variant_type_parameters9957); if (state.failed) return retval; 
            	    if ( state.backtracking==0 ) stream_COMMA.add(COMMA1176);


            	    pushFollow(FOLLOW_attributed_variance_type_parameter_in_variant_type_parameters9959);
            	    attributed_variance_type_parameter1177=attributed_variance_type_parameter();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) stream_attributed_variance_type_parameter.add(attributed_variance_type_parameter1177.getTree());

            	    }
            	    break;

            	default :
            	    break loop274;
                }
            } while (true);


            // AST REWRITE
            // elements: attributed_variance_type_parameter
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 2074:4: -> ^( VARIANT_TYPE_PARAMETERS ( attributed_variance_type_parameter )+ )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2074:7: ^( VARIANT_TYPE_PARAMETERS ( attributed_variance_type_parameter )+ )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(VARIANT_TYPE_PARAMETERS, "VARIANT_TYPE_PARAMETERS")
                , root_1);

                if ( !(stream_attributed_variance_type_parameter.hasNext()) ) {
                    throw new RewriteEarlyExitException();
                }
                while ( stream_attributed_variance_type_parameter.hasNext() ) {
                    adaptor.addChild(root_1, stream_attributed_variance_type_parameter.nextTree());

                }
                stream_attributed_variance_type_parameter.reset();

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "variant_type_parameters"


    public static class attributed_variance_type_parameter_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "attributed_variance_type_parameter"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2077:1: attributed_variance_type_parameter : ( attributes )? ( variance_annotation )? type_parameter ;
    public final CSharp4AST.attributed_variance_type_parameter_return attributed_variance_type_parameter() throws RecognitionException {
        CSharp4AST.attributed_variance_type_parameter_return retval = new CSharp4AST.attributed_variance_type_parameter_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.attributes_return attributes1178 =null;

        CSharp4AST.variance_annotation_return variance_annotation1179 =null;

        CSharp4AST.type_parameter_return type_parameter1180 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2078:3: ( ( attributes )? ( variance_annotation )? type_parameter )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2078:5: ( attributes )? ( variance_annotation )? type_parameter
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2078:5: ( attributes )?
            int alt275=2;
            int LA275_0 = input.LA(1);

            if ( (LA275_0==OPEN_BRACKET) ) {
                alt275=1;
            }
            switch (alt275) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2078:5: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_attributed_variance_type_parameter9987);
                    attributes1178=attributes();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, attributes1178.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2078:17: ( variance_annotation )?
            int alt276=2;
            int LA276_0 = input.LA(1);

            if ( (LA276_0==IN||LA276_0==OUT) ) {
                alt276=1;
            }
            switch (alt276) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2078:17: variance_annotation
                    {
                    pushFollow(FOLLOW_variance_annotation_in_attributed_variance_type_parameter9990);
                    variance_annotation1179=variance_annotation();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, variance_annotation1179.getTree());

                    }
                    break;

            }


            pushFollow(FOLLOW_type_parameter_in_attributed_variance_type_parameter9993);
            type_parameter1180=type_parameter();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, type_parameter1180.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "attributed_variance_type_parameter"


    public static class variance_annotation_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "variance_annotation"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2080:1: variance_annotation : ( IN -> ^( VARIANCE_ANNOTATION IN ) | OUT -> ^( VARIANCE_ANNOTATION OUT ) );
    public final CSharp4AST.variance_annotation_return variance_annotation() throws RecognitionException {
        CSharp4AST.variance_annotation_return retval = new CSharp4AST.variance_annotation_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IN1181=null;
        Token OUT1182=null;

        Object IN1181_tree=null;
        Object OUT1182_tree=null;
        RewriteRuleTokenStream stream_IN=new RewriteRuleTokenStream(adaptor,"token IN");
        RewriteRuleTokenStream stream_OUT=new RewriteRuleTokenStream(adaptor,"token OUT");

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2081:2: ( IN -> ^( VARIANCE_ANNOTATION IN ) | OUT -> ^( VARIANCE_ANNOTATION OUT ) )
            int alt277=2;
            int LA277_0 = input.LA(1);

            if ( (LA277_0==IN) ) {
                alt277=1;
            }
            else if ( (LA277_0==OUT) ) {
                alt277=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 277, 0, input);

                throw nvae;

            }
            switch (alt277) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2081:4: IN
                    {
                    IN1181=(Token)match(input,IN,FOLLOW_IN_in_variance_annotation10005); if (state.failed) return retval; 
                    if ( state.backtracking==0 ) stream_IN.add(IN1181);


                    // AST REWRITE
                    // elements: IN
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    // wildcard labels: 
                    if ( state.backtracking==0 ) {

                    retval.tree = root_0;
                    RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

                    root_0 = (Object)adaptor.nil();
                    // 2081:9: -> ^( VARIANCE_ANNOTATION IN )
                    {
                        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2081:12: ^( VARIANCE_ANNOTATION IN )
                        {
                        Object root_1 = (Object)adaptor.nil();
                        root_1 = (Object)adaptor.becomeRoot(
                        (Object)adaptor.create(VARIANCE_ANNOTATION, "VARIANCE_ANNOTATION")
                        , root_1);

                        adaptor.addChild(root_1, 
                        stream_IN.nextNode()
                        );

                        adaptor.addChild(root_0, root_1);
                        }

                    }


                    retval.tree = root_0;
                    }

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2082:4: OUT
                    {
                    OUT1182=(Token)match(input,OUT,FOLLOW_OUT_in_variance_annotation10020); if (state.failed) return retval; 
                    if ( state.backtracking==0 ) stream_OUT.add(OUT1182);


                    // AST REWRITE
                    // elements: OUT
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    // wildcard labels: 
                    if ( state.backtracking==0 ) {

                    retval.tree = root_0;
                    RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

                    root_0 = (Object)adaptor.nil();
                    // 2082:9: -> ^( VARIANCE_ANNOTATION OUT )
                    {
                        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2082:12: ^( VARIANCE_ANNOTATION OUT )
                        {
                        Object root_1 = (Object)adaptor.nil();
                        root_1 = (Object)adaptor.becomeRoot(
                        (Object)adaptor.create(VARIANCE_ANNOTATION, "VARIANCE_ANNOTATION")
                        , root_1);

                        adaptor.addChild(root_1, 
                        stream_OUT.nextNode()
                        );

                        adaptor.addChild(root_0, root_1);
                        }

                    }


                    retval.tree = root_0;
                    }

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "variance_annotation"


    public static class interface_base_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "interface_base"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2084:1: interface_base : COLON ! interface_type_list ;
    public final CSharp4AST.interface_base_return interface_base() throws RecognitionException {
        CSharp4AST.interface_base_return retval = new CSharp4AST.interface_base_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token COLON1183=null;
        CSharp4AST.interface_type_list_return interface_type_list1184 =null;


        Object COLON1183_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2085:2: ( COLON ! interface_type_list )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2085:4: COLON ! interface_type_list
            {
            root_0 = (Object)adaptor.nil();


            COLON1183=(Token)match(input,COLON,FOLLOW_COLON_in_interface_base10040); if (state.failed) return retval;

            pushFollow(FOLLOW_interface_type_list_in_interface_base10043);
            interface_type_list1184=interface_type_list();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, interface_type_list1184.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "interface_base"


    public static class interface_body_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "interface_body"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2087:1: interface_body : OPEN_BRACE ! ( interface_member_declarations )? CLOSE_BRACE !;
    public final CSharp4AST.interface_body_return interface_body() throws RecognitionException {
        CSharp4AST.interface_body_return retval = new CSharp4AST.interface_body_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token OPEN_BRACE1185=null;
        Token CLOSE_BRACE1187=null;
        CSharp4AST.interface_member_declarations_return interface_member_declarations1186 =null;


        Object OPEN_BRACE1185_tree=null;
        Object CLOSE_BRACE1187_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2088:2: ( OPEN_BRACE ! ( interface_member_declarations )? CLOSE_BRACE !)
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2088:4: OPEN_BRACE ! ( interface_member_declarations )? CLOSE_BRACE !
            {
            root_0 = (Object)adaptor.nil();


            OPEN_BRACE1185=(Token)match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_interface_body10054); if (state.failed) return retval;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2088:16: ( interface_member_declarations )?
            int alt278=2;
            int LA278_0 = input.LA(1);

            if ( (LA278_0==BOOL||LA278_0==BYTE||LA278_0==CHAR||LA278_0==DECIMAL||LA278_0==DOUBLE||LA278_0==EVENT||LA278_0==FLOAT||LA278_0==IDENTIFIER||LA278_0==INT||LA278_0==LONG||LA278_0==NEW||LA278_0==OBJECT||LA278_0==OPEN_BRACKET||LA278_0==SBYTE||LA278_0==SHORT||LA278_0==STRING||(LA278_0 >= UINT && LA278_0 <= ULONG)||LA278_0==USHORT||LA278_0==VOID) ) {
                alt278=1;
            }
            switch (alt278) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2088:16: interface_member_declarations
                    {
                    pushFollow(FOLLOW_interface_member_declarations_in_interface_body10057);
                    interface_member_declarations1186=interface_member_declarations();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, interface_member_declarations1186.getTree());

                    }
                    break;

            }


            CLOSE_BRACE1187=(Token)match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_interface_body10060); if (state.failed) return retval;

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "interface_body"


    public static class interface_member_declarations_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "interface_member_declarations"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2090:1: interface_member_declarations : ( interface_member_declaration )+ -> ^( INTERFACE_MEMBER_DECLARATIONS ( interface_member_declaration )+ ) ;
    public final CSharp4AST.interface_member_declarations_return interface_member_declarations() throws RecognitionException {
        CSharp4AST.interface_member_declarations_return retval = new CSharp4AST.interface_member_declarations_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.interface_member_declaration_return interface_member_declaration1188 =null;


        RewriteRuleSubtreeStream stream_interface_member_declaration=new RewriteRuleSubtreeStream(adaptor,"rule interface_member_declaration");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2091:2: ( ( interface_member_declaration )+ -> ^( INTERFACE_MEMBER_DECLARATIONS ( interface_member_declaration )+ ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2091:4: ( interface_member_declaration )+
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2091:4: ( interface_member_declaration )+
            int cnt279=0;
            loop279:
            do {
                int alt279=2;
                int LA279_0 = input.LA(1);

                if ( (LA279_0==BOOL||LA279_0==BYTE||LA279_0==CHAR||LA279_0==DECIMAL||LA279_0==DOUBLE||LA279_0==EVENT||LA279_0==FLOAT||LA279_0==IDENTIFIER||LA279_0==INT||LA279_0==LONG||LA279_0==NEW||LA279_0==OBJECT||LA279_0==OPEN_BRACKET||LA279_0==SBYTE||LA279_0==SHORT||LA279_0==STRING||(LA279_0 >= UINT && LA279_0 <= ULONG)||LA279_0==USHORT||LA279_0==VOID) ) {
                    alt279=1;
                }


                switch (alt279) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2091:4: interface_member_declaration
            	    {
            	    pushFollow(FOLLOW_interface_member_declaration_in_interface_member_declarations10072);
            	    interface_member_declaration1188=interface_member_declaration();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) stream_interface_member_declaration.add(interface_member_declaration1188.getTree());

            	    }
            	    break;

            	default :
            	    if ( cnt279 >= 1 ) break loop279;
            	    if (state.backtracking>0) {state.failed=true; return retval;}
                        EarlyExitException eee =
                            new EarlyExitException(279, input);
                        throw eee;
                }
                cnt279++;
            } while (true);


            // AST REWRITE
            // elements: interface_member_declaration
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 2092:4: -> ^( INTERFACE_MEMBER_DECLARATIONS ( interface_member_declaration )+ )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2092:7: ^( INTERFACE_MEMBER_DECLARATIONS ( interface_member_declaration )+ )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(INTERFACE_MEMBER_DECLARATIONS, "INTERFACE_MEMBER_DECLARATIONS")
                , root_1);

                if ( !(stream_interface_member_declaration.hasNext()) ) {
                    throw new RewriteEarlyExitException();
                }
                while ( stream_interface_member_declaration.hasNext() ) {
                    adaptor.addChild(root_1, stream_interface_member_declaration.nextTree());

                }
                stream_interface_member_declaration.reset();

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "interface_member_declarations"


    public static class interface_member_declaration_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "interface_member_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2102:1: interface_member_declaration : ( attributes )? ( NEW )? ( type ( interface_method_declaration2 ^| interface_property_declaration2 ^| interface_indexer_declaration2 ^) | type_void interface_method_declaration2 ^| interface_event_declaration2 ^) ;
    public final CSharp4AST.interface_member_declaration_return interface_member_declaration() throws RecognitionException {
        CSharp4AST.interface_member_declaration_return retval = new CSharp4AST.interface_member_declaration_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token NEW1190=null;
        CSharp4AST.attributes_return attributes1189 =null;

        CSharp4AST.type_return type1191 =null;

        CSharp4AST.interface_method_declaration2_return interface_method_declaration21192 =null;

        CSharp4AST.interface_property_declaration2_return interface_property_declaration21193 =null;

        CSharp4AST.interface_indexer_declaration2_return interface_indexer_declaration21194 =null;

        CSharp4AST.type_void_return type_void1195 =null;

        CSharp4AST.interface_method_declaration2_return interface_method_declaration21196 =null;

        CSharp4AST.interface_event_declaration2_return interface_event_declaration21197 =null;


        Object NEW1190_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2103:3: ( ( attributes )? ( NEW )? ( type ( interface_method_declaration2 ^| interface_property_declaration2 ^| interface_indexer_declaration2 ^) | type_void interface_method_declaration2 ^| interface_event_declaration2 ^) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2103:5: ( attributes )? ( NEW )? ( type ( interface_method_declaration2 ^| interface_property_declaration2 ^| interface_indexer_declaration2 ^) | type_void interface_method_declaration2 ^| interface_event_declaration2 ^)
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2103:5: ( attributes )?
            int alt280=2;
            int LA280_0 = input.LA(1);

            if ( (LA280_0==OPEN_BRACKET) ) {
                alt280=1;
            }
            switch (alt280) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2103:5: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_interface_member_declaration10100);
                    attributes1189=attributes();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, attributes1189.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2103:17: ( NEW )?
            int alt281=2;
            int LA281_0 = input.LA(1);

            if ( (LA281_0==NEW) ) {
                alt281=1;
            }
            switch (alt281) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2103:17: NEW
                    {
                    NEW1190=(Token)match(input,NEW,FOLLOW_NEW_in_interface_member_declaration10103); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    NEW1190_tree = 
                    (Object)adaptor.create(NEW1190)
                    ;
                    adaptor.addChild(root_0, NEW1190_tree);
                    }

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2104:5: ( type ( interface_method_declaration2 ^| interface_property_declaration2 ^| interface_indexer_declaration2 ^) | type_void interface_method_declaration2 ^| interface_event_declaration2 ^)
            int alt283=3;
            switch ( input.LA(1) ) {
            case BOOL:
            case BYTE:
            case CHAR:
            case DECIMAL:
            case DOUBLE:
            case FLOAT:
            case IDENTIFIER:
            case INT:
            case LONG:
            case OBJECT:
            case SBYTE:
            case SHORT:
            case STRING:
            case UINT:
            case ULONG:
            case USHORT:
                {
                alt283=1;
                }
                break;
            case VOID:
                {
                int LA283_2 = input.LA(2);

                if ( (LA283_2==STAR) ) {
                    alt283=1;
                }
                else if ( (LA283_2==IDENTIFIER) ) {
                    alt283=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 283, 2, input);

                    throw nvae;

                }
                }
                break;
            case EVENT:
                {
                alt283=3;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 283, 0, input);

                throw nvae;

            }

            switch (alt283) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2104:7: type ( interface_method_declaration2 ^| interface_property_declaration2 ^| interface_indexer_declaration2 ^)
                    {
                    pushFollow(FOLLOW_type_in_interface_member_declaration10112);
                    type1191=type();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, type1191.getTree());

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2105:7: ( interface_method_declaration2 ^| interface_property_declaration2 ^| interface_indexer_declaration2 ^)
                    int alt282=3;
                    int LA282_0 = input.LA(1);

                    if ( (LA282_0==IDENTIFIER) ) {
                        int LA282_1 = input.LA(2);

                        if ( (LA282_1==OPEN_BRACE) ) {
                            alt282=2;
                        }
                        else if ( (LA282_1==LT||LA282_1==OPEN_PARENS) ) {
                            alt282=1;
                        }
                        else {
                            if (state.backtracking>0) {state.failed=true; return retval;}
                            NoViableAltException nvae =
                                new NoViableAltException("", 282, 1, input);

                            throw nvae;

                        }
                    }
                    else if ( (LA282_0==THIS) ) {
                        alt282=3;
                    }
                    else {
                        if (state.backtracking>0) {state.failed=true; return retval;}
                        NoViableAltException nvae =
                            new NoViableAltException("", 282, 0, input);

                        throw nvae;

                    }
                    switch (alt282) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2105:9: interface_method_declaration2 ^
                            {
                            pushFollow(FOLLOW_interface_method_declaration2_in_interface_member_declaration10122);
                            interface_method_declaration21192=interface_method_declaration2();

                            state._fsp--;
                            if (state.failed) return retval;
                            if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(interface_method_declaration21192.getTree(), root_0);

                            }
                            break;
                        case 2 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2106:9: interface_property_declaration2 ^
                            {
                            pushFollow(FOLLOW_interface_property_declaration2_in_interface_member_declaration10133);
                            interface_property_declaration21193=interface_property_declaration2();

                            state._fsp--;
                            if (state.failed) return retval;
                            if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(interface_property_declaration21193.getTree(), root_0);

                            }
                            break;
                        case 3 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2107:9: interface_indexer_declaration2 ^
                            {
                            pushFollow(FOLLOW_interface_indexer_declaration2_in_interface_member_declaration10144);
                            interface_indexer_declaration21194=interface_indexer_declaration2();

                            state._fsp--;
                            if (state.failed) return retval;
                            if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(interface_indexer_declaration21194.getTree(), root_0);

                            }
                            break;

                    }


                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2109:7: type_void interface_method_declaration2 ^
                    {
                    pushFollow(FOLLOW_type_void_in_interface_member_declaration10161);
                    type_void1195=type_void();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, type_void1195.getTree());

                    pushFollow(FOLLOW_interface_method_declaration2_in_interface_member_declaration10163);
                    interface_method_declaration21196=interface_method_declaration2();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(interface_method_declaration21196.getTree(), root_0);

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2110:7: interface_event_declaration2 ^
                    {
                    pushFollow(FOLLOW_interface_event_declaration2_in_interface_member_declaration10172);
                    interface_event_declaration21197=interface_event_declaration2();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(interface_event_declaration21197.getTree(), root_0);

                    }
                    break;

            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "interface_member_declaration"


    public static class interface_method_declaration_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "interface_method_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2113:1: interface_method_declaration : ( attributes )? ( NEW )? return_type IDENTIFIER ( type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? SEMICOLON ;
    public final CSharp4AST.interface_method_declaration_return interface_method_declaration() throws RecognitionException {
        CSharp4AST.interface_method_declaration_return retval = new CSharp4AST.interface_method_declaration_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token NEW1199=null;
        Token IDENTIFIER1201=null;
        Token OPEN_PARENS1203=null;
        Token CLOSE_PARENS1205=null;
        Token SEMICOLON1207=null;
        CSharp4AST.attributes_return attributes1198 =null;

        CSharp4AST.return_type_return return_type1200 =null;

        CSharp4AST.type_parameter_list_return type_parameter_list1202 =null;

        CSharp4AST.formal_parameter_list_return formal_parameter_list1204 =null;

        CSharp4AST.type_parameter_constraints_clauses_return type_parameter_constraints_clauses1206 =null;


        Object NEW1199_tree=null;
        Object IDENTIFIER1201_tree=null;
        Object OPEN_PARENS1203_tree=null;
        Object CLOSE_PARENS1205_tree=null;
        Object SEMICOLON1207_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2114:2: ( ( attributes )? ( NEW )? return_type IDENTIFIER ( type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? SEMICOLON )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2114:4: ( attributes )? ( NEW )? return_type IDENTIFIER ( type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? SEMICOLON
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2114:4: ( attributes )?
            int alt284=2;
            int LA284_0 = input.LA(1);

            if ( (LA284_0==OPEN_BRACKET) ) {
                alt284=1;
            }
            switch (alt284) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2114:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_interface_method_declaration10191);
                    attributes1198=attributes();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, attributes1198.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2114:16: ( NEW )?
            int alt285=2;
            int LA285_0 = input.LA(1);

            if ( (LA285_0==NEW) ) {
                alt285=1;
            }
            switch (alt285) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2114:16: NEW
                    {
                    NEW1199=(Token)match(input,NEW,FOLLOW_NEW_in_interface_method_declaration10194); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    NEW1199_tree = 
                    (Object)adaptor.create(NEW1199)
                    ;
                    adaptor.addChild(root_0, NEW1199_tree);
                    }

                    }
                    break;

            }


            pushFollow(FOLLOW_return_type_in_interface_method_declaration10197);
            return_type1200=return_type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, return_type1200.getTree());

            IDENTIFIER1201=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_interface_method_declaration10199); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1201_tree = 
            (Object)adaptor.create(IDENTIFIER1201)
            ;
            adaptor.addChild(root_0, IDENTIFIER1201_tree);
            }

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2114:44: ( type_parameter_list )?
            int alt286=2;
            int LA286_0 = input.LA(1);

            if ( (LA286_0==LT) ) {
                alt286=1;
            }
            switch (alt286) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2114:44: type_parameter_list
                    {
                    pushFollow(FOLLOW_type_parameter_list_in_interface_method_declaration10201);
                    type_parameter_list1202=type_parameter_list();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, type_parameter_list1202.getTree());

                    }
                    break;

            }


            OPEN_PARENS1203=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_interface_method_declaration10204); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            OPEN_PARENS1203_tree = 
            (Object)adaptor.create(OPEN_PARENS1203)
            ;
            adaptor.addChild(root_0, OPEN_PARENS1203_tree);
            }

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2114:77: ( formal_parameter_list )?
            int alt287=2;
            int LA287_0 = input.LA(1);

            if ( (LA287_0==BOOL||LA287_0==BYTE||LA287_0==CHAR||LA287_0==DECIMAL||LA287_0==DOUBLE||LA287_0==FLOAT||LA287_0==IDENTIFIER||LA287_0==INT||LA287_0==LONG||LA287_0==OBJECT||LA287_0==OPEN_BRACKET||LA287_0==OUT||LA287_0==PARAMS||LA287_0==REF||LA287_0==SBYTE||LA287_0==SHORT||LA287_0==STRING||LA287_0==THIS||(LA287_0 >= UINT && LA287_0 <= ULONG)||LA287_0==USHORT||LA287_0==VOID) ) {
                alt287=1;
            }
            switch (alt287) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2114:77: formal_parameter_list
                    {
                    pushFollow(FOLLOW_formal_parameter_list_in_interface_method_declaration10206);
                    formal_parameter_list1204=formal_parameter_list();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, formal_parameter_list1204.getTree());

                    }
                    break;

            }


            CLOSE_PARENS1205=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_interface_method_declaration10209); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            CLOSE_PARENS1205_tree = 
            (Object)adaptor.create(CLOSE_PARENS1205)
            ;
            adaptor.addChild(root_0, CLOSE_PARENS1205_tree);
            }

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2114:113: ( type_parameter_constraints_clauses )?
            int alt288=2;
            int LA288_0 = input.LA(1);

            if ( (LA288_0==IDENTIFIER) ) {
                alt288=1;
            }
            switch (alt288) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2114:113: type_parameter_constraints_clauses
                    {
                    pushFollow(FOLLOW_type_parameter_constraints_clauses_in_interface_method_declaration10211);
                    type_parameter_constraints_clauses1206=type_parameter_constraints_clauses();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, type_parameter_constraints_clauses1206.getTree());

                    }
                    break;

            }


            SEMICOLON1207=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_interface_method_declaration10214); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            SEMICOLON1207_tree = 
            (Object)adaptor.create(SEMICOLON1207)
            ;
            adaptor.addChild(root_0, SEMICOLON1207_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "interface_method_declaration"


    public static class interface_property_declaration_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "interface_property_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2116:1: interface_property_declaration : ( attributes )? ( NEW )? type IDENTIFIER OPEN_BRACE interface_accessors CLOSE_BRACE ;
    public final CSharp4AST.interface_property_declaration_return interface_property_declaration() throws RecognitionException {
        CSharp4AST.interface_property_declaration_return retval = new CSharp4AST.interface_property_declaration_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token NEW1209=null;
        Token IDENTIFIER1211=null;
        Token OPEN_BRACE1212=null;
        Token CLOSE_BRACE1214=null;
        CSharp4AST.attributes_return attributes1208 =null;

        CSharp4AST.type_return type1210 =null;

        CSharp4AST.interface_accessors_return interface_accessors1213 =null;


        Object NEW1209_tree=null;
        Object IDENTIFIER1211_tree=null;
        Object OPEN_BRACE1212_tree=null;
        Object CLOSE_BRACE1214_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2117:2: ( ( attributes )? ( NEW )? type IDENTIFIER OPEN_BRACE interface_accessors CLOSE_BRACE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2117:4: ( attributes )? ( NEW )? type IDENTIFIER OPEN_BRACE interface_accessors CLOSE_BRACE
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2117:4: ( attributes )?
            int alt289=2;
            int LA289_0 = input.LA(1);

            if ( (LA289_0==OPEN_BRACKET) ) {
                alt289=1;
            }
            switch (alt289) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2117:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_interface_property_declaration10225);
                    attributes1208=attributes();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, attributes1208.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2117:16: ( NEW )?
            int alt290=2;
            int LA290_0 = input.LA(1);

            if ( (LA290_0==NEW) ) {
                alt290=1;
            }
            switch (alt290) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2117:16: NEW
                    {
                    NEW1209=(Token)match(input,NEW,FOLLOW_NEW_in_interface_property_declaration10228); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    NEW1209_tree = 
                    (Object)adaptor.create(NEW1209)
                    ;
                    adaptor.addChild(root_0, NEW1209_tree);
                    }

                    }
                    break;

            }


            pushFollow(FOLLOW_type_in_interface_property_declaration10231);
            type1210=type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, type1210.getTree());

            IDENTIFIER1211=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_interface_property_declaration10233); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1211_tree = 
            (Object)adaptor.create(IDENTIFIER1211)
            ;
            adaptor.addChild(root_0, IDENTIFIER1211_tree);
            }

            OPEN_BRACE1212=(Token)match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_interface_property_declaration10235); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            OPEN_BRACE1212_tree = 
            (Object)adaptor.create(OPEN_BRACE1212)
            ;
            adaptor.addChild(root_0, OPEN_BRACE1212_tree);
            }

            pushFollow(FOLLOW_interface_accessors_in_interface_property_declaration10237);
            interface_accessors1213=interface_accessors();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, interface_accessors1213.getTree());

            CLOSE_BRACE1214=(Token)match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_interface_property_declaration10239); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            CLOSE_BRACE1214_tree = 
            (Object)adaptor.create(CLOSE_BRACE1214)
            ;
            adaptor.addChild(root_0, CLOSE_BRACE1214_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "interface_property_declaration"


    public static class interface_accessors_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "interface_accessors"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2127:1: interface_accessors : ( attributes )? ( get_contextual_keyword SEMICOLON ( ( attributes )? set_contextual_keyword SEMICOLON )? | set_contextual_keyword SEMICOLON ( ( attributes )? get_contextual_keyword SEMICOLON )? ) ;
    public final CSharp4AST.interface_accessors_return interface_accessors() throws RecognitionException {
        CSharp4AST.interface_accessors_return retval = new CSharp4AST.interface_accessors_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token SEMICOLON1217=null;
        Token SEMICOLON1220=null;
        Token SEMICOLON1222=null;
        Token SEMICOLON1225=null;
        CSharp4AST.attributes_return attributes1215 =null;

        CSharp4AST.get_contextual_keyword_return get_contextual_keyword1216 =null;

        CSharp4AST.attributes_return attributes1218 =null;

        CSharp4AST.set_contextual_keyword_return set_contextual_keyword1219 =null;

        CSharp4AST.set_contextual_keyword_return set_contextual_keyword1221 =null;

        CSharp4AST.attributes_return attributes1223 =null;

        CSharp4AST.get_contextual_keyword_return get_contextual_keyword1224 =null;


        Object SEMICOLON1217_tree=null;
        Object SEMICOLON1220_tree=null;
        Object SEMICOLON1222_tree=null;
        Object SEMICOLON1225_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2128:3: ( ( attributes )? ( get_contextual_keyword SEMICOLON ( ( attributes )? set_contextual_keyword SEMICOLON )? | set_contextual_keyword SEMICOLON ( ( attributes )? get_contextual_keyword SEMICOLON )? ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2128:5: ( attributes )? ( get_contextual_keyword SEMICOLON ( ( attributes )? set_contextual_keyword SEMICOLON )? | set_contextual_keyword SEMICOLON ( ( attributes )? get_contextual_keyword SEMICOLON )? )
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2128:5: ( attributes )?
            int alt291=2;
            int LA291_0 = input.LA(1);

            if ( (LA291_0==OPEN_BRACKET) ) {
                alt291=1;
            }
            switch (alt291) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2128:5: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_interface_accessors10253);
                    attributes1215=attributes();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, attributes1215.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2129:5: ( get_contextual_keyword SEMICOLON ( ( attributes )? set_contextual_keyword SEMICOLON )? | set_contextual_keyword SEMICOLON ( ( attributes )? get_contextual_keyword SEMICOLON )? )
            int alt296=2;
            int LA296_0 = input.LA(1);

            if ( (LA296_0==IDENTIFIER) ) {
                int LA296_1 = input.LA(2);

                if ( (LA296_1==SEMICOLON) ) {
                    int LA296_2 = input.LA(3);

                    if ( ((input.LT(1).getText().equals("get"))) ) {
                        alt296=1;
                    }
                    else if ( ((input.LT(1).getText().equals("set"))) ) {
                        alt296=2;
                    }
                    else {
                        if (state.backtracking>0) {state.failed=true; return retval;}
                        NoViableAltException nvae =
                            new NoViableAltException("", 296, 2, input);

                        throw nvae;

                    }
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 296, 1, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 296, 0, input);

                throw nvae;

            }
            switch (alt296) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2129:7: get_contextual_keyword SEMICOLON ( ( attributes )? set_contextual_keyword SEMICOLON )?
                    {
                    pushFollow(FOLLOW_get_contextual_keyword_in_interface_accessors10262);
                    get_contextual_keyword1216=get_contextual_keyword();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, get_contextual_keyword1216.getTree());

                    SEMICOLON1217=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_interface_accessors10264); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    SEMICOLON1217_tree = 
                    (Object)adaptor.create(SEMICOLON1217)
                    ;
                    adaptor.addChild(root_0, SEMICOLON1217_tree);
                    }

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2129:40: ( ( attributes )? set_contextual_keyword SEMICOLON )?
                    int alt293=2;
                    int LA293_0 = input.LA(1);

                    if ( (LA293_0==IDENTIFIER||LA293_0==OPEN_BRACKET) ) {
                        alt293=1;
                    }
                    switch (alt293) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2129:41: ( attributes )? set_contextual_keyword SEMICOLON
                            {
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2129:41: ( attributes )?
                            int alt292=2;
                            int LA292_0 = input.LA(1);

                            if ( (LA292_0==OPEN_BRACKET) ) {
                                alt292=1;
                            }
                            switch (alt292) {
                                case 1 :
                                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2129:41: attributes
                                    {
                                    pushFollow(FOLLOW_attributes_in_interface_accessors10267);
                                    attributes1218=attributes();

                                    state._fsp--;
                                    if (state.failed) return retval;
                                    if ( state.backtracking==0 ) adaptor.addChild(root_0, attributes1218.getTree());

                                    }
                                    break;

                            }


                            pushFollow(FOLLOW_set_contextual_keyword_in_interface_accessors10270);
                            set_contextual_keyword1219=set_contextual_keyword();

                            state._fsp--;
                            if (state.failed) return retval;
                            if ( state.backtracking==0 ) adaptor.addChild(root_0, set_contextual_keyword1219.getTree());

                            SEMICOLON1220=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_interface_accessors10272); if (state.failed) return retval;
                            if ( state.backtracking==0 ) {
                            SEMICOLON1220_tree = 
                            (Object)adaptor.create(SEMICOLON1220)
                            ;
                            adaptor.addChild(root_0, SEMICOLON1220_tree);
                            }

                            }
                            break;

                    }


                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2130:7: set_contextual_keyword SEMICOLON ( ( attributes )? get_contextual_keyword SEMICOLON )?
                    {
                    pushFollow(FOLLOW_set_contextual_keyword_in_interface_accessors10282);
                    set_contextual_keyword1221=set_contextual_keyword();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, set_contextual_keyword1221.getTree());

                    SEMICOLON1222=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_interface_accessors10284); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    SEMICOLON1222_tree = 
                    (Object)adaptor.create(SEMICOLON1222)
                    ;
                    adaptor.addChild(root_0, SEMICOLON1222_tree);
                    }

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2130:40: ( ( attributes )? get_contextual_keyword SEMICOLON )?
                    int alt295=2;
                    int LA295_0 = input.LA(1);

                    if ( (LA295_0==IDENTIFIER||LA295_0==OPEN_BRACKET) ) {
                        alt295=1;
                    }
                    switch (alt295) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2130:41: ( attributes )? get_contextual_keyword SEMICOLON
                            {
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2130:41: ( attributes )?
                            int alt294=2;
                            int LA294_0 = input.LA(1);

                            if ( (LA294_0==OPEN_BRACKET) ) {
                                alt294=1;
                            }
                            switch (alt294) {
                                case 1 :
                                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2130:41: attributes
                                    {
                                    pushFollow(FOLLOW_attributes_in_interface_accessors10287);
                                    attributes1223=attributes();

                                    state._fsp--;
                                    if (state.failed) return retval;
                                    if ( state.backtracking==0 ) adaptor.addChild(root_0, attributes1223.getTree());

                                    }
                                    break;

                            }


                            pushFollow(FOLLOW_get_contextual_keyword_in_interface_accessors10290);
                            get_contextual_keyword1224=get_contextual_keyword();

                            state._fsp--;
                            if (state.failed) return retval;
                            if ( state.backtracking==0 ) adaptor.addChild(root_0, get_contextual_keyword1224.getTree());

                            SEMICOLON1225=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_interface_accessors10292); if (state.failed) return retval;
                            if ( state.backtracking==0 ) {
                            SEMICOLON1225_tree = 
                            (Object)adaptor.create(SEMICOLON1225)
                            ;
                            adaptor.addChild(root_0, SEMICOLON1225_tree);
                            }

                            }
                            break;

                    }


                    }
                    break;

            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "interface_accessors"


    public static class interface_event_declaration_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "interface_event_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2133:1: interface_event_declaration : ( attributes )? ( NEW )? EVENT type IDENTIFIER SEMICOLON ;
    public final CSharp4AST.interface_event_declaration_return interface_event_declaration() throws RecognitionException {
        CSharp4AST.interface_event_declaration_return retval = new CSharp4AST.interface_event_declaration_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token NEW1227=null;
        Token EVENT1228=null;
        Token IDENTIFIER1230=null;
        Token SEMICOLON1231=null;
        CSharp4AST.attributes_return attributes1226 =null;

        CSharp4AST.type_return type1229 =null;


        Object NEW1227_tree=null;
        Object EVENT1228_tree=null;
        Object IDENTIFIER1230_tree=null;
        Object SEMICOLON1231_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2134:2: ( ( attributes )? ( NEW )? EVENT type IDENTIFIER SEMICOLON )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2134:4: ( attributes )? ( NEW )? EVENT type IDENTIFIER SEMICOLON
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2134:4: ( attributes )?
            int alt297=2;
            int LA297_0 = input.LA(1);

            if ( (LA297_0==OPEN_BRACKET) ) {
                alt297=1;
            }
            switch (alt297) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2134:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_interface_event_declaration10312);
                    attributes1226=attributes();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, attributes1226.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2134:16: ( NEW )?
            int alt298=2;
            int LA298_0 = input.LA(1);

            if ( (LA298_0==NEW) ) {
                alt298=1;
            }
            switch (alt298) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2134:16: NEW
                    {
                    NEW1227=(Token)match(input,NEW,FOLLOW_NEW_in_interface_event_declaration10315); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    NEW1227_tree = 
                    (Object)adaptor.create(NEW1227)
                    ;
                    adaptor.addChild(root_0, NEW1227_tree);
                    }

                    }
                    break;

            }


            EVENT1228=(Token)match(input,EVENT,FOLLOW_EVENT_in_interface_event_declaration10318); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            EVENT1228_tree = 
            (Object)adaptor.create(EVENT1228)
            ;
            adaptor.addChild(root_0, EVENT1228_tree);
            }

            pushFollow(FOLLOW_type_in_interface_event_declaration10320);
            type1229=type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, type1229.getTree());

            IDENTIFIER1230=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_interface_event_declaration10322); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1230_tree = 
            (Object)adaptor.create(IDENTIFIER1230)
            ;
            adaptor.addChild(root_0, IDENTIFIER1230_tree);
            }

            SEMICOLON1231=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_interface_event_declaration10324); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            SEMICOLON1231_tree = 
            (Object)adaptor.create(SEMICOLON1231)
            ;
            adaptor.addChild(root_0, SEMICOLON1231_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "interface_event_declaration"


    public static class interface_indexer_declaration_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "interface_indexer_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2136:1: interface_indexer_declaration : ( attributes )? ( NEW )? type THIS OPEN_BRACKET formal_parameter_list CLOSE_BRACKET OPEN_BRACE interface_accessors CLOSE_BRACE ;
    public final CSharp4AST.interface_indexer_declaration_return interface_indexer_declaration() throws RecognitionException {
        CSharp4AST.interface_indexer_declaration_return retval = new CSharp4AST.interface_indexer_declaration_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token NEW1233=null;
        Token THIS1235=null;
        Token OPEN_BRACKET1236=null;
        Token CLOSE_BRACKET1238=null;
        Token OPEN_BRACE1239=null;
        Token CLOSE_BRACE1241=null;
        CSharp4AST.attributes_return attributes1232 =null;

        CSharp4AST.type_return type1234 =null;

        CSharp4AST.formal_parameter_list_return formal_parameter_list1237 =null;

        CSharp4AST.interface_accessors_return interface_accessors1240 =null;


        Object NEW1233_tree=null;
        Object THIS1235_tree=null;
        Object OPEN_BRACKET1236_tree=null;
        Object CLOSE_BRACKET1238_tree=null;
        Object OPEN_BRACE1239_tree=null;
        Object CLOSE_BRACE1241_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2137:2: ( ( attributes )? ( NEW )? type THIS OPEN_BRACKET formal_parameter_list CLOSE_BRACKET OPEN_BRACE interface_accessors CLOSE_BRACE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2137:4: ( attributes )? ( NEW )? type THIS OPEN_BRACKET formal_parameter_list CLOSE_BRACKET OPEN_BRACE interface_accessors CLOSE_BRACE
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2137:4: ( attributes )?
            int alt299=2;
            int LA299_0 = input.LA(1);

            if ( (LA299_0==OPEN_BRACKET) ) {
                alt299=1;
            }
            switch (alt299) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2137:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_interface_indexer_declaration10335);
                    attributes1232=attributes();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, attributes1232.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2137:16: ( NEW )?
            int alt300=2;
            int LA300_0 = input.LA(1);

            if ( (LA300_0==NEW) ) {
                alt300=1;
            }
            switch (alt300) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2137:16: NEW
                    {
                    NEW1233=(Token)match(input,NEW,FOLLOW_NEW_in_interface_indexer_declaration10338); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    NEW1233_tree = 
                    (Object)adaptor.create(NEW1233)
                    ;
                    adaptor.addChild(root_0, NEW1233_tree);
                    }

                    }
                    break;

            }


            pushFollow(FOLLOW_type_in_interface_indexer_declaration10341);
            type1234=type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, type1234.getTree());

            THIS1235=(Token)match(input,THIS,FOLLOW_THIS_in_interface_indexer_declaration10343); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            THIS1235_tree = 
            (Object)adaptor.create(THIS1235)
            ;
            adaptor.addChild(root_0, THIS1235_tree);
            }

            OPEN_BRACKET1236=(Token)match(input,OPEN_BRACKET,FOLLOW_OPEN_BRACKET_in_interface_indexer_declaration10345); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            OPEN_BRACKET1236_tree = 
            (Object)adaptor.create(OPEN_BRACKET1236)
            ;
            adaptor.addChild(root_0, OPEN_BRACKET1236_tree);
            }

            pushFollow(FOLLOW_formal_parameter_list_in_interface_indexer_declaration10347);
            formal_parameter_list1237=formal_parameter_list();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, formal_parameter_list1237.getTree());

            CLOSE_BRACKET1238=(Token)match(input,CLOSE_BRACKET,FOLLOW_CLOSE_BRACKET_in_interface_indexer_declaration10349); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            CLOSE_BRACKET1238_tree = 
            (Object)adaptor.create(CLOSE_BRACKET1238)
            ;
            adaptor.addChild(root_0, CLOSE_BRACKET1238_tree);
            }

            OPEN_BRACE1239=(Token)match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_interface_indexer_declaration10351); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            OPEN_BRACE1239_tree = 
            (Object)adaptor.create(OPEN_BRACE1239)
            ;
            adaptor.addChild(root_0, OPEN_BRACE1239_tree);
            }

            pushFollow(FOLLOW_interface_accessors_in_interface_indexer_declaration10353);
            interface_accessors1240=interface_accessors();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, interface_accessors1240.getTree());

            CLOSE_BRACE1241=(Token)match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_interface_indexer_declaration10355); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            CLOSE_BRACE1241_tree = 
            (Object)adaptor.create(CLOSE_BRACE1241)
            ;
            adaptor.addChild(root_0, CLOSE_BRACE1241_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "interface_indexer_declaration"


    public static class enum_declaration_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "enum_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2142:1: enum_declaration : ( attributes )? ( enum_modifiers )? ENUM IDENTIFIER ( enum_base )? enum_body ( SEMICOLON )? ;
    public final CSharp4AST.enum_declaration_return enum_declaration() throws RecognitionException {
        CSharp4AST.enum_declaration_return retval = new CSharp4AST.enum_declaration_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token ENUM1244=null;
        Token IDENTIFIER1245=null;
        Token SEMICOLON1248=null;
        CSharp4AST.attributes_return attributes1242 =null;

        CSharp4AST.enum_modifiers_return enum_modifiers1243 =null;

        CSharp4AST.enum_base_return enum_base1246 =null;

        CSharp4AST.enum_body_return enum_body1247 =null;


        Object ENUM1244_tree=null;
        Object IDENTIFIER1245_tree=null;
        Object SEMICOLON1248_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2143:2: ( ( attributes )? ( enum_modifiers )? ENUM IDENTIFIER ( enum_base )? enum_body ( SEMICOLON )? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2143:4: ( attributes )? ( enum_modifiers )? ENUM IDENTIFIER ( enum_base )? enum_body ( SEMICOLON )?
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2143:4: ( attributes )?
            int alt301=2;
            int LA301_0 = input.LA(1);

            if ( (LA301_0==OPEN_BRACKET) ) {
                alt301=1;
            }
            switch (alt301) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2143:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_enum_declaration10369);
                    attributes1242=attributes();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, attributes1242.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2143:16: ( enum_modifiers )?
            int alt302=2;
            int LA302_0 = input.LA(1);

            if ( (LA302_0==INTERNAL||LA302_0==NEW||(LA302_0 >= PRIVATE && LA302_0 <= PUBLIC)) ) {
                alt302=1;
            }
            switch (alt302) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2143:16: enum_modifiers
                    {
                    pushFollow(FOLLOW_enum_modifiers_in_enum_declaration10372);
                    enum_modifiers1243=enum_modifiers();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, enum_modifiers1243.getTree());

                    }
                    break;

            }


            ENUM1244=(Token)match(input,ENUM,FOLLOW_ENUM_in_enum_declaration10375); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            ENUM1244_tree = 
            (Object)adaptor.create(ENUM1244)
            ;
            adaptor.addChild(root_0, ENUM1244_tree);
            }

            IDENTIFIER1245=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_enum_declaration10377); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1245_tree = 
            (Object)adaptor.create(IDENTIFIER1245)
            ;
            adaptor.addChild(root_0, IDENTIFIER1245_tree);
            }

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2143:48: ( enum_base )?
            int alt303=2;
            int LA303_0 = input.LA(1);

            if ( (LA303_0==COLON) ) {
                alt303=1;
            }
            switch (alt303) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2143:48: enum_base
                    {
                    pushFollow(FOLLOW_enum_base_in_enum_declaration10379);
                    enum_base1246=enum_base();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, enum_base1246.getTree());

                    }
                    break;

            }


            pushFollow(FOLLOW_enum_body_in_enum_declaration10382);
            enum_body1247=enum_body();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, enum_body1247.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2143:69: ( SEMICOLON )?
            int alt304=2;
            int LA304_0 = input.LA(1);

            if ( (LA304_0==SEMICOLON) ) {
                alt304=1;
            }
            switch (alt304) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2143:69: SEMICOLON
                    {
                    SEMICOLON1248=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_enum_declaration10384); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    SEMICOLON1248_tree = 
                    (Object)adaptor.create(SEMICOLON1248)
                    ;
                    adaptor.addChild(root_0, SEMICOLON1248_tree);
                    }

                    }
                    break;

            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "enum_declaration"


    public static class enum_base_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "enum_base"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2145:1: enum_base : COLON integral_type -> ^( ENUM_EXTENDS integral_type ) ;
    public final CSharp4AST.enum_base_return enum_base() throws RecognitionException {
        CSharp4AST.enum_base_return retval = new CSharp4AST.enum_base_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token COLON1249=null;
        CSharp4AST.integral_type_return integral_type1250 =null;


        Object COLON1249_tree=null;
        RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
        RewriteRuleSubtreeStream stream_integral_type=new RewriteRuleSubtreeStream(adaptor,"rule integral_type");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2146:2: ( COLON integral_type -> ^( ENUM_EXTENDS integral_type ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2146:4: COLON integral_type
            {
            COLON1249=(Token)match(input,COLON,FOLLOW_COLON_in_enum_base10396); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_COLON.add(COLON1249);


            pushFollow(FOLLOW_integral_type_in_enum_base10398);
            integral_type1250=integral_type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_integral_type.add(integral_type1250.getTree());

            // AST REWRITE
            // elements: integral_type
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 2147:4: -> ^( ENUM_EXTENDS integral_type )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2147:7: ^( ENUM_EXTENDS integral_type )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(ENUM_EXTENDS, "ENUM_EXTENDS")
                , root_1);

                adaptor.addChild(root_1, stream_integral_type.nextTree());

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "enum_base"


    public static class enum_body_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "enum_body"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2155:1: enum_body : ( OPEN_BRACE ! CLOSE_BRACE !| OPEN_BRACE ! enum_member_declarations ( COMMA !)? CLOSE_BRACE !);
    public final CSharp4AST.enum_body_return enum_body() throws RecognitionException {
        CSharp4AST.enum_body_return retval = new CSharp4AST.enum_body_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token OPEN_BRACE1251=null;
        Token CLOSE_BRACE1252=null;
        Token OPEN_BRACE1253=null;
        Token COMMA1255=null;
        Token CLOSE_BRACE1256=null;
        CSharp4AST.enum_member_declarations_return enum_member_declarations1254 =null;


        Object OPEN_BRACE1251_tree=null;
        Object CLOSE_BRACE1252_tree=null;
        Object OPEN_BRACE1253_tree=null;
        Object COMMA1255_tree=null;
        Object CLOSE_BRACE1256_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2156:3: ( OPEN_BRACE ! CLOSE_BRACE !| OPEN_BRACE ! enum_member_declarations ( COMMA !)? CLOSE_BRACE !)
            int alt306=2;
            int LA306_0 = input.LA(1);

            if ( (LA306_0==OPEN_BRACE) ) {
                int LA306_1 = input.LA(2);

                if ( (LA306_1==CLOSE_BRACE) ) {
                    alt306=1;
                }
                else if ( (LA306_1==IDENTIFIER||LA306_1==OPEN_BRACKET) ) {
                    alt306=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 306, 1, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 306, 0, input);

                throw nvae;

            }
            switch (alt306) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2156:5: OPEN_BRACE ! CLOSE_BRACE !
                    {
                    root_0 = (Object)adaptor.nil();


                    OPEN_BRACE1251=(Token)match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_enum_body10423); if (state.failed) return retval;

                    CLOSE_BRACE1252=(Token)match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_enum_body10426); if (state.failed) return retval;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2157:5: OPEN_BRACE ! enum_member_declarations ( COMMA !)? CLOSE_BRACE !
                    {
                    root_0 = (Object)adaptor.nil();


                    OPEN_BRACE1253=(Token)match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_enum_body10433); if (state.failed) return retval;

                    pushFollow(FOLLOW_enum_member_declarations_in_enum_body10436);
                    enum_member_declarations1254=enum_member_declarations();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, enum_member_declarations1254.getTree());

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2157:47: ( COMMA !)?
                    int alt305=2;
                    int LA305_0 = input.LA(1);

                    if ( (LA305_0==COMMA) ) {
                        alt305=1;
                    }
                    switch (alt305) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2157:47: COMMA !
                            {
                            COMMA1255=(Token)match(input,COMMA,FOLLOW_COMMA_in_enum_body10438); if (state.failed) return retval;

                            }
                            break;

                    }


                    CLOSE_BRACE1256=(Token)match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_enum_body10442); if (state.failed) return retval;

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "enum_body"


    public static class enum_modifiers_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "enum_modifiers"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2159:1: enum_modifiers : ( enum_modifier )+ ;
    public final CSharp4AST.enum_modifiers_return enum_modifiers() throws RecognitionException {
        CSharp4AST.enum_modifiers_return retval = new CSharp4AST.enum_modifiers_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.enum_modifier_return enum_modifier1257 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2160:2: ( ( enum_modifier )+ )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2160:4: ( enum_modifier )+
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2160:4: ( enum_modifier )+
            int cnt307=0;
            loop307:
            do {
                int alt307=2;
                int LA307_0 = input.LA(1);

                if ( (LA307_0==INTERNAL||LA307_0==NEW||(LA307_0 >= PRIVATE && LA307_0 <= PUBLIC)) ) {
                    alt307=1;
                }


                switch (alt307) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2160:4: enum_modifier
            	    {
            	    pushFollow(FOLLOW_enum_modifier_in_enum_modifiers10455);
            	    enum_modifier1257=enum_modifier();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, enum_modifier1257.getTree());

            	    }
            	    break;

            	default :
            	    if ( cnt307 >= 1 ) break loop307;
            	    if (state.backtracking>0) {state.failed=true; return retval;}
                        EarlyExitException eee =
                            new EarlyExitException(307, input);
                        throw eee;
                }
                cnt307++;
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "enum_modifiers"


    public static class enum_modifier_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "enum_modifier"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2162:1: enum_modifier : ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE );
    public final CSharp4AST.enum_modifier_return enum_modifier() throws RecognitionException {
        CSharp4AST.enum_modifier_return retval = new CSharp4AST.enum_modifier_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token set1258=null;

        Object set1258_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2163:2: ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:
            {
            root_0 = (Object)adaptor.nil();


            set1258=(Token)input.LT(1);

            if ( input.LA(1)==INTERNAL||input.LA(1)==NEW||(input.LA(1) >= PRIVATE && input.LA(1) <= PUBLIC) ) {
                input.consume();
                if ( state.backtracking==0 ) adaptor.addChild(root_0, 
                (Object)adaptor.create(set1258)
                );
                state.errorRecovery=false;
                state.failed=false;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                MismatchedSetException mse = new MismatchedSetException(null,input);
                throw mse;
            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "enum_modifier"


    public static class enum_member_declarations_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "enum_member_declarations"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2169:1: enum_member_declarations : enum_member_declaration ( COMMA enum_member_declaration )* -> ^( ENUM_MEMBER_DECLARATIONS ( enum_member_declaration )+ ) ;
    public final CSharp4AST.enum_member_declarations_return enum_member_declarations() throws RecognitionException {
        CSharp4AST.enum_member_declarations_return retval = new CSharp4AST.enum_member_declarations_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token COMMA1260=null;
        CSharp4AST.enum_member_declaration_return enum_member_declaration1259 =null;

        CSharp4AST.enum_member_declaration_return enum_member_declaration1261 =null;


        Object COMMA1260_tree=null;
        RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
        RewriteRuleSubtreeStream stream_enum_member_declaration=new RewriteRuleSubtreeStream(adaptor,"rule enum_member_declaration");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2170:2: ( enum_member_declaration ( COMMA enum_member_declaration )* -> ^( ENUM_MEMBER_DECLARATIONS ( enum_member_declaration )+ ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2170:4: enum_member_declaration ( COMMA enum_member_declaration )*
            {
            pushFollow(FOLLOW_enum_member_declaration_in_enum_member_declarations10498);
            enum_member_declaration1259=enum_member_declaration();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_enum_member_declaration.add(enum_member_declaration1259.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2170:28: ( COMMA enum_member_declaration )*
            loop308:
            do {
                int alt308=2;
                int LA308_0 = input.LA(1);

                if ( (LA308_0==COMMA) ) {
                    int LA308_1 = input.LA(2);

                    if ( (LA308_1==IDENTIFIER||LA308_1==OPEN_BRACKET) ) {
                        alt308=1;
                    }


                }


                switch (alt308) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2170:30: COMMA enum_member_declaration
            	    {
            	    COMMA1260=(Token)match(input,COMMA,FOLLOW_COMMA_in_enum_member_declarations10502); if (state.failed) return retval; 
            	    if ( state.backtracking==0 ) stream_COMMA.add(COMMA1260);


            	    pushFollow(FOLLOW_enum_member_declaration_in_enum_member_declarations10505);
            	    enum_member_declaration1261=enum_member_declaration();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) stream_enum_member_declaration.add(enum_member_declaration1261.getTree());

            	    }
            	    break;

            	default :
            	    break loop308;
                }
            } while (true);


            // AST REWRITE
            // elements: enum_member_declaration
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 2171:4: -> ^( ENUM_MEMBER_DECLARATIONS ( enum_member_declaration )+ )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2171:7: ^( ENUM_MEMBER_DECLARATIONS ( enum_member_declaration )+ )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(ENUM_MEMBER_DECLARATIONS, "ENUM_MEMBER_DECLARATIONS")
                , root_1);

                if ( !(stream_enum_member_declaration.hasNext()) ) {
                    throw new RewriteEarlyExitException();
                }
                while ( stream_enum_member_declaration.hasNext() ) {
                    adaptor.addChild(root_1, stream_enum_member_declaration.nextTree());

                }
                stream_enum_member_declaration.reset();

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "enum_member_declarations"


    public static class enum_member_declaration_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "enum_member_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2179:1: enum_member_declaration : ( attributes )? IDENTIFIER ( ASSIGNMENT constant_expression )? -> ^( ENUM_MEMBER_DECLARATION ( attributes )? IDENTIFIER ( ^( ENUM_MEMBER_INITIALIZER constant_expression ) )? ) ;
    public final CSharp4AST.enum_member_declaration_return enum_member_declaration() throws RecognitionException {
        CSharp4AST.enum_member_declaration_return retval = new CSharp4AST.enum_member_declaration_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER1263=null;
        Token ASSIGNMENT1264=null;
        CSharp4AST.attributes_return attributes1262 =null;

        CSharp4AST.constant_expression_return constant_expression1265 =null;


        Object IDENTIFIER1263_tree=null;
        Object ASSIGNMENT1264_tree=null;
        RewriteRuleTokenStream stream_ASSIGNMENT=new RewriteRuleTokenStream(adaptor,"token ASSIGNMENT");
        RewriteRuleTokenStream stream_IDENTIFIER=new RewriteRuleTokenStream(adaptor,"token IDENTIFIER");
        RewriteRuleSubtreeStream stream_constant_expression=new RewriteRuleSubtreeStream(adaptor,"rule constant_expression");
        RewriteRuleSubtreeStream stream_attributes=new RewriteRuleSubtreeStream(adaptor,"rule attributes");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2180:3: ( ( attributes )? IDENTIFIER ( ASSIGNMENT constant_expression )? -> ^( ENUM_MEMBER_DECLARATION ( attributes )? IDENTIFIER ( ^( ENUM_MEMBER_INITIALIZER constant_expression ) )? ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2180:5: ( attributes )? IDENTIFIER ( ASSIGNMENT constant_expression )?
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2180:5: ( attributes )?
            int alt309=2;
            int LA309_0 = input.LA(1);

            if ( (LA309_0==OPEN_BRACKET) ) {
                alt309=1;
            }
            switch (alt309) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2180:5: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_enum_member_declaration10534);
                    attributes1262=attributes();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) stream_attributes.add(attributes1262.getTree());

                    }
                    break;

            }


            IDENTIFIER1263=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_enum_member_declaration10537); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_IDENTIFIER.add(IDENTIFIER1263);


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2180:28: ( ASSIGNMENT constant_expression )?
            int alt310=2;
            int LA310_0 = input.LA(1);

            if ( (LA310_0==ASSIGNMENT) ) {
                alt310=1;
            }
            switch (alt310) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2180:29: ASSIGNMENT constant_expression
                    {
                    ASSIGNMENT1264=(Token)match(input,ASSIGNMENT,FOLLOW_ASSIGNMENT_in_enum_member_declaration10540); if (state.failed) return retval; 
                    if ( state.backtracking==0 ) stream_ASSIGNMENT.add(ASSIGNMENT1264);


                    pushFollow(FOLLOW_constant_expression_in_enum_member_declaration10542);
                    constant_expression1265=constant_expression();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) stream_constant_expression.add(constant_expression1265.getTree());

                    }
                    break;

            }


            // AST REWRITE
            // elements: constant_expression, attributes, IDENTIFIER
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 2181:5: -> ^( ENUM_MEMBER_DECLARATION ( attributes )? IDENTIFIER ( ^( ENUM_MEMBER_INITIALIZER constant_expression ) )? )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2181:8: ^( ENUM_MEMBER_DECLARATION ( attributes )? IDENTIFIER ( ^( ENUM_MEMBER_INITIALIZER constant_expression ) )? )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(ENUM_MEMBER_DECLARATION, "ENUM_MEMBER_DECLARATION")
                , root_1);

                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2181:34: ( attributes )?
                if ( stream_attributes.hasNext() ) {
                    adaptor.addChild(root_1, stream_attributes.nextTree());

                }
                stream_attributes.reset();

                adaptor.addChild(root_1, 
                stream_IDENTIFIER.nextNode()
                );

                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2181:57: ( ^( ENUM_MEMBER_INITIALIZER constant_expression ) )?
                if ( stream_constant_expression.hasNext() ) {
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2181:57: ^( ENUM_MEMBER_INITIALIZER constant_expression )
                    {
                    Object root_2 = (Object)adaptor.nil();
                    root_2 = (Object)adaptor.becomeRoot(
                    (Object)adaptor.create(ENUM_MEMBER_INITIALIZER, "ENUM_MEMBER_INITIALIZER")
                    , root_2);

                    adaptor.addChild(root_2, stream_constant_expression.nextTree());

                    adaptor.addChild(root_1, root_2);
                    }

                }
                stream_constant_expression.reset();

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "enum_member_declaration"


    public static class delegate_declaration_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "delegate_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2186:1: delegate_declaration : ( attributes )? ( delegate_modifiers )? DELEGATE return_type IDENTIFIER ( variant_type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? SEMICOLON ;
    public final CSharp4AST.delegate_declaration_return delegate_declaration() throws RecognitionException {
        CSharp4AST.delegate_declaration_return retval = new CSharp4AST.delegate_declaration_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token DELEGATE1268=null;
        Token IDENTIFIER1270=null;
        Token OPEN_PARENS1272=null;
        Token CLOSE_PARENS1274=null;
        Token SEMICOLON1276=null;
        CSharp4AST.attributes_return attributes1266 =null;

        CSharp4AST.delegate_modifiers_return delegate_modifiers1267 =null;

        CSharp4AST.return_type_return return_type1269 =null;

        CSharp4AST.variant_type_parameter_list_return variant_type_parameter_list1271 =null;

        CSharp4AST.formal_parameter_list_return formal_parameter_list1273 =null;

        CSharp4AST.type_parameter_constraints_clauses_return type_parameter_constraints_clauses1275 =null;


        Object DELEGATE1268_tree=null;
        Object IDENTIFIER1270_tree=null;
        Object OPEN_PARENS1272_tree=null;
        Object CLOSE_PARENS1274_tree=null;
        Object SEMICOLON1276_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2187:2: ( ( attributes )? ( delegate_modifiers )? DELEGATE return_type IDENTIFIER ( variant_type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? SEMICOLON )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2187:4: ( attributes )? ( delegate_modifiers )? DELEGATE return_type IDENTIFIER ( variant_type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? SEMICOLON
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2187:4: ( attributes )?
            int alt311=2;
            int LA311_0 = input.LA(1);

            if ( (LA311_0==OPEN_BRACKET) ) {
                alt311=1;
            }
            switch (alt311) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2187:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_delegate_declaration10583);
                    attributes1266=attributes();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, attributes1266.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2187:16: ( delegate_modifiers )?
            int alt312=2;
            int LA312_0 = input.LA(1);

            if ( (LA312_0==INTERNAL||LA312_0==NEW||(LA312_0 >= PRIVATE && LA312_0 <= PUBLIC)||LA312_0==UNSAFE) ) {
                alt312=1;
            }
            switch (alt312) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2187:16: delegate_modifiers
                    {
                    pushFollow(FOLLOW_delegate_modifiers_in_delegate_declaration10586);
                    delegate_modifiers1267=delegate_modifiers();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, delegate_modifiers1267.getTree());

                    }
                    break;

            }


            DELEGATE1268=(Token)match(input,DELEGATE,FOLLOW_DELEGATE_in_delegate_declaration10589); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            DELEGATE1268_tree = 
            (Object)adaptor.create(DELEGATE1268)
            ;
            adaptor.addChild(root_0, DELEGATE1268_tree);
            }

            pushFollow(FOLLOW_return_type_in_delegate_declaration10591);
            return_type1269=return_type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, return_type1269.getTree());

            IDENTIFIER1270=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_delegate_declaration10593); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1270_tree = 
            (Object)adaptor.create(IDENTIFIER1270)
            ;
            adaptor.addChild(root_0, IDENTIFIER1270_tree);
            }

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2187:68: ( variant_type_parameter_list )?
            int alt313=2;
            int LA313_0 = input.LA(1);

            if ( (LA313_0==LT) ) {
                alt313=1;
            }
            switch (alt313) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2187:68: variant_type_parameter_list
                    {
                    pushFollow(FOLLOW_variant_type_parameter_list_in_delegate_declaration10595);
                    variant_type_parameter_list1271=variant_type_parameter_list();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, variant_type_parameter_list1271.getTree());

                    }
                    break;

            }


            OPEN_PARENS1272=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_delegate_declaration10604); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            OPEN_PARENS1272_tree = 
            (Object)adaptor.create(OPEN_PARENS1272)
            ;
            adaptor.addChild(root_0, OPEN_PARENS1272_tree);
            }

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2188:18: ( formal_parameter_list )?
            int alt314=2;
            int LA314_0 = input.LA(1);

            if ( (LA314_0==BOOL||LA314_0==BYTE||LA314_0==CHAR||LA314_0==DECIMAL||LA314_0==DOUBLE||LA314_0==FLOAT||LA314_0==IDENTIFIER||LA314_0==INT||LA314_0==LONG||LA314_0==OBJECT||LA314_0==OPEN_BRACKET||LA314_0==OUT||LA314_0==PARAMS||LA314_0==REF||LA314_0==SBYTE||LA314_0==SHORT||LA314_0==STRING||LA314_0==THIS||(LA314_0 >= UINT && LA314_0 <= ULONG)||LA314_0==USHORT||LA314_0==VOID) ) {
                alt314=1;
            }
            switch (alt314) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2188:18: formal_parameter_list
                    {
                    pushFollow(FOLLOW_formal_parameter_list_in_delegate_declaration10606);
                    formal_parameter_list1273=formal_parameter_list();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, formal_parameter_list1273.getTree());

                    }
                    break;

            }


            CLOSE_PARENS1274=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_delegate_declaration10609); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            CLOSE_PARENS1274_tree = 
            (Object)adaptor.create(CLOSE_PARENS1274)
            ;
            adaptor.addChild(root_0, CLOSE_PARENS1274_tree);
            }

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2188:54: ( type_parameter_constraints_clauses )?
            int alt315=2;
            int LA315_0 = input.LA(1);

            if ( (LA315_0==IDENTIFIER) ) {
                alt315=1;
            }
            switch (alt315) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2188:54: type_parameter_constraints_clauses
                    {
                    pushFollow(FOLLOW_type_parameter_constraints_clauses_in_delegate_declaration10611);
                    type_parameter_constraints_clauses1275=type_parameter_constraints_clauses();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, type_parameter_constraints_clauses1275.getTree());

                    }
                    break;

            }


            SEMICOLON1276=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_delegate_declaration10614); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            SEMICOLON1276_tree = 
            (Object)adaptor.create(SEMICOLON1276)
            ;
            adaptor.addChild(root_0, SEMICOLON1276_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "delegate_declaration"


    public static class delegate_modifiers_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "delegate_modifiers"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2190:1: delegate_modifiers : delegate_modifier ( delegate_modifier )* ;
    public final CSharp4AST.delegate_modifiers_return delegate_modifiers() throws RecognitionException {
        CSharp4AST.delegate_modifiers_return retval = new CSharp4AST.delegate_modifiers_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.delegate_modifier_return delegate_modifier1277 =null;

        CSharp4AST.delegate_modifier_return delegate_modifier1278 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2191:2: ( delegate_modifier ( delegate_modifier )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2191:4: delegate_modifier ( delegate_modifier )*
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_delegate_modifier_in_delegate_modifiers10625);
            delegate_modifier1277=delegate_modifier();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, delegate_modifier1277.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2191:22: ( delegate_modifier )*
            loop316:
            do {
                int alt316=2;
                int LA316_0 = input.LA(1);

                if ( (LA316_0==INTERNAL||LA316_0==NEW||(LA316_0 >= PRIVATE && LA316_0 <= PUBLIC)||LA316_0==UNSAFE) ) {
                    alt316=1;
                }


                switch (alt316) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2191:24: delegate_modifier
            	    {
            	    pushFollow(FOLLOW_delegate_modifier_in_delegate_modifiers10629);
            	    delegate_modifier1278=delegate_modifier();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, delegate_modifier1278.getTree());

            	    }
            	    break;

            	default :
            	    break loop316;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "delegate_modifiers"


    public static class delegate_modifier_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "delegate_modifier"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2193:1: delegate_modifier : ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | delegate_modifier_unsafe );
    public final CSharp4AST.delegate_modifier_return delegate_modifier() throws RecognitionException {
        CSharp4AST.delegate_modifier_return retval = new CSharp4AST.delegate_modifier_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token NEW1279=null;
        Token PUBLIC1280=null;
        Token PROTECTED1281=null;
        Token INTERNAL1282=null;
        Token PRIVATE1283=null;
        CSharp4AST.delegate_modifier_unsafe_return delegate_modifier_unsafe1284 =null;


        Object NEW1279_tree=null;
        Object PUBLIC1280_tree=null;
        Object PROTECTED1281_tree=null;
        Object INTERNAL1282_tree=null;
        Object PRIVATE1283_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2194:2: ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | delegate_modifier_unsafe )
            int alt317=6;
            switch ( input.LA(1) ) {
            case NEW:
                {
                alt317=1;
                }
                break;
            case PUBLIC:
                {
                alt317=2;
                }
                break;
            case PROTECTED:
                {
                alt317=3;
                }
                break;
            case INTERNAL:
                {
                alt317=4;
                }
                break;
            case PRIVATE:
                {
                alt317=5;
                }
                break;
            case UNSAFE:
                {
                alt317=6;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 317, 0, input);

                throw nvae;

            }

            switch (alt317) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2194:4: NEW
                    {
                    root_0 = (Object)adaptor.nil();


                    NEW1279=(Token)match(input,NEW,FOLLOW_NEW_in_delegate_modifier10643); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    NEW1279_tree = 
                    (Object)adaptor.create(NEW1279)
                    ;
                    adaptor.addChild(root_0, NEW1279_tree);
                    }

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2195:4: PUBLIC
                    {
                    root_0 = (Object)adaptor.nil();


                    PUBLIC1280=(Token)match(input,PUBLIC,FOLLOW_PUBLIC_in_delegate_modifier10648); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PUBLIC1280_tree = 
                    (Object)adaptor.create(PUBLIC1280)
                    ;
                    adaptor.addChild(root_0, PUBLIC1280_tree);
                    }

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2196:4: PROTECTED
                    {
                    root_0 = (Object)adaptor.nil();


                    PROTECTED1281=(Token)match(input,PROTECTED,FOLLOW_PROTECTED_in_delegate_modifier10653); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PROTECTED1281_tree = 
                    (Object)adaptor.create(PROTECTED1281)
                    ;
                    adaptor.addChild(root_0, PROTECTED1281_tree);
                    }

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2197:4: INTERNAL
                    {
                    root_0 = (Object)adaptor.nil();


                    INTERNAL1282=(Token)match(input,INTERNAL,FOLLOW_INTERNAL_in_delegate_modifier10658); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    INTERNAL1282_tree = 
                    (Object)adaptor.create(INTERNAL1282)
                    ;
                    adaptor.addChild(root_0, INTERNAL1282_tree);
                    }

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2198:4: PRIVATE
                    {
                    root_0 = (Object)adaptor.nil();


                    PRIVATE1283=(Token)match(input,PRIVATE,FOLLOW_PRIVATE_in_delegate_modifier10663); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    PRIVATE1283_tree = 
                    (Object)adaptor.create(PRIVATE1283)
                    ;
                    adaptor.addChild(root_0, PRIVATE1283_tree);
                    }

                    }
                    break;
                case 6 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2199:4: delegate_modifier_unsafe
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_delegate_modifier_unsafe_in_delegate_modifier10668);
                    delegate_modifier_unsafe1284=delegate_modifier_unsafe();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, delegate_modifier_unsafe1284.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "delegate_modifier"


    public static class global_attributes_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "global_attributes"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2205:1: global_attributes : global_attribute_sections ;
    public final CSharp4AST.global_attributes_return global_attributes() throws RecognitionException {
        CSharp4AST.global_attributes_return retval = new CSharp4AST.global_attributes_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.global_attribute_sections_return global_attribute_sections1285 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2206:2: ( global_attribute_sections )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2206:4: global_attribute_sections
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_global_attribute_sections_in_global_attributes10683);
            global_attribute_sections1285=global_attribute_sections();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, global_attribute_sections1285.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "global_attributes"


    public static class global_attribute_sections_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "global_attribute_sections"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2208:1: global_attribute_sections : ( global_attribute_section )+ ;
    public final CSharp4AST.global_attribute_sections_return global_attribute_sections() throws RecognitionException {
        CSharp4AST.global_attribute_sections_return retval = new CSharp4AST.global_attribute_sections_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.global_attribute_section_return global_attribute_section1286 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2209:2: ( ( global_attribute_section )+ )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2209:4: ( global_attribute_section )+
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2209:4: ( global_attribute_section )+
            int cnt318=0;
            loop318:
            do {
                int alt318=2;
                int LA318_0 = input.LA(1);

                if ( (LA318_0==OPEN_BRACKET) ) {
                    alt318=1;
                }


                switch (alt318) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2209:4: global_attribute_section
            	    {
            	    pushFollow(FOLLOW_global_attribute_section_in_global_attribute_sections10694);
            	    global_attribute_section1286=global_attribute_section();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, global_attribute_section1286.getTree());

            	    }
            	    break;

            	default :
            	    if ( cnt318 >= 1 ) break loop318;
            	    if (state.backtracking>0) {state.failed=true; return retval;}
                        EarlyExitException eee =
                            new EarlyExitException(318, input);
                        throw eee;
                }
                cnt318++;
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "global_attribute_sections"


    public static class global_attribute_section_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "global_attribute_section"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2217:1: global_attribute_section : OPEN_BRACKET ! global_attribute_target_specifier attribute_list ( COMMA !)? CLOSE_BRACKET !;
    public final CSharp4AST.global_attribute_section_return global_attribute_section() throws RecognitionException {
        CSharp4AST.global_attribute_section_return retval = new CSharp4AST.global_attribute_section_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token OPEN_BRACKET1287=null;
        Token COMMA1290=null;
        Token CLOSE_BRACKET1291=null;
        CSharp4AST.global_attribute_target_specifier_return global_attribute_target_specifier1288 =null;

        CSharp4AST.attribute_list_return attribute_list1289 =null;


        Object OPEN_BRACKET1287_tree=null;
        Object COMMA1290_tree=null;
        Object CLOSE_BRACKET1291_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2218:3: ( OPEN_BRACKET ! global_attribute_target_specifier attribute_list ( COMMA !)? CLOSE_BRACKET !)
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2218:5: OPEN_BRACKET ! global_attribute_target_specifier attribute_list ( COMMA !)? CLOSE_BRACKET !
            {
            root_0 = (Object)adaptor.nil();


            OPEN_BRACKET1287=(Token)match(input,OPEN_BRACKET,FOLLOW_OPEN_BRACKET_in_global_attribute_section10709); if (state.failed) return retval;

            pushFollow(FOLLOW_global_attribute_target_specifier_in_global_attribute_section10712);
            global_attribute_target_specifier1288=global_attribute_target_specifier();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, global_attribute_target_specifier1288.getTree());

            pushFollow(FOLLOW_attribute_list_in_global_attribute_section10714);
            attribute_list1289=attribute_list();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, attribute_list1289.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2218:73: ( COMMA !)?
            int alt319=2;
            int LA319_0 = input.LA(1);

            if ( (LA319_0==COMMA) ) {
                alt319=1;
            }
            switch (alt319) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2218:73: COMMA !
                    {
                    COMMA1290=(Token)match(input,COMMA,FOLLOW_COMMA_in_global_attribute_section10716); if (state.failed) return retval;

                    }
                    break;

            }


            CLOSE_BRACKET1291=(Token)match(input,CLOSE_BRACKET,FOLLOW_CLOSE_BRACKET_in_global_attribute_section10720); if (state.failed) return retval;

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "global_attribute_section"


    public static class global_attribute_target_specifier_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "global_attribute_target_specifier"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2220:1: global_attribute_target_specifier : global_attribute_target COLON !;
    public final CSharp4AST.global_attribute_target_specifier_return global_attribute_target_specifier() throws RecognitionException {
        CSharp4AST.global_attribute_target_specifier_return retval = new CSharp4AST.global_attribute_target_specifier_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token COLON1293=null;
        CSharp4AST.global_attribute_target_return global_attribute_target1292 =null;


        Object COLON1293_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2221:2: ( global_attribute_target COLON !)
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2221:4: global_attribute_target COLON !
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_global_attribute_target_in_global_attribute_target_specifier10733);
            global_attribute_target1292=global_attribute_target();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, global_attribute_target1292.getTree());

            COLON1293=(Token)match(input,COLON,FOLLOW_COLON_in_global_attribute_target_specifier10735); if (state.failed) return retval;

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "global_attribute_target_specifier"


    public static class global_attribute_target_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "global_attribute_target"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2223:1: global_attribute_target : ( keyword | IDENTIFIER );
    public final CSharp4AST.global_attribute_target_return global_attribute_target() throws RecognitionException {
        CSharp4AST.global_attribute_target_return retval = new CSharp4AST.global_attribute_target_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER1295=null;
        CSharp4AST.keyword_return keyword1294 =null;


        Object IDENTIFIER1295_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2224:3: ( keyword | IDENTIFIER )
            int alt320=2;
            int LA320_0 = input.LA(1);

            if ( (LA320_0==ABSTRACT||LA320_0==AS||LA320_0==BASE||(LA320_0 >= BOOL && LA320_0 <= BYTE)||(LA320_0 >= CASE && LA320_0 <= CHAR)||(LA320_0 >= CHECKED && LA320_0 <= CLASS)||(LA320_0 >= CONST && LA320_0 <= CONTINUE)||LA320_0==DECIMAL||(LA320_0 >= DEFAULT && LA320_0 <= DELEGATE)||LA320_0==DO||LA320_0==DOUBLE||(LA320_0 >= ELSE && LA320_0 <= EXTERN)||(LA320_0 >= FALSE && LA320_0 <= FOREACH)||LA320_0==GOTO||(LA320_0 >= IF && LA320_0 <= INT)||(LA320_0 >= INTERFACE && LA320_0 <= INTERNAL)||LA320_0==IS||(LA320_0 >= LOCK && LA320_0 <= LONG)||(LA320_0 >= NAMESPACE && LA320_0 <= NEW)||LA320_0==NULL||LA320_0==OBJECT||LA320_0==OPERATOR||(LA320_0 >= OUT && LA320_0 <= PARAMS)||(LA320_0 >= PRIVATE && LA320_0 <= PUBLIC)||LA320_0==READONLY||(LA320_0 >= REF && LA320_0 <= RETURN)||(LA320_0 >= SBYTE && LA320_0 <= SEALED)||LA320_0==SHORT||(LA320_0 >= SIZEOF && LA320_0 <= STACKALLOC)||(LA320_0 >= STATIC && LA320_0 <= STRING)||(LA320_0 >= STRUCT && LA320_0 <= SWITCH)||(LA320_0 >= THIS && LA320_0 <= THROW)||(LA320_0 >= TRUE && LA320_0 <= TYPEOF)||(LA320_0 >= UINT && LA320_0 <= UNCHECKED)||(LA320_0 >= UNSAFE && LA320_0 <= USING)||(LA320_0 >= VIRTUAL && LA320_0 <= VOLATILE)||LA320_0==WHILE) ) {
                alt320=1;
            }
            else if ( (LA320_0==IDENTIFIER) ) {
                alt320=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 320, 0, input);

                throw nvae;

            }
            switch (alt320) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2224:5: keyword
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_keyword_in_global_attribute_target10748);
                    keyword1294=keyword();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, keyword1294.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2225:5: IDENTIFIER
                    {
                    root_0 = (Object)adaptor.nil();


                    IDENTIFIER1295=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_global_attribute_target10754); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    IDENTIFIER1295_tree = 
                    (Object)adaptor.create(IDENTIFIER1295)
                    ;
                    adaptor.addChild(root_0, IDENTIFIER1295_tree);
                    }

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "global_attribute_target"


    public static class attributes_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "attributes"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2233:1: attributes : attribute_sections ;
    public final CSharp4AST.attributes_return attributes() throws RecognitionException {
        CSharp4AST.attributes_return retval = new CSharp4AST.attributes_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.attribute_sections_return attribute_sections1296 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2234:2: ( attribute_sections )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2234:4: attribute_sections
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_attribute_sections_in_attributes10768);
            attribute_sections1296=attribute_sections();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, attribute_sections1296.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "attributes"


    public static class attribute_sections_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "attribute_sections"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2236:1: attribute_sections : ( attribute_section )+ -> ^( ATTRIBUTES ( attribute_section )+ ) ;
    public final CSharp4AST.attribute_sections_return attribute_sections() throws RecognitionException {
        CSharp4AST.attribute_sections_return retval = new CSharp4AST.attribute_sections_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.attribute_section_return attribute_section1297 =null;


        RewriteRuleSubtreeStream stream_attribute_section=new RewriteRuleSubtreeStream(adaptor,"rule attribute_section");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2237:2: ( ( attribute_section )+ -> ^( ATTRIBUTES ( attribute_section )+ ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2237:4: ( attribute_section )+
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2237:4: ( attribute_section )+
            int cnt321=0;
            loop321:
            do {
                int alt321=2;
                int LA321_0 = input.LA(1);

                if ( (LA321_0==OPEN_BRACKET) ) {
                    alt321=1;
                }


                switch (alt321) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2237:4: attribute_section
            	    {
            	    pushFollow(FOLLOW_attribute_section_in_attribute_sections10779);
            	    attribute_section1297=attribute_section();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) stream_attribute_section.add(attribute_section1297.getTree());

            	    }
            	    break;

            	default :
            	    if ( cnt321 >= 1 ) break loop321;
            	    if (state.backtracking>0) {state.failed=true; return retval;}
                        EarlyExitException eee =
                            new EarlyExitException(321, input);
                        throw eee;
                }
                cnt321++;
            } while (true);


            // AST REWRITE
            // elements: attribute_section
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 2238:4: -> ^( ATTRIBUTES ( attribute_section )+ )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2238:7: ^( ATTRIBUTES ( attribute_section )+ )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(ATTRIBUTES, "ATTRIBUTES")
                , root_1);

                if ( !(stream_attribute_section.hasNext()) ) {
                    throw new RewriteEarlyExitException();
                }
                while ( stream_attribute_section.hasNext() ) {
                    adaptor.addChild(root_1, stream_attribute_section.nextTree());

                }
                stream_attribute_section.reset();

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "attribute_sections"


    public static class attribute_section_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "attribute_section"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2246:1: attribute_section : OPEN_BRACKET ! ( attribute_target_specifier )? attribute_list ( COMMA !)? CLOSE_BRACKET !;
    public final CSharp4AST.attribute_section_return attribute_section() throws RecognitionException {
        CSharp4AST.attribute_section_return retval = new CSharp4AST.attribute_section_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token OPEN_BRACKET1298=null;
        Token COMMA1301=null;
        Token CLOSE_BRACKET1302=null;
        CSharp4AST.attribute_target_specifier_return attribute_target_specifier1299 =null;

        CSharp4AST.attribute_list_return attribute_list1300 =null;


        Object OPEN_BRACKET1298_tree=null;
        Object COMMA1301_tree=null;
        Object CLOSE_BRACKET1302_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2247:3: ( OPEN_BRACKET ! ( attribute_target_specifier )? attribute_list ( COMMA !)? CLOSE_BRACKET !)
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2247:5: OPEN_BRACKET ! ( attribute_target_specifier )? attribute_list ( COMMA !)? CLOSE_BRACKET !
            {
            root_0 = (Object)adaptor.nil();


            OPEN_BRACKET1298=(Token)match(input,OPEN_BRACKET,FOLLOW_OPEN_BRACKET_in_attribute_section10806); if (state.failed) return retval;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2247:19: ( attribute_target_specifier )?
            int alt322=2;
            int LA322_0 = input.LA(1);

            if ( (LA322_0==ABSTRACT||LA322_0==AS||LA322_0==BASE||(LA322_0 >= BOOL && LA322_0 <= BYTE)||(LA322_0 >= CASE && LA322_0 <= CHAR)||(LA322_0 >= CHECKED && LA322_0 <= CLASS)||(LA322_0 >= CONST && LA322_0 <= CONTINUE)||LA322_0==DECIMAL||(LA322_0 >= DEFAULT && LA322_0 <= DELEGATE)||LA322_0==DO||LA322_0==DOUBLE||(LA322_0 >= ELSE && LA322_0 <= EXTERN)||(LA322_0 >= FALSE && LA322_0 <= FOREACH)||LA322_0==GOTO||(LA322_0 >= IF && LA322_0 <= INT)||(LA322_0 >= INTERFACE && LA322_0 <= INTERNAL)||LA322_0==IS||(LA322_0 >= LOCK && LA322_0 <= LONG)||(LA322_0 >= NAMESPACE && LA322_0 <= NEW)||LA322_0==NULL||LA322_0==OBJECT||LA322_0==OPERATOR||(LA322_0 >= OUT && LA322_0 <= PARAMS)||(LA322_0 >= PRIVATE && LA322_0 <= PUBLIC)||LA322_0==READONLY||(LA322_0 >= REF && LA322_0 <= RETURN)||(LA322_0 >= SBYTE && LA322_0 <= SEALED)||LA322_0==SHORT||(LA322_0 >= SIZEOF && LA322_0 <= STACKALLOC)||(LA322_0 >= STATIC && LA322_0 <= STRING)||(LA322_0 >= STRUCT && LA322_0 <= SWITCH)||(LA322_0 >= THIS && LA322_0 <= THROW)||(LA322_0 >= TRUE && LA322_0 <= TYPEOF)||(LA322_0 >= UINT && LA322_0 <= UNCHECKED)||(LA322_0 >= UNSAFE && LA322_0 <= USING)||(LA322_0 >= VIRTUAL && LA322_0 <= VOLATILE)||LA322_0==WHILE) ) {
                alt322=1;
            }
            else if ( (LA322_0==IDENTIFIER) ) {
                int LA322_2 = input.LA(2);

                if ( (LA322_2==COLON) ) {
                    alt322=1;
                }
            }
            switch (alt322) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2247:19: attribute_target_specifier
                    {
                    pushFollow(FOLLOW_attribute_target_specifier_in_attribute_section10809);
                    attribute_target_specifier1299=attribute_target_specifier();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, attribute_target_specifier1299.getTree());

                    }
                    break;

            }


            pushFollow(FOLLOW_attribute_list_in_attribute_section10812);
            attribute_list1300=attribute_list();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, attribute_list1300.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2247:67: ( COMMA !)?
            int alt323=2;
            int LA323_0 = input.LA(1);

            if ( (LA323_0==COMMA) ) {
                alt323=1;
            }
            switch (alt323) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2247:67: COMMA !
                    {
                    COMMA1301=(Token)match(input,COMMA,FOLLOW_COMMA_in_attribute_section10814); if (state.failed) return retval;

                    }
                    break;

            }


            CLOSE_BRACKET1302=(Token)match(input,CLOSE_BRACKET,FOLLOW_CLOSE_BRACKET_in_attribute_section10818); if (state.failed) return retval;

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "attribute_section"


    public static class attribute_target_specifier_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "attribute_target_specifier"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2249:1: attribute_target_specifier : attribute_target COLON -> ^( ATTRIBUTE_TARGET attribute_target ) ;
    public final CSharp4AST.attribute_target_specifier_return attribute_target_specifier() throws RecognitionException {
        CSharp4AST.attribute_target_specifier_return retval = new CSharp4AST.attribute_target_specifier_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token COLON1304=null;
        CSharp4AST.attribute_target_return attribute_target1303 =null;


        Object COLON1304_tree=null;
        RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
        RewriteRuleSubtreeStream stream_attribute_target=new RewriteRuleSubtreeStream(adaptor,"rule attribute_target");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2250:2: ( attribute_target COLON -> ^( ATTRIBUTE_TARGET attribute_target ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2250:4: attribute_target COLON
            {
            pushFollow(FOLLOW_attribute_target_in_attribute_target_specifier10831);
            attribute_target1303=attribute_target();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_attribute_target.add(attribute_target1303.getTree());

            COLON1304=(Token)match(input,COLON,FOLLOW_COLON_in_attribute_target_specifier10833); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_COLON.add(COLON1304);


            // AST REWRITE
            // elements: attribute_target
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 2251:4: -> ^( ATTRIBUTE_TARGET attribute_target )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2251:7: ^( ATTRIBUTE_TARGET attribute_target )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(ATTRIBUTE_TARGET, "ATTRIBUTE_TARGET")
                , root_1);

                adaptor.addChild(root_1, stream_attribute_target.nextTree());

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "attribute_target_specifier"


    public static class attribute_target_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "attribute_target"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2253:1: attribute_target : ( keyword | IDENTIFIER );
    public final CSharp4AST.attribute_target_return attribute_target() throws RecognitionException {
        CSharp4AST.attribute_target_return retval = new CSharp4AST.attribute_target_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER1306=null;
        CSharp4AST.keyword_return keyword1305 =null;


        Object IDENTIFIER1306_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2254:3: ( keyword | IDENTIFIER )
            int alt324=2;
            int LA324_0 = input.LA(1);

            if ( (LA324_0==ABSTRACT||LA324_0==AS||LA324_0==BASE||(LA324_0 >= BOOL && LA324_0 <= BYTE)||(LA324_0 >= CASE && LA324_0 <= CHAR)||(LA324_0 >= CHECKED && LA324_0 <= CLASS)||(LA324_0 >= CONST && LA324_0 <= CONTINUE)||LA324_0==DECIMAL||(LA324_0 >= DEFAULT && LA324_0 <= DELEGATE)||LA324_0==DO||LA324_0==DOUBLE||(LA324_0 >= ELSE && LA324_0 <= EXTERN)||(LA324_0 >= FALSE && LA324_0 <= FOREACH)||LA324_0==GOTO||(LA324_0 >= IF && LA324_0 <= INT)||(LA324_0 >= INTERFACE && LA324_0 <= INTERNAL)||LA324_0==IS||(LA324_0 >= LOCK && LA324_0 <= LONG)||(LA324_0 >= NAMESPACE && LA324_0 <= NEW)||LA324_0==NULL||LA324_0==OBJECT||LA324_0==OPERATOR||(LA324_0 >= OUT && LA324_0 <= PARAMS)||(LA324_0 >= PRIVATE && LA324_0 <= PUBLIC)||LA324_0==READONLY||(LA324_0 >= REF && LA324_0 <= RETURN)||(LA324_0 >= SBYTE && LA324_0 <= SEALED)||LA324_0==SHORT||(LA324_0 >= SIZEOF && LA324_0 <= STACKALLOC)||(LA324_0 >= STATIC && LA324_0 <= STRING)||(LA324_0 >= STRUCT && LA324_0 <= SWITCH)||(LA324_0 >= THIS && LA324_0 <= THROW)||(LA324_0 >= TRUE && LA324_0 <= TYPEOF)||(LA324_0 >= UINT && LA324_0 <= UNCHECKED)||(LA324_0 >= UNSAFE && LA324_0 <= USING)||(LA324_0 >= VIRTUAL && LA324_0 <= VOLATILE)||LA324_0==WHILE) ) {
                alt324=1;
            }
            else if ( (LA324_0==IDENTIFIER) ) {
                alt324=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 324, 0, input);

                throw nvae;

            }
            switch (alt324) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2254:5: keyword
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_keyword_in_attribute_target10856);
                    keyword1305=keyword();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, keyword1305.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2254:15: IDENTIFIER
                    {
                    root_0 = (Object)adaptor.nil();


                    IDENTIFIER1306=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_attribute_target10860); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    IDENTIFIER1306_tree = 
                    (Object)adaptor.create(IDENTIFIER1306)
                    ;
                    adaptor.addChild(root_0, IDENTIFIER1306_tree);
                    }

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "attribute_target"


    public static class attribute_list_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "attribute_list"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2267:1: attribute_list : attribute ( COMMA attribute )* -> ^( ATTRIBUTE_LIST ( attribute )+ ) ;
    public final CSharp4AST.attribute_list_return attribute_list() throws RecognitionException {
        CSharp4AST.attribute_list_return retval = new CSharp4AST.attribute_list_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token COMMA1308=null;
        CSharp4AST.attribute_return attribute1307 =null;

        CSharp4AST.attribute_return attribute1309 =null;


        Object COMMA1308_tree=null;
        RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
        RewriteRuleSubtreeStream stream_attribute=new RewriteRuleSubtreeStream(adaptor,"rule attribute");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2268:2: ( attribute ( COMMA attribute )* -> ^( ATTRIBUTE_LIST ( attribute )+ ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2268:4: attribute ( COMMA attribute )*
            {
            pushFollow(FOLLOW_attribute_in_attribute_list10874);
            attribute1307=attribute();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_attribute.add(attribute1307.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2268:14: ( COMMA attribute )*
            loop325:
            do {
                int alt325=2;
                int LA325_0 = input.LA(1);

                if ( (LA325_0==COMMA) ) {
                    int LA325_1 = input.LA(2);

                    if ( (LA325_1==IDENTIFIER) ) {
                        alt325=1;
                    }


                }


                switch (alt325) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2268:16: COMMA attribute
            	    {
            	    COMMA1308=(Token)match(input,COMMA,FOLLOW_COMMA_in_attribute_list10878); if (state.failed) return retval; 
            	    if ( state.backtracking==0 ) stream_COMMA.add(COMMA1308);


            	    pushFollow(FOLLOW_attribute_in_attribute_list10881);
            	    attribute1309=attribute();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) stream_attribute.add(attribute1309.getTree());

            	    }
            	    break;

            	default :
            	    break loop325;
                }
            } while (true);


            // AST REWRITE
            // elements: attribute
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 2269:4: -> ^( ATTRIBUTE_LIST ( attribute )+ )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2269:7: ^( ATTRIBUTE_LIST ( attribute )+ )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(ATTRIBUTE_LIST, "ATTRIBUTE_LIST")
                , root_1);

                if ( !(stream_attribute.hasNext()) ) {
                    throw new RewriteEarlyExitException();
                }
                while ( stream_attribute.hasNext() ) {
                    adaptor.addChild(root_1, stream_attribute.nextTree());

                }
                stream_attribute.reset();

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "attribute_list"


    public static class attribute_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "attribute"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2271:1: attribute : attribute_name ( attribute_arguments )? -> ^( ATTRIBUTE attribute_name ( attribute_arguments )? ) ;
    public final CSharp4AST.attribute_return attribute() throws RecognitionException {
        CSharp4AST.attribute_return retval = new CSharp4AST.attribute_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.attribute_name_return attribute_name1310 =null;

        CSharp4AST.attribute_arguments_return attribute_arguments1311 =null;


        RewriteRuleSubtreeStream stream_attribute_arguments=new RewriteRuleSubtreeStream(adaptor,"rule attribute_arguments");
        RewriteRuleSubtreeStream stream_attribute_name=new RewriteRuleSubtreeStream(adaptor,"rule attribute_name");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2272:2: ( attribute_name ( attribute_arguments )? -> ^( ATTRIBUTE attribute_name ( attribute_arguments )? ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2272:4: attribute_name ( attribute_arguments )?
            {
            pushFollow(FOLLOW_attribute_name_in_attribute10908);
            attribute_name1310=attribute_name();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_attribute_name.add(attribute_name1310.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2272:19: ( attribute_arguments )?
            int alt326=2;
            int LA326_0 = input.LA(1);

            if ( (LA326_0==OPEN_PARENS) ) {
                alt326=1;
            }
            switch (alt326) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2272:19: attribute_arguments
                    {
                    pushFollow(FOLLOW_attribute_arguments_in_attribute10910);
                    attribute_arguments1311=attribute_arguments();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) stream_attribute_arguments.add(attribute_arguments1311.getTree());

                    }
                    break;

            }


            // AST REWRITE
            // elements: attribute_name, attribute_arguments
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 2273:4: -> ^( ATTRIBUTE attribute_name ( attribute_arguments )? )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2273:7: ^( ATTRIBUTE attribute_name ( attribute_arguments )? )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(ATTRIBUTE, "ATTRIBUTE")
                , root_1);

                adaptor.addChild(root_1, stream_attribute_name.nextTree());

                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2273:38: ( attribute_arguments )?
                if ( stream_attribute_arguments.hasNext() ) {
                    adaptor.addChild(root_1, stream_attribute_arguments.nextTree());

                }
                stream_attribute_arguments.reset();

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "attribute"


    public static class attribute_name_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "attribute_name"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2275:1: attribute_name : type_name -> ^( ATTRIBUTE_NAME type_name ) ;
    public final CSharp4AST.attribute_name_return attribute_name() throws RecognitionException {
        CSharp4AST.attribute_name_return retval = new CSharp4AST.attribute_name_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.type_name_return type_name1312 =null;


        RewriteRuleSubtreeStream stream_type_name=new RewriteRuleSubtreeStream(adaptor,"rule type_name");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2276:2: ( type_name -> ^( ATTRIBUTE_NAME type_name ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2276:4: type_name
            {
            pushFollow(FOLLOW_type_name_in_attribute_name10940);
            type_name1312=type_name();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_type_name.add(type_name1312.getTree());

            // AST REWRITE
            // elements: type_name
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 2277:4: -> ^( ATTRIBUTE_NAME type_name )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2277:7: ^( ATTRIBUTE_NAME type_name )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(ATTRIBUTE_NAME, "ATTRIBUTE_NAME")
                , root_1);

                adaptor.addChild(root_1, stream_type_name.nextTree());

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "attribute_name"


    public static class attribute_arguments_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "attribute_arguments"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2287:1: attribute_arguments : OPEN_PARENS ! ( positional_argument_list )? CLOSE_PARENS !;
    public final CSharp4AST.attribute_arguments_return attribute_arguments() throws RecognitionException {
        CSharp4AST.attribute_arguments_return retval = new CSharp4AST.attribute_arguments_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token OPEN_PARENS1313=null;
        Token CLOSE_PARENS1315=null;
        CSharp4AST.positional_argument_list_return positional_argument_list1314 =null;


        Object OPEN_PARENS1313_tree=null;
        Object CLOSE_PARENS1315_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2288:3: ( OPEN_PARENS ! ( positional_argument_list )? CLOSE_PARENS !)
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2288:5: OPEN_PARENS ! ( positional_argument_list )? CLOSE_PARENS !
            {
            root_0 = (Object)adaptor.nil();


            OPEN_PARENS1313=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_attribute_arguments10969); if (state.failed) return retval;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2288:18: ( positional_argument_list )?
            int alt327=2;
            int LA327_0 = input.LA(1);

            if ( (LA327_0==AMP||(LA327_0 >= BANG && LA327_0 <= BASE)||LA327_0==BOOL||LA327_0==BYTE||(LA327_0 >= CHAR && LA327_0 <= CHECKED)||LA327_0==DECIMAL||(LA327_0 >= DEFAULT && LA327_0 <= DELEGATE)||LA327_0==DOUBLE||LA327_0==FALSE||LA327_0==FLOAT||LA327_0==IDENTIFIER||(LA327_0 >= INT && LA327_0 <= INTEGER_LITERAL)||LA327_0==LONG||LA327_0==MINUS||LA327_0==NEW||LA327_0==NULL||LA327_0==OBJECT||LA327_0==OPEN_PARENS||LA327_0==OP_DEC||LA327_0==OP_INC||LA327_0==PLUS||LA327_0==REAL_LITERAL||LA327_0==SBYTE||LA327_0==SHORT||LA327_0==SIZEOF||LA327_0==STAR||(LA327_0 >= STRING && LA327_0 <= STRING_LITERAL)||LA327_0==THIS||(LA327_0 >= TILDE && LA327_0 <= TRUE)||LA327_0==TYPEOF||(LA327_0 >= UINT && LA327_0 <= UNCHECKED)||LA327_0==USHORT) ) {
                alt327=1;
            }
            switch (alt327) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2288:18: positional_argument_list
                    {
                    pushFollow(FOLLOW_positional_argument_list_in_attribute_arguments10972);
                    positional_argument_list1314=positional_argument_list();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, positional_argument_list1314.getTree());

                    }
                    break;

            }


            CLOSE_PARENS1315=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_attribute_arguments10975); if (state.failed) return retval;

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "attribute_arguments"


    public static class positional_argument_list_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "positional_argument_list"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2290:1: positional_argument_list : positional_argument ( COMMA positional_argument )* -> ^( POSITIONAL_ARGUMENT_LIST ( positional_argument )+ ) ;
    public final CSharp4AST.positional_argument_list_return positional_argument_list() throws RecognitionException {
        CSharp4AST.positional_argument_list_return retval = new CSharp4AST.positional_argument_list_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token COMMA1317=null;
        CSharp4AST.positional_argument_return positional_argument1316 =null;

        CSharp4AST.positional_argument_return positional_argument1318 =null;


        Object COMMA1317_tree=null;
        RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
        RewriteRuleSubtreeStream stream_positional_argument=new RewriteRuleSubtreeStream(adaptor,"rule positional_argument");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2291:2: ( positional_argument ( COMMA positional_argument )* -> ^( POSITIONAL_ARGUMENT_LIST ( positional_argument )+ ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2291:4: positional_argument ( COMMA positional_argument )*
            {
            pushFollow(FOLLOW_positional_argument_in_positional_argument_list10988);
            positional_argument1316=positional_argument();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_positional_argument.add(positional_argument1316.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2291:24: ( COMMA positional_argument )*
            loop328:
            do {
                int alt328=2;
                int LA328_0 = input.LA(1);

                if ( (LA328_0==COMMA) ) {
                    alt328=1;
                }


                switch (alt328) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2291:25: COMMA positional_argument
            	    {
            	    COMMA1317=(Token)match(input,COMMA,FOLLOW_COMMA_in_positional_argument_list10991); if (state.failed) return retval; 
            	    if ( state.backtracking==0 ) stream_COMMA.add(COMMA1317);


            	    pushFollow(FOLLOW_positional_argument_in_positional_argument_list10993);
            	    positional_argument1318=positional_argument();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) stream_positional_argument.add(positional_argument1318.getTree());

            	    }
            	    break;

            	default :
            	    break loop328;
                }
            } while (true);


            // AST REWRITE
            // elements: positional_argument
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 2292:4: -> ^( POSITIONAL_ARGUMENT_LIST ( positional_argument )+ )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2292:7: ^( POSITIONAL_ARGUMENT_LIST ( positional_argument )+ )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(POSITIONAL_ARGUMENT_LIST, "POSITIONAL_ARGUMENT_LIST")
                , root_1);

                if ( !(stream_positional_argument.hasNext()) ) {
                    throw new RewriteEarlyExitException();
                }
                while ( stream_positional_argument.hasNext() ) {
                    adaptor.addChild(root_1, stream_positional_argument.nextTree());

                }
                stream_positional_argument.reset();

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "positional_argument_list"


    public static class positional_argument_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "positional_argument"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2295:1: positional_argument : attribute_argument_expression ;
    public final CSharp4AST.positional_argument_return positional_argument() throws RecognitionException {
        CSharp4AST.positional_argument_return retval = new CSharp4AST.positional_argument_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.attribute_argument_expression_return attribute_argument_expression1319 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2296:2: ( attribute_argument_expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2296:4: attribute_argument_expression
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_attribute_argument_expression_in_positional_argument11022);
            attribute_argument_expression1319=attribute_argument_expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, attribute_argument_expression1319.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "positional_argument"


    public static class named_argument_list_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "named_argument_list"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2299:1: named_argument_list : named_argument ( COMMA named_argument )* ;
    public final CSharp4AST.named_argument_list_return named_argument_list() throws RecognitionException {
        CSharp4AST.named_argument_list_return retval = new CSharp4AST.named_argument_list_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token COMMA1321=null;
        CSharp4AST.named_argument_return named_argument1320 =null;

        CSharp4AST.named_argument_return named_argument1322 =null;


        Object COMMA1321_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2300:2: ( named_argument ( COMMA named_argument )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2300:4: named_argument ( COMMA named_argument )*
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_named_argument_in_named_argument_list11035);
            named_argument1320=named_argument();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, named_argument1320.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2300:19: ( COMMA named_argument )*
            loop329:
            do {
                int alt329=2;
                int LA329_0 = input.LA(1);

                if ( (LA329_0==COMMA) ) {
                    alt329=1;
                }


                switch (alt329) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2300:21: COMMA named_argument
            	    {
            	    COMMA1321=(Token)match(input,COMMA,FOLLOW_COMMA_in_named_argument_list11039); if (state.failed) return retval;
            	    if ( state.backtracking==0 ) {
            	    COMMA1321_tree = 
            	    (Object)adaptor.create(COMMA1321)
            	    ;
            	    adaptor.addChild(root_0, COMMA1321_tree);
            	    }

            	    pushFollow(FOLLOW_named_argument_in_named_argument_list11042);
            	    named_argument1322=named_argument();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, named_argument1322.getTree());

            	    }
            	    break;

            	default :
            	    break loop329;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "named_argument_list"


    public static class named_argument_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "named_argument"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2303:1: named_argument : IDENTIFIER ASSIGNMENT attribute_argument_expression ;
    public final CSharp4AST.named_argument_return named_argument() throws RecognitionException {
        CSharp4AST.named_argument_return retval = new CSharp4AST.named_argument_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER1323=null;
        Token ASSIGNMENT1324=null;
        CSharp4AST.attribute_argument_expression_return attribute_argument_expression1325 =null;


        Object IDENTIFIER1323_tree=null;
        Object ASSIGNMENT1324_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2304:2: ( IDENTIFIER ASSIGNMENT attribute_argument_expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2304:4: IDENTIFIER ASSIGNMENT attribute_argument_expression
            {
            root_0 = (Object)adaptor.nil();


            IDENTIFIER1323=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_named_argument11058); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1323_tree = 
            (Object)adaptor.create(IDENTIFIER1323)
            ;
            adaptor.addChild(root_0, IDENTIFIER1323_tree);
            }

            ASSIGNMENT1324=(Token)match(input,ASSIGNMENT,FOLLOW_ASSIGNMENT_in_named_argument11060); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            ASSIGNMENT1324_tree = 
            (Object)adaptor.create(ASSIGNMENT1324)
            ;
            adaptor.addChild(root_0, ASSIGNMENT1324_tree);
            }

            pushFollow(FOLLOW_attribute_argument_expression_in_named_argument11062);
            attribute_argument_expression1325=attribute_argument_expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, attribute_argument_expression1325.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "named_argument"


    public static class attribute_argument_expression_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "attribute_argument_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2306:1: attribute_argument_expression : expression ;
    public final CSharp4AST.attribute_argument_expression_return attribute_argument_expression() throws RecognitionException {
        CSharp4AST.attribute_argument_expression_return retval = new CSharp4AST.attribute_argument_expression_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.expression_return expression1326 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2307:2: ( expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2307:4: expression
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_expression_in_attribute_argument_expression11073);
            expression1326=expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, expression1326.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "attribute_argument_expression"


    public static class class_modifier_unsafe_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "class_modifier_unsafe"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2312:1: class_modifier_unsafe : UNSAFE ;
    public final CSharp4AST.class_modifier_unsafe_return class_modifier_unsafe() throws RecognitionException {
        CSharp4AST.class_modifier_unsafe_return retval = new CSharp4AST.class_modifier_unsafe_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token UNSAFE1327=null;

        Object UNSAFE1327_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2313:2: ( UNSAFE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2313:4: UNSAFE
            {
            root_0 = (Object)adaptor.nil();


            UNSAFE1327=(Token)match(input,UNSAFE,FOLLOW_UNSAFE_in_class_modifier_unsafe11087); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            UNSAFE1327_tree = 
            (Object)adaptor.create(UNSAFE1327)
            ;
            adaptor.addChild(root_0, UNSAFE1327_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "class_modifier_unsafe"


    public static class struct_modifier_unsafe_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "struct_modifier_unsafe"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2315:1: struct_modifier_unsafe : UNSAFE ;
    public final CSharp4AST.struct_modifier_unsafe_return struct_modifier_unsafe() throws RecognitionException {
        CSharp4AST.struct_modifier_unsafe_return retval = new CSharp4AST.struct_modifier_unsafe_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token UNSAFE1328=null;

        Object UNSAFE1328_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2316:2: ( UNSAFE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2316:4: UNSAFE
            {
            root_0 = (Object)adaptor.nil();


            UNSAFE1328=(Token)match(input,UNSAFE,FOLLOW_UNSAFE_in_struct_modifier_unsafe11098); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            UNSAFE1328_tree = 
            (Object)adaptor.create(UNSAFE1328)
            ;
            adaptor.addChild(root_0, UNSAFE1328_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "struct_modifier_unsafe"


    public static class interface_modifier_unsafe_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "interface_modifier_unsafe"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2318:1: interface_modifier_unsafe : UNSAFE ;
    public final CSharp4AST.interface_modifier_unsafe_return interface_modifier_unsafe() throws RecognitionException {
        CSharp4AST.interface_modifier_unsafe_return retval = new CSharp4AST.interface_modifier_unsafe_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token UNSAFE1329=null;

        Object UNSAFE1329_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2319:2: ( UNSAFE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2319:4: UNSAFE
            {
            root_0 = (Object)adaptor.nil();


            UNSAFE1329=(Token)match(input,UNSAFE,FOLLOW_UNSAFE_in_interface_modifier_unsafe11109); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            UNSAFE1329_tree = 
            (Object)adaptor.create(UNSAFE1329)
            ;
            adaptor.addChild(root_0, UNSAFE1329_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "interface_modifier_unsafe"


    public static class delegate_modifier_unsafe_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "delegate_modifier_unsafe"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2321:1: delegate_modifier_unsafe : UNSAFE ;
    public final CSharp4AST.delegate_modifier_unsafe_return delegate_modifier_unsafe() throws RecognitionException {
        CSharp4AST.delegate_modifier_unsafe_return retval = new CSharp4AST.delegate_modifier_unsafe_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token UNSAFE1330=null;

        Object UNSAFE1330_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2322:2: ( UNSAFE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2322:4: UNSAFE
            {
            root_0 = (Object)adaptor.nil();


            UNSAFE1330=(Token)match(input,UNSAFE,FOLLOW_UNSAFE_in_delegate_modifier_unsafe11120); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            UNSAFE1330_tree = 
            (Object)adaptor.create(UNSAFE1330)
            ;
            adaptor.addChild(root_0, UNSAFE1330_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "delegate_modifier_unsafe"


    public static class field_modifier_unsafe_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "field_modifier_unsafe"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2324:1: field_modifier_unsafe : UNSAFE ;
    public final CSharp4AST.field_modifier_unsafe_return field_modifier_unsafe() throws RecognitionException {
        CSharp4AST.field_modifier_unsafe_return retval = new CSharp4AST.field_modifier_unsafe_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token UNSAFE1331=null;

        Object UNSAFE1331_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2325:2: ( UNSAFE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2325:4: UNSAFE
            {
            root_0 = (Object)adaptor.nil();


            UNSAFE1331=(Token)match(input,UNSAFE,FOLLOW_UNSAFE_in_field_modifier_unsafe11131); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            UNSAFE1331_tree = 
            (Object)adaptor.create(UNSAFE1331)
            ;
            adaptor.addChild(root_0, UNSAFE1331_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "field_modifier_unsafe"


    public static class method_modifier_unsafe_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "method_modifier_unsafe"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2327:1: method_modifier_unsafe : UNSAFE ;
    public final CSharp4AST.method_modifier_unsafe_return method_modifier_unsafe() throws RecognitionException {
        CSharp4AST.method_modifier_unsafe_return retval = new CSharp4AST.method_modifier_unsafe_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token UNSAFE1332=null;

        Object UNSAFE1332_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2328:2: ( UNSAFE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2328:4: UNSAFE
            {
            root_0 = (Object)adaptor.nil();


            UNSAFE1332=(Token)match(input,UNSAFE,FOLLOW_UNSAFE_in_method_modifier_unsafe11142); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            UNSAFE1332_tree = 
            (Object)adaptor.create(UNSAFE1332)
            ;
            adaptor.addChild(root_0, UNSAFE1332_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "method_modifier_unsafe"


    public static class property_modifier_unsafe_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "property_modifier_unsafe"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2330:1: property_modifier_unsafe : UNSAFE ;
    public final CSharp4AST.property_modifier_unsafe_return property_modifier_unsafe() throws RecognitionException {
        CSharp4AST.property_modifier_unsafe_return retval = new CSharp4AST.property_modifier_unsafe_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token UNSAFE1333=null;

        Object UNSAFE1333_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2331:2: ( UNSAFE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2331:4: UNSAFE
            {
            root_0 = (Object)adaptor.nil();


            UNSAFE1333=(Token)match(input,UNSAFE,FOLLOW_UNSAFE_in_property_modifier_unsafe11153); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            UNSAFE1333_tree = 
            (Object)adaptor.create(UNSAFE1333)
            ;
            adaptor.addChild(root_0, UNSAFE1333_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "property_modifier_unsafe"


    public static class event_modifier_unsafe_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "event_modifier_unsafe"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2333:1: event_modifier_unsafe : UNSAFE ;
    public final CSharp4AST.event_modifier_unsafe_return event_modifier_unsafe() throws RecognitionException {
        CSharp4AST.event_modifier_unsafe_return retval = new CSharp4AST.event_modifier_unsafe_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token UNSAFE1334=null;

        Object UNSAFE1334_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2334:2: ( UNSAFE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2334:4: UNSAFE
            {
            root_0 = (Object)adaptor.nil();


            UNSAFE1334=(Token)match(input,UNSAFE,FOLLOW_UNSAFE_in_event_modifier_unsafe11164); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            UNSAFE1334_tree = 
            (Object)adaptor.create(UNSAFE1334)
            ;
            adaptor.addChild(root_0, UNSAFE1334_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "event_modifier_unsafe"


    public static class indexer_modifier_unsafe_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "indexer_modifier_unsafe"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2336:1: indexer_modifier_unsafe : UNSAFE ;
    public final CSharp4AST.indexer_modifier_unsafe_return indexer_modifier_unsafe() throws RecognitionException {
        CSharp4AST.indexer_modifier_unsafe_return retval = new CSharp4AST.indexer_modifier_unsafe_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token UNSAFE1335=null;

        Object UNSAFE1335_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2337:2: ( UNSAFE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2337:4: UNSAFE
            {
            root_0 = (Object)adaptor.nil();


            UNSAFE1335=(Token)match(input,UNSAFE,FOLLOW_UNSAFE_in_indexer_modifier_unsafe11175); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            UNSAFE1335_tree = 
            (Object)adaptor.create(UNSAFE1335)
            ;
            adaptor.addChild(root_0, UNSAFE1335_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "indexer_modifier_unsafe"


    public static class operator_modifier_unsafe_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "operator_modifier_unsafe"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2339:1: operator_modifier_unsafe : UNSAFE ;
    public final CSharp4AST.operator_modifier_unsafe_return operator_modifier_unsafe() throws RecognitionException {
        CSharp4AST.operator_modifier_unsafe_return retval = new CSharp4AST.operator_modifier_unsafe_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token UNSAFE1336=null;

        Object UNSAFE1336_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2340:2: ( UNSAFE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2340:4: UNSAFE
            {
            root_0 = (Object)adaptor.nil();


            UNSAFE1336=(Token)match(input,UNSAFE,FOLLOW_UNSAFE_in_operator_modifier_unsafe11186); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            UNSAFE1336_tree = 
            (Object)adaptor.create(UNSAFE1336)
            ;
            adaptor.addChild(root_0, UNSAFE1336_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "operator_modifier_unsafe"


    public static class constructor_modifier_unsafe_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "constructor_modifier_unsafe"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2342:1: constructor_modifier_unsafe : UNSAFE ;
    public final CSharp4AST.constructor_modifier_unsafe_return constructor_modifier_unsafe() throws RecognitionException {
        CSharp4AST.constructor_modifier_unsafe_return retval = new CSharp4AST.constructor_modifier_unsafe_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token UNSAFE1337=null;

        Object UNSAFE1337_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2343:2: ( UNSAFE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2343:4: UNSAFE
            {
            root_0 = (Object)adaptor.nil();


            UNSAFE1337=(Token)match(input,UNSAFE,FOLLOW_UNSAFE_in_constructor_modifier_unsafe11197); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            UNSAFE1337_tree = 
            (Object)adaptor.create(UNSAFE1337)
            ;
            adaptor.addChild(root_0, UNSAFE1337_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "constructor_modifier_unsafe"


    public static class destructor_declaration_unsafe_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "destructor_declaration_unsafe"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2351:1: destructor_declaration_unsafe : ( attributes )? ( ( EXTERN )? ( UNSAFE )? | UNSAFE EXTERN ) TILDE ^ IDENTIFIER OPEN_PARENS CLOSE_PARENS destructor_body ;
    public final CSharp4AST.destructor_declaration_unsafe_return destructor_declaration_unsafe() throws RecognitionException {
        CSharp4AST.destructor_declaration_unsafe_return retval = new CSharp4AST.destructor_declaration_unsafe_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token EXTERN1339=null;
        Token UNSAFE1340=null;
        Token UNSAFE1341=null;
        Token EXTERN1342=null;
        Token TILDE1343=null;
        Token IDENTIFIER1344=null;
        Token OPEN_PARENS1345=null;
        Token CLOSE_PARENS1346=null;
        CSharp4AST.attributes_return attributes1338 =null;

        CSharp4AST.destructor_body_return destructor_body1347 =null;


        Object EXTERN1339_tree=null;
        Object UNSAFE1340_tree=null;
        Object UNSAFE1341_tree=null;
        Object EXTERN1342_tree=null;
        Object TILDE1343_tree=null;
        Object IDENTIFIER1344_tree=null;
        Object OPEN_PARENS1345_tree=null;
        Object CLOSE_PARENS1346_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2352:3: ( ( attributes )? ( ( EXTERN )? ( UNSAFE )? | UNSAFE EXTERN ) TILDE ^ IDENTIFIER OPEN_PARENS CLOSE_PARENS destructor_body )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2352:5: ( attributes )? ( ( EXTERN )? ( UNSAFE )? | UNSAFE EXTERN ) TILDE ^ IDENTIFIER OPEN_PARENS CLOSE_PARENS destructor_body
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2352:5: ( attributes )?
            int alt330=2;
            int LA330_0 = input.LA(1);

            if ( (LA330_0==OPEN_BRACKET) ) {
                alt330=1;
            }
            switch (alt330) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2352:5: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_destructor_declaration_unsafe11211);
                    attributes1338=attributes();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, attributes1338.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2353:5: ( ( EXTERN )? ( UNSAFE )? | UNSAFE EXTERN )
            int alt333=2;
            int LA333_0 = input.LA(1);

            if ( (LA333_0==EXTERN||LA333_0==TILDE) ) {
                alt333=1;
            }
            else if ( (LA333_0==UNSAFE) ) {
                int LA333_2 = input.LA(2);

                if ( (LA333_2==EXTERN) ) {
                    alt333=2;
                }
                else if ( (LA333_2==TILDE) ) {
                    alt333=1;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 333, 2, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 333, 0, input);

                throw nvae;

            }
            switch (alt333) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2353:7: ( EXTERN )? ( UNSAFE )?
                    {
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2353:7: ( EXTERN )?
                    int alt331=2;
                    int LA331_0 = input.LA(1);

                    if ( (LA331_0==EXTERN) ) {
                        alt331=1;
                    }
                    switch (alt331) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2353:7: EXTERN
                            {
                            EXTERN1339=(Token)match(input,EXTERN,FOLLOW_EXTERN_in_destructor_declaration_unsafe11220); if (state.failed) return retval;
                            if ( state.backtracking==0 ) {
                            EXTERN1339_tree = 
                            (Object)adaptor.create(EXTERN1339)
                            ;
                            adaptor.addChild(root_0, EXTERN1339_tree);
                            }

                            }
                            break;

                    }


                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2353:15: ( UNSAFE )?
                    int alt332=2;
                    int LA332_0 = input.LA(1);

                    if ( (LA332_0==UNSAFE) ) {
                        alt332=1;
                    }
                    switch (alt332) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2353:15: UNSAFE
                            {
                            UNSAFE1340=(Token)match(input,UNSAFE,FOLLOW_UNSAFE_in_destructor_declaration_unsafe11223); if (state.failed) return retval;
                            if ( state.backtracking==0 ) {
                            UNSAFE1340_tree = 
                            (Object)adaptor.create(UNSAFE1340)
                            ;
                            adaptor.addChild(root_0, UNSAFE1340_tree);
                            }

                            }
                            break;

                    }


                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2354:7: UNSAFE EXTERN
                    {
                    UNSAFE1341=(Token)match(input,UNSAFE,FOLLOW_UNSAFE_in_destructor_declaration_unsafe11232); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    UNSAFE1341_tree = 
                    (Object)adaptor.create(UNSAFE1341)
                    ;
                    adaptor.addChild(root_0, UNSAFE1341_tree);
                    }

                    EXTERN1342=(Token)match(input,EXTERN,FOLLOW_EXTERN_in_destructor_declaration_unsafe11234); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    EXTERN1342_tree = 
                    (Object)adaptor.create(EXTERN1342)
                    ;
                    adaptor.addChild(root_0, EXTERN1342_tree);
                    }

                    }
                    break;

            }


            TILDE1343=(Token)match(input,TILDE,FOLLOW_TILDE_in_destructor_declaration_unsafe11248); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            TILDE1343_tree = 
            (Object)adaptor.create(TILDE1343)
            ;
            root_0 = (Object)adaptor.becomeRoot(TILDE1343_tree, root_0);
            }

            IDENTIFIER1344=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_destructor_declaration_unsafe11251); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1344_tree = 
            (Object)adaptor.create(IDENTIFIER1344)
            ;
            adaptor.addChild(root_0, IDENTIFIER1344_tree);
            }

            OPEN_PARENS1345=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_destructor_declaration_unsafe11253); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            OPEN_PARENS1345_tree = 
            (Object)adaptor.create(OPEN_PARENS1345)
            ;
            adaptor.addChild(root_0, OPEN_PARENS1345_tree);
            }

            CLOSE_PARENS1346=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_destructor_declaration_unsafe11255); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            CLOSE_PARENS1346_tree = 
            (Object)adaptor.create(CLOSE_PARENS1346)
            ;
            adaptor.addChild(root_0, CLOSE_PARENS1346_tree);
            }

            pushFollow(FOLLOW_destructor_body_in_destructor_declaration_unsafe11257);
            destructor_body1347=destructor_body();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, destructor_body1347.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "destructor_declaration_unsafe"


    public static class static_constructor_modifiers_unsafe_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "static_constructor_modifiers_unsafe"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2368:1: static_constructor_modifiers_unsafe : ( ( EXTERN | UNSAFE )? STATIC | EXTERN UNSAFE STATIC | UNSAFE EXTERN STATIC | EXTERN STATIC UNSAFE | UNSAFE STATIC EXTERN | STATIC ( EXTERN | UNSAFE ) | STATIC EXTERN UNSAFE | STATIC UNSAFE EXTERN );
    public final CSharp4AST.static_constructor_modifiers_unsafe_return static_constructor_modifiers_unsafe() throws RecognitionException {
        CSharp4AST.static_constructor_modifiers_unsafe_return retval = new CSharp4AST.static_constructor_modifiers_unsafe_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token set1348=null;
        Token STATIC1349=null;
        Token EXTERN1350=null;
        Token UNSAFE1351=null;
        Token STATIC1352=null;
        Token UNSAFE1353=null;
        Token EXTERN1354=null;
        Token STATIC1355=null;
        Token EXTERN1356=null;
        Token STATIC1357=null;
        Token UNSAFE1358=null;
        Token UNSAFE1359=null;
        Token STATIC1360=null;
        Token EXTERN1361=null;
        Token STATIC1362=null;
        Token set1363=null;
        Token STATIC1364=null;
        Token EXTERN1365=null;
        Token UNSAFE1366=null;
        Token STATIC1367=null;
        Token UNSAFE1368=null;
        Token EXTERN1369=null;

        Object set1348_tree=null;
        Object STATIC1349_tree=null;
        Object EXTERN1350_tree=null;
        Object UNSAFE1351_tree=null;
        Object STATIC1352_tree=null;
        Object UNSAFE1353_tree=null;
        Object EXTERN1354_tree=null;
        Object STATIC1355_tree=null;
        Object EXTERN1356_tree=null;
        Object STATIC1357_tree=null;
        Object UNSAFE1358_tree=null;
        Object UNSAFE1359_tree=null;
        Object STATIC1360_tree=null;
        Object EXTERN1361_tree=null;
        Object STATIC1362_tree=null;
        Object set1363_tree=null;
        Object STATIC1364_tree=null;
        Object EXTERN1365_tree=null;
        Object UNSAFE1366_tree=null;
        Object STATIC1367_tree=null;
        Object UNSAFE1368_tree=null;
        Object EXTERN1369_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2369:3: ( ( EXTERN | UNSAFE )? STATIC | EXTERN UNSAFE STATIC | UNSAFE EXTERN STATIC | EXTERN STATIC UNSAFE | UNSAFE STATIC EXTERN | STATIC ( EXTERN | UNSAFE ) | STATIC EXTERN UNSAFE | STATIC UNSAFE EXTERN )
            int alt335=8;
            switch ( input.LA(1) ) {
            case EXTERN:
                {
                int LA335_1 = input.LA(2);

                if ( (LA335_1==UNSAFE) ) {
                    alt335=2;
                }
                else if ( (LA335_1==STATIC) ) {
                    int LA335_5 = input.LA(3);

                    if ( (LA335_5==UNSAFE) ) {
                        alt335=4;
                    }
                    else if ( (LA335_5==IDENTIFIER) ) {
                        alt335=1;
                    }
                    else {
                        if (state.backtracking>0) {state.failed=true; return retval;}
                        NoViableAltException nvae =
                            new NoViableAltException("", 335, 5, input);

                        throw nvae;

                    }
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 335, 1, input);

                    throw nvae;

                }
                }
                break;
            case STATIC:
                {
                switch ( input.LA(2) ) {
                case EXTERN:
                    {
                    int LA335_6 = input.LA(3);

                    if ( (LA335_6==UNSAFE) ) {
                        alt335=7;
                    }
                    else if ( (LA335_6==IDENTIFIER) ) {
                        alt335=6;
                    }
                    else {
                        if (state.backtracking>0) {state.failed=true; return retval;}
                        NoViableAltException nvae =
                            new NoViableAltException("", 335, 6, input);

                        throw nvae;

                    }
                    }
                    break;
                case UNSAFE:
                    {
                    int LA335_7 = input.LA(3);

                    if ( (LA335_7==EXTERN) ) {
                        alt335=8;
                    }
                    else if ( (LA335_7==IDENTIFIER) ) {
                        alt335=6;
                    }
                    else {
                        if (state.backtracking>0) {state.failed=true; return retval;}
                        NoViableAltException nvae =
                            new NoViableAltException("", 335, 7, input);

                        throw nvae;

                    }
                    }
                    break;
                case IDENTIFIER:
                    {
                    alt335=1;
                    }
                    break;
                default:
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 335, 2, input);

                    throw nvae;

                }

                }
                break;
            case UNSAFE:
                {
                int LA335_3 = input.LA(2);

                if ( (LA335_3==EXTERN) ) {
                    alt335=3;
                }
                else if ( (LA335_3==STATIC) ) {
                    int LA335_10 = input.LA(3);

                    if ( (LA335_10==EXTERN) ) {
                        alt335=5;
                    }
                    else if ( (LA335_10==IDENTIFIER) ) {
                        alt335=1;
                    }
                    else {
                        if (state.backtracking>0) {state.failed=true; return retval;}
                        NoViableAltException nvae =
                            new NoViableAltException("", 335, 10, input);

                        throw nvae;

                    }
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 335, 3, input);

                    throw nvae;

                }
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 335, 0, input);

                throw nvae;

            }

            switch (alt335) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2369:5: ( EXTERN | UNSAFE )? STATIC
                    {
                    root_0 = (Object)adaptor.nil();


                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2369:5: ( EXTERN | UNSAFE )?
                    int alt334=2;
                    int LA334_0 = input.LA(1);

                    if ( (LA334_0==EXTERN||LA334_0==UNSAFE) ) {
                        alt334=1;
                    }
                    switch (alt334) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:
                            {
                            set1348=(Token)input.LT(1);

                            if ( input.LA(1)==EXTERN||input.LA(1)==UNSAFE ) {
                                input.consume();
                                if ( state.backtracking==0 ) adaptor.addChild(root_0, 
                                (Object)adaptor.create(set1348)
                                );
                                state.errorRecovery=false;
                                state.failed=false;
                            }
                            else {
                                if (state.backtracking>0) {state.failed=true; return retval;}
                                MismatchedSetException mse = new MismatchedSetException(null,input);
                                throw mse;
                            }


                            }
                            break;

                    }


                    STATIC1349=(Token)match(input,STATIC,FOLLOW_STATIC_in_static_constructor_modifiers_unsafe11281); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    STATIC1349_tree = 
                    (Object)adaptor.create(STATIC1349)
                    ;
                    adaptor.addChild(root_0, STATIC1349_tree);
                    }

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2370:5: EXTERN UNSAFE STATIC
                    {
                    root_0 = (Object)adaptor.nil();


                    EXTERN1350=(Token)match(input,EXTERN,FOLLOW_EXTERN_in_static_constructor_modifiers_unsafe11287); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    EXTERN1350_tree = 
                    (Object)adaptor.create(EXTERN1350)
                    ;
                    adaptor.addChild(root_0, EXTERN1350_tree);
                    }

                    UNSAFE1351=(Token)match(input,UNSAFE,FOLLOW_UNSAFE_in_static_constructor_modifiers_unsafe11289); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    UNSAFE1351_tree = 
                    (Object)adaptor.create(UNSAFE1351)
                    ;
                    adaptor.addChild(root_0, UNSAFE1351_tree);
                    }

                    STATIC1352=(Token)match(input,STATIC,FOLLOW_STATIC_in_static_constructor_modifiers_unsafe11291); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    STATIC1352_tree = 
                    (Object)adaptor.create(STATIC1352)
                    ;
                    adaptor.addChild(root_0, STATIC1352_tree);
                    }

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2371:5: UNSAFE EXTERN STATIC
                    {
                    root_0 = (Object)adaptor.nil();


                    UNSAFE1353=(Token)match(input,UNSAFE,FOLLOW_UNSAFE_in_static_constructor_modifiers_unsafe11297); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    UNSAFE1353_tree = 
                    (Object)adaptor.create(UNSAFE1353)
                    ;
                    adaptor.addChild(root_0, UNSAFE1353_tree);
                    }

                    EXTERN1354=(Token)match(input,EXTERN,FOLLOW_EXTERN_in_static_constructor_modifiers_unsafe11299); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    EXTERN1354_tree = 
                    (Object)adaptor.create(EXTERN1354)
                    ;
                    adaptor.addChild(root_0, EXTERN1354_tree);
                    }

                    STATIC1355=(Token)match(input,STATIC,FOLLOW_STATIC_in_static_constructor_modifiers_unsafe11301); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    STATIC1355_tree = 
                    (Object)adaptor.create(STATIC1355)
                    ;
                    adaptor.addChild(root_0, STATIC1355_tree);
                    }

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2372:5: EXTERN STATIC UNSAFE
                    {
                    root_0 = (Object)adaptor.nil();


                    EXTERN1356=(Token)match(input,EXTERN,FOLLOW_EXTERN_in_static_constructor_modifiers_unsafe11307); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    EXTERN1356_tree = 
                    (Object)adaptor.create(EXTERN1356)
                    ;
                    adaptor.addChild(root_0, EXTERN1356_tree);
                    }

                    STATIC1357=(Token)match(input,STATIC,FOLLOW_STATIC_in_static_constructor_modifiers_unsafe11309); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    STATIC1357_tree = 
                    (Object)adaptor.create(STATIC1357)
                    ;
                    adaptor.addChild(root_0, STATIC1357_tree);
                    }

                    UNSAFE1358=(Token)match(input,UNSAFE,FOLLOW_UNSAFE_in_static_constructor_modifiers_unsafe11311); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    UNSAFE1358_tree = 
                    (Object)adaptor.create(UNSAFE1358)
                    ;
                    adaptor.addChild(root_0, UNSAFE1358_tree);
                    }

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2373:5: UNSAFE STATIC EXTERN
                    {
                    root_0 = (Object)adaptor.nil();


                    UNSAFE1359=(Token)match(input,UNSAFE,FOLLOW_UNSAFE_in_static_constructor_modifiers_unsafe11317); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    UNSAFE1359_tree = 
                    (Object)adaptor.create(UNSAFE1359)
                    ;
                    adaptor.addChild(root_0, UNSAFE1359_tree);
                    }

                    STATIC1360=(Token)match(input,STATIC,FOLLOW_STATIC_in_static_constructor_modifiers_unsafe11319); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    STATIC1360_tree = 
                    (Object)adaptor.create(STATIC1360)
                    ;
                    adaptor.addChild(root_0, STATIC1360_tree);
                    }

                    EXTERN1361=(Token)match(input,EXTERN,FOLLOW_EXTERN_in_static_constructor_modifiers_unsafe11321); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    EXTERN1361_tree = 
                    (Object)adaptor.create(EXTERN1361)
                    ;
                    adaptor.addChild(root_0, EXTERN1361_tree);
                    }

                    }
                    break;
                case 6 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2374:5: STATIC ( EXTERN | UNSAFE )
                    {
                    root_0 = (Object)adaptor.nil();


                    STATIC1362=(Token)match(input,STATIC,FOLLOW_STATIC_in_static_constructor_modifiers_unsafe11327); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    STATIC1362_tree = 
                    (Object)adaptor.create(STATIC1362)
                    ;
                    adaptor.addChild(root_0, STATIC1362_tree);
                    }

                    set1363=(Token)input.LT(1);

                    if ( input.LA(1)==EXTERN||input.LA(1)==UNSAFE ) {
                        input.consume();
                        if ( state.backtracking==0 ) adaptor.addChild(root_0, 
                        (Object)adaptor.create(set1363)
                        );
                        state.errorRecovery=false;
                        state.failed=false;
                    }
                    else {
                        if (state.backtracking>0) {state.failed=true; return retval;}
                        MismatchedSetException mse = new MismatchedSetException(null,input);
                        throw mse;
                    }


                    }
                    break;
                case 7 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2375:5: STATIC EXTERN UNSAFE
                    {
                    root_0 = (Object)adaptor.nil();


                    STATIC1364=(Token)match(input,STATIC,FOLLOW_STATIC_in_static_constructor_modifiers_unsafe11341); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    STATIC1364_tree = 
                    (Object)adaptor.create(STATIC1364)
                    ;
                    adaptor.addChild(root_0, STATIC1364_tree);
                    }

                    EXTERN1365=(Token)match(input,EXTERN,FOLLOW_EXTERN_in_static_constructor_modifiers_unsafe11343); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    EXTERN1365_tree = 
                    (Object)adaptor.create(EXTERN1365)
                    ;
                    adaptor.addChild(root_0, EXTERN1365_tree);
                    }

                    UNSAFE1366=(Token)match(input,UNSAFE,FOLLOW_UNSAFE_in_static_constructor_modifiers_unsafe11345); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    UNSAFE1366_tree = 
                    (Object)adaptor.create(UNSAFE1366)
                    ;
                    adaptor.addChild(root_0, UNSAFE1366_tree);
                    }

                    }
                    break;
                case 8 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2376:5: STATIC UNSAFE EXTERN
                    {
                    root_0 = (Object)adaptor.nil();


                    STATIC1367=(Token)match(input,STATIC,FOLLOW_STATIC_in_static_constructor_modifiers_unsafe11351); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    STATIC1367_tree = 
                    (Object)adaptor.create(STATIC1367)
                    ;
                    adaptor.addChild(root_0, STATIC1367_tree);
                    }

                    UNSAFE1368=(Token)match(input,UNSAFE,FOLLOW_UNSAFE_in_static_constructor_modifiers_unsafe11353); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    UNSAFE1368_tree = 
                    (Object)adaptor.create(UNSAFE1368)
                    ;
                    adaptor.addChild(root_0, UNSAFE1368_tree);
                    }

                    EXTERN1369=(Token)match(input,EXTERN,FOLLOW_EXTERN_in_static_constructor_modifiers_unsafe11355); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    EXTERN1369_tree = 
                    (Object)adaptor.create(EXTERN1369)
                    ;
                    adaptor.addChild(root_0, EXTERN1369_tree);
                    }

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "static_constructor_modifiers_unsafe"


    public static class embedded_statement_unsafe_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "embedded_statement_unsafe"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2379:1: embedded_statement_unsafe : ( unsafe_statement | fixed_statement );
    public final CSharp4AST.embedded_statement_unsafe_return embedded_statement_unsafe() throws RecognitionException {
        CSharp4AST.embedded_statement_unsafe_return retval = new CSharp4AST.embedded_statement_unsafe_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.unsafe_statement_return unsafe_statement1370 =null;

        CSharp4AST.fixed_statement_return fixed_statement1371 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2380:2: ( unsafe_statement | fixed_statement )
            int alt336=2;
            int LA336_0 = input.LA(1);

            if ( (LA336_0==UNSAFE) ) {
                alt336=1;
            }
            else if ( (LA336_0==FIXED) ) {
                alt336=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 336, 0, input);

                throw nvae;

            }
            switch (alt336) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2380:4: unsafe_statement
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_unsafe_statement_in_embedded_statement_unsafe11369);
                    unsafe_statement1370=unsafe_statement();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, unsafe_statement1370.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2381:4: fixed_statement
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_fixed_statement_in_embedded_statement_unsafe11374);
                    fixed_statement1371=fixed_statement();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, fixed_statement1371.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "embedded_statement_unsafe"


    public static class unsafe_statement_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "unsafe_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2383:1: unsafe_statement : UNSAFE block ;
    public final CSharp4AST.unsafe_statement_return unsafe_statement() throws RecognitionException {
        CSharp4AST.unsafe_statement_return retval = new CSharp4AST.unsafe_statement_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token UNSAFE1372=null;
        CSharp4AST.block_return block1373 =null;


        Object UNSAFE1372_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2384:2: ( UNSAFE block )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2384:4: UNSAFE block
            {
            root_0 = (Object)adaptor.nil();


            UNSAFE1372=(Token)match(input,UNSAFE,FOLLOW_UNSAFE_in_unsafe_statement11385); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            UNSAFE1372_tree = 
            (Object)adaptor.create(UNSAFE1372)
            ;
            adaptor.addChild(root_0, UNSAFE1372_tree);
            }

            pushFollow(FOLLOW_block_in_unsafe_statement11387);
            block1373=block();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, block1373.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "unsafe_statement"


    public static class type_unsafe_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "type_unsafe"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2386:1: type_unsafe : pointer_type ;
    public final CSharp4AST.type_unsafe_return type_unsafe() throws RecognitionException {
        CSharp4AST.type_unsafe_return retval = new CSharp4AST.type_unsafe_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.pointer_type_return pointer_type1374 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2387:2: ( pointer_type )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2387:4: pointer_type
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_pointer_type_in_type_unsafe11398);
            pointer_type1374=pointer_type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, pointer_type1374.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "type_unsafe"


    public static class pointer_type_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "pointer_type"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2396:1: pointer_type : ( simple_type | class_type | VOID ) ({...}? => rank_specifier |{...}? => INTERR | STAR )* STAR ;
    public final CSharp4AST.pointer_type_return pointer_type() throws RecognitionException {
        CSharp4AST.pointer_type_return retval = new CSharp4AST.pointer_type_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token VOID1377=null;
        Token INTERR1379=null;
        Token STAR1380=null;
        Token STAR1381=null;
        CSharp4AST.simple_type_return simple_type1375 =null;

        CSharp4AST.class_type_return class_type1376 =null;

        CSharp4AST.rank_specifier_return rank_specifier1378 =null;


        Object VOID1377_tree=null;
        Object INTERR1379_tree=null;
        Object STAR1380_tree=null;
        Object STAR1381_tree=null;


            boolean allowAll = true;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2400:3: ( ( simple_type | class_type | VOID ) ({...}? => rank_specifier |{...}? => INTERR | STAR )* STAR )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2400:5: ( simple_type | class_type | VOID ) ({...}? => rank_specifier |{...}? => INTERR | STAR )* STAR
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2400:5: ( simple_type | class_type | VOID )
            int alt337=3;
            switch ( input.LA(1) ) {
            case BOOL:
            case BYTE:
            case CHAR:
            case DECIMAL:
            case DOUBLE:
            case FLOAT:
            case INT:
            case LONG:
            case SBYTE:
            case SHORT:
            case UINT:
            case ULONG:
            case USHORT:
                {
                alt337=1;
                }
                break;
            case IDENTIFIER:
            case OBJECT:
            case STRING:
                {
                alt337=2;
                }
                break;
            case VOID:
                {
                alt337=3;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 337, 0, input);

                throw nvae;

            }

            switch (alt337) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2400:7: simple_type
                    {
                    pushFollow(FOLLOW_simple_type_in_pointer_type11420);
                    simple_type1375=simple_type();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, simple_type1375.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2401:6: class_type
                    {
                    pushFollow(FOLLOW_class_type_in_pointer_type11427);
                    class_type1376=class_type();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, class_type1376.getTree());

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2402:6: VOID
                    {
                    VOID1377=(Token)match(input,VOID,FOLLOW_VOID_in_pointer_type11434); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    VOID1377_tree = 
                    (Object)adaptor.create(VOID1377)
                    ;
                    adaptor.addChild(root_0, VOID1377_tree);
                    }

                    if ( state.backtracking==0 ) {allowAll = false;}

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2403:5: ({...}? => rank_specifier |{...}? => INTERR | STAR )*
            loop338:
            do {
                int alt338=4;
                int LA338_0 = input.LA(1);

                if ( (LA338_0==STAR) ) {
                    int LA338_1 = input.LA(2);

                    if ( (LA338_1==INTERR||LA338_1==OPEN_BRACKET||LA338_1==STAR) ) {
                        alt338=3;
                    }


                }
                else if ( (LA338_0==OPEN_BRACKET) && ((allowAll))) {
                    alt338=1;
                }
                else if ( (LA338_0==INTERR) && ((allowAll))) {
                    alt338=2;
                }


                switch (alt338) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2403:7: {...}? => rank_specifier
            	    {
            	    if ( !((allowAll)) ) {
            	        if (state.backtracking>0) {state.failed=true; return retval;}
            	        throw new FailedPredicateException(input, "pointer_type", "allowAll");
            	    }

            	    pushFollow(FOLLOW_rank_specifier_in_pointer_type11448);
            	    rank_specifier1378=rank_specifier();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, rank_specifier1378.getTree());

            	    }
            	    break;
            	case 2 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2404:7: {...}? => INTERR
            	    {
            	    if ( !((allowAll)) ) {
            	        if (state.backtracking>0) {state.failed=true; return retval;}
            	        throw new FailedPredicateException(input, "pointer_type", "allowAll");
            	    }

            	    INTERR1379=(Token)match(input,INTERR,FOLLOW_INTERR_in_pointer_type11460); if (state.failed) return retval;
            	    if ( state.backtracking==0 ) {
            	    INTERR1379_tree = 
            	    (Object)adaptor.create(INTERR1379)
            	    ;
            	    adaptor.addChild(root_0, INTERR1379_tree);
            	    }

            	    }
            	    break;
            	case 3 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2405:7: STAR
            	    {
            	    STAR1380=(Token)match(input,STAR,FOLLOW_STAR_in_pointer_type11468); if (state.failed) return retval;
            	    if ( state.backtracking==0 ) {
            	    STAR1380_tree = 
            	    (Object)adaptor.create(STAR1380)
            	    ;
            	    adaptor.addChild(root_0, STAR1380_tree);
            	    }

            	    if ( state.backtracking==0 ) {allowAll = true;}

            	    }
            	    break;

            	default :
            	    break loop338;
                }
            } while (true);


            STAR1381=(Token)match(input,STAR,FOLLOW_STAR_in_pointer_type11479); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            STAR1381_tree = 
            (Object)adaptor.create(STAR1381)
            ;
            adaptor.addChild(root_0, STAR1381_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "pointer_type"


    public static class unmanaged_type_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "unmanaged_type"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2419:1: unmanaged_type : type ;
    public final CSharp4AST.unmanaged_type_return unmanaged_type() throws RecognitionException {
        CSharp4AST.unmanaged_type_return retval = new CSharp4AST.unmanaged_type_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.type_return type1382 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2420:2: ( type )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2420:4: type
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_type_in_unmanaged_type11502);
            type1382=type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, type1382.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "unmanaged_type"


    public static class primary_no_array_creation_expression_unsafe_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "primary_no_array_creation_expression_unsafe"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2429:1: primary_no_array_creation_expression_unsafe : primary_expression ;
    public final CSharp4AST.primary_no_array_creation_expression_unsafe_return primary_no_array_creation_expression_unsafe() throws RecognitionException {
        CSharp4AST.primary_no_array_creation_expression_unsafe_return retval = new CSharp4AST.primary_no_array_creation_expression_unsafe_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.primary_expression_return primary_expression1383 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2430:2: ( primary_expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2430:4: primary_expression
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_primary_expression_in_primary_no_array_creation_expression_unsafe11515);
            primary_expression1383=primary_expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, primary_expression1383.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "primary_no_array_creation_expression_unsafe"


    public static class unary_expression_unsafe_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "unary_expression_unsafe"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2433:1: unary_expression_unsafe : ( pointer_indirection_expression | addressof_expression );
    public final CSharp4AST.unary_expression_unsafe_return unary_expression_unsafe() throws RecognitionException {
        CSharp4AST.unary_expression_unsafe_return retval = new CSharp4AST.unary_expression_unsafe_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.pointer_indirection_expression_return pointer_indirection_expression1384 =null;

        CSharp4AST.addressof_expression_return addressof_expression1385 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2434:2: ( pointer_indirection_expression | addressof_expression )
            int alt339=2;
            int LA339_0 = input.LA(1);

            if ( (LA339_0==STAR) ) {
                alt339=1;
            }
            else if ( (LA339_0==AMP) ) {
                alt339=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 339, 0, input);

                throw nvae;

            }
            switch (alt339) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2434:4: pointer_indirection_expression
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_pointer_indirection_expression_in_unary_expression_unsafe11528);
                    pointer_indirection_expression1384=pointer_indirection_expression();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, pointer_indirection_expression1384.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2435:4: addressof_expression
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_addressof_expression_in_unary_expression_unsafe11533);
                    addressof_expression1385=addressof_expression();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, addressof_expression1385.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "unary_expression_unsafe"


    public static class pointer_indirection_expression_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "pointer_indirection_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2437:1: pointer_indirection_expression : STAR unary_expression ;
    public final CSharp4AST.pointer_indirection_expression_return pointer_indirection_expression() throws RecognitionException {
        CSharp4AST.pointer_indirection_expression_return retval = new CSharp4AST.pointer_indirection_expression_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token STAR1386=null;
        CSharp4AST.unary_expression_return unary_expression1387 =null;


        Object STAR1386_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2438:2: ( STAR unary_expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2438:4: STAR unary_expression
            {
            root_0 = (Object)adaptor.nil();


            STAR1386=(Token)match(input,STAR,FOLLOW_STAR_in_pointer_indirection_expression11544); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            STAR1386_tree = 
            (Object)adaptor.create(STAR1386)
            ;
            adaptor.addChild(root_0, STAR1386_tree);
            }

            pushFollow(FOLLOW_unary_expression_in_pointer_indirection_expression11546);
            unary_expression1387=unary_expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, unary_expression1387.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "pointer_indirection_expression"


    public static class addressof_expression_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "addressof_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2451:1: addressof_expression : AMP unary_expression ;
    public final CSharp4AST.addressof_expression_return addressof_expression() throws RecognitionException {
        CSharp4AST.addressof_expression_return retval = new CSharp4AST.addressof_expression_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token AMP1388=null;
        CSharp4AST.unary_expression_return unary_expression1389 =null;


        Object AMP1388_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2452:2: ( AMP unary_expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2452:4: AMP unary_expression
            {
            root_0 = (Object)adaptor.nil();


            AMP1388=(Token)match(input,AMP,FOLLOW_AMP_in_addressof_expression11563); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            AMP1388_tree = 
            (Object)adaptor.create(AMP1388)
            ;
            adaptor.addChild(root_0, AMP1388_tree);
            }

            pushFollow(FOLLOW_unary_expression_in_addressof_expression11565);
            unary_expression1389=unary_expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, unary_expression1389.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "addressof_expression"


    public static class sizeof_expression_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "sizeof_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2454:1: sizeof_expression : SIZEOF OPEN_PARENS unmanaged_type CLOSE_PARENS ;
    public final CSharp4AST.sizeof_expression_return sizeof_expression() throws RecognitionException {
        CSharp4AST.sizeof_expression_return retval = new CSharp4AST.sizeof_expression_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token SIZEOF1390=null;
        Token OPEN_PARENS1391=null;
        Token CLOSE_PARENS1393=null;
        CSharp4AST.unmanaged_type_return unmanaged_type1392 =null;


        Object SIZEOF1390_tree=null;
        Object OPEN_PARENS1391_tree=null;
        Object CLOSE_PARENS1393_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2455:2: ( SIZEOF OPEN_PARENS unmanaged_type CLOSE_PARENS )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2455:4: SIZEOF OPEN_PARENS unmanaged_type CLOSE_PARENS
            {
            root_0 = (Object)adaptor.nil();


            SIZEOF1390=(Token)match(input,SIZEOF,FOLLOW_SIZEOF_in_sizeof_expression11576); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            SIZEOF1390_tree = 
            (Object)adaptor.create(SIZEOF1390)
            ;
            adaptor.addChild(root_0, SIZEOF1390_tree);
            }

            OPEN_PARENS1391=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_sizeof_expression11578); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            OPEN_PARENS1391_tree = 
            (Object)adaptor.create(OPEN_PARENS1391)
            ;
            adaptor.addChild(root_0, OPEN_PARENS1391_tree);
            }

            pushFollow(FOLLOW_unmanaged_type_in_sizeof_expression11580);
            unmanaged_type1392=unmanaged_type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, unmanaged_type1392.getTree());

            CLOSE_PARENS1393=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_sizeof_expression11582); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            CLOSE_PARENS1393_tree = 
            (Object)adaptor.create(CLOSE_PARENS1393)
            ;
            adaptor.addChild(root_0, CLOSE_PARENS1393_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "sizeof_expression"


    public static class fixed_statement_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "fixed_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2457:1: fixed_statement : FIXED OPEN_PARENS pointer_type fixed_pointer_declarators CLOSE_PARENS embedded_statement ;
    public final CSharp4AST.fixed_statement_return fixed_statement() throws RecognitionException {
        CSharp4AST.fixed_statement_return retval = new CSharp4AST.fixed_statement_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token FIXED1394=null;
        Token OPEN_PARENS1395=null;
        Token CLOSE_PARENS1398=null;
        CSharp4AST.pointer_type_return pointer_type1396 =null;

        CSharp4AST.fixed_pointer_declarators_return fixed_pointer_declarators1397 =null;

        CSharp4AST.embedded_statement_return embedded_statement1399 =null;


        Object FIXED1394_tree=null;
        Object OPEN_PARENS1395_tree=null;
        Object CLOSE_PARENS1398_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2458:2: ( FIXED OPEN_PARENS pointer_type fixed_pointer_declarators CLOSE_PARENS embedded_statement )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2458:4: FIXED OPEN_PARENS pointer_type fixed_pointer_declarators CLOSE_PARENS embedded_statement
            {
            root_0 = (Object)adaptor.nil();


            FIXED1394=(Token)match(input,FIXED,FOLLOW_FIXED_in_fixed_statement11593); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            FIXED1394_tree = 
            (Object)adaptor.create(FIXED1394)
            ;
            adaptor.addChild(root_0, FIXED1394_tree);
            }

            OPEN_PARENS1395=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_fixed_statement11595); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            OPEN_PARENS1395_tree = 
            (Object)adaptor.create(OPEN_PARENS1395)
            ;
            adaptor.addChild(root_0, OPEN_PARENS1395_tree);
            }

            pushFollow(FOLLOW_pointer_type_in_fixed_statement11597);
            pointer_type1396=pointer_type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, pointer_type1396.getTree());

            pushFollow(FOLLOW_fixed_pointer_declarators_in_fixed_statement11599);
            fixed_pointer_declarators1397=fixed_pointer_declarators();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, fixed_pointer_declarators1397.getTree());

            CLOSE_PARENS1398=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_fixed_statement11601); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            CLOSE_PARENS1398_tree = 
            (Object)adaptor.create(CLOSE_PARENS1398)
            ;
            adaptor.addChild(root_0, CLOSE_PARENS1398_tree);
            }

            pushFollow(FOLLOW_embedded_statement_in_fixed_statement11603);
            embedded_statement1399=embedded_statement();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, embedded_statement1399.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "fixed_statement"


    public static class fixed_pointer_declarators_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "fixed_pointer_declarators"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2460:1: fixed_pointer_declarators : fixed_pointer_declarator ( COMMA fixed_pointer_declarator )* ;
    public final CSharp4AST.fixed_pointer_declarators_return fixed_pointer_declarators() throws RecognitionException {
        CSharp4AST.fixed_pointer_declarators_return retval = new CSharp4AST.fixed_pointer_declarators_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token COMMA1401=null;
        CSharp4AST.fixed_pointer_declarator_return fixed_pointer_declarator1400 =null;

        CSharp4AST.fixed_pointer_declarator_return fixed_pointer_declarator1402 =null;


        Object COMMA1401_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2461:2: ( fixed_pointer_declarator ( COMMA fixed_pointer_declarator )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2461:4: fixed_pointer_declarator ( COMMA fixed_pointer_declarator )*
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_fixed_pointer_declarator_in_fixed_pointer_declarators11614);
            fixed_pointer_declarator1400=fixed_pointer_declarator();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, fixed_pointer_declarator1400.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2461:29: ( COMMA fixed_pointer_declarator )*
            loop340:
            do {
                int alt340=2;
                int LA340_0 = input.LA(1);

                if ( (LA340_0==COMMA) ) {
                    alt340=1;
                }


                switch (alt340) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2461:31: COMMA fixed_pointer_declarator
            	    {
            	    COMMA1401=(Token)match(input,COMMA,FOLLOW_COMMA_in_fixed_pointer_declarators11618); if (state.failed) return retval;
            	    if ( state.backtracking==0 ) {
            	    COMMA1401_tree = 
            	    (Object)adaptor.create(COMMA1401)
            	    ;
            	    adaptor.addChild(root_0, COMMA1401_tree);
            	    }

            	    pushFollow(FOLLOW_fixed_pointer_declarator_in_fixed_pointer_declarators11621);
            	    fixed_pointer_declarator1402=fixed_pointer_declarator();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, fixed_pointer_declarator1402.getTree());

            	    }
            	    break;

            	default :
            	    break loop340;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "fixed_pointer_declarators"


    public static class fixed_pointer_declarator_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "fixed_pointer_declarator"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2463:1: fixed_pointer_declarator : IDENTIFIER ASSIGNMENT fixed_pointer_initializer ;
    public final CSharp4AST.fixed_pointer_declarator_return fixed_pointer_declarator() throws RecognitionException {
        CSharp4AST.fixed_pointer_declarator_return retval = new CSharp4AST.fixed_pointer_declarator_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER1403=null;
        Token ASSIGNMENT1404=null;
        CSharp4AST.fixed_pointer_initializer_return fixed_pointer_initializer1405 =null;


        Object IDENTIFIER1403_tree=null;
        Object ASSIGNMENT1404_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2464:2: ( IDENTIFIER ASSIGNMENT fixed_pointer_initializer )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2464:4: IDENTIFIER ASSIGNMENT fixed_pointer_initializer
            {
            root_0 = (Object)adaptor.nil();


            IDENTIFIER1403=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_fixed_pointer_declarator11635); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1403_tree = 
            (Object)adaptor.create(IDENTIFIER1403)
            ;
            adaptor.addChild(root_0, IDENTIFIER1403_tree);
            }

            ASSIGNMENT1404=(Token)match(input,ASSIGNMENT,FOLLOW_ASSIGNMENT_in_fixed_pointer_declarator11637); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            ASSIGNMENT1404_tree = 
            (Object)adaptor.create(ASSIGNMENT1404)
            ;
            adaptor.addChild(root_0, ASSIGNMENT1404_tree);
            }

            pushFollow(FOLLOW_fixed_pointer_initializer_in_fixed_pointer_declarator11639);
            fixed_pointer_initializer1405=fixed_pointer_initializer();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, fixed_pointer_initializer1405.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "fixed_pointer_declarator"


    public static class fixed_pointer_initializer_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "fixed_pointer_initializer"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2472:1: fixed_pointer_initializer : ( ( AMP )=> AMP variable_reference | expression );
    public final CSharp4AST.fixed_pointer_initializer_return fixed_pointer_initializer() throws RecognitionException {
        CSharp4AST.fixed_pointer_initializer_return retval = new CSharp4AST.fixed_pointer_initializer_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token AMP1406=null;
        CSharp4AST.variable_reference_return variable_reference1407 =null;

        CSharp4AST.expression_return expression1408 =null;


        Object AMP1406_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2473:3: ( ( AMP )=> AMP variable_reference | expression )
            int alt341=2;
            int LA341_0 = input.LA(1);

            if ( (LA341_0==AMP) ) {
                int LA341_1 = input.LA(2);

                if ( (synpred27_CSharp4AST()) ) {
                    alt341=1;
                }
                else if ( (true) ) {
                    alt341=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 341, 1, input);

                    throw nvae;

                }
            }
            else if ( ((LA341_0 >= BANG && LA341_0 <= BASE)||LA341_0==BOOL||LA341_0==BYTE||(LA341_0 >= CHAR && LA341_0 <= CHECKED)||LA341_0==DECIMAL||(LA341_0 >= DEFAULT && LA341_0 <= DELEGATE)||LA341_0==DOUBLE||LA341_0==FALSE||LA341_0==FLOAT||LA341_0==IDENTIFIER||(LA341_0 >= INT && LA341_0 <= INTEGER_LITERAL)||LA341_0==LONG||LA341_0==MINUS||LA341_0==NEW||LA341_0==NULL||LA341_0==OBJECT||LA341_0==OPEN_PARENS||LA341_0==OP_DEC||LA341_0==OP_INC||LA341_0==PLUS||LA341_0==REAL_LITERAL||LA341_0==SBYTE||LA341_0==SHORT||LA341_0==SIZEOF||LA341_0==STAR||(LA341_0 >= STRING && LA341_0 <= STRING_LITERAL)||LA341_0==THIS||(LA341_0 >= TILDE && LA341_0 <= TRUE)||LA341_0==TYPEOF||(LA341_0 >= UINT && LA341_0 <= UNCHECKED)||LA341_0==USHORT) ) {
                alt341=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 341, 0, input);

                throw nvae;

            }
            switch (alt341) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2473:5: ( AMP )=> AMP variable_reference
                    {
                    root_0 = (Object)adaptor.nil();


                    AMP1406=(Token)match(input,AMP,FOLLOW_AMP_in_fixed_pointer_initializer11659); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    AMP1406_tree = 
                    (Object)adaptor.create(AMP1406)
                    ;
                    adaptor.addChild(root_0, AMP1406_tree);
                    }

                    pushFollow(FOLLOW_variable_reference_in_fixed_pointer_initializer11661);
                    variable_reference1407=variable_reference();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, variable_reference1407.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2474:5: expression
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_expression_in_fixed_pointer_initializer11667);
                    expression1408=expression();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, expression1408.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "fixed_pointer_initializer"


    public static class struct_member_declaration_unsafe_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "struct_member_declaration_unsafe"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2476:1: struct_member_declaration_unsafe : fixed_size_buffer_declaration ;
    public final CSharp4AST.struct_member_declaration_unsafe_return struct_member_declaration_unsafe() throws RecognitionException {
        CSharp4AST.struct_member_declaration_unsafe_return retval = new CSharp4AST.struct_member_declaration_unsafe_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.fixed_size_buffer_declaration_return fixed_size_buffer_declaration1409 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2477:2: ( fixed_size_buffer_declaration )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2477:4: fixed_size_buffer_declaration
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_fixed_size_buffer_declaration_in_struct_member_declaration_unsafe11679);
            fixed_size_buffer_declaration1409=fixed_size_buffer_declaration();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, fixed_size_buffer_declaration1409.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "struct_member_declaration_unsafe"


    public static class fixed_size_buffer_declaration_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "fixed_size_buffer_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2479:1: fixed_size_buffer_declaration : ( attributes )? ( fixed_size_buffer_modifiers )? FIXED buffer_element_type fixed_size_buffer_declarators SEMICOLON ;
    public final CSharp4AST.fixed_size_buffer_declaration_return fixed_size_buffer_declaration() throws RecognitionException {
        CSharp4AST.fixed_size_buffer_declaration_return retval = new CSharp4AST.fixed_size_buffer_declaration_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token FIXED1412=null;
        Token SEMICOLON1415=null;
        CSharp4AST.attributes_return attributes1410 =null;

        CSharp4AST.fixed_size_buffer_modifiers_return fixed_size_buffer_modifiers1411 =null;

        CSharp4AST.buffer_element_type_return buffer_element_type1413 =null;

        CSharp4AST.fixed_size_buffer_declarators_return fixed_size_buffer_declarators1414 =null;


        Object FIXED1412_tree=null;
        Object SEMICOLON1415_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2480:2: ( ( attributes )? ( fixed_size_buffer_modifiers )? FIXED buffer_element_type fixed_size_buffer_declarators SEMICOLON )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2480:4: ( attributes )? ( fixed_size_buffer_modifiers )? FIXED buffer_element_type fixed_size_buffer_declarators SEMICOLON
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2480:4: ( attributes )?
            int alt342=2;
            int LA342_0 = input.LA(1);

            if ( (LA342_0==OPEN_BRACKET) ) {
                alt342=1;
            }
            switch (alt342) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2480:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_fixed_size_buffer_declaration11690);
                    attributes1410=attributes();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, attributes1410.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2480:16: ( fixed_size_buffer_modifiers )?
            int alt343=2;
            int LA343_0 = input.LA(1);

            if ( (LA343_0==INTERNAL||LA343_0==NEW||(LA343_0 >= PRIVATE && LA343_0 <= PUBLIC)||LA343_0==UNSAFE) ) {
                alt343=1;
            }
            switch (alt343) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2480:16: fixed_size_buffer_modifiers
                    {
                    pushFollow(FOLLOW_fixed_size_buffer_modifiers_in_fixed_size_buffer_declaration11693);
                    fixed_size_buffer_modifiers1411=fixed_size_buffer_modifiers();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, fixed_size_buffer_modifiers1411.getTree());

                    }
                    break;

            }


            FIXED1412=(Token)match(input,FIXED,FOLLOW_FIXED_in_fixed_size_buffer_declaration11696); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            FIXED1412_tree = 
            (Object)adaptor.create(FIXED1412)
            ;
            adaptor.addChild(root_0, FIXED1412_tree);
            }

            pushFollow(FOLLOW_buffer_element_type_in_fixed_size_buffer_declaration11698);
            buffer_element_type1413=buffer_element_type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, buffer_element_type1413.getTree());

            pushFollow(FOLLOW_fixed_size_buffer_declarators_in_fixed_size_buffer_declaration11700);
            fixed_size_buffer_declarators1414=fixed_size_buffer_declarators();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, fixed_size_buffer_declarators1414.getTree());

            SEMICOLON1415=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_fixed_size_buffer_declaration11702); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            SEMICOLON1415_tree = 
            (Object)adaptor.create(SEMICOLON1415)
            ;
            adaptor.addChild(root_0, SEMICOLON1415_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "fixed_size_buffer_declaration"


    public static class fixed_size_buffer_modifiers_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "fixed_size_buffer_modifiers"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2482:1: fixed_size_buffer_modifiers : ( fixed_size_buffer_modifier )+ ;
    public final CSharp4AST.fixed_size_buffer_modifiers_return fixed_size_buffer_modifiers() throws RecognitionException {
        CSharp4AST.fixed_size_buffer_modifiers_return retval = new CSharp4AST.fixed_size_buffer_modifiers_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.fixed_size_buffer_modifier_return fixed_size_buffer_modifier1416 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2483:2: ( ( fixed_size_buffer_modifier )+ )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2483:4: ( fixed_size_buffer_modifier )+
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2483:4: ( fixed_size_buffer_modifier )+
            int cnt344=0;
            loop344:
            do {
                int alt344=2;
                int LA344_0 = input.LA(1);

                if ( (LA344_0==INTERNAL||LA344_0==NEW||(LA344_0 >= PRIVATE && LA344_0 <= PUBLIC)||LA344_0==UNSAFE) ) {
                    alt344=1;
                }


                switch (alt344) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2483:4: fixed_size_buffer_modifier
            	    {
            	    pushFollow(FOLLOW_fixed_size_buffer_modifier_in_fixed_size_buffer_modifiers11713);
            	    fixed_size_buffer_modifier1416=fixed_size_buffer_modifier();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, fixed_size_buffer_modifier1416.getTree());

            	    }
            	    break;

            	default :
            	    if ( cnt344 >= 1 ) break loop344;
            	    if (state.backtracking>0) {state.failed=true; return retval;}
                        EarlyExitException eee =
                            new EarlyExitException(344, input);
                        throw eee;
                }
                cnt344++;
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "fixed_size_buffer_modifiers"


    public static class fixed_size_buffer_modifier_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "fixed_size_buffer_modifier"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2485:1: fixed_size_buffer_modifier : ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | UNSAFE );
    public final CSharp4AST.fixed_size_buffer_modifier_return fixed_size_buffer_modifier() throws RecognitionException {
        CSharp4AST.fixed_size_buffer_modifier_return retval = new CSharp4AST.fixed_size_buffer_modifier_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token set1417=null;

        Object set1417_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2486:2: ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | UNSAFE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:
            {
            root_0 = (Object)adaptor.nil();


            set1417=(Token)input.LT(1);

            if ( input.LA(1)==INTERNAL||input.LA(1)==NEW||(input.LA(1) >= PRIVATE && input.LA(1) <= PUBLIC)||input.LA(1)==UNSAFE ) {
                input.consume();
                if ( state.backtracking==0 ) adaptor.addChild(root_0, 
                (Object)adaptor.create(set1417)
                );
                state.errorRecovery=false;
                state.failed=false;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                MismatchedSetException mse = new MismatchedSetException(null,input);
                throw mse;
            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "fixed_size_buffer_modifier"


    public static class buffer_element_type_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "buffer_element_type"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2493:1: buffer_element_type : type ;
    public final CSharp4AST.buffer_element_type_return buffer_element_type() throws RecognitionException {
        CSharp4AST.buffer_element_type_return retval = new CSharp4AST.buffer_element_type_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.type_return type1418 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2494:2: ( type )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2494:4: type
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_type_in_buffer_element_type11761);
            type1418=type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, type1418.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "buffer_element_type"


    public static class fixed_size_buffer_declarators_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "fixed_size_buffer_declarators"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2496:1: fixed_size_buffer_declarators : ( fixed_size_buffer_declarator )+ ;
    public final CSharp4AST.fixed_size_buffer_declarators_return fixed_size_buffer_declarators() throws RecognitionException {
        CSharp4AST.fixed_size_buffer_declarators_return retval = new CSharp4AST.fixed_size_buffer_declarators_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.fixed_size_buffer_declarator_return fixed_size_buffer_declarator1419 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2497:2: ( ( fixed_size_buffer_declarator )+ )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2497:4: ( fixed_size_buffer_declarator )+
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2497:4: ( fixed_size_buffer_declarator )+
            int cnt345=0;
            loop345:
            do {
                int alt345=2;
                int LA345_0 = input.LA(1);

                if ( (LA345_0==IDENTIFIER) ) {
                    alt345=1;
                }


                switch (alt345) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2497:4: fixed_size_buffer_declarator
            	    {
            	    pushFollow(FOLLOW_fixed_size_buffer_declarator_in_fixed_size_buffer_declarators11772);
            	    fixed_size_buffer_declarator1419=fixed_size_buffer_declarator();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, fixed_size_buffer_declarator1419.getTree());

            	    }
            	    break;

            	default :
            	    if ( cnt345 >= 1 ) break loop345;
            	    if (state.backtracking>0) {state.failed=true; return retval;}
                        EarlyExitException eee =
                            new EarlyExitException(345, input);
                        throw eee;
                }
                cnt345++;
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "fixed_size_buffer_declarators"


    public static class fixed_size_buffer_declarator_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "fixed_size_buffer_declarator"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2499:1: fixed_size_buffer_declarator : IDENTIFIER OPEN_BRACKET constant_expression CLOSE_BRACKET ;
    public final CSharp4AST.fixed_size_buffer_declarator_return fixed_size_buffer_declarator() throws RecognitionException {
        CSharp4AST.fixed_size_buffer_declarator_return retval = new CSharp4AST.fixed_size_buffer_declarator_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER1420=null;
        Token OPEN_BRACKET1421=null;
        Token CLOSE_BRACKET1423=null;
        CSharp4AST.constant_expression_return constant_expression1422 =null;


        Object IDENTIFIER1420_tree=null;
        Object OPEN_BRACKET1421_tree=null;
        Object CLOSE_BRACKET1423_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2500:2: ( IDENTIFIER OPEN_BRACKET constant_expression CLOSE_BRACKET )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2500:4: IDENTIFIER OPEN_BRACKET constant_expression CLOSE_BRACKET
            {
            root_0 = (Object)adaptor.nil();


            IDENTIFIER1420=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_fixed_size_buffer_declarator11784); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1420_tree = 
            (Object)adaptor.create(IDENTIFIER1420)
            ;
            adaptor.addChild(root_0, IDENTIFIER1420_tree);
            }

            OPEN_BRACKET1421=(Token)match(input,OPEN_BRACKET,FOLLOW_OPEN_BRACKET_in_fixed_size_buffer_declarator11786); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            OPEN_BRACKET1421_tree = 
            (Object)adaptor.create(OPEN_BRACKET1421)
            ;
            adaptor.addChild(root_0, OPEN_BRACKET1421_tree);
            }

            pushFollow(FOLLOW_constant_expression_in_fixed_size_buffer_declarator11788);
            constant_expression1422=constant_expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, constant_expression1422.getTree());

            CLOSE_BRACKET1423=(Token)match(input,CLOSE_BRACKET,FOLLOW_CLOSE_BRACKET_in_fixed_size_buffer_declarator11790); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            CLOSE_BRACKET1423_tree = 
            (Object)adaptor.create(CLOSE_BRACKET1423)
            ;
            adaptor.addChild(root_0, CLOSE_BRACKET1423_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "fixed_size_buffer_declarator"


    public static class local_variable_initializer_unsafe_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "local_variable_initializer_unsafe"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2503:1: local_variable_initializer_unsafe : stackalloc_initializer ;
    public final CSharp4AST.local_variable_initializer_unsafe_return local_variable_initializer_unsafe() throws RecognitionException {
        CSharp4AST.local_variable_initializer_unsafe_return retval = new CSharp4AST.local_variable_initializer_unsafe_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.stackalloc_initializer_return stackalloc_initializer1424 =null;



        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2504:2: ( stackalloc_initializer )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2504:4: stackalloc_initializer
            {
            root_0 = (Object)adaptor.nil();


            pushFollow(FOLLOW_stackalloc_initializer_in_local_variable_initializer_unsafe11803);
            stackalloc_initializer1424=stackalloc_initializer();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, stackalloc_initializer1424.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "local_variable_initializer_unsafe"


    public static class stackalloc_initializer_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "stackalloc_initializer"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2506:1: stackalloc_initializer : STACKALLOC unmanaged_type OPEN_BRACKET expression CLOSE_BRACKET ;
    public final CSharp4AST.stackalloc_initializer_return stackalloc_initializer() throws RecognitionException {
        CSharp4AST.stackalloc_initializer_return retval = new CSharp4AST.stackalloc_initializer_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token STACKALLOC1425=null;
        Token OPEN_BRACKET1427=null;
        Token CLOSE_BRACKET1429=null;
        CSharp4AST.unmanaged_type_return unmanaged_type1426 =null;

        CSharp4AST.expression_return expression1428 =null;


        Object STACKALLOC1425_tree=null;
        Object OPEN_BRACKET1427_tree=null;
        Object CLOSE_BRACKET1429_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2507:2: ( STACKALLOC unmanaged_type OPEN_BRACKET expression CLOSE_BRACKET )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2507:4: STACKALLOC unmanaged_type OPEN_BRACKET expression CLOSE_BRACKET
            {
            root_0 = (Object)adaptor.nil();


            STACKALLOC1425=(Token)match(input,STACKALLOC,FOLLOW_STACKALLOC_in_stackalloc_initializer11814); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            STACKALLOC1425_tree = 
            (Object)adaptor.create(STACKALLOC1425)
            ;
            adaptor.addChild(root_0, STACKALLOC1425_tree);
            }

            pushFollow(FOLLOW_unmanaged_type_in_stackalloc_initializer11816);
            unmanaged_type1426=unmanaged_type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, unmanaged_type1426.getTree());

            OPEN_BRACKET1427=(Token)match(input,OPEN_BRACKET,FOLLOW_OPEN_BRACKET_in_stackalloc_initializer11818); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            OPEN_BRACKET1427_tree = 
            (Object)adaptor.create(OPEN_BRACKET1427)
            ;
            adaptor.addChild(root_0, OPEN_BRACKET1427_tree);
            }

            pushFollow(FOLLOW_expression_in_stackalloc_initializer11820);
            expression1428=expression();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, expression1428.getTree());

            CLOSE_BRACKET1429=(Token)match(input,CLOSE_BRACKET,FOLLOW_CLOSE_BRACKET_in_stackalloc_initializer11822); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            CLOSE_BRACKET1429_tree = 
            (Object)adaptor.create(CLOSE_BRACKET1429)
            ;
            adaptor.addChild(root_0, CLOSE_BRACKET1429_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "stackalloc_initializer"


    public static class from_contextual_keyword_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "from_contextual_keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2517:1: from_contextual_keyword :{...}? IDENTIFIER ;
    public final CSharp4AST.from_contextual_keyword_return from_contextual_keyword() throws RecognitionException {
        CSharp4AST.from_contextual_keyword_return retval = new CSharp4AST.from_contextual_keyword_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER1430=null;

        Object IDENTIFIER1430_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2518:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2518:5: {...}? IDENTIFIER
            {
            root_0 = (Object)adaptor.nil();


            if ( !((input.LT(1).getText().equals("from"))) ) {
                if (state.backtracking>0) {state.failed=true; return retval;}
                throw new FailedPredicateException(input, "from_contextual_keyword", "input.LT(1).getText().equals(\"from\")");
            }

            IDENTIFIER1430=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_from_contextual_keyword11844); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1430_tree = 
            (Object)adaptor.create(IDENTIFIER1430)
            ;
            adaptor.addChild(root_0, IDENTIFIER1430_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "from_contextual_keyword"


    public static class let_contextual_keyword_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "let_contextual_keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2520:1: let_contextual_keyword :{...}? IDENTIFIER ;
    public final CSharp4AST.let_contextual_keyword_return let_contextual_keyword() throws RecognitionException {
        CSharp4AST.let_contextual_keyword_return retval = new CSharp4AST.let_contextual_keyword_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER1431=null;

        Object IDENTIFIER1431_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2521:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2521:5: {...}? IDENTIFIER
            {
            root_0 = (Object)adaptor.nil();


            if ( !((input.LT(1).getText().equals("let"))) ) {
                if (state.backtracking>0) {state.failed=true; return retval;}
                throw new FailedPredicateException(input, "let_contextual_keyword", "input.LT(1).getText().equals(\"let\")");
            }

            IDENTIFIER1431=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_let_contextual_keyword11858); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1431_tree = 
            (Object)adaptor.create(IDENTIFIER1431)
            ;
            adaptor.addChild(root_0, IDENTIFIER1431_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "let_contextual_keyword"


    public static class where_contextual_keyword_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "where_contextual_keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2523:1: where_contextual_keyword :{...}? IDENTIFIER ;
    public final CSharp4AST.where_contextual_keyword_return where_contextual_keyword() throws RecognitionException {
        CSharp4AST.where_contextual_keyword_return retval = new CSharp4AST.where_contextual_keyword_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER1432=null;

        Object IDENTIFIER1432_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2524:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2524:5: {...}? IDENTIFIER
            {
            root_0 = (Object)adaptor.nil();


            if ( !((input.LT(1).getText().equals("where"))) ) {
                if (state.backtracking>0) {state.failed=true; return retval;}
                throw new FailedPredicateException(input, "where_contextual_keyword", "input.LT(1).getText().equals(\"where\")");
            }

            IDENTIFIER1432=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_where_contextual_keyword11872); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1432_tree = 
            (Object)adaptor.create(IDENTIFIER1432)
            ;
            adaptor.addChild(root_0, IDENTIFIER1432_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "where_contextual_keyword"


    public static class join_contextual_keyword_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "join_contextual_keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2526:1: join_contextual_keyword :{...}? IDENTIFIER ;
    public final CSharp4AST.join_contextual_keyword_return join_contextual_keyword() throws RecognitionException {
        CSharp4AST.join_contextual_keyword_return retval = new CSharp4AST.join_contextual_keyword_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER1433=null;

        Object IDENTIFIER1433_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2527:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2527:5: {...}? IDENTIFIER
            {
            root_0 = (Object)adaptor.nil();


            if ( !((input.LT(1).getText().equals("join"))) ) {
                if (state.backtracking>0) {state.failed=true; return retval;}
                throw new FailedPredicateException(input, "join_contextual_keyword", "input.LT(1).getText().equals(\"join\")");
            }

            IDENTIFIER1433=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_join_contextual_keyword11886); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1433_tree = 
            (Object)adaptor.create(IDENTIFIER1433)
            ;
            adaptor.addChild(root_0, IDENTIFIER1433_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "join_contextual_keyword"


    public static class on_contextual_keyword_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "on_contextual_keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2529:1: on_contextual_keyword :{...}? IDENTIFIER ;
    public final CSharp4AST.on_contextual_keyword_return on_contextual_keyword() throws RecognitionException {
        CSharp4AST.on_contextual_keyword_return retval = new CSharp4AST.on_contextual_keyword_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER1434=null;

        Object IDENTIFIER1434_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2530:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2530:5: {...}? IDENTIFIER
            {
            root_0 = (Object)adaptor.nil();


            if ( !((input.LT(1).getText().equals("on"))) ) {
                if (state.backtracking>0) {state.failed=true; return retval;}
                throw new FailedPredicateException(input, "on_contextual_keyword", "input.LT(1).getText().equals(\"on\")");
            }

            IDENTIFIER1434=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_on_contextual_keyword11900); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1434_tree = 
            (Object)adaptor.create(IDENTIFIER1434)
            ;
            adaptor.addChild(root_0, IDENTIFIER1434_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "on_contextual_keyword"


    public static class equals_contextual_keyword_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "equals_contextual_keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2532:1: equals_contextual_keyword :{...}? IDENTIFIER ;
    public final CSharp4AST.equals_contextual_keyword_return equals_contextual_keyword() throws RecognitionException {
        CSharp4AST.equals_contextual_keyword_return retval = new CSharp4AST.equals_contextual_keyword_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER1435=null;

        Object IDENTIFIER1435_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2533:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2533:5: {...}? IDENTIFIER
            {
            root_0 = (Object)adaptor.nil();


            if ( !((input.LT(1).getText().equals("equals"))) ) {
                if (state.backtracking>0) {state.failed=true; return retval;}
                throw new FailedPredicateException(input, "equals_contextual_keyword", "input.LT(1).getText().equals(\"equals\")");
            }

            IDENTIFIER1435=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_equals_contextual_keyword11914); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1435_tree = 
            (Object)adaptor.create(IDENTIFIER1435)
            ;
            adaptor.addChild(root_0, IDENTIFIER1435_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "equals_contextual_keyword"


    public static class into_contextual_keyword_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "into_contextual_keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2535:1: into_contextual_keyword :{...}? IDENTIFIER ;
    public final CSharp4AST.into_contextual_keyword_return into_contextual_keyword() throws RecognitionException {
        CSharp4AST.into_contextual_keyword_return retval = new CSharp4AST.into_contextual_keyword_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER1436=null;

        Object IDENTIFIER1436_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2536:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2536:5: {...}? IDENTIFIER
            {
            root_0 = (Object)adaptor.nil();


            if ( !((input.LT(1).getText().equals("into"))) ) {
                if (state.backtracking>0) {state.failed=true; return retval;}
                throw new FailedPredicateException(input, "into_contextual_keyword", "input.LT(1).getText().equals(\"into\")");
            }

            IDENTIFIER1436=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_into_contextual_keyword11928); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1436_tree = 
            (Object)adaptor.create(IDENTIFIER1436)
            ;
            adaptor.addChild(root_0, IDENTIFIER1436_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "into_contextual_keyword"


    public static class orderby_contextual_keyword_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "orderby_contextual_keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2538:1: orderby_contextual_keyword :{...}? IDENTIFIER ;
    public final CSharp4AST.orderby_contextual_keyword_return orderby_contextual_keyword() throws RecognitionException {
        CSharp4AST.orderby_contextual_keyword_return retval = new CSharp4AST.orderby_contextual_keyword_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER1437=null;

        Object IDENTIFIER1437_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2539:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2539:5: {...}? IDENTIFIER
            {
            root_0 = (Object)adaptor.nil();


            if ( !((input.LT(1).getText().equals("orderby"))) ) {
                if (state.backtracking>0) {state.failed=true; return retval;}
                throw new FailedPredicateException(input, "orderby_contextual_keyword", "input.LT(1).getText().equals(\"orderby\")");
            }

            IDENTIFIER1437=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_orderby_contextual_keyword11942); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1437_tree = 
            (Object)adaptor.create(IDENTIFIER1437)
            ;
            adaptor.addChild(root_0, IDENTIFIER1437_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "orderby_contextual_keyword"


    public static class ascending_contextual_keyword_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "ascending_contextual_keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2541:1: ascending_contextual_keyword :{...}? IDENTIFIER ;
    public final CSharp4AST.ascending_contextual_keyword_return ascending_contextual_keyword() throws RecognitionException {
        CSharp4AST.ascending_contextual_keyword_return retval = new CSharp4AST.ascending_contextual_keyword_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER1438=null;

        Object IDENTIFIER1438_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2542:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2542:5: {...}? IDENTIFIER
            {
            root_0 = (Object)adaptor.nil();


            if ( !((input.LT(1).getText().equals("ascending"))) ) {
                if (state.backtracking>0) {state.failed=true; return retval;}
                throw new FailedPredicateException(input, "ascending_contextual_keyword", "input.LT(1).getText().equals(\"ascending\")");
            }

            IDENTIFIER1438=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_ascending_contextual_keyword11956); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1438_tree = 
            (Object)adaptor.create(IDENTIFIER1438)
            ;
            adaptor.addChild(root_0, IDENTIFIER1438_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "ascending_contextual_keyword"


    public static class descending_contextual_keyword_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "descending_contextual_keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2544:1: descending_contextual_keyword :{...}? IDENTIFIER ;
    public final CSharp4AST.descending_contextual_keyword_return descending_contextual_keyword() throws RecognitionException {
        CSharp4AST.descending_contextual_keyword_return retval = new CSharp4AST.descending_contextual_keyword_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER1439=null;

        Object IDENTIFIER1439_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2545:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2545:5: {...}? IDENTIFIER
            {
            root_0 = (Object)adaptor.nil();


            if ( !((input.LT(1).getText().equals("descending"))) ) {
                if (state.backtracking>0) {state.failed=true; return retval;}
                throw new FailedPredicateException(input, "descending_contextual_keyword", "input.LT(1).getText().equals(\"descending\")");
            }

            IDENTIFIER1439=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_descending_contextual_keyword11970); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1439_tree = 
            (Object)adaptor.create(IDENTIFIER1439)
            ;
            adaptor.addChild(root_0, IDENTIFIER1439_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "descending_contextual_keyword"


    public static class select_contextual_keyword_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "select_contextual_keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2547:1: select_contextual_keyword :{...}? IDENTIFIER ;
    public final CSharp4AST.select_contextual_keyword_return select_contextual_keyword() throws RecognitionException {
        CSharp4AST.select_contextual_keyword_return retval = new CSharp4AST.select_contextual_keyword_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER1440=null;

        Object IDENTIFIER1440_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2548:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2548:5: {...}? IDENTIFIER
            {
            root_0 = (Object)adaptor.nil();


            if ( !((input.LT(1).getText().equals("select"))) ) {
                if (state.backtracking>0) {state.failed=true; return retval;}
                throw new FailedPredicateException(input, "select_contextual_keyword", "input.LT(1).getText().equals(\"select\")");
            }

            IDENTIFIER1440=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_select_contextual_keyword11984); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1440_tree = 
            (Object)adaptor.create(IDENTIFIER1440)
            ;
            adaptor.addChild(root_0, IDENTIFIER1440_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "select_contextual_keyword"


    public static class group_contextual_keyword_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "group_contextual_keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2550:1: group_contextual_keyword :{...}? IDENTIFIER ;
    public final CSharp4AST.group_contextual_keyword_return group_contextual_keyword() throws RecognitionException {
        CSharp4AST.group_contextual_keyword_return retval = new CSharp4AST.group_contextual_keyword_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER1441=null;

        Object IDENTIFIER1441_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2551:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2551:5: {...}? IDENTIFIER
            {
            root_0 = (Object)adaptor.nil();


            if ( !((input.LT(1).getText().equals("group"))) ) {
                if (state.backtracking>0) {state.failed=true; return retval;}
                throw new FailedPredicateException(input, "group_contextual_keyword", "input.LT(1).getText().equals(\"group\")");
            }

            IDENTIFIER1441=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_group_contextual_keyword11998); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1441_tree = 
            (Object)adaptor.create(IDENTIFIER1441)
            ;
            adaptor.addChild(root_0, IDENTIFIER1441_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "group_contextual_keyword"


    public static class by_contextual_keyword_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "by_contextual_keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2553:1: by_contextual_keyword :{...}? IDENTIFIER ;
    public final CSharp4AST.by_contextual_keyword_return by_contextual_keyword() throws RecognitionException {
        CSharp4AST.by_contextual_keyword_return retval = new CSharp4AST.by_contextual_keyword_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER1442=null;

        Object IDENTIFIER1442_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2554:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2554:5: {...}? IDENTIFIER
            {
            root_0 = (Object)adaptor.nil();


            if ( !((input.LT(1).getText().equals("by"))) ) {
                if (state.backtracking>0) {state.failed=true; return retval;}
                throw new FailedPredicateException(input, "by_contextual_keyword", "input.LT(1).getText().equals(\"by\")");
            }

            IDENTIFIER1442=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_by_contextual_keyword12012); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1442_tree = 
            (Object)adaptor.create(IDENTIFIER1442)
            ;
            adaptor.addChild(root_0, IDENTIFIER1442_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "by_contextual_keyword"


    public static class partial_contextual_keyword_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "partial_contextual_keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2556:1: partial_contextual_keyword :{...}? IDENTIFIER ;
    public final CSharp4AST.partial_contextual_keyword_return partial_contextual_keyword() throws RecognitionException {
        CSharp4AST.partial_contextual_keyword_return retval = new CSharp4AST.partial_contextual_keyword_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER1443=null;

        Object IDENTIFIER1443_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2557:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2557:5: {...}? IDENTIFIER
            {
            root_0 = (Object)adaptor.nil();


            if ( !((input.LT(1).getText().equals("partial"))) ) {
                if (state.backtracking>0) {state.failed=true; return retval;}
                throw new FailedPredicateException(input, "partial_contextual_keyword", "input.LT(1).getText().equals(\"partial\")");
            }

            IDENTIFIER1443=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_partial_contextual_keyword12026); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1443_tree = 
            (Object)adaptor.create(IDENTIFIER1443)
            ;
            adaptor.addChild(root_0, IDENTIFIER1443_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "partial_contextual_keyword"


    public static class alias_contextual_keyword_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "alias_contextual_keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2559:1: alias_contextual_keyword :{...}? IDENTIFIER ;
    public final CSharp4AST.alias_contextual_keyword_return alias_contextual_keyword() throws RecognitionException {
        CSharp4AST.alias_contextual_keyword_return retval = new CSharp4AST.alias_contextual_keyword_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER1444=null;

        Object IDENTIFIER1444_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2560:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2560:5: {...}? IDENTIFIER
            {
            root_0 = (Object)adaptor.nil();


            if ( !((input.LT(1).getText().equals("alias"))) ) {
                if (state.backtracking>0) {state.failed=true; return retval;}
                throw new FailedPredicateException(input, "alias_contextual_keyword", "input.LT(1).getText().equals(\"alias\")");
            }

            IDENTIFIER1444=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_alias_contextual_keyword12040); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1444_tree = 
            (Object)adaptor.create(IDENTIFIER1444)
            ;
            adaptor.addChild(root_0, IDENTIFIER1444_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "alias_contextual_keyword"


    public static class yield_contextual_keyword_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "yield_contextual_keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2562:1: yield_contextual_keyword :{...}? IDENTIFIER ;
    public final CSharp4AST.yield_contextual_keyword_return yield_contextual_keyword() throws RecognitionException {
        CSharp4AST.yield_contextual_keyword_return retval = new CSharp4AST.yield_contextual_keyword_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER1445=null;

        Object IDENTIFIER1445_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2563:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2563:5: {...}? IDENTIFIER
            {
            root_0 = (Object)adaptor.nil();


            if ( !((input.LT(1).getText().equals("yield"))) ) {
                if (state.backtracking>0) {state.failed=true; return retval;}
                throw new FailedPredicateException(input, "yield_contextual_keyword", "input.LT(1).getText().equals(\"yield\")");
            }

            IDENTIFIER1445=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_yield_contextual_keyword12054); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1445_tree = 
            (Object)adaptor.create(IDENTIFIER1445)
            ;
            adaptor.addChild(root_0, IDENTIFIER1445_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "yield_contextual_keyword"


    public static class get_contextual_keyword_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "get_contextual_keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2565:1: get_contextual_keyword :{...}? IDENTIFIER ;
    public final CSharp4AST.get_contextual_keyword_return get_contextual_keyword() throws RecognitionException {
        CSharp4AST.get_contextual_keyword_return retval = new CSharp4AST.get_contextual_keyword_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER1446=null;

        Object IDENTIFIER1446_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2566:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2566:5: {...}? IDENTIFIER
            {
            root_0 = (Object)adaptor.nil();


            if ( !((input.LT(1).getText().equals("get"))) ) {
                if (state.backtracking>0) {state.failed=true; return retval;}
                throw new FailedPredicateException(input, "get_contextual_keyword", "input.LT(1).getText().equals(\"get\")");
            }

            IDENTIFIER1446=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_get_contextual_keyword12068); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1446_tree = 
            (Object)adaptor.create(IDENTIFIER1446)
            ;
            adaptor.addChild(root_0, IDENTIFIER1446_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "get_contextual_keyword"


    public static class set_contextual_keyword_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "set_contextual_keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2568:1: set_contextual_keyword :{...}? IDENTIFIER ;
    public final CSharp4AST.set_contextual_keyword_return set_contextual_keyword() throws RecognitionException {
        CSharp4AST.set_contextual_keyword_return retval = new CSharp4AST.set_contextual_keyword_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER1447=null;

        Object IDENTIFIER1447_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2569:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2569:5: {...}? IDENTIFIER
            {
            root_0 = (Object)adaptor.nil();


            if ( !((input.LT(1).getText().equals("set"))) ) {
                if (state.backtracking>0) {state.failed=true; return retval;}
                throw new FailedPredicateException(input, "set_contextual_keyword", "input.LT(1).getText().equals(\"set\")");
            }

            IDENTIFIER1447=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_set_contextual_keyword12082); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1447_tree = 
            (Object)adaptor.create(IDENTIFIER1447)
            ;
            adaptor.addChild(root_0, IDENTIFIER1447_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "set_contextual_keyword"


    public static class add_contextual_keyword_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "add_contextual_keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2571:1: add_contextual_keyword :{...}? IDENTIFIER ;
    public final CSharp4AST.add_contextual_keyword_return add_contextual_keyword() throws RecognitionException {
        CSharp4AST.add_contextual_keyword_return retval = new CSharp4AST.add_contextual_keyword_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER1448=null;

        Object IDENTIFIER1448_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2572:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2572:5: {...}? IDENTIFIER
            {
            root_0 = (Object)adaptor.nil();


            if ( !((input.LT(1).getText().equals("add"))) ) {
                if (state.backtracking>0) {state.failed=true; return retval;}
                throw new FailedPredicateException(input, "add_contextual_keyword", "input.LT(1).getText().equals(\"add\")");
            }

            IDENTIFIER1448=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_add_contextual_keyword12096); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1448_tree = 
            (Object)adaptor.create(IDENTIFIER1448)
            ;
            adaptor.addChild(root_0, IDENTIFIER1448_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "add_contextual_keyword"


    public static class remove_contextual_keyword_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "remove_contextual_keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2574:1: remove_contextual_keyword :{...}? IDENTIFIER ;
    public final CSharp4AST.remove_contextual_keyword_return remove_contextual_keyword() throws RecognitionException {
        CSharp4AST.remove_contextual_keyword_return retval = new CSharp4AST.remove_contextual_keyword_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER1449=null;

        Object IDENTIFIER1449_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2575:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2575:5: {...}? IDENTIFIER
            {
            root_0 = (Object)adaptor.nil();


            if ( !((input.LT(1).getText().equals("remove"))) ) {
                if (state.backtracking>0) {state.failed=true; return retval;}
                throw new FailedPredicateException(input, "remove_contextual_keyword", "input.LT(1).getText().equals(\"remove\")");
            }

            IDENTIFIER1449=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_remove_contextual_keyword12110); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1449_tree = 
            (Object)adaptor.create(IDENTIFIER1449)
            ;
            adaptor.addChild(root_0, IDENTIFIER1449_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "remove_contextual_keyword"


    public static class dynamic_contextual_keyword_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "dynamic_contextual_keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2577:1: dynamic_contextual_keyword :{...}? IDENTIFIER ;
    public final CSharp4AST.dynamic_contextual_keyword_return dynamic_contextual_keyword() throws RecognitionException {
        CSharp4AST.dynamic_contextual_keyword_return retval = new CSharp4AST.dynamic_contextual_keyword_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER1450=null;

        Object IDENTIFIER1450_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2578:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2578:5: {...}? IDENTIFIER
            {
            root_0 = (Object)adaptor.nil();


            if ( !((input.LT(1).getText().equals("dynamic"))) ) {
                if (state.backtracking>0) {state.failed=true; return retval;}
                throw new FailedPredicateException(input, "dynamic_contextual_keyword", "input.LT(1).getText().equals(\"dynamic\")");
            }

            IDENTIFIER1450=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_dynamic_contextual_keyword12124); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1450_tree = 
            (Object)adaptor.create(IDENTIFIER1450)
            ;
            adaptor.addChild(root_0, IDENTIFIER1450_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "dynamic_contextual_keyword"


    public static class arglist_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "arglist"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2580:1: arglist :{...}? IDENTIFIER ;
    public final CSharp4AST.arglist_return arglist() throws RecognitionException {
        CSharp4AST.arglist_return retval = new CSharp4AST.arglist_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER1451=null;

        Object IDENTIFIER1451_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2581:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2581:5: {...}? IDENTIFIER
            {
            root_0 = (Object)adaptor.nil();


            if ( !((input.LT(1).getText().equals("__arglist"))) ) {
                if (state.backtracking>0) {state.failed=true; return retval;}
                throw new FailedPredicateException(input, "arglist", "input.LT(1).getText().equals(\"__arglist\")");
            }

            IDENTIFIER1451=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_arglist12138); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1451_tree = 
            (Object)adaptor.create(IDENTIFIER1451)
            ;
            adaptor.addChild(root_0, IDENTIFIER1451_tree);
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "arglist"


    public static class right_arrow_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "right_arrow"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2583:1: right_arrow : first= ASSIGNMENT second= GT {...}?;
    public final CSharp4AST.right_arrow_return right_arrow() throws RecognitionException {
        CSharp4AST.right_arrow_return retval = new CSharp4AST.right_arrow_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token first=null;
        Token second=null;

        Object first_tree=null;
        Object second_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2584:3: (first= ASSIGNMENT second= GT {...}?)
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2584:5: first= ASSIGNMENT second= GT {...}?
            {
            root_0 = (Object)adaptor.nil();


            first=(Token)match(input,ASSIGNMENT,FOLLOW_ASSIGNMENT_in_right_arrow12152); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            first_tree = 
            (Object)adaptor.create(first)
            ;
            adaptor.addChild(root_0, first_tree);
            }

            second=(Token)match(input,GT,FOLLOW_GT_in_right_arrow12156); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            second_tree = 
            (Object)adaptor.create(second)
            ;
            adaptor.addChild(root_0, second_tree);
            }

            if ( !(((first!=null?first.getTokenIndex():0) + 1 == (second!=null?second.getTokenIndex():0))) ) {
                if (state.backtracking>0) {state.failed=true; return retval;}
                throw new FailedPredicateException(input, "right_arrow", "$first.index + 1 == $second.index");
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "right_arrow"


    public static class right_shift_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "right_shift"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2586:1: right_shift : first= GT second= GT {...}? -> OP_RIGHT_SHIFT ;
    public final CSharp4AST.right_shift_return right_shift() throws RecognitionException {
        CSharp4AST.right_shift_return retval = new CSharp4AST.right_shift_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token first=null;
        Token second=null;

        Object first_tree=null;
        Object second_tree=null;
        RewriteRuleTokenStream stream_GT=new RewriteRuleTokenStream(adaptor,"token GT");

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2587:3: (first= GT second= GT {...}? -> OP_RIGHT_SHIFT )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2587:5: first= GT second= GT {...}?
            {
            first=(Token)match(input,GT,FOLLOW_GT_in_right_shift12173); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_GT.add(first);


            second=(Token)match(input,GT,FOLLOW_GT_in_right_shift12177); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_GT.add(second);


            if ( !(((first!=null?first.getTokenIndex():0) + 1 == (second!=null?second.getTokenIndex():0))) ) {
                if (state.backtracking>0) {state.failed=true; return retval;}
                throw new FailedPredicateException(input, "right_shift", "$first.index + 1 == $second.index");
            }

            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 2588:5: -> OP_RIGHT_SHIFT
            {
                adaptor.addChild(root_0, 
                (Object)adaptor.create(OP_RIGHT_SHIFT, "OP_RIGHT_SHIFT")
                );

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "right_shift"


    public static class right_shift_assignment_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "right_shift_assignment"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2590:1: right_shift_assignment : first= GT second= OP_GE {...}? -> OP_RIGHT_SHIFT_ASSIGNMENT ;
    public final CSharp4AST.right_shift_assignment_return right_shift_assignment() throws RecognitionException {
        CSharp4AST.right_shift_assignment_return retval = new CSharp4AST.right_shift_assignment_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token first=null;
        Token second=null;

        Object first_tree=null;
        Object second_tree=null;
        RewriteRuleTokenStream stream_GT=new RewriteRuleTokenStream(adaptor,"token GT");
        RewriteRuleTokenStream stream_OP_GE=new RewriteRuleTokenStream(adaptor,"token OP_GE");

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2591:3: (first= GT second= OP_GE {...}? -> OP_RIGHT_SHIFT_ASSIGNMENT )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2591:5: first= GT second= OP_GE {...}?
            {
            first=(Token)match(input,GT,FOLLOW_GT_in_right_shift_assignment12202); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_GT.add(first);


            second=(Token)match(input,OP_GE,FOLLOW_OP_GE_in_right_shift_assignment12206); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_OP_GE.add(second);


            if ( !(((first!=null?first.getTokenIndex():0) + 1 == (second!=null?second.getTokenIndex():0))) ) {
                if (state.backtracking>0) {state.failed=true; return retval;}
                throw new FailedPredicateException(input, "right_shift_assignment", "$first.index + 1 == $second.index");
            }

            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 2592:5: -> OP_RIGHT_SHIFT_ASSIGNMENT
            {
                adaptor.addChild(root_0, 
                (Object)adaptor.create(OP_RIGHT_SHIFT_ASSIGNMENT, "OP_RIGHT_SHIFT_ASSIGNMENT")
                );

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "right_shift_assignment"


    public static class literal_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "literal"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2594:1: literal : ( boolean_literal | INTEGER_LITERAL | REAL_LITERAL | CHARACTER_LITERAL | STRING_LITERAL | NULL );
    public final CSharp4AST.literal_return literal() throws RecognitionException {
        CSharp4AST.literal_return retval = new CSharp4AST.literal_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token INTEGER_LITERAL1453=null;
        Token REAL_LITERAL1454=null;
        Token CHARACTER_LITERAL1455=null;
        Token STRING_LITERAL1456=null;
        Token NULL1457=null;
        CSharp4AST.boolean_literal_return boolean_literal1452 =null;


        Object INTEGER_LITERAL1453_tree=null;
        Object REAL_LITERAL1454_tree=null;
        Object CHARACTER_LITERAL1455_tree=null;
        Object STRING_LITERAL1456_tree=null;
        Object NULL1457_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2595:3: ( boolean_literal | INTEGER_LITERAL | REAL_LITERAL | CHARACTER_LITERAL | STRING_LITERAL | NULL )
            int alt346=6;
            switch ( input.LA(1) ) {
            case FALSE:
            case TRUE:
                {
                alt346=1;
                }
                break;
            case INTEGER_LITERAL:
                {
                alt346=2;
                }
                break;
            case REAL_LITERAL:
                {
                alt346=3;
                }
                break;
            case CHARACTER_LITERAL:
                {
                alt346=4;
                }
                break;
            case STRING_LITERAL:
                {
                alt346=5;
                }
                break;
            case NULL:
                {
                alt346=6;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 346, 0, input);

                throw nvae;

            }

            switch (alt346) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2595:5: boolean_literal
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_boolean_literal_in_literal12229);
                    boolean_literal1452=boolean_literal();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, boolean_literal1452.getTree());

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2596:5: INTEGER_LITERAL
                    {
                    root_0 = (Object)adaptor.nil();


                    INTEGER_LITERAL1453=(Token)match(input,INTEGER_LITERAL,FOLLOW_INTEGER_LITERAL_in_literal12235); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    INTEGER_LITERAL1453_tree = 
                    (Object)adaptor.create(INTEGER_LITERAL1453)
                    ;
                    adaptor.addChild(root_0, INTEGER_LITERAL1453_tree);
                    }

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2597:5: REAL_LITERAL
                    {
                    root_0 = (Object)adaptor.nil();


                    REAL_LITERAL1454=(Token)match(input,REAL_LITERAL,FOLLOW_REAL_LITERAL_in_literal12241); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    REAL_LITERAL1454_tree = 
                    (Object)adaptor.create(REAL_LITERAL1454)
                    ;
                    adaptor.addChild(root_0, REAL_LITERAL1454_tree);
                    }

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2598:5: CHARACTER_LITERAL
                    {
                    root_0 = (Object)adaptor.nil();


                    CHARACTER_LITERAL1455=(Token)match(input,CHARACTER_LITERAL,FOLLOW_CHARACTER_LITERAL_in_literal12247); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    CHARACTER_LITERAL1455_tree = 
                    (Object)adaptor.create(CHARACTER_LITERAL1455)
                    ;
                    adaptor.addChild(root_0, CHARACTER_LITERAL1455_tree);
                    }

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2599:5: STRING_LITERAL
                    {
                    root_0 = (Object)adaptor.nil();


                    STRING_LITERAL1456=(Token)match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_literal12253); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    STRING_LITERAL1456_tree = 
                    (Object)adaptor.create(STRING_LITERAL1456)
                    ;
                    adaptor.addChild(root_0, STRING_LITERAL1456_tree);
                    }

                    }
                    break;
                case 6 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2600:5: NULL
                    {
                    root_0 = (Object)adaptor.nil();


                    NULL1457=(Token)match(input,NULL,FOLLOW_NULL_in_literal12259); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    NULL1457_tree = 
                    (Object)adaptor.create(NULL1457)
                    ;
                    adaptor.addChild(root_0, NULL1457_tree);
                    }

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "literal"


    public static class boolean_literal_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "boolean_literal"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2602:1: boolean_literal : ( TRUE | FALSE );
    public final CSharp4AST.boolean_literal_return boolean_literal() throws RecognitionException {
        CSharp4AST.boolean_literal_return retval = new CSharp4AST.boolean_literal_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token set1458=null;

        Object set1458_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2603:3: ( TRUE | FALSE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:
            {
            root_0 = (Object)adaptor.nil();


            set1458=(Token)input.LT(1);

            if ( input.LA(1)==FALSE||input.LA(1)==TRUE ) {
                input.consume();
                if ( state.backtracking==0 ) adaptor.addChild(root_0, 
                (Object)adaptor.create(set1458)
                );
                state.errorRecovery=false;
                state.failed=false;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                MismatchedSetException mse = new MismatchedSetException(null,input);
                throw mse;
            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "boolean_literal"


    public static class keyword_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2607:1: keyword : ( ABSTRACT | AS | BASE | BOOL | BREAK | BYTE | CASE | CATCH | CHAR | CHECKED | CLASS | CONST | CONTINUE | DECIMAL | DEFAULT | DELEGATE | DO | DOUBLE | ELSE | ENUM | EVENT | EXPLICIT | EXTERN | FALSE | FINALLY | FIXED | FLOAT | FOR | FOREACH | GOTO | IF | IMPLICIT | IN | INT | INTERFACE | INTERNAL | IS | LOCK | LONG | NAMESPACE | NEW | NULL | OBJECT | OPERATOR | OUT | OVERRIDE | PARAMS | PRIVATE | PROTECTED | PUBLIC | READONLY | REF | RETURN | SBYTE | SEALED | SHORT | SIZEOF | STACKALLOC | STATIC | STRING | STRUCT | SWITCH | THIS | THROW | TRUE | TRY | TYPEOF | UINT | ULONG | UNCHECKED | UNSAFE | USHORT | USING | VIRTUAL | VOID | VOLATILE | WHILE );
    public final CSharp4AST.keyword_return keyword() throws RecognitionException {
        CSharp4AST.keyword_return retval = new CSharp4AST.keyword_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token set1459=null;

        Object set1459_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2608:3: ( ABSTRACT | AS | BASE | BOOL | BREAK | BYTE | CASE | CATCH | CHAR | CHECKED | CLASS | CONST | CONTINUE | DECIMAL | DEFAULT | DELEGATE | DO | DOUBLE | ELSE | ENUM | EVENT | EXPLICIT | EXTERN | FALSE | FINALLY | FIXED | FLOAT | FOR | FOREACH | GOTO | IF | IMPLICIT | IN | INT | INTERFACE | INTERNAL | IS | LOCK | LONG | NAMESPACE | NEW | NULL | OBJECT | OPERATOR | OUT | OVERRIDE | PARAMS | PRIVATE | PROTECTED | PUBLIC | READONLY | REF | RETURN | SBYTE | SEALED | SHORT | SIZEOF | STACKALLOC | STATIC | STRING | STRUCT | SWITCH | THIS | THROW | TRUE | TRY | TYPEOF | UINT | ULONG | UNCHECKED | UNSAFE | USHORT | USING | VIRTUAL | VOID | VOLATILE | WHILE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:
            {
            root_0 = (Object)adaptor.nil();


            set1459=(Token)input.LT(1);

            if ( input.LA(1)==ABSTRACT||input.LA(1)==AS||input.LA(1)==BASE||(input.LA(1) >= BOOL && input.LA(1) <= BYTE)||(input.LA(1) >= CASE && input.LA(1) <= CHAR)||(input.LA(1) >= CHECKED && input.LA(1) <= CLASS)||(input.LA(1) >= CONST && input.LA(1) <= CONTINUE)||input.LA(1)==DECIMAL||(input.LA(1) >= DEFAULT && input.LA(1) <= DELEGATE)||input.LA(1)==DO||input.LA(1)==DOUBLE||(input.LA(1) >= ELSE && input.LA(1) <= EXTERN)||(input.LA(1) >= FALSE && input.LA(1) <= FOREACH)||input.LA(1)==GOTO||(input.LA(1) >= IF && input.LA(1) <= INT)||(input.LA(1) >= INTERFACE && input.LA(1) <= INTERNAL)||input.LA(1)==IS||(input.LA(1) >= LOCK && input.LA(1) <= LONG)||(input.LA(1) >= NAMESPACE && input.LA(1) <= NEW)||input.LA(1)==NULL||input.LA(1)==OBJECT||input.LA(1)==OPERATOR||(input.LA(1) >= OUT && input.LA(1) <= PARAMS)||(input.LA(1) >= PRIVATE && input.LA(1) <= PUBLIC)||input.LA(1)==READONLY||(input.LA(1) >= REF && input.LA(1) <= RETURN)||(input.LA(1) >= SBYTE && input.LA(1) <= SEALED)||input.LA(1)==SHORT||(input.LA(1) >= SIZEOF && input.LA(1) <= STACKALLOC)||(input.LA(1) >= STATIC && input.LA(1) <= STRING)||(input.LA(1) >= STRUCT && input.LA(1) <= SWITCH)||(input.LA(1) >= THIS && input.LA(1) <= THROW)||(input.LA(1) >= TRUE && input.LA(1) <= TYPEOF)||(input.LA(1) >= UINT && input.LA(1) <= UNCHECKED)||(input.LA(1) >= UNSAFE && input.LA(1) <= USING)||(input.LA(1) >= VIRTUAL && input.LA(1) <= VOLATILE)||input.LA(1)==WHILE ) {
                input.consume();
                if ( state.backtracking==0 ) adaptor.addChild(root_0, 
                (Object)adaptor.create(set1459)
                );
                state.errorRecovery=false;
                state.failed=false;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                MismatchedSetException mse = new MismatchedSetException(null,input);
                throw mse;
            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "keyword"


    public static class class_definition_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "class_definition"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2689:1: class_definition : CLASS ^ IDENTIFIER ( type_parameter_list )? ( class_base )? ( type_parameter_constraints_clauses )? class_body ( SEMICOLON !)? ;
    public final CSharp4AST.class_definition_return class_definition() throws RecognitionException {
        CSharp4AST.class_definition_return retval = new CSharp4AST.class_definition_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token CLASS1460=null;
        Token IDENTIFIER1461=null;
        Token SEMICOLON1466=null;
        CSharp4AST.type_parameter_list_return type_parameter_list1462 =null;

        CSharp4AST.class_base_return class_base1463 =null;

        CSharp4AST.type_parameter_constraints_clauses_return type_parameter_constraints_clauses1464 =null;

        CSharp4AST.class_body_return class_body1465 =null;


        Object CLASS1460_tree=null;
        Object IDENTIFIER1461_tree=null;
        Object SEMICOLON1466_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2690:3: ( CLASS ^ IDENTIFIER ( type_parameter_list )? ( class_base )? ( type_parameter_constraints_clauses )? class_body ( SEMICOLON !)? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2690:5: CLASS ^ IDENTIFIER ( type_parameter_list )? ( class_base )? ( type_parameter_constraints_clauses )? class_body ( SEMICOLON !)?
            {
            root_0 = (Object)adaptor.nil();


            CLASS1460=(Token)match(input,CLASS,FOLLOW_CLASS_in_class_definition12761); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            CLASS1460_tree = 
            (Object)adaptor.create(CLASS1460)
            ;
            root_0 = (Object)adaptor.becomeRoot(CLASS1460_tree, root_0);
            }

            IDENTIFIER1461=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_class_definition12764); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1461_tree = 
            (Object)adaptor.create(IDENTIFIER1461)
            ;
            adaptor.addChild(root_0, IDENTIFIER1461_tree);
            }

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2690:23: ( type_parameter_list )?
            int alt347=2;
            int LA347_0 = input.LA(1);

            if ( (LA347_0==LT) ) {
                alt347=1;
            }
            switch (alt347) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2690:23: type_parameter_list
                    {
                    pushFollow(FOLLOW_type_parameter_list_in_class_definition12766);
                    type_parameter_list1462=type_parameter_list();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, type_parameter_list1462.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2690:44: ( class_base )?
            int alt348=2;
            int LA348_0 = input.LA(1);

            if ( (LA348_0==COLON) ) {
                alt348=1;
            }
            switch (alt348) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2690:44: class_base
                    {
                    pushFollow(FOLLOW_class_base_in_class_definition12769);
                    class_base1463=class_base();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, class_base1463.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2690:56: ( type_parameter_constraints_clauses )?
            int alt349=2;
            int LA349_0 = input.LA(1);

            if ( (LA349_0==IDENTIFIER) ) {
                alt349=1;
            }
            switch (alt349) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2690:56: type_parameter_constraints_clauses
                    {
                    pushFollow(FOLLOW_type_parameter_constraints_clauses_in_class_definition12772);
                    type_parameter_constraints_clauses1464=type_parameter_constraints_clauses();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, type_parameter_constraints_clauses1464.getTree());

                    }
                    break;

            }


            pushFollow(FOLLOW_class_body_in_class_definition12781);
            class_body1465=class_body();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, class_body1465.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2691:27: ( SEMICOLON !)?
            int alt350=2;
            int LA350_0 = input.LA(1);

            if ( (LA350_0==SEMICOLON) ) {
                alt350=1;
            }
            switch (alt350) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2691:27: SEMICOLON !
                    {
                    SEMICOLON1466=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_class_definition12783); if (state.failed) return retval;

                    }
                    break;

            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "class_definition"


    public static class struct_definition_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "struct_definition"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2693:1: struct_definition : STRUCT ^ IDENTIFIER ( type_parameter_list )? ( struct_interfaces )? ( type_parameter_constraints_clauses )? struct_body ( SEMICOLON !)? ;
    public final CSharp4AST.struct_definition_return struct_definition() throws RecognitionException {
        CSharp4AST.struct_definition_return retval = new CSharp4AST.struct_definition_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token STRUCT1467=null;
        Token IDENTIFIER1468=null;
        Token SEMICOLON1473=null;
        CSharp4AST.type_parameter_list_return type_parameter_list1469 =null;

        CSharp4AST.struct_interfaces_return struct_interfaces1470 =null;

        CSharp4AST.type_parameter_constraints_clauses_return type_parameter_constraints_clauses1471 =null;

        CSharp4AST.struct_body_return struct_body1472 =null;


        Object STRUCT1467_tree=null;
        Object IDENTIFIER1468_tree=null;
        Object SEMICOLON1473_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2694:3: ( STRUCT ^ IDENTIFIER ( type_parameter_list )? ( struct_interfaces )? ( type_parameter_constraints_clauses )? struct_body ( SEMICOLON !)? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2694:5: STRUCT ^ IDENTIFIER ( type_parameter_list )? ( struct_interfaces )? ( type_parameter_constraints_clauses )? struct_body ( SEMICOLON !)?
            {
            root_0 = (Object)adaptor.nil();


            STRUCT1467=(Token)match(input,STRUCT,FOLLOW_STRUCT_in_struct_definition12797); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            STRUCT1467_tree = 
            (Object)adaptor.create(STRUCT1467)
            ;
            root_0 = (Object)adaptor.becomeRoot(STRUCT1467_tree, root_0);
            }

            IDENTIFIER1468=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_struct_definition12800); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1468_tree = 
            (Object)adaptor.create(IDENTIFIER1468)
            ;
            adaptor.addChild(root_0, IDENTIFIER1468_tree);
            }

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2694:24: ( type_parameter_list )?
            int alt351=2;
            int LA351_0 = input.LA(1);

            if ( (LA351_0==LT) ) {
                alt351=1;
            }
            switch (alt351) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2694:24: type_parameter_list
                    {
                    pushFollow(FOLLOW_type_parameter_list_in_struct_definition12802);
                    type_parameter_list1469=type_parameter_list();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, type_parameter_list1469.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2694:45: ( struct_interfaces )?
            int alt352=2;
            int LA352_0 = input.LA(1);

            if ( (LA352_0==COLON) ) {
                alt352=1;
            }
            switch (alt352) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2694:45: struct_interfaces
                    {
                    pushFollow(FOLLOW_struct_interfaces_in_struct_definition12805);
                    struct_interfaces1470=struct_interfaces();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, struct_interfaces1470.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2694:64: ( type_parameter_constraints_clauses )?
            int alt353=2;
            int LA353_0 = input.LA(1);

            if ( (LA353_0==IDENTIFIER) ) {
                alt353=1;
            }
            switch (alt353) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2694:64: type_parameter_constraints_clauses
                    {
                    pushFollow(FOLLOW_type_parameter_constraints_clauses_in_struct_definition12808);
                    type_parameter_constraints_clauses1471=type_parameter_constraints_clauses();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, type_parameter_constraints_clauses1471.getTree());

                    }
                    break;

            }


            pushFollow(FOLLOW_struct_body_in_struct_definition12817);
            struct_body1472=struct_body();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, struct_body1472.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2695:28: ( SEMICOLON !)?
            int alt354=2;
            int LA354_0 = input.LA(1);

            if ( (LA354_0==SEMICOLON) ) {
                alt354=1;
            }
            switch (alt354) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2695:28: SEMICOLON !
                    {
                    SEMICOLON1473=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_struct_definition12819); if (state.failed) return retval;

                    }
                    break;

            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "struct_definition"


    public static class interface_definition_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "interface_definition"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2697:1: interface_definition : INTERFACE ^ IDENTIFIER ( variant_type_parameter_list )? ( interface_base )? ( type_parameter_constraints_clauses )? interface_body ( SEMICOLON !)? ;
    public final CSharp4AST.interface_definition_return interface_definition() throws RecognitionException {
        CSharp4AST.interface_definition_return retval = new CSharp4AST.interface_definition_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token INTERFACE1474=null;
        Token IDENTIFIER1475=null;
        Token SEMICOLON1480=null;
        CSharp4AST.variant_type_parameter_list_return variant_type_parameter_list1476 =null;

        CSharp4AST.interface_base_return interface_base1477 =null;

        CSharp4AST.type_parameter_constraints_clauses_return type_parameter_constraints_clauses1478 =null;

        CSharp4AST.interface_body_return interface_body1479 =null;


        Object INTERFACE1474_tree=null;
        Object IDENTIFIER1475_tree=null;
        Object SEMICOLON1480_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2698:3: ( INTERFACE ^ IDENTIFIER ( variant_type_parameter_list )? ( interface_base )? ( type_parameter_constraints_clauses )? interface_body ( SEMICOLON !)? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2698:5: INTERFACE ^ IDENTIFIER ( variant_type_parameter_list )? ( interface_base )? ( type_parameter_constraints_clauses )? interface_body ( SEMICOLON !)?
            {
            root_0 = (Object)adaptor.nil();


            INTERFACE1474=(Token)match(input,INTERFACE,FOLLOW_INTERFACE_in_interface_definition12833); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            INTERFACE1474_tree = 
            (Object)adaptor.create(INTERFACE1474)
            ;
            root_0 = (Object)adaptor.becomeRoot(INTERFACE1474_tree, root_0);
            }

            IDENTIFIER1475=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_interface_definition12836); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1475_tree = 
            (Object)adaptor.create(IDENTIFIER1475)
            ;
            adaptor.addChild(root_0, IDENTIFIER1475_tree);
            }

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2698:27: ( variant_type_parameter_list )?
            int alt355=2;
            int LA355_0 = input.LA(1);

            if ( (LA355_0==LT) ) {
                alt355=1;
            }
            switch (alt355) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2698:27: variant_type_parameter_list
                    {
                    pushFollow(FOLLOW_variant_type_parameter_list_in_interface_definition12838);
                    variant_type_parameter_list1476=variant_type_parameter_list();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, variant_type_parameter_list1476.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2698:56: ( interface_base )?
            int alt356=2;
            int LA356_0 = input.LA(1);

            if ( (LA356_0==COLON) ) {
                alt356=1;
            }
            switch (alt356) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2698:56: interface_base
                    {
                    pushFollow(FOLLOW_interface_base_in_interface_definition12841);
                    interface_base1477=interface_base();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, interface_base1477.getTree());

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2699:7: ( type_parameter_constraints_clauses )?
            int alt357=2;
            int LA357_0 = input.LA(1);

            if ( (LA357_0==IDENTIFIER) ) {
                alt357=1;
            }
            switch (alt357) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2699:7: type_parameter_constraints_clauses
                    {
                    pushFollow(FOLLOW_type_parameter_constraints_clauses_in_interface_definition12850);
                    type_parameter_constraints_clauses1478=type_parameter_constraints_clauses();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, type_parameter_constraints_clauses1478.getTree());

                    }
                    break;

            }


            pushFollow(FOLLOW_interface_body_in_interface_definition12853);
            interface_body1479=interface_body();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, interface_body1479.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2699:67: ( SEMICOLON !)?
            int alt358=2;
            int LA358_0 = input.LA(1);

            if ( (LA358_0==SEMICOLON) ) {
                alt358=1;
            }
            switch (alt358) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2699:67: SEMICOLON !
                    {
                    SEMICOLON1480=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_interface_definition12855); if (state.failed) return retval;

                    }
                    break;

            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "interface_definition"


    public static class enum_definition_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "enum_definition"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2701:1: enum_definition : ENUM ^ IDENTIFIER ( enum_base )? enum_body ( SEMICOLON !)? ;
    public final CSharp4AST.enum_definition_return enum_definition() throws RecognitionException {
        CSharp4AST.enum_definition_return retval = new CSharp4AST.enum_definition_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token ENUM1481=null;
        Token IDENTIFIER1482=null;
        Token SEMICOLON1485=null;
        CSharp4AST.enum_base_return enum_base1483 =null;

        CSharp4AST.enum_body_return enum_body1484 =null;


        Object ENUM1481_tree=null;
        Object IDENTIFIER1482_tree=null;
        Object SEMICOLON1485_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2702:3: ( ENUM ^ IDENTIFIER ( enum_base )? enum_body ( SEMICOLON !)? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2702:5: ENUM ^ IDENTIFIER ( enum_base )? enum_body ( SEMICOLON !)?
            {
            root_0 = (Object)adaptor.nil();


            ENUM1481=(Token)match(input,ENUM,FOLLOW_ENUM_in_enum_definition12869); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            ENUM1481_tree = 
            (Object)adaptor.create(ENUM1481)
            ;
            root_0 = (Object)adaptor.becomeRoot(ENUM1481_tree, root_0);
            }

            IDENTIFIER1482=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_enum_definition12872); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1482_tree = 
            (Object)adaptor.create(IDENTIFIER1482)
            ;
            adaptor.addChild(root_0, IDENTIFIER1482_tree);
            }

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2702:22: ( enum_base )?
            int alt359=2;
            int LA359_0 = input.LA(1);

            if ( (LA359_0==COLON) ) {
                alt359=1;
            }
            switch (alt359) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2702:22: enum_base
                    {
                    pushFollow(FOLLOW_enum_base_in_enum_definition12874);
                    enum_base1483=enum_base();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, enum_base1483.getTree());

                    }
                    break;

            }


            pushFollow(FOLLOW_enum_body_in_enum_definition12877);
            enum_body1484=enum_body();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, enum_body1484.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2702:52: ( SEMICOLON !)?
            int alt360=2;
            int LA360_0 = input.LA(1);

            if ( (LA360_0==SEMICOLON) ) {
                alt360=1;
            }
            switch (alt360) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2702:52: SEMICOLON !
                    {
                    SEMICOLON1485=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_enum_definition12879); if (state.failed) return retval;

                    }
                    break;

            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "enum_definition"


    public static class delegate_definition_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "delegate_definition"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2704:1: delegate_definition : DELEGATE ^ return_type IDENTIFIER ( variant_type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? SEMICOLON !;
    public final CSharp4AST.delegate_definition_return delegate_definition() throws RecognitionException {
        CSharp4AST.delegate_definition_return retval = new CSharp4AST.delegate_definition_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token DELEGATE1486=null;
        Token IDENTIFIER1488=null;
        Token OPEN_PARENS1490=null;
        Token CLOSE_PARENS1492=null;
        Token SEMICOLON1494=null;
        CSharp4AST.return_type_return return_type1487 =null;

        CSharp4AST.variant_type_parameter_list_return variant_type_parameter_list1489 =null;

        CSharp4AST.formal_parameter_list_return formal_parameter_list1491 =null;

        CSharp4AST.type_parameter_constraints_clauses_return type_parameter_constraints_clauses1493 =null;


        Object DELEGATE1486_tree=null;
        Object IDENTIFIER1488_tree=null;
        Object OPEN_PARENS1490_tree=null;
        Object CLOSE_PARENS1492_tree=null;
        Object SEMICOLON1494_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2705:3: ( DELEGATE ^ return_type IDENTIFIER ( variant_type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? SEMICOLON !)
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2705:5: DELEGATE ^ return_type IDENTIFIER ( variant_type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? SEMICOLON !
            {
            root_0 = (Object)adaptor.nil();


            DELEGATE1486=(Token)match(input,DELEGATE,FOLLOW_DELEGATE_in_delegate_definition12893); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            DELEGATE1486_tree = 
            (Object)adaptor.create(DELEGATE1486)
            ;
            root_0 = (Object)adaptor.becomeRoot(DELEGATE1486_tree, root_0);
            }

            pushFollow(FOLLOW_return_type_in_delegate_definition12896);
            return_type1487=return_type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, return_type1487.getTree());

            IDENTIFIER1488=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_delegate_definition12898); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1488_tree = 
            (Object)adaptor.create(IDENTIFIER1488)
            ;
            adaptor.addChild(root_0, IDENTIFIER1488_tree);
            }

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2705:38: ( variant_type_parameter_list )?
            int alt361=2;
            int LA361_0 = input.LA(1);

            if ( (LA361_0==LT) ) {
                alt361=1;
            }
            switch (alt361) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2705:38: variant_type_parameter_list
                    {
                    pushFollow(FOLLOW_variant_type_parameter_list_in_delegate_definition12900);
                    variant_type_parameter_list1489=variant_type_parameter_list();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, variant_type_parameter_list1489.getTree());

                    }
                    break;

            }


            OPEN_PARENS1490=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_delegate_definition12903); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            OPEN_PARENS1490_tree = 
            (Object)adaptor.create(OPEN_PARENS1490)
            ;
            adaptor.addChild(root_0, OPEN_PARENS1490_tree);
            }

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2706:7: ( formal_parameter_list )?
            int alt362=2;
            int LA362_0 = input.LA(1);

            if ( (LA362_0==BOOL||LA362_0==BYTE||LA362_0==CHAR||LA362_0==DECIMAL||LA362_0==DOUBLE||LA362_0==FLOAT||LA362_0==IDENTIFIER||LA362_0==INT||LA362_0==LONG||LA362_0==OBJECT||LA362_0==OPEN_BRACKET||LA362_0==OUT||LA362_0==PARAMS||LA362_0==REF||LA362_0==SBYTE||LA362_0==SHORT||LA362_0==STRING||LA362_0==THIS||(LA362_0 >= UINT && LA362_0 <= ULONG)||LA362_0==USHORT||LA362_0==VOID) ) {
                alt362=1;
            }
            switch (alt362) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2706:7: formal_parameter_list
                    {
                    pushFollow(FOLLOW_formal_parameter_list_in_delegate_definition12911);
                    formal_parameter_list1491=formal_parameter_list();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, formal_parameter_list1491.getTree());

                    }
                    break;

            }


            CLOSE_PARENS1492=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_delegate_definition12914); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            CLOSE_PARENS1492_tree = 
            (Object)adaptor.create(CLOSE_PARENS1492)
            ;
            adaptor.addChild(root_0, CLOSE_PARENS1492_tree);
            }

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2706:43: ( type_parameter_constraints_clauses )?
            int alt363=2;
            int LA363_0 = input.LA(1);

            if ( (LA363_0==IDENTIFIER) ) {
                alt363=1;
            }
            switch (alt363) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2706:43: type_parameter_constraints_clauses
                    {
                    pushFollow(FOLLOW_type_parameter_constraints_clauses_in_delegate_definition12916);
                    type_parameter_constraints_clauses1493=type_parameter_constraints_clauses();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, type_parameter_constraints_clauses1493.getTree());

                    }
                    break;

            }


            SEMICOLON1494=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_delegate_definition12919); if (state.failed) return retval;

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "delegate_definition"


    public static class event_declaration2_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "event_declaration2"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2708:1: event_declaration2 : EVENT type ( variable_declarators SEMICOLON -> ^( EVENT variable_declarators ) | member_name OPEN_BRACE event_accessor_declarations CLOSE_BRACE -> ^( EVENT type member_name event_accessor_declarations ) ) ;
    public final CSharp4AST.event_declaration2_return event_declaration2() throws RecognitionException {
        CSharp4AST.event_declaration2_return retval = new CSharp4AST.event_declaration2_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token EVENT1495=null;
        Token SEMICOLON1498=null;
        Token OPEN_BRACE1500=null;
        Token CLOSE_BRACE1502=null;
        CSharp4AST.type_return type1496 =null;

        CSharp4AST.variable_declarators_return variable_declarators1497 =null;

        CSharp4AST.member_name_return member_name1499 =null;

        CSharp4AST.event_accessor_declarations_return event_accessor_declarations1501 =null;


        Object EVENT1495_tree=null;
        Object SEMICOLON1498_tree=null;
        Object OPEN_BRACE1500_tree=null;
        Object CLOSE_BRACE1502_tree=null;
        RewriteRuleTokenStream stream_SEMICOLON=new RewriteRuleTokenStream(adaptor,"token SEMICOLON");
        RewriteRuleTokenStream stream_CLOSE_BRACE=new RewriteRuleTokenStream(adaptor,"token CLOSE_BRACE");
        RewriteRuleTokenStream stream_EVENT=new RewriteRuleTokenStream(adaptor,"token EVENT");
        RewriteRuleTokenStream stream_OPEN_BRACE=new RewriteRuleTokenStream(adaptor,"token OPEN_BRACE");
        RewriteRuleSubtreeStream stream_event_accessor_declarations=new RewriteRuleSubtreeStream(adaptor,"rule event_accessor_declarations");
        RewriteRuleSubtreeStream stream_variable_declarators=new RewriteRuleSubtreeStream(adaptor,"rule variable_declarators");
        RewriteRuleSubtreeStream stream_type=new RewriteRuleSubtreeStream(adaptor,"rule type");
        RewriteRuleSubtreeStream stream_member_name=new RewriteRuleSubtreeStream(adaptor,"rule member_name");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2709:3: ( EVENT type ( variable_declarators SEMICOLON -> ^( EVENT variable_declarators ) | member_name OPEN_BRACE event_accessor_declarations CLOSE_BRACE -> ^( EVENT type member_name event_accessor_declarations ) ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2709:5: EVENT type ( variable_declarators SEMICOLON -> ^( EVENT variable_declarators ) | member_name OPEN_BRACE event_accessor_declarations CLOSE_BRACE -> ^( EVENT type member_name event_accessor_declarations ) )
            {
            EVENT1495=(Token)match(input,EVENT,FOLLOW_EVENT_in_event_declaration212932); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_EVENT.add(EVENT1495);


            pushFollow(FOLLOW_type_in_event_declaration212934);
            type1496=type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_type.add(type1496.getTree());

            if ( state.backtracking==0 ) {((common_member_declaration_scope)common_member_declaration_stack.peek()).type = (type1496!=null?((Object)type1496.tree):null);}

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2710:7: ( variable_declarators SEMICOLON -> ^( EVENT variable_declarators ) | member_name OPEN_BRACE event_accessor_declarations CLOSE_BRACE -> ^( EVENT type member_name event_accessor_declarations ) )
            int alt364=2;
            int LA364_0 = input.LA(1);

            if ( (LA364_0==IDENTIFIER) ) {
                int LA364_1 = input.LA(2);

                if ( (LA364_1==DOT||LA364_1==DOUBLE_COLON||LA364_1==LT||LA364_1==OPEN_BRACE) ) {
                    alt364=2;
                }
                else if ( (LA364_1==ASSIGNMENT||LA364_1==COMMA||LA364_1==SEMICOLON) ) {
                    alt364=1;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 364, 1, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 364, 0, input);

                throw nvae;

            }
            switch (alt364) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2710:9: variable_declarators SEMICOLON
                    {
                    pushFollow(FOLLOW_variable_declarators_in_event_declaration212946);
                    variable_declarators1497=variable_declarators();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) stream_variable_declarators.add(variable_declarators1497.getTree());

                    SEMICOLON1498=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_event_declaration212948); if (state.failed) return retval; 
                    if ( state.backtracking==0 ) stream_SEMICOLON.add(SEMICOLON1498);


                    // AST REWRITE
                    // elements: EVENT, variable_declarators
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    // wildcard labels: 
                    if ( state.backtracking==0 ) {

                    retval.tree = root_0;
                    RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

                    root_0 = (Object)adaptor.nil();
                    // 2711:9: -> ^( EVENT variable_declarators )
                    {
                        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2711:12: ^( EVENT variable_declarators )
                        {
                        Object root_1 = (Object)adaptor.nil();
                        root_1 = (Object)adaptor.becomeRoot(
                        stream_EVENT.nextNode()
                        , root_1);

                        adaptor.addChild(root_1, stream_variable_declarators.nextTree());

                        adaptor.addChild(root_0, root_1);
                        }

                    }


                    retval.tree = root_0;
                    }

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2712:9: member_name OPEN_BRACE event_accessor_declarations CLOSE_BRACE
                    {
                    pushFollow(FOLLOW_member_name_in_event_declaration212974);
                    member_name1499=member_name();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) stream_member_name.add(member_name1499.getTree());

                    OPEN_BRACE1500=(Token)match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_event_declaration212976); if (state.failed) return retval; 
                    if ( state.backtracking==0 ) stream_OPEN_BRACE.add(OPEN_BRACE1500);


                    pushFollow(FOLLOW_event_accessor_declarations_in_event_declaration212978);
                    event_accessor_declarations1501=event_accessor_declarations();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) stream_event_accessor_declarations.add(event_accessor_declarations1501.getTree());

                    CLOSE_BRACE1502=(Token)match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_event_declaration212980); if (state.failed) return retval; 
                    if ( state.backtracking==0 ) stream_CLOSE_BRACE.add(CLOSE_BRACE1502);


                    // AST REWRITE
                    // elements: event_accessor_declarations, EVENT, type, member_name
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    // wildcard labels: 
                    if ( state.backtracking==0 ) {

                    retval.tree = root_0;
                    RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

                    root_0 = (Object)adaptor.nil();
                    // 2713:9: -> ^( EVENT type member_name event_accessor_declarations )
                    {
                        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2713:12: ^( EVENT type member_name event_accessor_declarations )
                        {
                        Object root_1 = (Object)adaptor.nil();
                        root_1 = (Object)adaptor.becomeRoot(
                        stream_EVENT.nextNode()
                        , root_1);

                        adaptor.addChild(root_1, stream_type.nextTree());

                        adaptor.addChild(root_1, stream_member_name.nextTree());

                        adaptor.addChild(root_1, stream_event_accessor_declarations.nextTree());

                        adaptor.addChild(root_0, root_1);
                        }

                    }


                    retval.tree = root_0;
                    }

                    }
                    break;

            }


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "event_declaration2"


    public static class field_declaration2_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "field_declaration2"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2716:1: field_declaration2 : variable_declarators SEMICOLON -> ^( FIELD_DECL variable_declarators ) ;
    public final CSharp4AST.field_declaration2_return field_declaration2() throws RecognitionException {
        CSharp4AST.field_declaration2_return retval = new CSharp4AST.field_declaration2_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token SEMICOLON1504=null;
        CSharp4AST.variable_declarators_return variable_declarators1503 =null;


        Object SEMICOLON1504_tree=null;
        RewriteRuleTokenStream stream_SEMICOLON=new RewriteRuleTokenStream(adaptor,"token SEMICOLON");
        RewriteRuleSubtreeStream stream_variable_declarators=new RewriteRuleSubtreeStream(adaptor,"rule variable_declarators");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2717:3: ( variable_declarators SEMICOLON -> ^( FIELD_DECL variable_declarators ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2717:5: variable_declarators SEMICOLON
            {
            pushFollow(FOLLOW_variable_declarators_in_field_declaration213020);
            variable_declarators1503=variable_declarators();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_variable_declarators.add(variable_declarators1503.getTree());

            SEMICOLON1504=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_field_declaration213022); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_SEMICOLON.add(SEMICOLON1504);


            // AST REWRITE
            // elements: variable_declarators
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 2718:5: -> ^( FIELD_DECL variable_declarators )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2718:8: ^( FIELD_DECL variable_declarators )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(FIELD_DECL, "FIELD_DECL")
                , root_1);

                adaptor.addChild(root_1, stream_variable_declarators.nextTree());

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "field_declaration2"


    public static class property_declaration2_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "property_declaration2"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2720:1: property_declaration2 : member_name OPEN_BRACE accessor_declarations CLOSE_BRACE -> ^( PROPERTY_DECL member_name accessor_declarations ) ;
    public final CSharp4AST.property_declaration2_return property_declaration2() throws RecognitionException {
        CSharp4AST.property_declaration2_return retval = new CSharp4AST.property_declaration2_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token OPEN_BRACE1506=null;
        Token CLOSE_BRACE1508=null;
        CSharp4AST.member_name_return member_name1505 =null;

        CSharp4AST.accessor_declarations_return accessor_declarations1507 =null;


        Object OPEN_BRACE1506_tree=null;
        Object CLOSE_BRACE1508_tree=null;
        RewriteRuleTokenStream stream_CLOSE_BRACE=new RewriteRuleTokenStream(adaptor,"token CLOSE_BRACE");
        RewriteRuleTokenStream stream_OPEN_BRACE=new RewriteRuleTokenStream(adaptor,"token OPEN_BRACE");
        RewriteRuleSubtreeStream stream_accessor_declarations=new RewriteRuleSubtreeStream(adaptor,"rule accessor_declarations");
        RewriteRuleSubtreeStream stream_member_name=new RewriteRuleSubtreeStream(adaptor,"rule member_name");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2721:3: ( member_name OPEN_BRACE accessor_declarations CLOSE_BRACE -> ^( PROPERTY_DECL member_name accessor_declarations ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2721:5: member_name OPEN_BRACE accessor_declarations CLOSE_BRACE
            {
            pushFollow(FOLLOW_member_name_in_property_declaration213046);
            member_name1505=member_name();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_member_name.add(member_name1505.getTree());

            OPEN_BRACE1506=(Token)match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_property_declaration213048); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_OPEN_BRACE.add(OPEN_BRACE1506);


            pushFollow(FOLLOW_accessor_declarations_in_property_declaration213050);
            accessor_declarations1507=accessor_declarations();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_accessor_declarations.add(accessor_declarations1507.getTree());

            CLOSE_BRACE1508=(Token)match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_property_declaration213052); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_CLOSE_BRACE.add(CLOSE_BRACE1508);


            // AST REWRITE
            // elements: member_name, accessor_declarations
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 2722:5: -> ^( PROPERTY_DECL member_name accessor_declarations )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2722:8: ^( PROPERTY_DECL member_name accessor_declarations )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(PROPERTY_DECL, "PROPERTY_DECL")
                , root_1);

                adaptor.addChild(root_1, stream_member_name.nextTree());

                adaptor.addChild(root_1, stream_accessor_declarations.nextTree());

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "property_declaration2"


    public static class constant_declaration2_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "constant_declaration2"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2724:1: constant_declaration2 : CONST !t= type ! constant_declarators[t.tree] SEMICOLON !;
    public final CSharp4AST.constant_declaration2_return constant_declaration2() throws RecognitionException {
        CSharp4AST.constant_declaration2_return retval = new CSharp4AST.constant_declaration2_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token CONST1509=null;
        Token SEMICOLON1511=null;
        CSharp4AST.type_return t =null;

        CSharp4AST.constant_declarators_return constant_declarators1510 =null;


        Object CONST1509_tree=null;
        Object SEMICOLON1511_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2725:3: ( CONST !t= type ! constant_declarators[t.tree] SEMICOLON !)
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2725:5: CONST !t= type ! constant_declarators[t.tree] SEMICOLON !
            {
            root_0 = (Object)adaptor.nil();


            CONST1509=(Token)match(input,CONST,FOLLOW_CONST_in_constant_declaration213080); if (state.failed) return retval;

            pushFollow(FOLLOW_type_in_constant_declaration213085);
            t=type();

            state._fsp--;
            if (state.failed) return retval;

            pushFollow(FOLLOW_constant_declarators_in_constant_declaration213088);
            constant_declarators1510=constant_declarators(t.tree);

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, constant_declarators1510.getTree());

            SEMICOLON1511=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_constant_declaration213091); if (state.failed) return retval;

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "constant_declaration2"


    public static class indexer_declaration2_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "indexer_declaration2"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2727:1: indexer_declaration2 : THIS OPEN_BRACKET formal_parameter_list CLOSE_BRACKET OPEN_BRACE accessor_declarations CLOSE_BRACE -> ^( INDEXER_DECL formal_parameter_list accessor_declarations ) ;
    public final CSharp4AST.indexer_declaration2_return indexer_declaration2() throws RecognitionException {
        CSharp4AST.indexer_declaration2_return retval = new CSharp4AST.indexer_declaration2_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token THIS1512=null;
        Token OPEN_BRACKET1513=null;
        Token CLOSE_BRACKET1515=null;
        Token OPEN_BRACE1516=null;
        Token CLOSE_BRACE1518=null;
        CSharp4AST.formal_parameter_list_return formal_parameter_list1514 =null;

        CSharp4AST.accessor_declarations_return accessor_declarations1517 =null;


        Object THIS1512_tree=null;
        Object OPEN_BRACKET1513_tree=null;
        Object CLOSE_BRACKET1515_tree=null;
        Object OPEN_BRACE1516_tree=null;
        Object CLOSE_BRACE1518_tree=null;
        RewriteRuleTokenStream stream_OPEN_BRACKET=new RewriteRuleTokenStream(adaptor,"token OPEN_BRACKET");
        RewriteRuleTokenStream stream_CLOSE_BRACE=new RewriteRuleTokenStream(adaptor,"token CLOSE_BRACE");
        RewriteRuleTokenStream stream_OPEN_BRACE=new RewriteRuleTokenStream(adaptor,"token OPEN_BRACE");
        RewriteRuleTokenStream stream_THIS=new RewriteRuleTokenStream(adaptor,"token THIS");
        RewriteRuleTokenStream stream_CLOSE_BRACKET=new RewriteRuleTokenStream(adaptor,"token CLOSE_BRACKET");
        RewriteRuleSubtreeStream stream_accessor_declarations=new RewriteRuleSubtreeStream(adaptor,"rule accessor_declarations");
        RewriteRuleSubtreeStream stream_formal_parameter_list=new RewriteRuleSubtreeStream(adaptor,"rule formal_parameter_list");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2728:3: ( THIS OPEN_BRACKET formal_parameter_list CLOSE_BRACKET OPEN_BRACE accessor_declarations CLOSE_BRACE -> ^( INDEXER_DECL formal_parameter_list accessor_declarations ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2728:5: THIS OPEN_BRACKET formal_parameter_list CLOSE_BRACKET OPEN_BRACE accessor_declarations CLOSE_BRACE
            {
            THIS1512=(Token)match(input,THIS,FOLLOW_THIS_in_indexer_declaration213104); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_THIS.add(THIS1512);


            OPEN_BRACKET1513=(Token)match(input,OPEN_BRACKET,FOLLOW_OPEN_BRACKET_in_indexer_declaration213106); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_OPEN_BRACKET.add(OPEN_BRACKET1513);


            pushFollow(FOLLOW_formal_parameter_list_in_indexer_declaration213108);
            formal_parameter_list1514=formal_parameter_list();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_formal_parameter_list.add(formal_parameter_list1514.getTree());

            CLOSE_BRACKET1515=(Token)match(input,CLOSE_BRACKET,FOLLOW_CLOSE_BRACKET_in_indexer_declaration213110); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_CLOSE_BRACKET.add(CLOSE_BRACKET1515);


            OPEN_BRACE1516=(Token)match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_indexer_declaration213118); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_OPEN_BRACE.add(OPEN_BRACE1516);


            pushFollow(FOLLOW_accessor_declarations_in_indexer_declaration213120);
            accessor_declarations1517=accessor_declarations();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_accessor_declarations.add(accessor_declarations1517.getTree());

            CLOSE_BRACE1518=(Token)match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_indexer_declaration213122); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_CLOSE_BRACE.add(CLOSE_BRACE1518);


            // AST REWRITE
            // elements: formal_parameter_list, accessor_declarations
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 2730:5: -> ^( INDEXER_DECL formal_parameter_list accessor_declarations )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2730:8: ^( INDEXER_DECL formal_parameter_list accessor_declarations )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(INDEXER_DECL, "INDEXER_DECL")
                , root_1);

                adaptor.addChild(root_1, stream_formal_parameter_list.nextTree());

                adaptor.addChild(root_1, stream_accessor_declarations.nextTree());

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "indexer_declaration2"


    public static class destructor_definition_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "destructor_definition"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2732:1: destructor_definition : TILDE ^ IDENTIFIER OPEN_PARENS ! CLOSE_PARENS ! destructor_body ;
    public final CSharp4AST.destructor_definition_return destructor_definition() throws RecognitionException {
        CSharp4AST.destructor_definition_return retval = new CSharp4AST.destructor_definition_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token TILDE1519=null;
        Token IDENTIFIER1520=null;
        Token OPEN_PARENS1521=null;
        Token CLOSE_PARENS1522=null;
        CSharp4AST.destructor_body_return destructor_body1523 =null;


        Object TILDE1519_tree=null;
        Object IDENTIFIER1520_tree=null;
        Object OPEN_PARENS1521_tree=null;
        Object CLOSE_PARENS1522_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2733:3: ( TILDE ^ IDENTIFIER OPEN_PARENS ! CLOSE_PARENS ! destructor_body )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2733:5: TILDE ^ IDENTIFIER OPEN_PARENS ! CLOSE_PARENS ! destructor_body
            {
            root_0 = (Object)adaptor.nil();


            TILDE1519=(Token)match(input,TILDE,FOLLOW_TILDE_in_destructor_definition13149); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            TILDE1519_tree = 
            (Object)adaptor.create(TILDE1519)
            ;
            root_0 = (Object)adaptor.becomeRoot(TILDE1519_tree, root_0);
            }

            IDENTIFIER1520=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_destructor_definition13152); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1520_tree = 
            (Object)adaptor.create(IDENTIFIER1520)
            ;
            adaptor.addChild(root_0, IDENTIFIER1520_tree);
            }

            OPEN_PARENS1521=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_destructor_definition13154); if (state.failed) return retval;

            CLOSE_PARENS1522=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_destructor_definition13157); if (state.failed) return retval;

            pushFollow(FOLLOW_destructor_body_in_destructor_definition13160);
            destructor_body1523=destructor_body();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, destructor_body1523.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "destructor_definition"


    public static class constructor_declaration2_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "constructor_declaration2"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2735:1: constructor_declaration2 : IDENTIFIER OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( constructor_initializer )? body -> ^( CONSTRUCTOR_DECL IDENTIFIER ( formal_parameter_list )? ( constructor_initializer )? body ) ;
    public final CSharp4AST.constructor_declaration2_return constructor_declaration2() throws RecognitionException {
        CSharp4AST.constructor_declaration2_return retval = new CSharp4AST.constructor_declaration2_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER1524=null;
        Token OPEN_PARENS1525=null;
        Token CLOSE_PARENS1527=null;
        CSharp4AST.formal_parameter_list_return formal_parameter_list1526 =null;

        CSharp4AST.constructor_initializer_return constructor_initializer1528 =null;

        CSharp4AST.body_return body1529 =null;


        Object IDENTIFIER1524_tree=null;
        Object OPEN_PARENS1525_tree=null;
        Object CLOSE_PARENS1527_tree=null;
        RewriteRuleTokenStream stream_IDENTIFIER=new RewriteRuleTokenStream(adaptor,"token IDENTIFIER");
        RewriteRuleTokenStream stream_OPEN_PARENS=new RewriteRuleTokenStream(adaptor,"token OPEN_PARENS");
        RewriteRuleTokenStream stream_CLOSE_PARENS=new RewriteRuleTokenStream(adaptor,"token CLOSE_PARENS");
        RewriteRuleSubtreeStream stream_body=new RewriteRuleSubtreeStream(adaptor,"rule body");
        RewriteRuleSubtreeStream stream_constructor_initializer=new RewriteRuleSubtreeStream(adaptor,"rule constructor_initializer");
        RewriteRuleSubtreeStream stream_formal_parameter_list=new RewriteRuleSubtreeStream(adaptor,"rule formal_parameter_list");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2736:3: ( IDENTIFIER OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( constructor_initializer )? body -> ^( CONSTRUCTOR_DECL IDENTIFIER ( formal_parameter_list )? ( constructor_initializer )? body ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2736:5: IDENTIFIER OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( constructor_initializer )? body
            {
            IDENTIFIER1524=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_constructor_declaration213172); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_IDENTIFIER.add(IDENTIFIER1524);


            OPEN_PARENS1525=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_constructor_declaration213174); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_OPEN_PARENS.add(OPEN_PARENS1525);


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2736:28: ( formal_parameter_list )?
            int alt365=2;
            int LA365_0 = input.LA(1);

            if ( (LA365_0==BOOL||LA365_0==BYTE||LA365_0==CHAR||LA365_0==DECIMAL||LA365_0==DOUBLE||LA365_0==FLOAT||LA365_0==IDENTIFIER||LA365_0==INT||LA365_0==LONG||LA365_0==OBJECT||LA365_0==OPEN_BRACKET||LA365_0==OUT||LA365_0==PARAMS||LA365_0==REF||LA365_0==SBYTE||LA365_0==SHORT||LA365_0==STRING||LA365_0==THIS||(LA365_0 >= UINT && LA365_0 <= ULONG)||LA365_0==USHORT||LA365_0==VOID) ) {
                alt365=1;
            }
            switch (alt365) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2736:28: formal_parameter_list
                    {
                    pushFollow(FOLLOW_formal_parameter_list_in_constructor_declaration213176);
                    formal_parameter_list1526=formal_parameter_list();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) stream_formal_parameter_list.add(formal_parameter_list1526.getTree());

                    }
                    break;

            }


            CLOSE_PARENS1527=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_constructor_declaration213179); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_CLOSE_PARENS.add(CLOSE_PARENS1527);


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2736:64: ( constructor_initializer )?
            int alt366=2;
            int LA366_0 = input.LA(1);

            if ( (LA366_0==COLON) ) {
                alt366=1;
            }
            switch (alt366) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2736:64: constructor_initializer
                    {
                    pushFollow(FOLLOW_constructor_initializer_in_constructor_declaration213181);
                    constructor_initializer1528=constructor_initializer();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) stream_constructor_initializer.add(constructor_initializer1528.getTree());

                    }
                    break;

            }


            pushFollow(FOLLOW_body_in_constructor_declaration213184);
            body1529=body();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_body.add(body1529.getTree());

            // AST REWRITE
            // elements: IDENTIFIER, formal_parameter_list, body, constructor_initializer
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 2737:5: -> ^( CONSTRUCTOR_DECL IDENTIFIER ( formal_parameter_list )? ( constructor_initializer )? body )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2737:8: ^( CONSTRUCTOR_DECL IDENTIFIER ( formal_parameter_list )? ( constructor_initializer )? body )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(CONSTRUCTOR_DECL, "CONSTRUCTOR_DECL")
                , root_1);

                adaptor.addChild(root_1, 
                stream_IDENTIFIER.nextNode()
                );

                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2737:40: ( formal_parameter_list )?
                if ( stream_formal_parameter_list.hasNext() ) {
                    adaptor.addChild(root_1, stream_formal_parameter_list.nextTree());

                }
                stream_formal_parameter_list.reset();

                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2737:63: ( constructor_initializer )?
                if ( stream_constructor_initializer.hasNext() ) {
                    adaptor.addChild(root_1, stream_constructor_initializer.nextTree());

                }
                stream_constructor_initializer.reset();

                adaptor.addChild(root_1, stream_body.nextTree());

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "constructor_declaration2"


    public static class method_declaration2_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "method_declaration2"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2739:1: method_declaration2 : method_member_name ( type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? method_body -> ^( METHOD_DECL method_member_name ( type_parameter_list )? ( formal_parameter_list )? ( type_parameter_constraints_clauses )? ( method_body )? ) ;
    public final CSharp4AST.method_declaration2_return method_declaration2() throws RecognitionException {
        CSharp4AST.method_declaration2_return retval = new CSharp4AST.method_declaration2_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token OPEN_PARENS1532=null;
        Token CLOSE_PARENS1534=null;
        CSharp4AST.method_member_name_return method_member_name1530 =null;

        CSharp4AST.type_parameter_list_return type_parameter_list1531 =null;

        CSharp4AST.formal_parameter_list_return formal_parameter_list1533 =null;

        CSharp4AST.type_parameter_constraints_clauses_return type_parameter_constraints_clauses1535 =null;

        CSharp4AST.method_body_return method_body1536 =null;


        Object OPEN_PARENS1532_tree=null;
        Object CLOSE_PARENS1534_tree=null;
        RewriteRuleTokenStream stream_OPEN_PARENS=new RewriteRuleTokenStream(adaptor,"token OPEN_PARENS");
        RewriteRuleTokenStream stream_CLOSE_PARENS=new RewriteRuleTokenStream(adaptor,"token CLOSE_PARENS");
        RewriteRuleSubtreeStream stream_type_parameter_list=new RewriteRuleSubtreeStream(adaptor,"rule type_parameter_list");
        RewriteRuleSubtreeStream stream_type_parameter_constraints_clauses=new RewriteRuleSubtreeStream(adaptor,"rule type_parameter_constraints_clauses");
        RewriteRuleSubtreeStream stream_formal_parameter_list=new RewriteRuleSubtreeStream(adaptor,"rule formal_parameter_list");
        RewriteRuleSubtreeStream stream_method_body=new RewriteRuleSubtreeStream(adaptor,"rule method_body");
        RewriteRuleSubtreeStream stream_method_member_name=new RewriteRuleSubtreeStream(adaptor,"rule method_member_name");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2740:3: ( method_member_name ( type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? method_body -> ^( METHOD_DECL method_member_name ( type_parameter_list )? ( formal_parameter_list )? ( type_parameter_constraints_clauses )? ( method_body )? ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2740:5: method_member_name ( type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? method_body
            {
            pushFollow(FOLLOW_method_member_name_in_method_declaration213219);
            method_member_name1530=method_member_name();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_method_member_name.add(method_member_name1530.getTree());

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2740:24: ( type_parameter_list )?
            int alt367=2;
            int LA367_0 = input.LA(1);

            if ( (LA367_0==LT) ) {
                alt367=1;
            }
            switch (alt367) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2740:24: type_parameter_list
                    {
                    pushFollow(FOLLOW_type_parameter_list_in_method_declaration213221);
                    type_parameter_list1531=type_parameter_list();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) stream_type_parameter_list.add(type_parameter_list1531.getTree());

                    }
                    break;

            }


            OPEN_PARENS1532=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_method_declaration213224); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_OPEN_PARENS.add(OPEN_PARENS1532);


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2740:57: ( formal_parameter_list )?
            int alt368=2;
            int LA368_0 = input.LA(1);

            if ( (LA368_0==BOOL||LA368_0==BYTE||LA368_0==CHAR||LA368_0==DECIMAL||LA368_0==DOUBLE||LA368_0==FLOAT||LA368_0==IDENTIFIER||LA368_0==INT||LA368_0==LONG||LA368_0==OBJECT||LA368_0==OPEN_BRACKET||LA368_0==OUT||LA368_0==PARAMS||LA368_0==REF||LA368_0==SBYTE||LA368_0==SHORT||LA368_0==STRING||LA368_0==THIS||(LA368_0 >= UINT && LA368_0 <= ULONG)||LA368_0==USHORT||LA368_0==VOID) ) {
                alt368=1;
            }
            switch (alt368) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2740:57: formal_parameter_list
                    {
                    pushFollow(FOLLOW_formal_parameter_list_in_method_declaration213226);
                    formal_parameter_list1533=formal_parameter_list();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) stream_formal_parameter_list.add(formal_parameter_list1533.getTree());

                    }
                    break;

            }


            CLOSE_PARENS1534=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_method_declaration213229); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_CLOSE_PARENS.add(CLOSE_PARENS1534);


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2741:7: ( type_parameter_constraints_clauses )?
            int alt369=2;
            int LA369_0 = input.LA(1);

            if ( (LA369_0==IDENTIFIER) ) {
                alt369=1;
            }
            switch (alt369) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2741:7: type_parameter_constraints_clauses
                    {
                    pushFollow(FOLLOW_type_parameter_constraints_clauses_in_method_declaration213237);
                    type_parameter_constraints_clauses1535=type_parameter_constraints_clauses();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) stream_type_parameter_constraints_clauses.add(type_parameter_constraints_clauses1535.getTree());

                    }
                    break;

            }


            pushFollow(FOLLOW_method_body_in_method_declaration213240);
            method_body1536=method_body();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_method_body.add(method_body1536.getTree());

            // AST REWRITE
            // elements: method_body, type_parameter_constraints_clauses, formal_parameter_list, type_parameter_list, method_member_name
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 2742:5: -> ^( METHOD_DECL method_member_name ( type_parameter_list )? ( formal_parameter_list )? ( type_parameter_constraints_clauses )? ( method_body )? )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2742:8: ^( METHOD_DECL method_member_name ( type_parameter_list )? ( formal_parameter_list )? ( type_parameter_constraints_clauses )? ( method_body )? )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(METHOD_DECL, "METHOD_DECL")
                , root_1);

                adaptor.addChild(root_1, stream_method_member_name.nextTree());

                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2742:43: ( type_parameter_list )?
                if ( stream_type_parameter_list.hasNext() ) {
                    adaptor.addChild(root_1, stream_type_parameter_list.nextTree());

                }
                stream_type_parameter_list.reset();

                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2742:65: ( formal_parameter_list )?
                if ( stream_formal_parameter_list.hasNext() ) {
                    adaptor.addChild(root_1, stream_formal_parameter_list.nextTree());

                }
                stream_formal_parameter_list.reset();

                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2743:13: ( type_parameter_constraints_clauses )?
                if ( stream_type_parameter_constraints_clauses.hasNext() ) {
                    adaptor.addChild(root_1, stream_type_parameter_constraints_clauses.nextTree());

                }
                stream_type_parameter_constraints_clauses.reset();

                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2743:51: ( method_body )?
                if ( stream_method_body.hasNext() ) {
                    adaptor.addChild(root_1, stream_method_body.nextTree());

                }
                stream_method_body.reset();

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "method_declaration2"


    public static class method_member_name_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "method_member_name"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2746:1: method_member_name : method_member_name2 -> ^( MEMBER_NAME ^( NAMESPACE_OR_TYPE_NAME method_member_name2 ) ) ;
    public final CSharp4AST.method_member_name_return method_member_name() throws RecognitionException {
        CSharp4AST.method_member_name_return retval = new CSharp4AST.method_member_name_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        CSharp4AST.method_member_name2_return method_member_name21537 =null;


        RewriteRuleSubtreeStream stream_method_member_name2=new RewriteRuleSubtreeStream(adaptor,"rule method_member_name2");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2747:3: ( method_member_name2 -> ^( MEMBER_NAME ^( NAMESPACE_OR_TYPE_NAME method_member_name2 ) ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2747:5: method_member_name2
            {
            pushFollow(FOLLOW_method_member_name2_in_method_member_name13297);
            method_member_name21537=method_member_name2();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_method_member_name2.add(method_member_name21537.getTree());

            // AST REWRITE
            // elements: method_member_name2
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 2747:25: -> ^( MEMBER_NAME ^( NAMESPACE_OR_TYPE_NAME method_member_name2 ) )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2747:28: ^( MEMBER_NAME ^( NAMESPACE_OR_TYPE_NAME method_member_name2 ) )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(MEMBER_NAME, "MEMBER_NAME")
                , root_1);

                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2747:42: ^( NAMESPACE_OR_TYPE_NAME method_member_name2 )
                {
                Object root_2 = (Object)adaptor.nil();
                root_2 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(NAMESPACE_OR_TYPE_NAME, "NAMESPACE_OR_TYPE_NAME")
                , root_2);

                adaptor.addChild(root_2, stream_method_member_name2.nextTree());

                adaptor.addChild(root_1, root_2);
                }

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "method_member_name"


    public static class method_member_name2_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "method_member_name2"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2749:1: method_member_name2 : ( IDENTIFIER | IDENTIFIER DOUBLE_COLON IDENTIFIER ) ( type_argument_list_opt DOT IDENTIFIER )* ;
    public final CSharp4AST.method_member_name2_return method_member_name2() throws RecognitionException {
        CSharp4AST.method_member_name2_return retval = new CSharp4AST.method_member_name2_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER1538=null;
        Token IDENTIFIER1539=null;
        Token DOUBLE_COLON1540=null;
        Token IDENTIFIER1541=null;
        Token DOT1543=null;
        Token IDENTIFIER1544=null;
        CSharp4AST.type_argument_list_opt_return type_argument_list_opt1542 =null;


        Object IDENTIFIER1538_tree=null;
        Object IDENTIFIER1539_tree=null;
        Object DOUBLE_COLON1540_tree=null;
        Object IDENTIFIER1541_tree=null;
        Object DOT1543_tree=null;
        Object IDENTIFIER1544_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2750:3: ( ( IDENTIFIER | IDENTIFIER DOUBLE_COLON IDENTIFIER ) ( type_argument_list_opt DOT IDENTIFIER )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2750:5: ( IDENTIFIER | IDENTIFIER DOUBLE_COLON IDENTIFIER ) ( type_argument_list_opt DOT IDENTIFIER )*
            {
            root_0 = (Object)adaptor.nil();


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2750:5: ( IDENTIFIER | IDENTIFIER DOUBLE_COLON IDENTIFIER )
            int alt370=2;
            int LA370_0 = input.LA(1);

            if ( (LA370_0==IDENTIFIER) ) {
                int LA370_1 = input.LA(2);

                if ( (LA370_1==DOUBLE_COLON) ) {
                    alt370=2;
                }
                else if ( (LA370_1==DOT||LA370_1==LT||LA370_1==OPEN_PARENS) ) {
                    alt370=1;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return retval;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 370, 1, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return retval;}
                NoViableAltException nvae =
                    new NoViableAltException("", 370, 0, input);

                throw nvae;

            }
            switch (alt370) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2750:7: IDENTIFIER
                    {
                    IDENTIFIER1538=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_method_member_name213323); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    IDENTIFIER1538_tree = 
                    (Object)adaptor.create(IDENTIFIER1538)
                    ;
                    adaptor.addChild(root_0, IDENTIFIER1538_tree);
                    }

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2751:7: IDENTIFIER DOUBLE_COLON IDENTIFIER
                    {
                    IDENTIFIER1539=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_method_member_name213331); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    IDENTIFIER1539_tree = 
                    (Object)adaptor.create(IDENTIFIER1539)
                    ;
                    adaptor.addChild(root_0, IDENTIFIER1539_tree);
                    }

                    DOUBLE_COLON1540=(Token)match(input,DOUBLE_COLON,FOLLOW_DOUBLE_COLON_in_method_member_name213333); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    DOUBLE_COLON1540_tree = 
                    (Object)adaptor.create(DOUBLE_COLON1540)
                    ;
                    adaptor.addChild(root_0, DOUBLE_COLON1540_tree);
                    }

                    IDENTIFIER1541=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_method_member_name213335); if (state.failed) return retval;
                    if ( state.backtracking==0 ) {
                    IDENTIFIER1541_tree = 
                    (Object)adaptor.create(IDENTIFIER1541)
                    ;
                    adaptor.addChild(root_0, IDENTIFIER1541_tree);
                    }

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2752:7: ( type_argument_list_opt DOT IDENTIFIER )*
            loop371:
            do {
                int alt371=2;
                alt371 = dfa371.predict(input);
                switch (alt371) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2752:8: type_argument_list_opt DOT IDENTIFIER
            	    {
            	    pushFollow(FOLLOW_type_argument_list_opt_in_method_member_name213344);
            	    type_argument_list_opt1542=type_argument_list_opt();

            	    state._fsp--;
            	    if (state.failed) return retval;
            	    if ( state.backtracking==0 ) adaptor.addChild(root_0, type_argument_list_opt1542.getTree());

            	    DOT1543=(Token)match(input,DOT,FOLLOW_DOT_in_method_member_name213346); if (state.failed) return retval;
            	    if ( state.backtracking==0 ) {
            	    DOT1543_tree = 
            	    (Object)adaptor.create(DOT1543)
            	    ;
            	    adaptor.addChild(root_0, DOT1543_tree);
            	    }

            	    IDENTIFIER1544=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_method_member_name213348); if (state.failed) return retval;
            	    if ( state.backtracking==0 ) {
            	    IDENTIFIER1544_tree = 
            	    (Object)adaptor.create(IDENTIFIER1544)
            	    ;
            	    adaptor.addChild(root_0, IDENTIFIER1544_tree);
            	    }

            	    }
            	    break;

            	default :
            	    break loop371;
                }
            } while (true);


            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "method_member_name2"


    public static class operator_declaration2_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "operator_declaration2"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2754:1: operator_declaration2 : OPERATOR overloadable_operator OPEN_PARENS t1= type id1= IDENTIFIER ( COMMA t2= type id2= IDENTIFIER )? CLOSE_PARENS operator_body -> ^( OPERATOR overloadable_operator ^( FIRST_OP $t1 $id1) ^( SECOND_OP ( $t2)? ( $id2)? ) operator_body ) ;
    public final CSharp4AST.operator_declaration2_return operator_declaration2() throws RecognitionException {
        CSharp4AST.operator_declaration2_return retval = new CSharp4AST.operator_declaration2_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token id1=null;
        Token id2=null;
        Token OPERATOR1545=null;
        Token OPEN_PARENS1547=null;
        Token COMMA1548=null;
        Token CLOSE_PARENS1549=null;
        CSharp4AST.type_return t1 =null;

        CSharp4AST.type_return t2 =null;

        CSharp4AST.overloadable_operator_return overloadable_operator1546 =null;

        CSharp4AST.operator_body_return operator_body1550 =null;


        Object id1_tree=null;
        Object id2_tree=null;
        Object OPERATOR1545_tree=null;
        Object OPEN_PARENS1547_tree=null;
        Object COMMA1548_tree=null;
        Object CLOSE_PARENS1549_tree=null;
        RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
        RewriteRuleTokenStream stream_OPERATOR=new RewriteRuleTokenStream(adaptor,"token OPERATOR");
        RewriteRuleTokenStream stream_IDENTIFIER=new RewriteRuleTokenStream(adaptor,"token IDENTIFIER");
        RewriteRuleTokenStream stream_OPEN_PARENS=new RewriteRuleTokenStream(adaptor,"token OPEN_PARENS");
        RewriteRuleTokenStream stream_CLOSE_PARENS=new RewriteRuleTokenStream(adaptor,"token CLOSE_PARENS");
        RewriteRuleSubtreeStream stream_operator_body=new RewriteRuleSubtreeStream(adaptor,"rule operator_body");
        RewriteRuleSubtreeStream stream_type=new RewriteRuleSubtreeStream(adaptor,"rule type");
        RewriteRuleSubtreeStream stream_overloadable_operator=new RewriteRuleSubtreeStream(adaptor,"rule overloadable_operator");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2755:3: ( OPERATOR overloadable_operator OPEN_PARENS t1= type id1= IDENTIFIER ( COMMA t2= type id2= IDENTIFIER )? CLOSE_PARENS operator_body -> ^( OPERATOR overloadable_operator ^( FIRST_OP $t1 $id1) ^( SECOND_OP ( $t2)? ( $id2)? ) operator_body ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2755:5: OPERATOR overloadable_operator OPEN_PARENS t1= type id1= IDENTIFIER ( COMMA t2= type id2= IDENTIFIER )? CLOSE_PARENS operator_body
            {
            OPERATOR1545=(Token)match(input,OPERATOR,FOLLOW_OPERATOR_in_operator_declaration213362); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_OPERATOR.add(OPERATOR1545);


            pushFollow(FOLLOW_overloadable_operator_in_operator_declaration213364);
            overloadable_operator1546=overloadable_operator();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_overloadable_operator.add(overloadable_operator1546.getTree());

            OPEN_PARENS1547=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_operator_declaration213366); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_OPEN_PARENS.add(OPEN_PARENS1547);


            pushFollow(FOLLOW_type_in_operator_declaration213370);
            t1=type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_type.add(t1.getTree());

            id1=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_operator_declaration213374); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_IDENTIFIER.add(id1);


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2756:10: ( COMMA t2= type id2= IDENTIFIER )?
            int alt372=2;
            int LA372_0 = input.LA(1);

            if ( (LA372_0==COMMA) ) {
                alt372=1;
            }
            switch (alt372) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2756:11: COMMA t2= type id2= IDENTIFIER
                    {
                    COMMA1548=(Token)match(input,COMMA,FOLLOW_COMMA_in_operator_declaration213386); if (state.failed) return retval; 
                    if ( state.backtracking==0 ) stream_COMMA.add(COMMA1548);


                    pushFollow(FOLLOW_type_in_operator_declaration213390);
                    t2=type();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) stream_type.add(t2.getTree());

                    id2=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_operator_declaration213394); if (state.failed) return retval; 
                    if ( state.backtracking==0 ) stream_IDENTIFIER.add(id2);


                    }
                    break;

            }


            CLOSE_PARENS1549=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_operator_declaration213398); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_CLOSE_PARENS.add(CLOSE_PARENS1549);


            pushFollow(FOLLOW_operator_body_in_operator_declaration213400);
            operator_body1550=operator_body();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_operator_body.add(operator_body1550.getTree());

            // AST REWRITE
            // elements: operator_body, OPERATOR, id2, overloadable_operator, id1, t1, t2
            // token labels: id2, id1
            // rule labels: t2, retval, t1
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleTokenStream stream_id2=new RewriteRuleTokenStream(adaptor,"token id2",id2);
            RewriteRuleTokenStream stream_id1=new RewriteRuleTokenStream(adaptor,"token id1",id1);
            RewriteRuleSubtreeStream stream_t2=new RewriteRuleSubtreeStream(adaptor,"rule t2",t2!=null?t2.tree:null);
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
            RewriteRuleSubtreeStream stream_t1=new RewriteRuleSubtreeStream(adaptor,"rule t1",t1!=null?t1.tree:null);

            root_0 = (Object)adaptor.nil();
            // 2757:5: -> ^( OPERATOR overloadable_operator ^( FIRST_OP $t1 $id1) ^( SECOND_OP ( $t2)? ( $id2)? ) operator_body )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2757:8: ^( OPERATOR overloadable_operator ^( FIRST_OP $t1 $id1) ^( SECOND_OP ( $t2)? ( $id2)? ) operator_body )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                stream_OPERATOR.nextNode()
                , root_1);

                adaptor.addChild(root_1, stream_overloadable_operator.nextTree());

                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2757:41: ^( FIRST_OP $t1 $id1)
                {
                Object root_2 = (Object)adaptor.nil();
                root_2 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(FIRST_OP, "FIRST_OP")
                , root_2);

                adaptor.addChild(root_2, stream_t1.nextTree());

                adaptor.addChild(root_2, stream_id1.nextNode());

                adaptor.addChild(root_1, root_2);
                }

                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2757:62: ^( SECOND_OP ( $t2)? ( $id2)? )
                {
                Object root_2 = (Object)adaptor.nil();
                root_2 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(SECOND_OP, "SECOND_OP")
                , root_2);

                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2757:75: ( $t2)?
                if ( stream_t2.hasNext() ) {
                    adaptor.addChild(root_2, stream_t2.nextTree());

                }
                stream_t2.reset();

                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2757:80: ( $id2)?
                if ( stream_id2.hasNext() ) {
                    adaptor.addChild(root_2, stream_id2.nextNode());

                }
                stream_id2.reset();

                adaptor.addChild(root_1, root_2);
                }

                adaptor.addChild(root_1, stream_operator_body.nextTree());

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "operator_declaration2"


    public static class interface_method_declaration2_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "interface_method_declaration2"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2760:1: interface_method_declaration2 : IDENTIFIER ( type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? SEMICOLON -> ^( METHOD_DECL MEMBER_NAME[$IDENTIFIER] ( type_parameter_list )? ( formal_parameter_list )? ( type_parameter_constraints_clauses )? ) ;
    public final CSharp4AST.interface_method_declaration2_return interface_method_declaration2() throws RecognitionException {
        CSharp4AST.interface_method_declaration2_return retval = new CSharp4AST.interface_method_declaration2_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER1551=null;
        Token OPEN_PARENS1553=null;
        Token CLOSE_PARENS1555=null;
        Token SEMICOLON1557=null;
        CSharp4AST.type_parameter_list_return type_parameter_list1552 =null;

        CSharp4AST.formal_parameter_list_return formal_parameter_list1554 =null;

        CSharp4AST.type_parameter_constraints_clauses_return type_parameter_constraints_clauses1556 =null;


        Object IDENTIFIER1551_tree=null;
        Object OPEN_PARENS1553_tree=null;
        Object CLOSE_PARENS1555_tree=null;
        Object SEMICOLON1557_tree=null;
        RewriteRuleTokenStream stream_SEMICOLON=new RewriteRuleTokenStream(adaptor,"token SEMICOLON");
        RewriteRuleTokenStream stream_IDENTIFIER=new RewriteRuleTokenStream(adaptor,"token IDENTIFIER");
        RewriteRuleTokenStream stream_OPEN_PARENS=new RewriteRuleTokenStream(adaptor,"token OPEN_PARENS");
        RewriteRuleTokenStream stream_CLOSE_PARENS=new RewriteRuleTokenStream(adaptor,"token CLOSE_PARENS");
        RewriteRuleSubtreeStream stream_type_parameter_list=new RewriteRuleSubtreeStream(adaptor,"rule type_parameter_list");
        RewriteRuleSubtreeStream stream_type_parameter_constraints_clauses=new RewriteRuleSubtreeStream(adaptor,"rule type_parameter_constraints_clauses");
        RewriteRuleSubtreeStream stream_formal_parameter_list=new RewriteRuleSubtreeStream(adaptor,"rule formal_parameter_list");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2761:3: ( IDENTIFIER ( type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? SEMICOLON -> ^( METHOD_DECL MEMBER_NAME[$IDENTIFIER] ( type_parameter_list )? ( formal_parameter_list )? ( type_parameter_constraints_clauses )? ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2761:5: IDENTIFIER ( type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? SEMICOLON
            {
            IDENTIFIER1551=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_interface_method_declaration213449); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_IDENTIFIER.add(IDENTIFIER1551);


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2761:16: ( type_parameter_list )?
            int alt373=2;
            int LA373_0 = input.LA(1);

            if ( (LA373_0==LT) ) {
                alt373=1;
            }
            switch (alt373) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2761:16: type_parameter_list
                    {
                    pushFollow(FOLLOW_type_parameter_list_in_interface_method_declaration213451);
                    type_parameter_list1552=type_parameter_list();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) stream_type_parameter_list.add(type_parameter_list1552.getTree());

                    }
                    break;

            }


            OPEN_PARENS1553=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_interface_method_declaration213454); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_OPEN_PARENS.add(OPEN_PARENS1553);


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2761:49: ( formal_parameter_list )?
            int alt374=2;
            int LA374_0 = input.LA(1);

            if ( (LA374_0==BOOL||LA374_0==BYTE||LA374_0==CHAR||LA374_0==DECIMAL||LA374_0==DOUBLE||LA374_0==FLOAT||LA374_0==IDENTIFIER||LA374_0==INT||LA374_0==LONG||LA374_0==OBJECT||LA374_0==OPEN_BRACKET||LA374_0==OUT||LA374_0==PARAMS||LA374_0==REF||LA374_0==SBYTE||LA374_0==SHORT||LA374_0==STRING||LA374_0==THIS||(LA374_0 >= UINT && LA374_0 <= ULONG)||LA374_0==USHORT||LA374_0==VOID) ) {
                alt374=1;
            }
            switch (alt374) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2761:49: formal_parameter_list
                    {
                    pushFollow(FOLLOW_formal_parameter_list_in_interface_method_declaration213456);
                    formal_parameter_list1554=formal_parameter_list();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) stream_formal_parameter_list.add(formal_parameter_list1554.getTree());

                    }
                    break;

            }


            CLOSE_PARENS1555=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_interface_method_declaration213459); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_CLOSE_PARENS.add(CLOSE_PARENS1555);


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2761:85: ( type_parameter_constraints_clauses )?
            int alt375=2;
            int LA375_0 = input.LA(1);

            if ( (LA375_0==IDENTIFIER) ) {
                alt375=1;
            }
            switch (alt375) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2761:85: type_parameter_constraints_clauses
                    {
                    pushFollow(FOLLOW_type_parameter_constraints_clauses_in_interface_method_declaration213461);
                    type_parameter_constraints_clauses1556=type_parameter_constraints_clauses();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) stream_type_parameter_constraints_clauses.add(type_parameter_constraints_clauses1556.getTree());

                    }
                    break;

            }


            SEMICOLON1557=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_interface_method_declaration213464); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_SEMICOLON.add(SEMICOLON1557);


            // AST REWRITE
            // elements: formal_parameter_list, type_parameter_list, type_parameter_constraints_clauses
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 2762:5: -> ^( METHOD_DECL MEMBER_NAME[$IDENTIFIER] ( type_parameter_list )? ( formal_parameter_list )? ( type_parameter_constraints_clauses )? )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2762:8: ^( METHOD_DECL MEMBER_NAME[$IDENTIFIER] ( type_parameter_list )? ( formal_parameter_list )? ( type_parameter_constraints_clauses )? )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(METHOD_DECL, "METHOD_DECL")
                , root_1);

                adaptor.addChild(root_1, 
                (Object)adaptor.create(MEMBER_NAME, IDENTIFIER1551)
                );

                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2762:48: ( type_parameter_list )?
                if ( stream_type_parameter_list.hasNext() ) {
                    adaptor.addChild(root_1, stream_type_parameter_list.nextTree());

                }
                stream_type_parameter_list.reset();

                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2762:70: ( formal_parameter_list )?
                if ( stream_formal_parameter_list.hasNext() ) {
                    adaptor.addChild(root_1, stream_formal_parameter_list.nextTree());

                }
                stream_formal_parameter_list.reset();

                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2762:95: ( type_parameter_constraints_clauses )?
                if ( stream_type_parameter_constraints_clauses.hasNext() ) {
                    adaptor.addChild(root_1, stream_type_parameter_constraints_clauses.nextTree());

                }
                stream_type_parameter_constraints_clauses.reset();

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "interface_method_declaration2"


    public static class interface_property_declaration2_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "interface_property_declaration2"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2764:1: interface_property_declaration2 : IDENTIFIER OPEN_BRACE interface_accessors CLOSE_BRACE -> ^( PROPERTY_DECL MEMBER_NAME[$IDENTIFIER] interface_accessors ) ;
    public final CSharp4AST.interface_property_declaration2_return interface_property_declaration2() throws RecognitionException {
        CSharp4AST.interface_property_declaration2_return retval = new CSharp4AST.interface_property_declaration2_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER1558=null;
        Token OPEN_BRACE1559=null;
        Token CLOSE_BRACE1561=null;
        CSharp4AST.interface_accessors_return interface_accessors1560 =null;


        Object IDENTIFIER1558_tree=null;
        Object OPEN_BRACE1559_tree=null;
        Object CLOSE_BRACE1561_tree=null;
        RewriteRuleTokenStream stream_CLOSE_BRACE=new RewriteRuleTokenStream(adaptor,"token CLOSE_BRACE");
        RewriteRuleTokenStream stream_OPEN_BRACE=new RewriteRuleTokenStream(adaptor,"token OPEN_BRACE");
        RewriteRuleTokenStream stream_IDENTIFIER=new RewriteRuleTokenStream(adaptor,"token IDENTIFIER");
        RewriteRuleSubtreeStream stream_interface_accessors=new RewriteRuleSubtreeStream(adaptor,"rule interface_accessors");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2765:3: ( IDENTIFIER OPEN_BRACE interface_accessors CLOSE_BRACE -> ^( PROPERTY_DECL MEMBER_NAME[$IDENTIFIER] interface_accessors ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2765:5: IDENTIFIER OPEN_BRACE interface_accessors CLOSE_BRACE
            {
            IDENTIFIER1558=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_interface_property_declaration213502); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_IDENTIFIER.add(IDENTIFIER1558);


            OPEN_BRACE1559=(Token)match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_interface_property_declaration213504); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_OPEN_BRACE.add(OPEN_BRACE1559);


            pushFollow(FOLLOW_interface_accessors_in_interface_property_declaration213506);
            interface_accessors1560=interface_accessors();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_interface_accessors.add(interface_accessors1560.getTree());

            CLOSE_BRACE1561=(Token)match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_interface_property_declaration213508); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_CLOSE_BRACE.add(CLOSE_BRACE1561);


            // AST REWRITE
            // elements: interface_accessors
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 2766:5: -> ^( PROPERTY_DECL MEMBER_NAME[$IDENTIFIER] interface_accessors )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2766:8: ^( PROPERTY_DECL MEMBER_NAME[$IDENTIFIER] interface_accessors )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(PROPERTY_DECL, "PROPERTY_DECL")
                , root_1);

                adaptor.addChild(root_1, 
                (Object)adaptor.create(MEMBER_NAME, IDENTIFIER1558)
                );

                adaptor.addChild(root_1, stream_interface_accessors.nextTree());

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "interface_property_declaration2"


    public static class interface_event_declaration2_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "interface_event_declaration2"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2768:1: interface_event_declaration2 : EVENT ^ type IDENTIFIER SEMICOLON !;
    public final CSharp4AST.interface_event_declaration2_return interface_event_declaration2() throws RecognitionException {
        CSharp4AST.interface_event_declaration2_return retval = new CSharp4AST.interface_event_declaration2_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token EVENT1562=null;
        Token IDENTIFIER1564=null;
        Token SEMICOLON1565=null;
        CSharp4AST.type_return type1563 =null;


        Object EVENT1562_tree=null;
        Object IDENTIFIER1564_tree=null;
        Object SEMICOLON1565_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2769:3: ( EVENT ^ type IDENTIFIER SEMICOLON !)
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2769:5: EVENT ^ type IDENTIFIER SEMICOLON !
            {
            root_0 = (Object)adaptor.nil();


            EVENT1562=(Token)match(input,EVENT,FOLLOW_EVENT_in_interface_event_declaration213536); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            EVENT1562_tree = 
            (Object)adaptor.create(EVENT1562)
            ;
            root_0 = (Object)adaptor.becomeRoot(EVENT1562_tree, root_0);
            }

            pushFollow(FOLLOW_type_in_interface_event_declaration213539);
            type1563=type();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, type1563.getTree());

            IDENTIFIER1564=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_interface_event_declaration213541); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1564_tree = 
            (Object)adaptor.create(IDENTIFIER1564)
            ;
            adaptor.addChild(root_0, IDENTIFIER1564_tree);
            }

            SEMICOLON1565=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_interface_event_declaration213543); if (state.failed) return retval;

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "interface_event_declaration2"


    public static class interface_indexer_declaration2_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "interface_indexer_declaration2"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2771:1: interface_indexer_declaration2 : THIS OPEN_BRACKET formal_parameter_list CLOSE_BRACKET OPEN_BRACE interface_accessors CLOSE_BRACE -> ^( INDEXER_DECL formal_parameter_list interface_accessors ) ;
    public final CSharp4AST.interface_indexer_declaration2_return interface_indexer_declaration2() throws RecognitionException {
        CSharp4AST.interface_indexer_declaration2_return retval = new CSharp4AST.interface_indexer_declaration2_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token THIS1566=null;
        Token OPEN_BRACKET1567=null;
        Token CLOSE_BRACKET1569=null;
        Token OPEN_BRACE1570=null;
        Token CLOSE_BRACE1572=null;
        CSharp4AST.formal_parameter_list_return formal_parameter_list1568 =null;

        CSharp4AST.interface_accessors_return interface_accessors1571 =null;


        Object THIS1566_tree=null;
        Object OPEN_BRACKET1567_tree=null;
        Object CLOSE_BRACKET1569_tree=null;
        Object OPEN_BRACE1570_tree=null;
        Object CLOSE_BRACE1572_tree=null;
        RewriteRuleTokenStream stream_OPEN_BRACKET=new RewriteRuleTokenStream(adaptor,"token OPEN_BRACKET");
        RewriteRuleTokenStream stream_CLOSE_BRACE=new RewriteRuleTokenStream(adaptor,"token CLOSE_BRACE");
        RewriteRuleTokenStream stream_OPEN_BRACE=new RewriteRuleTokenStream(adaptor,"token OPEN_BRACE");
        RewriteRuleTokenStream stream_THIS=new RewriteRuleTokenStream(adaptor,"token THIS");
        RewriteRuleTokenStream stream_CLOSE_BRACKET=new RewriteRuleTokenStream(adaptor,"token CLOSE_BRACKET");
        RewriteRuleSubtreeStream stream_formal_parameter_list=new RewriteRuleSubtreeStream(adaptor,"rule formal_parameter_list");
        RewriteRuleSubtreeStream stream_interface_accessors=new RewriteRuleSubtreeStream(adaptor,"rule interface_accessors");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2772:3: ( THIS OPEN_BRACKET formal_parameter_list CLOSE_BRACKET OPEN_BRACE interface_accessors CLOSE_BRACE -> ^( INDEXER_DECL formal_parameter_list interface_accessors ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2772:5: THIS OPEN_BRACKET formal_parameter_list CLOSE_BRACKET OPEN_BRACE interface_accessors CLOSE_BRACE
            {
            THIS1566=(Token)match(input,THIS,FOLLOW_THIS_in_interface_indexer_declaration213556); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_THIS.add(THIS1566);


            OPEN_BRACKET1567=(Token)match(input,OPEN_BRACKET,FOLLOW_OPEN_BRACKET_in_interface_indexer_declaration213558); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_OPEN_BRACKET.add(OPEN_BRACKET1567);


            pushFollow(FOLLOW_formal_parameter_list_in_interface_indexer_declaration213560);
            formal_parameter_list1568=formal_parameter_list();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_formal_parameter_list.add(formal_parameter_list1568.getTree());

            CLOSE_BRACKET1569=(Token)match(input,CLOSE_BRACKET,FOLLOW_CLOSE_BRACKET_in_interface_indexer_declaration213562); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_CLOSE_BRACKET.add(CLOSE_BRACKET1569);


            OPEN_BRACE1570=(Token)match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_interface_indexer_declaration213564); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_OPEN_BRACE.add(OPEN_BRACE1570);


            pushFollow(FOLLOW_interface_accessors_in_interface_indexer_declaration213566);
            interface_accessors1571=interface_accessors();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) stream_interface_accessors.add(interface_accessors1571.getTree());

            CLOSE_BRACE1572=(Token)match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_interface_indexer_declaration213568); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_CLOSE_BRACE.add(CLOSE_BRACE1572);


            // AST REWRITE
            // elements: formal_parameter_list, interface_accessors
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 2773:5: -> ^( INDEXER_DECL formal_parameter_list interface_accessors )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2773:8: ^( INDEXER_DECL formal_parameter_list interface_accessors )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(INDEXER_DECL, "INDEXER_DECL")
                , root_1);

                adaptor.addChild(root_1, stream_formal_parameter_list.nextTree());

                adaptor.addChild(root_1, stream_interface_accessors.nextTree());

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "interface_indexer_declaration2"


    public static class member_access2_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "member_access2"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2776:1: member_access2 : DOT ! IDENTIFIER type_argument_list_opt ;
    public final CSharp4AST.member_access2_return member_access2() throws RecognitionException {
        CSharp4AST.member_access2_return retval = new CSharp4AST.member_access2_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token DOT1573=null;
        Token IDENTIFIER1574=null;
        CSharp4AST.type_argument_list_opt_return type_argument_list_opt1575 =null;


        Object DOT1573_tree=null;
        Object IDENTIFIER1574_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2777:3: ( DOT ! IDENTIFIER type_argument_list_opt )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2777:5: DOT ! IDENTIFIER type_argument_list_opt
            {
            root_0 = (Object)adaptor.nil();


            DOT1573=(Token)match(input,DOT,FOLLOW_DOT_in_member_access213596); if (state.failed) return retval;

            IDENTIFIER1574=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_member_access213599); if (state.failed) return retval;
            if ( state.backtracking==0 ) {
            IDENTIFIER1574_tree = 
            (Object)adaptor.create(IDENTIFIER1574)
            ;
            adaptor.addChild(root_0, IDENTIFIER1574_tree);
            }

            pushFollow(FOLLOW_type_argument_list_opt_in_member_access213601);
            type_argument_list_opt1575=type_argument_list_opt();

            state._fsp--;
            if (state.failed) return retval;
            if ( state.backtracking==0 ) adaptor.addChild(root_0, type_argument_list_opt1575.getTree());

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "member_access2"


    public static class method_invocation2_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "method_invocation2"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2779:1: method_invocation2 : OPEN_PARENS ! ( argument_list )? CLOSE_PARENS !;
    public final CSharp4AST.method_invocation2_return method_invocation2() throws RecognitionException {
        CSharp4AST.method_invocation2_return retval = new CSharp4AST.method_invocation2_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token OPEN_PARENS1576=null;
        Token CLOSE_PARENS1578=null;
        CSharp4AST.argument_list_return argument_list1577 =null;


        Object OPEN_PARENS1576_tree=null;
        Object CLOSE_PARENS1578_tree=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2780:3: ( OPEN_PARENS ! ( argument_list )? CLOSE_PARENS !)
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2780:5: OPEN_PARENS ! ( argument_list )? CLOSE_PARENS !
            {
            root_0 = (Object)adaptor.nil();


            OPEN_PARENS1576=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_method_invocation213613); if (state.failed) return retval;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2780:18: ( argument_list )?
            int alt376=2;
            int LA376_0 = input.LA(1);

            if ( (LA376_0==AMP||(LA376_0 >= BANG && LA376_0 <= BASE)||LA376_0==BOOL||LA376_0==BYTE||(LA376_0 >= CHAR && LA376_0 <= CHECKED)||LA376_0==DECIMAL||(LA376_0 >= DEFAULT && LA376_0 <= DELEGATE)||LA376_0==DOUBLE||LA376_0==FALSE||LA376_0==FLOAT||LA376_0==IDENTIFIER||(LA376_0 >= INT && LA376_0 <= INTEGER_LITERAL)||LA376_0==LONG||LA376_0==MINUS||LA376_0==NEW||LA376_0==NULL||LA376_0==OBJECT||LA376_0==OPEN_PARENS||LA376_0==OP_DEC||LA376_0==OP_INC||LA376_0==OUT||LA376_0==PLUS||(LA376_0 >= REAL_LITERAL && LA376_0 <= REF)||LA376_0==SBYTE||LA376_0==SHORT||LA376_0==SIZEOF||LA376_0==STAR||(LA376_0 >= STRING && LA376_0 <= STRING_LITERAL)||LA376_0==THIS||(LA376_0 >= TILDE && LA376_0 <= TRUE)||LA376_0==TYPEOF||(LA376_0 >= UINT && LA376_0 <= UNCHECKED)||LA376_0==USHORT) ) {
                alt376=1;
            }
            switch (alt376) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2780:18: argument_list
                    {
                    pushFollow(FOLLOW_argument_list_in_method_invocation213616);
                    argument_list1577=argument_list();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) adaptor.addChild(root_0, argument_list1577.getTree());

                    }
                    break;

            }


            CLOSE_PARENS1578=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_method_invocation213619); if (state.failed) return retval;

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "method_invocation2"


    public static class object_creation_expression2_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "object_creation_expression2"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2782:1: object_creation_expression2 : OPEN_PARENS ( argument_list )? CLOSE_PARENS ( object_or_collection_initializer )? -> ^( OBJECT_CREATION_EXPRESSION ( argument_list )? ( object_or_collection_initializer )? ) ;
    public final CSharp4AST.object_creation_expression2_return object_creation_expression2() throws RecognitionException {
        CSharp4AST.object_creation_expression2_return retval = new CSharp4AST.object_creation_expression2_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token OPEN_PARENS1579=null;
        Token CLOSE_PARENS1581=null;
        CSharp4AST.argument_list_return argument_list1580 =null;

        CSharp4AST.object_or_collection_initializer_return object_or_collection_initializer1582 =null;


        Object OPEN_PARENS1579_tree=null;
        Object CLOSE_PARENS1581_tree=null;
        RewriteRuleTokenStream stream_OPEN_PARENS=new RewriteRuleTokenStream(adaptor,"token OPEN_PARENS");
        RewriteRuleTokenStream stream_CLOSE_PARENS=new RewriteRuleTokenStream(adaptor,"token CLOSE_PARENS");
        RewriteRuleSubtreeStream stream_argument_list=new RewriteRuleSubtreeStream(adaptor,"rule argument_list");
        RewriteRuleSubtreeStream stream_object_or_collection_initializer=new RewriteRuleSubtreeStream(adaptor,"rule object_or_collection_initializer");
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2783:3: ( OPEN_PARENS ( argument_list )? CLOSE_PARENS ( object_or_collection_initializer )? -> ^( OBJECT_CREATION_EXPRESSION ( argument_list )? ( object_or_collection_initializer )? ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2783:5: OPEN_PARENS ( argument_list )? CLOSE_PARENS ( object_or_collection_initializer )?
            {
            OPEN_PARENS1579=(Token)match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_object_creation_expression213632); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_OPEN_PARENS.add(OPEN_PARENS1579);


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2783:17: ( argument_list )?
            int alt377=2;
            int LA377_0 = input.LA(1);

            if ( (LA377_0==AMP||(LA377_0 >= BANG && LA377_0 <= BASE)||LA377_0==BOOL||LA377_0==BYTE||(LA377_0 >= CHAR && LA377_0 <= CHECKED)||LA377_0==DECIMAL||(LA377_0 >= DEFAULT && LA377_0 <= DELEGATE)||LA377_0==DOUBLE||LA377_0==FALSE||LA377_0==FLOAT||LA377_0==IDENTIFIER||(LA377_0 >= INT && LA377_0 <= INTEGER_LITERAL)||LA377_0==LONG||LA377_0==MINUS||LA377_0==NEW||LA377_0==NULL||LA377_0==OBJECT||LA377_0==OPEN_PARENS||LA377_0==OP_DEC||LA377_0==OP_INC||LA377_0==OUT||LA377_0==PLUS||(LA377_0 >= REAL_LITERAL && LA377_0 <= REF)||LA377_0==SBYTE||LA377_0==SHORT||LA377_0==SIZEOF||LA377_0==STAR||(LA377_0 >= STRING && LA377_0 <= STRING_LITERAL)||LA377_0==THIS||(LA377_0 >= TILDE && LA377_0 <= TRUE)||LA377_0==TYPEOF||(LA377_0 >= UINT && LA377_0 <= UNCHECKED)||LA377_0==USHORT) ) {
                alt377=1;
            }
            switch (alt377) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2783:17: argument_list
                    {
                    pushFollow(FOLLOW_argument_list_in_object_creation_expression213634);
                    argument_list1580=argument_list();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) stream_argument_list.add(argument_list1580.getTree());

                    }
                    break;

            }


            CLOSE_PARENS1581=(Token)match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_object_creation_expression213637); if (state.failed) return retval; 
            if ( state.backtracking==0 ) stream_CLOSE_PARENS.add(CLOSE_PARENS1581);


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2783:45: ( object_or_collection_initializer )?
            int alt378=2;
            int LA378_0 = input.LA(1);

            if ( (LA378_0==OPEN_BRACE) ) {
                alt378=1;
            }
            switch (alt378) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2783:45: object_or_collection_initializer
                    {
                    pushFollow(FOLLOW_object_or_collection_initializer_in_object_creation_expression213639);
                    object_or_collection_initializer1582=object_or_collection_initializer();

                    state._fsp--;
                    if (state.failed) return retval;
                    if ( state.backtracking==0 ) stream_object_or_collection_initializer.add(object_or_collection_initializer1582.getTree());

                    }
                    break;

            }


            // AST REWRITE
            // elements: object_or_collection_initializer, argument_list
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( state.backtracking==0 ) {

            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 2784:5: -> ^( OBJECT_CREATION_EXPRESSION ( argument_list )? ( object_or_collection_initializer )? )
            {
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2784:8: ^( OBJECT_CREATION_EXPRESSION ( argument_list )? ( object_or_collection_initializer )? )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(OBJECT_CREATION_EXPRESSION, "OBJECT_CREATION_EXPRESSION")
                , root_1);

                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2784:38: ( argument_list )?
                if ( stream_argument_list.hasNext() ) {
                    adaptor.addChild(root_1, stream_argument_list.nextTree());

                }
                stream_argument_list.reset();

                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2784:53: ( object_or_collection_initializer )?
                if ( stream_object_or_collection_initializer.hasNext() ) {
                    adaptor.addChild(root_1, stream_object_or_collection_initializer.nextTree());

                }
                stream_object_or_collection_initializer.reset();

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;
            }

            }

            retval.stop = input.LT(-1);


            if ( state.backtracking==0 ) {

            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "object_creation_expression2"

    // $ANTLR start synpred1_CSharp4AST
    public final void synpred1_CSharp4AST_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:204:5: ( type_argument_list )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:204:6: type_argument_list
        {
        pushFollow(FOLLOW_type_argument_list_in_synpred1_CSharp4AST691);
        type_argument_list();

        state._fsp--;
        if (state.failed) return ;

        }

    }
    // $ANTLR end synpred1_CSharp4AST

    // $ANTLR start synpred2_CSharp4AST
    public final void synpred2_CSharp4AST_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:223:7: ( INTERR )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:223:8: INTERR
        {
        match(input,INTERR,FOLLOW_INTERR_in_synpred2_CSharp4AST754); if (state.failed) return ;

        }

    }
    // $ANTLR end synpred2_CSharp4AST

    // $ANTLR start synpred3_CSharp4AST
    public final void synpred3_CSharp4AST_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:224:7: ( rank_specifier )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:224:8: rank_specifier
        {
        pushFollow(FOLLOW_rank_specifier_in_synpred3_CSharp4AST788);
        rank_specifier();

        state._fsp--;
        if (state.failed) return ;

        }

    }
    // $ANTLR end synpred3_CSharp4AST

    // $ANTLR start synpred4_CSharp4AST
    public final void synpred4_CSharp4AST_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:281:7: ( rank_specifier )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:281:8: rank_specifier
        {
        pushFollow(FOLLOW_rank_specifier_in_synpred4_CSharp4AST1019);
        rank_specifier();

        state._fsp--;
        if (state.failed) return ;

        }

    }
    // $ANTLR end synpred4_CSharp4AST

    // $ANTLR start synpred5_CSharp4AST
    public final void synpred5_CSharp4AST_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:616:11: ( array_type OPEN_BRACKET )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:616:12: array_type OPEN_BRACKET
        {
        pushFollow(FOLLOW_array_type_in_synpred5_CSharp4AST2271);
        array_type();

        state._fsp--;
        if (state.failed) return ;

        match(input,OPEN_BRACKET,FOLLOW_OPEN_BRACKET_in_synpred5_CSharp4AST2273); if (state.failed) return ;

        }

    }
    // $ANTLR end synpred5_CSharp4AST

    // $ANTLR start synpred6_CSharp4AST
    public final void synpred6_CSharp4AST_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:657:6: ( unbound_type_name )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:657:7: unbound_type_name
        {
        pushFollow(FOLLOW_unbound_type_name_in_synpred6_CSharp4AST2462);
        unbound_type_name();

        state._fsp--;
        if (state.failed) return ;

        }

    }
    // $ANTLR end synpred6_CSharp4AST

    // $ANTLR start synpred7_CSharp4AST
    public final void synpred7_CSharp4AST_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:707:4: ( scan_for_cast_generic_precedence | OPEN_PARENS predefined_type )
        int alt379=2;
        int LA379_0 = input.LA(1);

        if ( (LA379_0==OPEN_PARENS) ) {
            switch ( input.LA(2) ) {
            case BYTE:
            case CHAR:
            case INT:
            case LONG:
            case SBYTE:
            case SHORT:
            case UINT:
            case ULONG:
            case USHORT:
                {
                int LA379_2 = input.LA(3);

                if ( (LA379_2==CLOSE_PARENS||LA379_2==INTERR||LA379_2==OPEN_BRACKET||LA379_2==STAR) ) {
                    alt379=1;
                }
                else if ( (LA379_2==EOF) ) {
                    alt379=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 379, 2, input);

                    throw nvae;

                }
                }
                break;
            case DOUBLE:
            case FLOAT:
                {
                int LA379_3 = input.LA(3);

                if ( (LA379_3==CLOSE_PARENS||LA379_3==INTERR||LA379_3==OPEN_BRACKET||LA379_3==STAR) ) {
                    alt379=1;
                }
                else if ( (LA379_3==EOF) ) {
                    alt379=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 379, 3, input);

                    throw nvae;

                }
                }
                break;
            case DECIMAL:
                {
                int LA379_4 = input.LA(3);

                if ( (LA379_4==CLOSE_PARENS||LA379_4==INTERR||LA379_4==OPEN_BRACKET||LA379_4==STAR) ) {
                    alt379=1;
                }
                else if ( (LA379_4==EOF) ) {
                    alt379=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 379, 4, input);

                    throw nvae;

                }
                }
                break;
            case BOOL:
                {
                int LA379_5 = input.LA(3);

                if ( (LA379_5==CLOSE_PARENS||LA379_5==INTERR||LA379_5==OPEN_BRACKET||LA379_5==STAR) ) {
                    alt379=1;
                }
                else if ( (LA379_5==EOF) ) {
                    alt379=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 379, 5, input);

                    throw nvae;

                }
                }
                break;
            case IDENTIFIER:
            case VOID:
                {
                alt379=1;
                }
                break;
            case OBJECT:
                {
                int LA379_7 = input.LA(3);

                if ( (LA379_7==CLOSE_PARENS||LA379_7==INTERR||LA379_7==OPEN_BRACKET||LA379_7==STAR) ) {
                    alt379=1;
                }
                else if ( (LA379_7==EOF) ) {
                    alt379=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 379, 7, input);

                    throw nvae;

                }
                }
                break;
            case STRING:
                {
                int LA379_8 = input.LA(3);

                if ( (LA379_8==CLOSE_PARENS||LA379_8==INTERR||LA379_8==OPEN_BRACKET||LA379_8==STAR) ) {
                    alt379=1;
                }
                else if ( (LA379_8==EOF) ) {
                    alt379=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 379, 8, input);

                    throw nvae;

                }
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 379, 1, input);

                throw nvae;

            }

        }
        else {
            if (state.backtracking>0) {state.failed=true; return ;}
            NoViableAltException nvae =
                new NoViableAltException("", 379, 0, input);

            throw nvae;

        }
        switch (alt379) {
            case 1 :
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:707:5: scan_for_cast_generic_precedence
                {
                pushFollow(FOLLOW_scan_for_cast_generic_precedence_in_synpred7_CSharp4AST2695);
                scan_for_cast_generic_precedence();

                state._fsp--;
                if (state.failed) return ;

                }
                break;
            case 2 :
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:707:40: OPEN_PARENS predefined_type
                {
                match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_synpred7_CSharp4AST2699); if (state.failed) return ;

                pushFollow(FOLLOW_predefined_type_in_synpred7_CSharp4AST2701);
                predefined_type();

                state._fsp--;
                if (state.failed) return ;

                }
                break;

        }
    }
    // $ANTLR end synpred7_CSharp4AST

    // $ANTLR start synpred8_CSharp4AST
    public final void synpred8_CSharp4AST_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:778:31: ( INTERR is_disambiguation_token )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:778:32: INTERR is_disambiguation_token
        {
        match(input,INTERR,FOLLOW_INTERR_in_synpred8_CSharp4AST3659); if (state.failed) return ;

        pushFollow(FOLLOW_is_disambiguation_token_in_synpred8_CSharp4AST3661);
        is_disambiguation_token();

        state._fsp--;
        if (state.failed) return ;

        }

    }
    // $ANTLR end synpred8_CSharp4AST

    // $ANTLR start synpred9_CSharp4AST
    public final void synpred9_CSharp4AST_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:889:29: ( type IDENTIFIER IN )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:889:30: type IDENTIFIER IN
        {
        pushFollow(FOLLOW_type_in_synpred9_CSharp4AST4372);
        type();

        state._fsp--;
        if (state.failed) return ;

        match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_synpred9_CSharp4AST4374); if (state.failed) return ;

        match(input,IN,FOLLOW_IN_in_synpred9_CSharp4AST4376); if (state.failed) return ;

        }

    }
    // $ANTLR end synpred9_CSharp4AST

    // $ANTLR start synpred10_CSharp4AST
    public final void synpred10_CSharp4AST_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:897:49: ( into_contextual_keyword )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:897:50: into_contextual_keyword
        {
        pushFollow(FOLLOW_into_contextual_keyword_in_synpred10_CSharp4AST4410);
        into_contextual_keyword();

        state._fsp--;
        if (state.failed) return ;

        }

    }
    // $ANTLR end synpred10_CSharp4AST

    // $ANTLR start synpred11_CSharp4AST
    public final void synpred11_CSharp4AST_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:983:4: ( assignment )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:983:5: assignment
        {
        pushFollow(FOLLOW_assignment_in_synpred11_CSharp4AST4840);
        assignment();

        state._fsp--;
        if (state.failed) return ;

        }

    }
    // $ANTLR end synpred11_CSharp4AST

    // $ANTLR start synpred12_CSharp4AST
    public final void synpred12_CSharp4AST_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:987:4: ( lambda_expression )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:987:5: lambda_expression
        {
        pushFollow(FOLLOW_lambda_expression_in_synpred12_CSharp4AST4865);
        lambda_expression();

        state._fsp--;
        if (state.failed) return ;

        }

    }
    // $ANTLR end synpred12_CSharp4AST

    // $ANTLR start synpred13_CSharp4AST
    public final void synpred13_CSharp4AST_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:988:4: ( query_expression )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:988:5: query_expression
        {
        pushFollow(FOLLOW_query_expression_in_synpred13_CSharp4AST4876);
        query_expression();

        state._fsp--;
        if (state.failed) return ;

        }

    }
    // $ANTLR end synpred13_CSharp4AST

    // $ANTLR start synpred14_CSharp4AST
    public final void synpred14_CSharp4AST_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1000:4: ( labeled_statement )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1000:5: labeled_statement
        {
        pushFollow(FOLLOW_labeled_statement_in_synpred14_CSharp4AST4924);
        labeled_statement();

        state._fsp--;
        if (state.failed) return ;

        }

    }
    // $ANTLR end synpred14_CSharp4AST

    // $ANTLR start synpred15_CSharp4AST
    public final void synpred15_CSharp4AST_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1001:4: ( declaration_statement )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1001:5: declaration_statement
        {
        pushFollow(FOLLOW_declaration_statement_in_synpred15_CSharp4AST4935);
        declaration_statement();

        state._fsp--;
        if (state.failed) return ;

        }

    }
    // $ANTLR end synpred15_CSharp4AST

    // $ANTLR start synpred16_CSharp4AST
    public final void synpred16_CSharp4AST_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1112:9: ( ELSE )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1112:10: ELSE
        {
        match(input,ELSE,FOLLOW_ELSE_in_synpred16_CSharp4AST5375); if (state.failed) return ;

        }

    }
    // $ANTLR end synpred16_CSharp4AST

    // $ANTLR start synpred17_CSharp4AST
    public final void synpred17_CSharp4AST_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1155:4: ( local_variable_declaration )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1155:5: local_variable_declaration
        {
        pushFollow(FOLLOW_local_variable_declaration_in_synpred17_CSharp4AST5734);
        local_variable_declaration();

        state._fsp--;
        if (state.failed) return ;

        }

    }
    // $ANTLR end synpred17_CSharp4AST

    // $ANTLR start synpred18_CSharp4AST
    public final void synpred18_CSharp4AST_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1246:4: ( local_variable_declaration )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1246:5: local_variable_declaration
        {
        pushFollow(FOLLOW_local_variable_declaration_in_synpred18_CSharp4AST6169);
        local_variable_declaration();

        state._fsp--;
        if (state.failed) return ;

        }

    }
    // $ANTLR end synpred18_CSharp4AST

    // $ANTLR start synpred19_CSharp4AST
    public final void synpred19_CSharp4AST_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1272:7: ( global_attribute_section )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1272:8: global_attribute_section
        {
        pushFollow(FOLLOW_global_attribute_section_in_synpred19_CSharp4AST6275);
        global_attribute_section();

        state._fsp--;
        if (state.failed) return ;

        }

    }
    // $ANTLR end synpred19_CSharp4AST

    // $ANTLR start synpred20_CSharp4AST
    public final void synpred20_CSharp4AST_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1521:7: ( interface_type DOT THIS )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1521:8: interface_type DOT THIS
        {
        pushFollow(FOLLOW_interface_type_in_synpred20_CSharp4AST7434);
        interface_type();

        state._fsp--;
        if (state.failed) return ;

        match(input,DOT,FOLLOW_DOT_in_synpred20_CSharp4AST7436); if (state.failed) return ;

        match(input,THIS,FOLLOW_THIS_in_synpred20_CSharp4AST7438); if (state.failed) return ;

        }

    }
    // $ANTLR end synpred20_CSharp4AST

    // $ANTLR start synpred21_CSharp4AST
    public final void synpred21_CSharp4AST_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1522:7: ( member_name ( type_parameter_list )? OPEN_PARENS )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1522:8: member_name ( type_parameter_list )? OPEN_PARENS
        {
        pushFollow(FOLLOW_member_name_in_synpred21_CSharp4AST7458);
        member_name();

        state._fsp--;
        if (state.failed) return ;

        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1522:20: ( type_parameter_list )?
        int alt380=2;
        int LA380_0 = input.LA(1);

        if ( (LA380_0==LT) ) {
            alt380=1;
        }
        switch (alt380) {
            case 1 :
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1522:20: type_parameter_list
                {
                pushFollow(FOLLOW_type_parameter_list_in_synpred21_CSharp4AST7460);
                type_parameter_list();

                state._fsp--;
                if (state.failed) return ;

                }
                break;

        }


        match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_synpred21_CSharp4AST7463); if (state.failed) return ;

        }

    }
    // $ANTLR end synpred21_CSharp4AST

    // $ANTLR start synpred22_CSharp4AST
    public final void synpred22_CSharp4AST_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1523:7: ( member_name OPEN_BRACE )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1523:8: member_name OPEN_BRACE
        {
        pushFollow(FOLLOW_member_name_in_synpred22_CSharp4AST7478);
        member_name();

        state._fsp--;
        if (state.failed) return ;

        match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_synpred22_CSharp4AST7480); if (state.failed) return ;

        }

    }
    // $ANTLR end synpred22_CSharp4AST

    // $ANTLR start synpred23_CSharp4AST
    public final void synpred23_CSharp4AST_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1639:5: ( ( attributes )? PARAMS )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1639:6: ( attributes )? PARAMS
        {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1639:6: ( attributes )?
        int alt381=2;
        int LA381_0 = input.LA(1);

        if ( (LA381_0==OPEN_BRACKET) ) {
            alt381=1;
        }
        switch (alt381) {
            case 1 :
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1639:6: attributes
                {
                pushFollow(FOLLOW_attributes_in_synpred23_CSharp4AST7907);
                attributes();

                state._fsp--;
                if (state.failed) return ;

                }
                break;

        }


        match(input,PARAMS,FOLLOW_PARAMS_in_synpred23_CSharp4AST7910); if (state.failed) return ;

        }

    }
    // $ANTLR end synpred23_CSharp4AST

    // $ANTLR start synpred24_CSharp4AST
    public final void synpred24_CSharp4AST_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1641:24: ( COMMA parameter_array )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1641:25: COMMA parameter_array
        {
        match(input,COMMA,FOLLOW_COMMA_in_synpred24_CSharp4AST7939); if (state.failed) return ;

        pushFollow(FOLLOW_parameter_array_in_synpred24_CSharp4AST7941);
        parameter_array();

        state._fsp--;
        if (state.failed) return ;

        }

    }
    // $ANTLR end synpred24_CSharp4AST

    // $ANTLR start synpred25_CSharp4AST
    public final void synpred25_CSharp4AST_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1645:23: ( COMMA fixed_parameter )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1645:24: COMMA fixed_parameter
        {
        match(input,COMMA,FOLLOW_COMMA_in_synpred25_CSharp4AST7985); if (state.failed) return ;

        pushFollow(FOLLOW_fixed_parameter_in_synpred25_CSharp4AST7987);
        fixed_parameter();

        state._fsp--;
        if (state.failed) return ;

        }

    }
    // $ANTLR end synpred25_CSharp4AST

    // $ANTLR start synpred26_CSharp4AST
    public final void synpred26_CSharp4AST_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1815:5: ( unary_operator_declarator )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:1815:6: unary_operator_declarator
        {
        pushFollow(FOLLOW_unary_operator_declarator_in_synpred26_CSharp4AST8769);
        unary_operator_declarator();

        state._fsp--;
        if (state.failed) return ;

        }

    }
    // $ANTLR end synpred26_CSharp4AST

    // $ANTLR start synpred27_CSharp4AST
    public final void synpred27_CSharp4AST_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2473:5: ( AMP )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4AST.g:2473:6: AMP
        {
        match(input,AMP,FOLLOW_AMP_in_synpred27_CSharp4AST11654); if (state.failed) return ;

        }

    }
    // $ANTLR end synpred27_CSharp4AST

    // Delegated rules

    public final boolean synpred27_CSharp4AST() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred27_CSharp4AST_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred1_CSharp4AST() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred1_CSharp4AST_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred15_CSharp4AST() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred15_CSharp4AST_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred16_CSharp4AST() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred16_CSharp4AST_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred24_CSharp4AST() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred24_CSharp4AST_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred26_CSharp4AST() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred26_CSharp4AST_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred20_CSharp4AST() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred20_CSharp4AST_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred8_CSharp4AST() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred8_CSharp4AST_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred13_CSharp4AST() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred13_CSharp4AST_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred10_CSharp4AST() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred10_CSharp4AST_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred23_CSharp4AST() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred23_CSharp4AST_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred19_CSharp4AST() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred19_CSharp4AST_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred3_CSharp4AST() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred3_CSharp4AST_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred21_CSharp4AST() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred21_CSharp4AST_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred9_CSharp4AST() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred9_CSharp4AST_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred7_CSharp4AST() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred7_CSharp4AST_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred25_CSharp4AST() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred25_CSharp4AST_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred14_CSharp4AST() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred14_CSharp4AST_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred12_CSharp4AST() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred12_CSharp4AST_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred5_CSharp4AST() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred5_CSharp4AST_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred2_CSharp4AST() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred2_CSharp4AST_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred11_CSharp4AST() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred11_CSharp4AST_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred4_CSharp4AST() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred4_CSharp4AST_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred18_CSharp4AST() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred18_CSharp4AST_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred6_CSharp4AST() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred6_CSharp4AST_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred17_CSharp4AST() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred17_CSharp4AST_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred22_CSharp4AST() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred22_CSharp4AST_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }


    protected DFA11 dfa11 = new DFA11(this);
    protected DFA47 dfa47 = new DFA47(this);
    protected DFA56 dfa56 = new DFA56(this);
    protected DFA371 dfa371 = new DFA371(this);
    static final String DFA11_eotS =
        "\7\uffff";
    static final String DFA11_eofS =
        "\4\uffff\1\5\2\uffff";
    static final String DFA11_minS =
        "\2\122\2\31\1\122\2\uffff";
    static final String DFA11_maxS =
        "\2\u00b1\2\34\1\u00b1\2\uffff";
    static final String DFA11_acceptS =
        "\5\uffff\1\2\1\1";
    static final String DFA11_specialS =
        "\7\uffff}>";
    static final String[] DFA11_transitionS = {
            "\1\1\27\uffff\1\2\106\uffff\1\1",
            "\1\1\27\uffff\1\2\106\uffff\1\1",
            "\1\4\2\uffff\1\3",
            "\1\4\2\uffff\1\3",
            "\1\6\27\uffff\1\6\106\uffff\1\6",
            "",
            ""
    };

    static final short[] DFA11_eot = DFA.unpackEncodedString(DFA11_eotS);
    static final short[] DFA11_eof = DFA.unpackEncodedString(DFA11_eofS);
    static final char[] DFA11_min = DFA.unpackEncodedStringToUnsignedChars(DFA11_minS);
    static final char[] DFA11_max = DFA.unpackEncodedStringToUnsignedChars(DFA11_maxS);
    static final short[] DFA11_accept = DFA.unpackEncodedString(DFA11_acceptS);
    static final short[] DFA11_special = DFA.unpackEncodedString(DFA11_specialS);
    static final short[][] DFA11_transition;

    static {
        int numStates = DFA11_transitionS.length;
        DFA11_transition = new short[numStates][];
        for (int i=0; i<numStates; i++) {
            DFA11_transition[i] = DFA.unpackEncodedString(DFA11_transitionS[i]);
        }
    }

    class DFA11 extends DFA {

        public DFA11(BaseRecognizer recognizer) {
            this.recognizer = recognizer;
            this.decisionNumber = 11;
            this.eot = DFA11_eot;
            this.eof = DFA11_eof;
            this.min = DFA11_min;
            this.max = DFA11_max;
            this.accept = DFA11_accept;
            this.special = DFA11_special;
            this.transition = DFA11_transition;
        }
        public String getDescription() {
            return "()* loopback of 303:5: ( ( STAR | INTERR )* rank_specifier )*";
        }
    }
    static final String DFA47_eotS =
        "\25\uffff";
    static final String DFA47_eofS =
        "\25\uffff";
    static final String DFA47_minS =
        "\1\16\1\32\1\uffff\1\32\1\112\1\16\1\112\1\0\1\uffff\1\32\2\uffff"+
        "\1\32\1\16\1\0\1\16\1\0\4\uffff";
    static final String DFA47_maxS =
        "\1\u00d9\1\u00b1\1\uffff\1\u00b1\1\112\1\u00d9\1\112\1\0\1\uffff"+
        "\1\u00b1\2\uffff\1\u00b1\1\u00d9\1\0\1\u00d9\1\0\4\uffff";
    static final String DFA47_acceptS =
        "\2\uffff\1\2\5\uffff\1\3\1\uffff\2\1\5\uffff\4\1";
    static final String DFA47_specialS =
        "\5\uffff\1\5\1\uffff\1\0\5\uffff\1\4\1\2\1\3\1\1\4\uffff}>";
    static final String[] DFA47_transitionS = {
            "\1\2\1\uffff\1\2\3\uffff\1\2\16\uffff\1\2\10\uffff\1\2\20\uffff"+
            "\1\2\14\uffff\1\1\3\uffff\1\2\14\uffff\1\2\14\uffff\1\2\77\uffff"+
            "\1\2\3\uffff\1\2\6\uffff\1\2\21\uffff\2\2\16\uffff\1\2\3\uffff"+
            "\1\3",
            "\1\7\20\uffff\1\6\2\uffff\1\4\43\uffff\1\2\11\uffff\1\5\15"+
            "\uffff\1\2\106\uffff\1\2",
            "",
            "\1\10\u0096\uffff\1\2",
            "\1\11",
            "\1\2\1\uffff\1\2\3\uffff\1\2\7\uffff\1\12\6\uffff\1\2\10\uffff"+
            "\1\2\20\uffff\1\2\7\uffff\1\13\4\uffff\1\2\3\uffff\1\2\14\uffff"+
            "\1\2\14\uffff\1\2\77\uffff\1\2\3\uffff\1\2\6\uffff\1\2\21\uffff"+
            "\2\2\16\uffff\1\2\3\uffff\1\2",
            "\1\14",
            "\1\uffff",
            "",
            "\1\16\20\uffff\1\6\46\uffff\1\2\11\uffff\1\15\15\uffff\1\2"+
            "\106\uffff\1\2",
            "",
            "",
            "\1\20\20\uffff\1\6\46\uffff\1\2\11\uffff\1\17\15\uffff\1\2"+
            "\106\uffff\1\2",
            "\1\2\1\uffff\1\2\3\uffff\1\2\7\uffff\1\21\6\uffff\1\2\10\uffff"+
            "\1\2\20\uffff\1\2\7\uffff\1\22\4\uffff\1\2\3\uffff\1\2\14\uffff"+
            "\1\2\14\uffff\1\2\77\uffff\1\2\3\uffff\1\2\6\uffff\1\2\21\uffff"+
            "\2\2\16\uffff\1\2\3\uffff\1\2",
            "\1\uffff",
            "\1\2\1\uffff\1\2\3\uffff\1\2\7\uffff\1\23\6\uffff\1\2\10\uffff"+
            "\1\2\20\uffff\1\2\7\uffff\1\24\4\uffff\1\2\3\uffff\1\2\14\uffff"+
            "\1\2\14\uffff\1\2\77\uffff\1\2\3\uffff\1\2\6\uffff\1\2\21\uffff"+
            "\2\2\16\uffff\1\2\3\uffff\1\2",
            "\1\uffff",
            "",
            "",
            "",
            ""
    };

    static final short[] DFA47_eot = DFA.unpackEncodedString(DFA47_eotS);
    static final short[] DFA47_eof = DFA.unpackEncodedString(DFA47_eofS);
    static final char[] DFA47_min = DFA.unpackEncodedStringToUnsignedChars(DFA47_minS);
    static final char[] DFA47_max = DFA.unpackEncodedStringToUnsignedChars(DFA47_maxS);
    static final short[] DFA47_accept = DFA.unpackEncodedString(DFA47_acceptS);
    static final short[] DFA47_special = DFA.unpackEncodedString(DFA47_specialS);
    static final short[][] DFA47_transition;

    static {
        int numStates = DFA47_transitionS.length;
        DFA47_transition = new short[numStates][];
        for (int i=0; i<numStates; i++) {
            DFA47_transition[i] = DFA.unpackEncodedString(DFA47_transitionS[i]);
        }
    }

    class DFA47 extends DFA {

        public DFA47(BaseRecognizer recognizer) {
            this.recognizer = recognizer;
            this.decisionNumber = 47;
            this.eot = DFA47_eot;
            this.eof = DFA47_eof;
            this.min = DFA47_min;
            this.max = DFA47_max;
            this.accept = DFA47_accept;
            this.special = DFA47_special;
            this.transition = DFA47_transition;
        }
        public String getDescription() {
            return "657:4: ( ( unbound_type_name )=> unbound_type_name CLOSE_PARENS | type CLOSE_PARENS | VOID CLOSE_PARENS )";
        }
        public int specialStateTransition(int s, IntStream _input) throws NoViableAltException {
            TokenStream input = (TokenStream)_input;
        	int _s = s;
            switch ( s ) {
                    case 0 : 
                        int LA47_7 = input.LA(1);

                         
                        int index47_7 = input.index();
                        input.rewind();

                        s = -1;
                        if ( (synpred6_CSharp4AST()) ) {s = 11;}

                        else if ( (true) ) {s = 2;}

                         
                        input.seek(index47_7);

                        if ( s>=0 ) return s;
                        break;

                    case 1 : 
                        int LA47_16 = input.LA(1);

                         
                        int index47_16 = input.index();
                        input.rewind();

                        s = -1;
                        if ( (synpred6_CSharp4AST()) ) {s = 20;}

                        else if ( (true) ) {s = 2;}

                         
                        input.seek(index47_16);

                        if ( s>=0 ) return s;
                        break;

                    case 2 : 
                        int LA47_14 = input.LA(1);

                         
                        int index47_14 = input.index();
                        input.rewind();

                        s = -1;
                        if ( (synpred6_CSharp4AST()) ) {s = 18;}

                        else if ( (true) ) {s = 2;}

                         
                        input.seek(index47_14);

                        if ( s>=0 ) return s;
                        break;

                    case 3 : 
                        int LA47_15 = input.LA(1);

                         
                        int index47_15 = input.index();
                        input.rewind();

                        s = -1;
                        if ( (LA47_15==COMMA) && (synpred6_CSharp4AST())) {s = 19;}

                        else if ( (LA47_15==GT) && (synpred6_CSharp4AST())) {s = 20;}

                        else if ( (LA47_15==BOOL||LA47_15==BYTE||LA47_15==CHAR||LA47_15==DECIMAL||LA47_15==DOUBLE||LA47_15==FLOAT||LA47_15==IDENTIFIER||LA47_15==INT||LA47_15==LONG||LA47_15==OBJECT||LA47_15==SBYTE||LA47_15==SHORT||LA47_15==STRING||(LA47_15 >= UINT && LA47_15 <= ULONG)||LA47_15==USHORT||LA47_15==VOID) ) {s = 2;}

                         
                        input.seek(index47_15);

                        if ( s>=0 ) return s;
                        break;

                    case 4 : 
                        int LA47_13 = input.LA(1);

                         
                        int index47_13 = input.index();
                        input.rewind();

                        s = -1;
                        if ( (LA47_13==BOOL||LA47_13==BYTE||LA47_13==CHAR||LA47_13==DECIMAL||LA47_13==DOUBLE||LA47_13==FLOAT||LA47_13==IDENTIFIER||LA47_13==INT||LA47_13==LONG||LA47_13==OBJECT||LA47_13==SBYTE||LA47_13==SHORT||LA47_13==STRING||(LA47_13 >= UINT && LA47_13 <= ULONG)||LA47_13==USHORT||LA47_13==VOID) ) {s = 2;}

                        else if ( (LA47_13==COMMA) && (synpred6_CSharp4AST())) {s = 17;}

                        else if ( (LA47_13==GT) && (synpred6_CSharp4AST())) {s = 18;}

                         
                        input.seek(index47_13);

                        if ( s>=0 ) return s;
                        break;

                    case 5 : 
                        int LA47_5 = input.LA(1);

                         
                        int index47_5 = input.index();
                        input.rewind();

                        s = -1;
                        if ( (LA47_5==COMMA) && (synpred6_CSharp4AST())) {s = 10;}

                        else if ( (LA47_5==GT) && (synpred6_CSharp4AST())) {s = 11;}

                        else if ( (LA47_5==BOOL||LA47_5==BYTE||LA47_5==CHAR||LA47_5==DECIMAL||LA47_5==DOUBLE||LA47_5==FLOAT||LA47_5==IDENTIFIER||LA47_5==INT||LA47_5==LONG||LA47_5==OBJECT||LA47_5==SBYTE||LA47_5==SHORT||LA47_5==STRING||(LA47_5 >= UINT && LA47_5 <= ULONG)||LA47_5==USHORT||LA47_5==VOID) ) {s = 2;}

                         
                        input.seek(index47_5);

                        if ( s>=0 ) return s;
                        break;
            }
            if (state.backtracking>0) {state.failed=true; return -1;}

            NoViableAltException nvae =
                new NoViableAltException(getDescription(), 47, _s, input);
            error(nvae);
            throw nvae;
        }

    }
    static final String DFA56_eotS =
        "\116\uffff";
    static final String DFA56_eofS =
        "\116\uffff";
    static final String DFA56_minS =
        "\1\4\115\uffff";
    static final String DFA56_maxS =
        "\1\u00dd\115\uffff";
    static final String DFA56_acceptS =
        "\1\uffff\1\1\1\2\1\3\1\4\1\5\1\6\1\7\1\10\1\11\1\12\1\13\1\14\1"+
        "\15\1\16\1\17\1\20\1\21\1\22\1\23\1\24\1\25\1\26\1\27\1\30\1\31"+
        "\1\32\1\33\1\34\1\35\1\36\1\37\1\40\1\41\1\42\1\43\1\44\1\45\1\46"+
        "\1\47\1\50\1\51\1\52\1\53\1\54\1\55\1\56\1\57\1\60\1\61\1\62\1\63"+
        "\1\64\1\65\1\66\1\67\1\70\1\71\1\72\1\73\1\74\1\75\1\76\1\77\1\100"+
        "\1\101\1\102\1\103\1\104\1\105\1\106\1\107\1\110\1\111\1\112\1\113"+
        "\1\114\1\115";
    static final String DFA56_specialS =
        "\116\uffff}>";
    static final String[] DFA56_transitionS = {
            "\1\6\6\uffff\1\2\1\7\1\uffff\1\10\1\11\1\12\1\uffff\1\13\1\14"+
            "\1\15\1\5\1\16\1\17\5\uffff\1\20\1\21\4\uffff\1\22\1\uffff\1"+
            "\23\1\24\3\uffff\1\25\1\uffff\1\26\7\uffff\1\27\1\30\1\31\1"+
            "\32\1\33\1\uffff\1\5\1\34\1\35\1\36\1\37\1\40\4\uffff\1\41\5"+
            "\uffff\1\4\1\42\1\43\1\44\1\45\1\5\1\46\1\47\10\uffff\1\50\1"+
            "\51\5\uffff\1\52\1\53\2\uffff\1\5\2\uffff\1\54\2\uffff\1\3\1"+
            "\55\24\uffff\1\56\1\57\1\60\2\uffff\1\61\1\62\1\63\30\uffff"+
            "\1\64\1\5\1\65\1\66\3\uffff\1\67\1\70\2\uffff\1\71\2\uffff\1"+
            "\72\1\73\1\uffff\1\74\1\75\1\5\1\76\1\77\7\uffff\1\100\1\101"+
            "\1\1\1\5\1\102\1\103\1\uffff\1\104\1\105\1\106\14\uffff\1\107"+
            "\1\110\1\111\1\uffff\1\112\1\113\1\114\2\uffff\1\115",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
    };

    static final short[] DFA56_eot = DFA.unpackEncodedString(DFA56_eotS);
    static final short[] DFA56_eof = DFA.unpackEncodedString(DFA56_eofS);
    static final char[] DFA56_min = DFA.unpackEncodedStringToUnsignedChars(DFA56_minS);
    static final char[] DFA56_max = DFA.unpackEncodedStringToUnsignedChars(DFA56_maxS);
    static final short[] DFA56_accept = DFA.unpackEncodedString(DFA56_acceptS);
    static final short[] DFA56_special = DFA.unpackEncodedString(DFA56_specialS);
    static final short[][] DFA56_transition;

    static {
        int numStates = DFA56_transitionS.length;
        DFA56_transition = new short[numStates][];
        for (int i=0; i<numStates; i++) {
            DFA56_transition[i] = DFA.unpackEncodedString(DFA56_transitionS[i]);
        }
    }

    class DFA56 extends DFA {

        public DFA56(BaseRecognizer recognizer) {
            this.recognizer = recognizer;
            this.decisionNumber = 56;
            this.eot = DFA56_eot;
            this.eof = DFA56_eof;
            this.min = DFA56_min;
            this.max = DFA56_max;
            this.accept = DFA56_accept;
            this.special = DFA56_special;
            this.transition = DFA56_transition;
        }
        public String getDescription() {
            return "727:5: ( TILDE | BANG | OPEN_PARENS | IDENTIFIER | literal | ABSTRACT | BASE | BOOL | BREAK | BYTE | CASE | CATCH | CHAR | CHECKED | CLASS | CONST | CONTINUE | DECIMAL | DEFAULT | DELEGATE | DO | DOUBLE | ELSE | ENUM | EVENT | EXPLICIT | EXTERN | FINALLY | FIXED | FLOAT | FOR | FOREACH | GOTO | IF | IMPLICIT | IN | INT | INTERFACE | INTERNAL | LOCK | LONG | NAMESPACE | NEW | OBJECT | OPERATOR | OUT | OVERRIDE | PARAMS | PRIVATE | PROTECTED | PUBLIC | READONLY | REF | RETURN | SBYTE | SEALED | SHORT | SIZEOF | STACKALLOC | STATIC | STRING | STRUCT | SWITCH | THIS | THROW | TRY | TYPEOF | UINT | ULONG | UNCHECKED | UNSAFE | USHORT | USING | VIRTUAL | VOID | VOLATILE | WHILE )";
        }
    }
    static final String DFA371_eotS =
        "\10\uffff";
    static final String DFA371_eofS =
        "\10\uffff";
    static final String DFA371_minS =
        "\1\53\1\16\2\uffff\1\34\1\16\1\53\1\34";
    static final String DFA371_maxS =
        "\1\153\1\u00d9\2\uffff\1\u00b1\1\u00d9\1\153\1\u00b1";
    static final String DFA371_acceptS =
        "\2\uffff\1\2\1\1\4\uffff";
    static final String DFA371_specialS =
        "\10\uffff}>";
    static final String[] DFA371_transitionS = {
            "\1\3\60\uffff\1\1\16\uffff\1\2",
            "\1\3\1\uffff\1\3\3\uffff\1\3\16\uffff\1\3\10\uffff\1\3\20\uffff"+
            "\1\3\14\uffff\1\4\3\uffff\1\3\14\uffff\1\3\14\uffff\1\3\1\uffff"+
            "\1\2\75\uffff\1\3\3\uffff\1\3\6\uffff\1\3\21\uffff\2\3\16\uffff"+
            "\1\3\3\uffff\1\3",
            "",
            "",
            "\1\5\16\uffff\1\3\2\uffff\1\3\26\uffff\1\6\14\uffff\1\3\11"+
            "\uffff\1\3\15\uffff\1\3\106\uffff\1\3",
            "\1\3\1\uffff\1\3\3\uffff\1\3\16\uffff\1\3\10\uffff\1\3\20\uffff"+
            "\1\3\14\uffff\1\7\3\uffff\1\3\14\uffff\1\3\14\uffff\1\3\1\uffff"+
            "\1\2\75\uffff\1\3\3\uffff\1\3\6\uffff\1\3\21\uffff\2\3\16\uffff"+
            "\1\3\3\uffff\1\3",
            "\1\3\77\uffff\1\2",
            "\1\5\16\uffff\1\3\2\uffff\1\3\26\uffff\1\6\14\uffff\1\3\11"+
            "\uffff\1\3\15\uffff\1\3\106\uffff\1\3"
    };

    static final short[] DFA371_eot = DFA.unpackEncodedString(DFA371_eotS);
    static final short[] DFA371_eof = DFA.unpackEncodedString(DFA371_eofS);
    static final char[] DFA371_min = DFA.unpackEncodedStringToUnsignedChars(DFA371_minS);
    static final char[] DFA371_max = DFA.unpackEncodedStringToUnsignedChars(DFA371_maxS);
    static final short[] DFA371_accept = DFA.unpackEncodedString(DFA371_acceptS);
    static final short[] DFA371_special = DFA.unpackEncodedString(DFA371_specialS);
    static final short[][] DFA371_transition;

    static {
        int numStates = DFA371_transitionS.length;
        DFA371_transition = new short[numStates][];
        for (int i=0; i<numStates; i++) {
            DFA371_transition[i] = DFA.unpackEncodedString(DFA371_transitionS[i]);
        }
    }

    class DFA371 extends DFA {

        public DFA371(BaseRecognizer recognizer) {
            this.recognizer = recognizer;
            this.decisionNumber = 371;
            this.eot = DFA371_eot;
            this.eof = DFA371_eof;
            this.min = DFA371_min;
            this.max = DFA371_max;
            this.accept = DFA371_accept;
            this.special = DFA371_special;
            this.transition = DFA371_transition;
        }
        public String getDescription() {
            return "()* loopback of 2752:7: ( type_argument_list_opt DOT IDENTIFIER )*";
        }
    }
 

    public static final BitSet FOLLOW_namespace_or_type_name_in_namespace_name572 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_namespace_or_type_name_in_type_name583 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_namespace_or_type_name2_in_namespace_or_type_name597 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_namespace_or_type_name2620 = new BitSet(new long[]{0x0000080000000000L,0x0000000010000000L});
    public static final BitSet FOLLOW_type_argument_list_opt_in_namespace_or_type_name2622 = new BitSet(new long[]{0x0000080000000002L});
    public static final BitSet FOLLOW_qualified_alias_member_in_namespace_or_type_name2630 = new BitSet(new long[]{0x0000080000000002L});
    public static final BitSet FOLLOW_namespace_part_in_namespace_or_type_name2638 = new BitSet(new long[]{0x0000080000000002L});
    public static final BitSet FOLLOW_DOT_in_namespace_part653 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_namespace_part657 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
    public static final BitSet FOLLOW_type_argument_list_opt_in_namespace_part659 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_type_argument_list_in_type_argument_list_opt696 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_type2_in_type720 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_base_type_in_type2745 = new BitSet(new long[]{0x0000000000000002L,0x0000040000040000L,0x0002000000000000L});
    public static final BitSet FOLLOW_INTERR_in_type2759 = new BitSet(new long[]{0x0000000000000002L,0x0000040000040000L,0x0002000000000000L});
    public static final BitSet FOLLOW_rank_specifier_in_type2793 = new BitSet(new long[]{0x0000000000000002L,0x0000040000040000L,0x0002000000000000L});
    public static final BitSet FOLLOW_STAR_in_type2804 = new BitSet(new long[]{0x0000000000000002L,0x0000040000040000L,0x0002000000000000L});
    public static final BitSet FOLLOW_simple_type_in_base_type858 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_class_type_in_base_type864 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_VOID_in_base_type872 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0002000000000000L});
    public static final BitSet FOLLOW_STAR_in_base_type874 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_numeric_type_in_simple_type890 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_BOOL_in_simple_type895 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_integral_type_in_numeric_type906 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_floating_point_type_in_numeric_type911 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_DECIMAL_in_numeric_type916 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_non_nullable_value_type_in_nullable_type994 = new BitSet(new long[]{0x0000000000000000L,0x0000000000040000L});
    public static final BitSet FOLLOW_INTERR_in_nullable_type996 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_base_type_in_non_nullable_value_type1010 = new BitSet(new long[]{0x0000000000000002L,0x0000040000000000L,0x0002000000000000L});
    public static final BitSet FOLLOW_rank_specifier_in_non_nullable_value_type1024 = new BitSet(new long[]{0x0000000000000002L,0x0000040000000000L,0x0002000000000000L});
    public static final BitSet FOLLOW_STAR_in_non_nullable_value_type1032 = new BitSet(new long[]{0x0000000000000002L,0x0000040000000000L,0x0002000000000000L});
    public static final BitSet FOLLOW_simple_type_in_reference_type1062 = new BitSet(new long[]{0x0000000000000000L,0x0000040000040000L,0x0002000000000000L});
    public static final BitSet FOLLOW_class_type_in_reference_type1072 = new BitSet(new long[]{0x0000000000000000L,0x0000040000040000L,0x0002000000000000L});
    public static final BitSet FOLLOW_VOID_in_reference_type1080 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0002000000000000L});
    public static final BitSet FOLLOW_STAR_in_reference_type1082 = new BitSet(new long[]{0x0000000000000000L,0x0000040000040000L,0x0002000000000000L});
    public static final BitSet FOLLOW_rank_specifier_in_reference_type1100 = new BitSet(new long[]{0x0000000000000000L,0x0000040000040000L,0x0002000000000000L});
    public static final BitSet FOLLOW_rank_specifier_in_reference_type1120 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_type_name_in_class_type1135 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OBJECT_in_class_type1140 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_dynamic_contextual_keyword_in_class_type1145 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STRING_in_class_type1150 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_type_name_in_interface_type1163 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_type_name_in_delegate_type1176 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_LT_in_type_argument_list1187 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_type_arguments_in_type_argument_list1189 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000020L});
    public static final BitSet FOLLOW_GT_in_type_argument_list1191 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_type_argument_in_type_arguments1213 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_type_arguments1217 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_type_argument_in_type_arguments1220 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_type_in_type_argument1233 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_VOID_in_type_void1245 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_expression_in_variable_reference1269 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_argument_in_argument_list1282 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_argument_list1286 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910C00000022L,0x00000000002000EBL});
    public static final BitSet FOLLOW_argument_in_argument_list1289 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_argument_name_in_argument1301 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910C00000022L,0x00000000002000EBL});
    public static final BitSet FOLLOW_argument_value_in_argument1304 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_argument_name1328 = new BitSet(new long[]{0x0000000008000000L});
    public static final BitSet FOLLOW_COLON_in_argument_name1330 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_argument_value2_in_argument_value1343 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_expression_in_argument_value21362 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_REF_in_argument_value21367 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_variable_reference_in_argument_value21369 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OUT_in_argument_value21374 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_variable_reference_in_argument_value21376 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_primary_expression_start_in_primary_expression1393 = new BitSet(new long[]{0x0000080000000002L,0x40220C0000000000L});
    public static final BitSet FOLLOW_bracket_expression_in_primary_expression1406 = new BitSet(new long[]{0x0000080000000002L,0x40220C0000000000L});
    public static final BitSet FOLLOW_member_access2_in_primary_expression1428 = new BitSet(new long[]{0x0000080000000002L,0x40220C0000000000L});
    public static final BitSet FOLLOW_method_invocation2_in_primary_expression1448 = new BitSet(new long[]{0x0000080000000002L,0x40220C0000000000L});
    public static final BitSet FOLLOW_OP_INC_in_primary_expression1469 = new BitSet(new long[]{0x0000080000000002L,0x40220C0000000000L});
    public static final BitSet FOLLOW_OP_DEC_in_primary_expression1487 = new BitSet(new long[]{0x0000080000000002L,0x40220C0000000000L});
    public static final BitSet FOLLOW_OP_PTR_in_primary_expression1505 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_primary_expression1507 = new BitSet(new long[]{0x0000080000000002L,0x40220C0000000000L});
    public static final BitSet FOLLOW_bracket_expression_in_primary_expression1535 = new BitSet(new long[]{0x0000080000000002L,0x40220C0000000000L});
    public static final BitSet FOLLOW_literal_in_primary_expression_start1565 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_simple_name_in_primary_expression_start1571 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_parenthesized_expression_in_primary_expression_start1577 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_predefined_type_in_primary_expression_start1583 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_qualified_alias_member_in_primary_expression_start1590 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_this_access_in_primary_expression_start1598 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_base_access_in_primary_expression_start1604 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_NEW_in_primary_expression_start1610 = new BitSet(new long[]{0x2000100800114000L,0x0000070008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_type_in_primary_expression_start1614 = new BitSet(new long[]{0x0000000000000000L,0x00000E0000000000L});
    public static final BitSet FOLLOW_object_creation_expression2_in_primary_expression_start1618 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_object_or_collection_initializer_in_primary_expression_start1638 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_BRACKET_in_primary_expression_start1657 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_expression_list_in_primary_expression_start1659 = new BitSet(new long[]{0x0000000002000000L});
    public static final BitSet FOLLOW_CLOSE_BRACKET_in_primary_expression_start1661 = new BitSet(new long[]{0x0000000000000002L,0x0000060000000000L});
    public static final BitSet FOLLOW_rank_specifiers_in_primary_expression_start1663 = new BitSet(new long[]{0x0000000000000002L,0x0000020000000000L});
    public static final BitSet FOLLOW_array_initializer_in_primary_expression_start1666 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_rank_specifiers_in_primary_expression_start1686 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_array_initializer_in_primary_expression_start1688 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_anonymous_object_initializer_in_primary_expression_start1717 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_rank_specifier_in_primary_expression_start1729 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_array_initializer_in_primary_expression_start1731 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_typeof_expression_in_primary_expression_start1747 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_checked_expression_in_primary_expression_start1753 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_unchecked_expression_in_primary_expression_start1759 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_default_value_expression_in_primary_expression_start1765 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_anonymous_method_expression_in_primary_expression_start1771 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_sizeof_expression_in_primary_expression_start1777 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_BRACKET_in_bracket_expression1791 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_expression_list_in_bracket_expression1793 = new BitSet(new long[]{0x0000000002000000L});
    public static final BitSet FOLLOW_CLOSE_BRACKET_in_bracket_expression1795 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_simple_name1825 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
    public static final BitSet FOLLOW_type_argument_list_opt_in_simple_name1827 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_parenthesized_expression1854 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_expression_in_parenthesized_expression1857 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_parenthesized_expression1859 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_primary_expression_in_member_access1876 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_expression_in_expression_list1975 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_expression_list1979 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_expression_in_expression_list1981 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_THIS_in_this_access1994 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_BASE_in_base_access2006 = new BitSet(new long[]{0x0000080000000000L});
    public static final BitSet FOLLOW_DOT_in_base_access2008 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_base_access2011 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
    public static final BitSet FOLLOW_type_argument_list_opt_in_base_access2013 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_BASE_in_base_access2018 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_OPEN_BRACKET_in_base_access2020 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_expression_list_in_base_access2022 = new BitSet(new long[]{0x0000000002000000L});
    public static final BitSet FOLLOW_CLOSE_BRACKET_in_base_access2024 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_NEW_in_object_creation_expression2042 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_type_in_object_creation_expression2044 = new BitSet(new long[]{0x0000000000000000L,0x00000A0000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_object_creation_expression2048 = new BitSet(new long[]{0x2400106804715820L,0x002209250800C400L,0x401A910C00000022L,0x00000000002000EBL});
    public static final BitSet FOLLOW_argument_list_in_object_creation_expression2050 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_object_creation_expression2053 = new BitSet(new long[]{0x0000000000000002L,0x0000020000000000L});
    public static final BitSet FOLLOW_object_or_collection_initializer_in_object_creation_expression2055 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_object_or_collection_initializer_in_object_creation_expression2073 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_object_initializer_in_object_or_collection_initializer2102 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_collection_initializer_in_object_or_collection_initializer2107 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_object_initializer2123 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_object_initializer2125 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_object_initializer2131 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_member_initializer_list_in_object_initializer2133 = new BitSet(new long[]{0x0000000011000000L});
    public static final BitSet FOLLOW_COMMA_in_object_initializer2135 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_object_initializer2138 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_member_initializer_in_member_initializer_list2150 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_member_initializer_list2154 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_member_initializer_in_member_initializer_list2156 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_member_initializer2169 = new BitSet(new long[]{0x0000000000000080L});
    public static final BitSet FOLLOW_ASSIGNMENT_in_member_initializer2171 = new BitSet(new long[]{0x2400106800715820L,0x00220B250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_initializer_value_in_member_initializer2173 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_expression_in_initializer_value2184 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_object_or_collection_initializer_in_initializer_value2189 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_collection_initializer2205 = new BitSet(new long[]{0x2400106800715820L,0x00220B250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_element_initializer_list_in_collection_initializer2207 = new BitSet(new long[]{0x0000000011000000L});
    public static final BitSet FOLLOW_COMMA_in_collection_initializer2209 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_collection_initializer2212 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_element_initializer_in_element_initializer_list2224 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_element_initializer_list2228 = new BitSet(new long[]{0x2400106800715820L,0x00220B250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_element_initializer_in_element_initializer_list2230 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_non_assignment_expression_in_element_initializer2243 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_element_initializer2248 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_expression_list_in_element_initializer2250 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_element_initializer2252 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_NEW_in_array_creation_expression2266 = new BitSet(new long[]{0x2000100800114000L,0x0000050008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_array_type_in_array_creation_expression2278 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_array_initializer_in_array_creation_expression2280 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_non_array_type_in_array_creation_expression2292 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_OPEN_BRACKET_in_array_creation_expression2294 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_expression_list_in_array_creation_expression2296 = new BitSet(new long[]{0x0000000002000000L});
    public static final BitSet FOLLOW_CLOSE_BRACKET_in_array_creation_expression2298 = new BitSet(new long[]{0x0000000000000002L,0x0000060000000000L});
    public static final BitSet FOLLOW_rank_specifiers_in_array_creation_expression2300 = new BitSet(new long[]{0x0000000000000002L,0x0000020000000000L});
    public static final BitSet FOLLOW_array_initializer_in_array_creation_expression2303 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_rank_specifier_in_array_creation_expression2316 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_array_initializer_in_array_creation_expression2318 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_NEW_in_delegate_creation_expression2342 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_delegate_type_in_delegate_creation_expression2344 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_delegate_creation_expression2346 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_expression_in_delegate_creation_expression2348 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_delegate_creation_expression2350 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_NEW_in_anonymous_object_creation_expression2363 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_anonymous_object_initializer_in_anonymous_object_creation_expression2365 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_anonymous_object_initializer2381 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_anonymous_object_initializer2383 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_anonymous_object_initializer2389 = new BitSet(new long[]{0x2400106800715000L,0x000009240800C400L,0x4018910400000000L,0x00000000002000EAL});
    public static final BitSet FOLLOW_member_declarator_list_in_anonymous_object_initializer2391 = new BitSet(new long[]{0x0000000011000000L});
    public static final BitSet FOLLOW_COMMA_in_anonymous_object_initializer2393 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_anonymous_object_initializer2396 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_member_declarator_in_member_declarator_list2408 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_member_declarator_list2412 = new BitSet(new long[]{0x2400106800715000L,0x000009240800C400L,0x4018910400000000L,0x00000000002000EAL});
    public static final BitSet FOLLOW_member_declarator_in_member_declarator_list2414 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_primary_expression_in_member_declarator2430 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_member_declarator2436 = new BitSet(new long[]{0x0000000000000080L});
    public static final BitSet FOLLOW_ASSIGNMENT_in_member_declarator2438 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_expression_in_member_declarator2440 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_TYPEOF_in_typeof_expression2452 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_typeof_expression2454 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_unbound_type_name_in_typeof_expression2467 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_typeof_expression2469 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_type_in_typeof_expression2476 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_typeof_expression2478 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_VOID_in_typeof_expression2485 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_typeof_expression2487 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_unbound_type_name2506 = new BitSet(new long[]{0x0000480000000002L,0x0000000010000000L});
    public static final BitSet FOLLOW_generic_dimension_specifier_in_unbound_type_name2510 = new BitSet(new long[]{0x0000080000000002L});
    public static final BitSet FOLLOW_DOUBLE_COLON_in_unbound_type_name2530 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_unbound_type_name2532 = new BitSet(new long[]{0x0000080000000002L,0x0000000010000000L});
    public static final BitSet FOLLOW_generic_dimension_specifier_in_unbound_type_name2534 = new BitSet(new long[]{0x0000080000000002L});
    public static final BitSet FOLLOW_DOT_in_unbound_type_name2559 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_unbound_type_name2561 = new BitSet(new long[]{0x0000080000000002L,0x0000000010000000L});
    public static final BitSet FOLLOW_generic_dimension_specifier_in_unbound_type_name2563 = new BitSet(new long[]{0x0000080000000002L});
    public static final BitSet FOLLOW_LT_in_generic_dimension_specifier2578 = new BitSet(new long[]{0x0000000010000000L,0x0000000000000020L});
    public static final BitSet FOLLOW_commas_in_generic_dimension_specifier2580 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000020L});
    public static final BitSet FOLLOW_GT_in_generic_dimension_specifier2583 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_COMMA_in_commas2594 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_commas2598 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_CHECKED_in_checked_expression2612 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_checked_expression2615 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_expression_in_checked_expression2618 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_checked_expression2620 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_UNCHECKED_in_unchecked_expression2632 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_unchecked_expression2635 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_expression_in_unchecked_expression2638 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_unchecked_expression2640 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_DEFAULT_in_default_value_expression2652 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_default_value_expression2655 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_type_in_default_value_expression2658 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_default_value_expression2660 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_unary_expression2_in_unary_expression2675 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_cast_expression_in_unary_expression22706 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_primary_expression_in_unary_expression22711 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PLUS_in_unary_expression22716 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_unary_expression_in_unary_expression22718 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_MINUS_in_unary_expression22723 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_unary_expression_in_unary_expression22725 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_BANG_in_unary_expression22730 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_unary_expression_in_unary_expression22732 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_TILDE_in_unary_expression22746 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_unary_expression_in_unary_expression22748 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_pre_increment_expression_in_unary_expression22753 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_pre_decrement_expression_in_unary_expression22758 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_unary_expression_unsafe_in_unary_expression22763 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_scan_for_cast_generic_precedence2777 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_type_in_scan_for_cast_generic_precedence2779 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_scan_for_cast_generic_precedence2781 = new BitSet(new long[]{0xFDF0146860FDD810L,0x000019260C03FC10L,0xC07D931E000001CEL,0x00000000277000EFL});
    public static final BitSet FOLLOW_cast_disambiguation_token_in_scan_for_cast_generic_precedence2783 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_TILDE_in_cast_disambiguation_token2799 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_BANG_in_cast_disambiguation_token2803 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_cast_disambiguation_token2807 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_cast_disambiguation_token2811 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_literal_in_cast_disambiguation_token2815 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_ABSTRACT_in_cast_disambiguation_token2819 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_BASE_in_cast_disambiguation_token2823 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_BOOL_in_cast_disambiguation_token2827 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_BREAK_in_cast_disambiguation_token2831 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_BYTE_in_cast_disambiguation_token2835 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_CASE_in_cast_disambiguation_token2839 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_CATCH_in_cast_disambiguation_token2843 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_CHAR_in_cast_disambiguation_token2851 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_CHECKED_in_cast_disambiguation_token2855 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_CLASS_in_cast_disambiguation_token2859 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_CONST_in_cast_disambiguation_token2863 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_CONTINUE_in_cast_disambiguation_token2867 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_DECIMAL_in_cast_disambiguation_token2871 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_DEFAULT_in_cast_disambiguation_token2875 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_DELEGATE_in_cast_disambiguation_token2879 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_DO_in_cast_disambiguation_token2883 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_DOUBLE_in_cast_disambiguation_token2887 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_ELSE_in_cast_disambiguation_token2891 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_ENUM_in_cast_disambiguation_token2895 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_EVENT_in_cast_disambiguation_token2903 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_EXPLICIT_in_cast_disambiguation_token2907 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_EXTERN_in_cast_disambiguation_token2911 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_FINALLY_in_cast_disambiguation_token2915 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_FIXED_in_cast_disambiguation_token2919 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_FLOAT_in_cast_disambiguation_token2923 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_FOR_in_cast_disambiguation_token2927 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_FOREACH_in_cast_disambiguation_token2931 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_GOTO_in_cast_disambiguation_token2935 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IF_in_cast_disambiguation_token2939 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IMPLICIT_in_cast_disambiguation_token2943 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IN_in_cast_disambiguation_token2947 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INT_in_cast_disambiguation_token2951 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INTERFACE_in_cast_disambiguation_token2959 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INTERNAL_in_cast_disambiguation_token2963 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_LOCK_in_cast_disambiguation_token2967 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_LONG_in_cast_disambiguation_token2971 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_NAMESPACE_in_cast_disambiguation_token2975 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_NEW_in_cast_disambiguation_token2979 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OBJECT_in_cast_disambiguation_token2983 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPERATOR_in_cast_disambiguation_token2987 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OUT_in_cast_disambiguation_token2991 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OVERRIDE_in_cast_disambiguation_token2995 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PARAMS_in_cast_disambiguation_token2999 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PRIVATE_in_cast_disambiguation_token3007 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PROTECTED_in_cast_disambiguation_token3011 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PUBLIC_in_cast_disambiguation_token3015 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_READONLY_in_cast_disambiguation_token3019 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_REF_in_cast_disambiguation_token3023 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_RETURN_in_cast_disambiguation_token3027 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_SBYTE_in_cast_disambiguation_token3031 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_SEALED_in_cast_disambiguation_token3035 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_SHORT_in_cast_disambiguation_token3039 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_SIZEOF_in_cast_disambiguation_token3043 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STACKALLOC_in_cast_disambiguation_token3047 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STATIC_in_cast_disambiguation_token3055 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STRING_in_cast_disambiguation_token3059 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STRUCT_in_cast_disambiguation_token3063 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_SWITCH_in_cast_disambiguation_token3067 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_THIS_in_cast_disambiguation_token3071 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_THROW_in_cast_disambiguation_token3075 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_TRY_in_cast_disambiguation_token3079 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_TYPEOF_in_cast_disambiguation_token3083 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_UINT_in_cast_disambiguation_token3087 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_ULONG_in_cast_disambiguation_token3091 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_UNCHECKED_in_cast_disambiguation_token3095 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_UNSAFE_in_cast_disambiguation_token3099 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_USHORT_in_cast_disambiguation_token3107 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_USING_in_cast_disambiguation_token3111 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_VIRTUAL_in_cast_disambiguation_token3115 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_VOID_in_cast_disambiguation_token3119 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_VOLATILE_in_cast_disambiguation_token3123 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_WHILE_in_cast_disambiguation_token3127 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_INC_in_pre_increment_expression3145 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_unary_expression_in_pre_increment_expression3147 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_DEC_in_pre_decrement_expression3158 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_unary_expression_in_pre_decrement_expression3160 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_cast_expression3171 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_type_in_cast_expression3173 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_cast_expression3175 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_unary_expression_in_cast_expression3177 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_unary_expression_in_multiplicative_expression3205 = new BitSet(new long[]{0x0000020000000002L,0x0000000000000000L,0x0002000000000010L});
    public static final BitSet FOLLOW_STAR_in_multiplicative_expression3221 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_unary_expression_in_multiplicative_expression3226 = new BitSet(new long[]{0x0000020000000002L,0x0000000000000000L,0x0002000000000010L});
    public static final BitSet FOLLOW_DIV_in_multiplicative_expression3247 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_unary_expression_in_multiplicative_expression3252 = new BitSet(new long[]{0x0000020000000002L,0x0000000000000000L,0x0002000000000010L});
    public static final BitSet FOLLOW_PERCENT_in_multiplicative_expression3273 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_unary_expression_in_multiplicative_expression3278 = new BitSet(new long[]{0x0000020000000002L,0x0000000000000000L,0x0002000000000010L});
    public static final BitSet FOLLOW_multiplicative_expression_in_additive_expression3312 = new BitSet(new long[]{0x0000000000000002L,0x0000000100000000L,0x0000000000000020L});
    public static final BitSet FOLLOW_PLUS_in_additive_expression3327 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_multiplicative_expression_in_additive_expression3332 = new BitSet(new long[]{0x0000000000000002L,0x0000000100000000L,0x0000000000000020L});
    public static final BitSet FOLLOW_MINUS_in_additive_expression3353 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_multiplicative_expression_in_additive_expression3358 = new BitSet(new long[]{0x0000000000000002L,0x0000000100000000L,0x0000000000000020L});
    public static final BitSet FOLLOW_additive_expression_in_shift_expression3392 = new BitSet(new long[]{0x0000000000000002L,0x0080000000000020L});
    public static final BitSet FOLLOW_OP_LEFT_SHIFT_in_shift_expression3407 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_additive_expression_in_shift_expression3412 = new BitSet(new long[]{0x0000000000000002L,0x0080000000000020L});
    public static final BitSet FOLLOW_right_shift_in_shift_expression3433 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_additive_expression_in_shift_expression3438 = new BitSet(new long[]{0x0000000000000002L,0x0080000000000020L});
    public static final BitSet FOLLOW_shift_expression_in_relational_expression3472 = new BitSet(new long[]{0x0000000000000042L,0x0050000010080020L});
    public static final BitSet FOLLOW_LT_in_relational_expression3487 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_shift_expression_in_relational_expression3491 = new BitSet(new long[]{0x0000000000000042L,0x0050000010080020L});
    public static final BitSet FOLLOW_GT_in_relational_expression3513 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_shift_expression_in_relational_expression3517 = new BitSet(new long[]{0x0000000000000042L,0x0050000010080020L});
    public static final BitSet FOLLOW_OP_LE_in_relational_expression3539 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_shift_expression_in_relational_expression3543 = new BitSet(new long[]{0x0000000000000042L,0x0050000010080020L});
    public static final BitSet FOLLOW_OP_GE_in_relational_expression3565 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_shift_expression_in_relational_expression3569 = new BitSet(new long[]{0x0000000000000042L,0x0050000010080020L});
    public static final BitSet FOLLOW_IS_in_relational_expression3591 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_isType_in_relational_expression3595 = new BitSet(new long[]{0x0000000000000042L,0x0050000010080020L});
    public static final BitSet FOLLOW_AS_in_relational_expression3617 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_type_in_relational_expression3621 = new BitSet(new long[]{0x0000000000000042L,0x0050000010080020L});
    public static final BitSet FOLLOW_non_nullable_value_type_in_isType3654 = new BitSet(new long[]{0x0000000000000002L,0x0000000000040000L});
    public static final BitSet FOLLOW_INTERR_in_isType3666 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_relational_expression_in_equality_expression3707 = new BitSet(new long[]{0x0000000000000002L,0x0808000000000000L});
    public static final BitSet FOLLOW_OP_EQ_in_equality_expression3723 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_relational_expression_in_equality_expression3728 = new BitSet(new long[]{0x0000000000000002L,0x0808000000000000L});
    public static final BitSet FOLLOW_OP_NE_in_equality_expression3750 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_relational_expression_in_equality_expression3755 = new BitSet(new long[]{0x0000000000000002L,0x0808000000000000L});
    public static final BitSet FOLLOW_equality_expression_in_and_expression3791 = new BitSet(new long[]{0x0000000000000022L});
    public static final BitSet FOLLOW_AMP_in_and_expression3806 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_equality_expression_in_and_expression3810 = new BitSet(new long[]{0x0000000000000022L});
    public static final BitSet FOLLOW_and_expression_in_exclusive_or_expression3844 = new BitSet(new long[]{0x0000000000020002L});
    public static final BitSet FOLLOW_CARET_in_exclusive_or_expression3859 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_and_expression_in_exclusive_or_expression3863 = new BitSet(new long[]{0x0000000000020002L});
    public static final BitSet FOLLOW_exclusive_or_expression_in_inclusive_or_expression3897 = new BitSet(new long[]{0x0000000000002002L});
    public static final BitSet FOLLOW_BITWISE_OR_in_inclusive_or_expression3912 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_exclusive_or_expression_in_inclusive_or_expression3916 = new BitSet(new long[]{0x0000000000002002L});
    public static final BitSet FOLLOW_inclusive_or_expression_in_conditional_and_expression3950 = new BitSet(new long[]{0x0000000000000002L,0x0000400000000000L});
    public static final BitSet FOLLOW_OP_AND_in_conditional_and_expression3965 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_inclusive_or_expression_in_conditional_and_expression3969 = new BitSet(new long[]{0x0000000000000002L,0x0000400000000000L});
    public static final BitSet FOLLOW_conditional_and_expression_in_conditional_or_expression4003 = new BitSet(new long[]{0x0000000000000002L,0x1000000000000000L});
    public static final BitSet FOLLOW_OP_OR_in_conditional_or_expression4018 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_conditional_and_expression_in_conditional_or_expression4022 = new BitSet(new long[]{0x0000000000000002L,0x1000000000000000L});
    public static final BitSet FOLLOW_conditional_or_expression_in_null_coalescing_expression4056 = new BitSet(new long[]{0x0000000000000002L,0x0001000000000000L});
    public static final BitSet FOLLOW_OP_COALESCING_in_null_coalescing_expression4059 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_null_coalescing_expression_in_null_coalescing_expression4062 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_null_coalescing_expression_in_conditional_expression4083 = new BitSet(new long[]{0x0000000000000002L,0x0000000000040000L});
    public static final BitSet FOLLOW_INTERR_in_conditional_expression4096 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_expression_in_conditional_expression4098 = new BitSet(new long[]{0x0000000008000000L});
    public static final BitSet FOLLOW_COLON_in_conditional_expression4100 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_expression_in_conditional_expression4102 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_anonymous_function_signature_in_lambda_expression4138 = new BitSet(new long[]{0x0000000000000080L});
    public static final BitSet FOLLOW_right_arrow_in_lambda_expression4140 = new BitSet(new long[]{0x2400106800715820L,0x00220B250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_anonymous_function_body_in_lambda_expression4142 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_DELEGATE_in_anonymous_method_expression4155 = new BitSet(new long[]{0x0000000000000000L,0x00000A0000000000L});
    public static final BitSet FOLLOW_explicit_anonymous_function_signature_in_anonymous_method_expression4158 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_block_in_anonymous_method_expression4161 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_anonymous_function_signature4177 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_anonymous_function_signature4179 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_anonymous_function_signature4185 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110800000002L,0x0000000002200060L});
    public static final BitSet FOLLOW_explicit_anonymous_function_parameter_list_in_anonymous_function_signature4187 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_anonymous_function_signature4189 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_anonymous_function_signature4195 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_implicit_anonymous_function_parameter_list_in_anonymous_function_signature4197 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_anonymous_function_signature4199 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_implicit_anonymous_function_parameter_in_anonymous_function_signature4205 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_explicit_anonymous_function_signature4217 = new BitSet(new long[]{0x2000100804114000L,0x0000010008004400L,0x0008110800000002L,0x0000000002200060L});
    public static final BitSet FOLLOW_explicit_anonymous_function_parameter_list_in_explicit_anonymous_function_signature4219 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_explicit_anonymous_function_signature4222 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_explicit_anonymous_function_parameter_in_explicit_anonymous_function_parameter_list4233 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_explicit_anonymous_function_parameter_list4237 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110800000002L,0x0000000002200060L});
    public static final BitSet FOLLOW_explicit_anonymous_function_parameter_in_explicit_anonymous_function_parameter_list4239 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_anonymous_function_parameter_modifier_in_explicit_anonymous_function_parameter4252 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_type_in_explicit_anonymous_function_parameter4255 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_explicit_anonymous_function_parameter4257 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_implicit_anonymous_function_signature4284 = new BitSet(new long[]{0x0000000004000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_implicit_anonymous_function_parameter_list_in_implicit_anonymous_function_signature4286 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_implicit_anonymous_function_signature4289 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_implicit_anonymous_function_parameter_in_implicit_anonymous_function_signature4294 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_implicit_anonymous_function_parameter_in_implicit_anonymous_function_parameter_list4305 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_implicit_anonymous_function_parameter_list4309 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_implicit_anonymous_function_parameter_in_implicit_anonymous_function_parameter_list4311 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_implicit_anonymous_function_parameter4326 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_expression_in_anonymous_function_body4337 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_block_in_anonymous_function_body4342 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_from_clause_in_query_expression4355 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_query_body_in_query_expression4357 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_from_contextual_keyword_in_from_clause4368 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_type_in_from_clause4381 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_from_clause4385 = new BitSet(new long[]{0x0000000000000000L,0x0000000000002000L});
    public static final BitSet FOLLOW_IN_in_from_clause4387 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_expression_in_from_clause4389 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_query_body_clauses_in_query_body4403 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_select_or_group_clause_in_query_body4406 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000400L});
    public static final BitSet FOLLOW_query_continuation_in_query_body4415 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_query_body_clause_in_query_body_clauses4429 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000400L});
    public static final BitSet FOLLOW_query_body_clause_in_query_body_clauses4433 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000400L});
    public static final BitSet FOLLOW_from_clause_in_query_body_clause4450 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_let_clause_in_query_body_clause4456 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_where_clause_in_query_body_clause4462 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_combined_join_clause_in_query_body_clause4468 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_orderby_clause_in_query_body_clause4474 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_let_contextual_keyword_in_let_clause4486 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_let_clause4488 = new BitSet(new long[]{0x0000000000000080L});
    public static final BitSet FOLLOW_ASSIGNMENT_in_let_clause4490 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_expression_in_let_clause4492 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_where_contextual_keyword_in_where_clause4503 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_boolean_expression_in_where_clause4505 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_join_contextual_keyword_in_join_clause4516 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_type_in_join_clause4518 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_join_clause4521 = new BitSet(new long[]{0x0000000000000000L,0x0000000000002000L});
    public static final BitSet FOLLOW_IN_in_join_clause4523 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_expression_in_join_clause4525 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_on_contextual_keyword_in_join_clause4527 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_expression_in_join_clause4529 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_equals_contextual_keyword_in_join_clause4531 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_expression_in_join_clause4533 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_join_contextual_keyword_in_join_into_clause4544 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_type_in_join_into_clause4546 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_join_into_clause4549 = new BitSet(new long[]{0x0000000000000000L,0x0000000000002000L});
    public static final BitSet FOLLOW_IN_in_join_into_clause4551 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_expression_in_join_into_clause4553 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_on_contextual_keyword_in_join_into_clause4555 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_expression_in_join_into_clause4557 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_equals_contextual_keyword_in_join_into_clause4559 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_expression_in_join_into_clause4561 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_into_contextual_keyword_in_join_into_clause4563 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_join_into_clause4565 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_join_contextual_keyword_in_combined_join_clause4577 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_type_in_combined_join_clause4579 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_combined_join_clause4582 = new BitSet(new long[]{0x0000000000000000L,0x0000000000002000L});
    public static final BitSet FOLLOW_IN_in_combined_join_clause4584 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_expression_in_combined_join_clause4586 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_on_contextual_keyword_in_combined_join_clause4588 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_expression_in_combined_join_clause4590 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_equals_contextual_keyword_in_combined_join_clause4592 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_expression_in_combined_join_clause4594 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000400L});
    public static final BitSet FOLLOW_into_contextual_keyword_in_combined_join_clause4597 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_combined_join_clause4599 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_orderby_contextual_keyword_in_orderby_clause4613 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_orderings_in_orderby_clause4615 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_ordering_in_orderings4626 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_orderings4630 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_ordering_in_orderings4633 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_expression_in_ordering4647 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000400L});
    public static final BitSet FOLLOW_ordering_direction_in_ordering4649 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_ascending_contextual_keyword_in_ordering_direction4661 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_descending_contextual_keyword_in_ordering_direction4666 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_select_clause_in_select_or_group_clause4677 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_group_clause_in_select_or_group_clause4682 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_select_contextual_keyword_in_select_clause4693 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_expression_in_select_clause4695 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_group_contextual_keyword_in_group_clause4706 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_expression_in_group_clause4708 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_by_contextual_keyword_in_group_clause4710 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_expression_in_group_clause4712 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_into_contextual_keyword_in_query_continuation4725 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_query_continuation4727 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_query_body_in_query_continuation4729 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_unary_expression_in_assignment4742 = new BitSet(new long[]{0x0000000000000080L,0xA704A00000000020L,0x0000000000000001L});
    public static final BitSet FOLLOW_assignment_operator_in_assignment4744 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_expression_in_assignment4747 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_assignment_operator2_in_assignment_operator4758 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_ASSIGNMENT_in_assignment_operator24778 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_ADD_ASSIGNMENT_in_assignment_operator24783 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_SUB_ASSIGNMENT_in_assignment_operator24788 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_MULT_ASSIGNMENT_in_assignment_operator24793 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_DIV_ASSIGNMENT_in_assignment_operator24798 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_MOD_ASSIGNMENT_in_assignment_operator24803 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_AND_ASSIGNMENT_in_assignment_operator24808 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_OR_ASSIGNMENT_in_assignment_operator24813 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_XOR_ASSIGNMENT_in_assignment_operator24818 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_LEFT_SHIFT_ASSIGNMENT_in_assignment_operator24823 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_right_shift_assignment_in_assignment_operator24828 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_assignment_in_expression4847 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_non_assignment_expression_in_expression4854 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_lambda_expression_in_non_assignment_expression4870 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_query_expression_in_non_assignment_expression4881 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_conditional_expression_in_non_assignment_expression4888 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_expression_in_constant_expression4899 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_expression_in_boolean_expression4910 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_labeled_statement_in_statement4929 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_declaration_statement_in_statement4940 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_embedded_statement_in_statement4945 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_block_in_embedded_statement4956 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_empty_statement_in_embedded_statement4961 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_expression_statement_in_embedded_statement4966 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_selection_statement_in_embedded_statement4971 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_iteration_statement_in_embedded_statement4976 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_jump_statement_in_embedded_statement4981 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_try_statement_in_embedded_statement4986 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_checked_statement_in_embedded_statement4991 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_unchecked_statement_in_embedded_statement4996 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_lock_statement_in_embedded_statement5001 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_using_statement_in_embedded_statement5006 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_yield_statement_in_embedded_statement5011 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_embedded_statement_unsafe_in_embedded_statement5016 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_block5029 = new BitSet(new long[]{0xF40014686171D820L,0x00220B250C00CC10L,0xC05A951400000020L,0x00000000227000EFL});
    public static final BitSet FOLLOW_statement_list_in_block5031 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_block5034 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_statement_in_statement_list5057 = new BitSet(new long[]{0xF40014686071D822L,0x00220B250C00CC10L,0xC05A951400000020L,0x00000000227000EFL});
    public static final BitSet FOLLOW_SEMICOLON_in_empty_statement5069 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_labeled_statement5082 = new BitSet(new long[]{0x0000000008000000L});
    public static final BitSet FOLLOW_COLON_in_labeled_statement5084 = new BitSet(new long[]{0xF40014686071D820L,0x00220B250C00CC10L,0xC05A951400000020L,0x00000000227000EFL});
    public static final BitSet FOLLOW_statement_in_labeled_statement5086 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_local_variable_declaration_in_declaration_statement5113 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_declaration_statement5115 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_local_constant_declaration_in_declaration_statement5121 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_declaration_statement5123 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_local_variable_type_in_local_variable_declaration5141 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_local_variable_declarators_in_local_variable_declaration5148 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_type_in_local_variable_type5161 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_local_variable_declarator_in_local_variable_declarators5175 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_local_variable_declarators5179 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_local_variable_declarator_in_local_variable_declarators5182 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_local_variable_declarator5215 = new BitSet(new long[]{0x0000000000000082L});
    public static final BitSet FOLLOW_ASSIGNMENT_in_local_variable_declarator5218 = new BitSet(new long[]{0x2400106800715820L,0x00220B250800C400L,0x401B910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_local_variable_initializer_in_local_variable_declarator5221 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_local_variable_initializer2_in_local_variable_initializer5235 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_expression_in_local_variable_initializer25254 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_array_initializer_in_local_variable_initializer25259 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_local_variable_initializer_unsafe_in_local_variable_initializer25264 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_CONST_in_local_constant_declaration5275 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_type_in_local_constant_declaration5280 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_constant_declarators_in_local_constant_declaration5283 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_statement_expression_in_expression_statement5294 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_expression_statement5296 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_expression_in_statement_expression5322 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_if_statement_in_selection_statement5333 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_switch_statement_in_selection_statement5338 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IF_in_if_statement5352 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_if_statement5354 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_boolean_expression_in_if_statement5358 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_if_statement5360 = new BitSet(new long[]{0xF40014684071D820L,0x00220B250C00CC10L,0xC05A951400000020L,0x00000000207000EFL});
    public static final BitSet FOLLOW_embedded_statement_in_if_statement5364 = new BitSet(new long[]{0x0010000000000002L});
    public static final BitSet FOLLOW_ELSE_in_if_statement5380 = new BitSet(new long[]{0xF40014684071D820L,0x00220B250C00CC10L,0xC05A951400000020L,0x00000000207000EFL});
    public static final BitSet FOLLOW_embedded_statement_in_if_statement5384 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_SWITCH_in_switch_statement5432 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_switch_statement5435 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_expression_in_switch_statement5437 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_switch_statement5439 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_switch_block_in_switch_statement5441 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_switch_block5452 = new BitSet(new long[]{0x0000002001040000L});
    public static final BitSet FOLLOW_switch_sections_in_switch_block5454 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_switch_block5457 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_switch_section_in_switch_sections5468 = new BitSet(new long[]{0x0000002000040002L});
    public static final BitSet FOLLOW_switch_section_in_switch_sections5472 = new BitSet(new long[]{0x0000002000040002L});
    public static final BitSet FOLLOW_switch_labels_in_switch_section5486 = new BitSet(new long[]{0xF40014686071D820L,0x00220B250C00CC10L,0xC05A951400000020L,0x00000000227000EFL});
    public static final BitSet FOLLOW_statement_list_in_switch_section5488 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_switch_label_in_switch_labels5499 = new BitSet(new long[]{0x0000002000040002L});
    public static final BitSet FOLLOW_switch_label_in_switch_labels5503 = new BitSet(new long[]{0x0000002000040002L});
    public static final BitSet FOLLOW_CASE_in_switch_label5517 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_constant_expression_in_switch_label5519 = new BitSet(new long[]{0x0000000008000000L});
    public static final BitSet FOLLOW_COLON_in_switch_label5521 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_DEFAULT_in_switch_label5526 = new BitSet(new long[]{0x0000000008000000L});
    public static final BitSet FOLLOW_COLON_in_switch_label5528 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_while_statement_in_iteration_statement5541 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_do_statement_in_iteration_statement5546 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_for_statement_in_iteration_statement5551 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_foreach_statement_in_iteration_statement5556 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_WHILE_in_while_statement5567 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_while_statement5569 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_boolean_expression_in_while_statement5571 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_while_statement5573 = new BitSet(new long[]{0xF40014684071D820L,0x00220B250C00CC10L,0xC05A951400000020L,0x00000000207000EFL});
    public static final BitSet FOLLOW_embedded_statement_in_while_statement5575 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_DO_in_do_statement5608 = new BitSet(new long[]{0xF40014684071D820L,0x00220B250C00CC10L,0xC05A951400000020L,0x00000000207000EFL});
    public static final BitSet FOLLOW_embedded_statement_in_do_statement5610 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000020000000L});
    public static final BitSet FOLLOW_WHILE_in_do_statement5612 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_do_statement5614 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_boolean_expression_in_do_statement5616 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_do_statement5618 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_do_statement5620 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_FOR_in_for_statement5653 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_for_statement5655 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A950400000020L,0x00000000022000EBL});
    public static final BitSet FOLLOW_for_initializer_in_for_statement5657 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_for_statement5660 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A950400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_for_condition_in_for_statement5662 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_for_statement5665 = new BitSet(new long[]{0x2400106804715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_for_iterator_in_for_statement5667 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_for_statement5670 = new BitSet(new long[]{0xF40014684071D820L,0x00220B250C00CC10L,0xC05A951400000020L,0x00000000207000EFL});
    public static final BitSet FOLLOW_embedded_statement_in_for_statement5672 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_local_variable_declaration_in_for_initializer5739 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_statement_expression_list_in_for_initializer5744 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_boolean_expression_in_for_condition5755 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_statement_expression_list_in_for_iterator5766 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_statement_expression_in_statement_expression_list5777 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_statement_expression_list5781 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_statement_expression_in_statement_expression_list5784 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_FOREACH_in_foreach_statement5798 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_foreach_statement5800 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_local_variable_type_in_foreach_statement5802 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_foreach_statement5804 = new BitSet(new long[]{0x0000000000000000L,0x0000000000002000L});
    public static final BitSet FOLLOW_IN_in_foreach_statement5806 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_expression_in_foreach_statement5808 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_foreach_statement5810 = new BitSet(new long[]{0xF40014684071D820L,0x00220B250C00CC10L,0xC05A951400000020L,0x00000000207000EFL});
    public static final BitSet FOLLOW_embedded_statement_in_foreach_statement5812 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_break_statement_in_jump_statement5846 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_continue_statement_in_jump_statement5851 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_goto_statement_in_jump_statement5856 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_return_statement_in_jump_statement5861 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_throw_statement_in_jump_statement5866 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_BREAK_in_break_statement5877 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_break_statement5880 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_CONTINUE_in_continue_statement5892 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_continue_statement5895 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_GOTO_in_goto_statement5907 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_goto_statement5910 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_goto_statement5912 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_GOTO_in_goto_statement5917 = new BitSet(new long[]{0x0000000000040000L});
    public static final BitSet FOLLOW_CASE_in_goto_statement5920 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_constant_expression_in_goto_statement5922 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_goto_statement5924 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_GOTO_in_goto_statement5929 = new BitSet(new long[]{0x0000002000000000L});
    public static final BitSet FOLLOW_DEFAULT_in_goto_statement5932 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_goto_statement5934 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_RETURN_in_return_statement5945 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A950400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_expression_in_return_statement5948 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_return_statement5951 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_THROW_in_throw_statement5963 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A950400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_expression_in_throw_statement5966 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_throw_statement5969 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_TRY_in_try_statement5984 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_block_in_try_statement5987 = new BitSet(new long[]{0x0800000000080002L});
    public static final BitSet FOLLOW_catch_clauses_in_try_statement5989 = new BitSet(new long[]{0x0800000000000002L});
    public static final BitSet FOLLOW_finally_clause_in_try_statement5992 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_specific_catch_clauses_in_catch_clauses6008 = new BitSet(new long[]{0x0000000000080002L});
    public static final BitSet FOLLOW_general_catch_clause_in_catch_clauses6010 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_general_catch_clause_in_catch_clauses6017 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_specific_catch_clause_in_specific_catch_clauses6029 = new BitSet(new long[]{0x0000000000080002L});
    public static final BitSet FOLLOW_specific_catch_clause_in_specific_catch_clauses6033 = new BitSet(new long[]{0x0000000000080002L});
    public static final BitSet FOLLOW_CATCH_in_specific_catch_clause6047 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_specific_catch_clause6050 = new BitSet(new long[]{0x0000000000000000L,0x0000010000000400L,0x0008000000000000L});
    public static final BitSet FOLLOW_class_type_in_specific_catch_clause6052 = new BitSet(new long[]{0x0000000004000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_specific_catch_clause6054 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_specific_catch_clause6057 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_block_in_specific_catch_clause6059 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_CATCH_in_general_catch_clause6070 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_block_in_general_catch_clause6073 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_FINALLY_in_finally_clause6084 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_block_in_finally_clause6087 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_CHECKED_in_checked_statement6098 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_block_in_checked_statement6101 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_UNCHECKED_in_unchecked_statement6112 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_block_in_unchecked_statement6115 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_LOCK_in_lock_statement6126 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_lock_statement6129 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_expression_in_lock_statement6131 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_lock_statement6133 = new BitSet(new long[]{0xF40014684071D820L,0x00220B250C00CC10L,0xC05A951400000020L,0x00000000207000EFL});
    public static final BitSet FOLLOW_embedded_statement_in_lock_statement6135 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_USING_in_using_statement6146 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_using_statement6149 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000022000EBL});
    public static final BitSet FOLLOW_resource_acquisition_in_using_statement6151 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_using_statement6153 = new BitSet(new long[]{0xF40014684071D820L,0x00220B250C00CC10L,0xC05A951400000020L,0x00000000207000EFL});
    public static final BitSet FOLLOW_embedded_statement_in_using_statement6155 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_local_variable_declaration_in_resource_acquisition6174 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_expression_in_resource_acquisition6179 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_yield_contextual_keyword_in_yield_statement6190 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000001000000000L});
    public static final BitSet FOLLOW_RETURN_in_yield_statement6192 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_expression_in_yield_statement6194 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_yield_statement6196 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_yield_contextual_keyword_in_yield_statement6201 = new BitSet(new long[]{0x0000000000008000L});
    public static final BitSet FOLLOW_BREAK_in_yield_statement6203 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_yield_statement6205 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_compilation_unit_in_csharpSource6229 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_extern_alias_directives_in_compilation_unit6262 = new BitSet(new long[]{0x0120004000800010L,0x0000040600030400L,0x00240202000001C4L,0x0000000005500000L});
    public static final BitSet FOLLOW_using_directives_in_compilation_unit6265 = new BitSet(new long[]{0x0120004000800010L,0x0000040600030400L,0x00240202000001C4L,0x0000000005100000L});
    public static final BitSet FOLLOW_global_attribute_section_in_compilation_unit6280 = new BitSet(new long[]{0x0120004000800010L,0x0000040600030400L,0x00240202000001C4L,0x0000000005100000L});
    public static final BitSet FOLLOW_namespace_member_declarations_in_compilation_unit6289 = new BitSet(new long[]{0x0000000000000000L});
    public static final BitSet FOLLOW_EOF_in_compilation_unit6292 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_NAMESPACE_in_namespace_declaration6306 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_qualified_identifier_in_namespace_declaration6309 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_namespace_body_in_namespace_declaration6311 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_namespace_declaration6313 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_qualified_identifier6326 = new BitSet(new long[]{0x0000080000000002L});
    public static final BitSet FOLLOW_DOT_in_qualified_identifier6330 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_qualified_identifier6333 = new BitSet(new long[]{0x0000080000000002L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_namespace_body6359 = new BitSet(new long[]{0x0120004001800010L,0x0000040600030400L,0x00240202000001C4L,0x0000000005500000L});
    public static final BitSet FOLLOW_extern_alias_directives_in_namespace_body6362 = new BitSet(new long[]{0x0120004001800010L,0x0000040600030400L,0x00240202000001C4L,0x0000000005500000L});
    public static final BitSet FOLLOW_using_directives_in_namespace_body6365 = new BitSet(new long[]{0x0120004001800010L,0x0000040600030400L,0x00240202000001C4L,0x0000000005100000L});
    public static final BitSet FOLLOW_namespace_member_declarations_in_namespace_body6368 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_namespace_body6371 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_extern_alias_directive_in_extern_alias_directives6382 = new BitSet(new long[]{0x0100000000000002L});
    public static final BitSet FOLLOW_EXTERN_in_extern_alias_directive6406 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_alias_contextual_keyword_in_extern_alias_directive6409 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_extern_alias_directive6412 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_extern_alias_directive6414 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_using_directive_in_using_directives6426 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000400000L});
    public static final BitSet FOLLOW_using_alias_directive_in_using_directive6450 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_using_namespace_directive_in_using_directive6455 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_USING_in_using_alias_directive6466 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_using_alias_directive6468 = new BitSet(new long[]{0x0000000000000080L});
    public static final BitSet FOLLOW_ASSIGNMENT_in_using_alias_directive6470 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_namespace_or_type_name_in_using_alias_directive6472 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_using_alias_directive6474 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_USING_in_using_namespace_directive6500 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_namespace_name_in_using_namespace_directive6502 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_using_namespace_directive6504 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_namespace_member_declaration_in_namespace_member_declarations6527 = new BitSet(new long[]{0x0120004000800012L,0x0000040600030400L,0x00240202000001C4L,0x0000000005100000L});
    public static final BitSet FOLLOW_namespace_declaration_in_namespace_member_declaration6551 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_type_declaration_in_namespace_member_declaration6556 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_type_declaration6570 = new BitSet(new long[]{0x0120004000800010L,0x0000000400030400L,0x00240202000001C4L,0x0000000005100000L});
    public static final BitSet FOLLOW_all_member_modifiers_in_type_declaration6573 = new BitSet(new long[]{0x0020004000800000L,0x0000000000010000L,0x0020000000000000L});
    public static final BitSet FOLLOW_class_definition_in_type_declaration6582 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_struct_definition_in_type_declaration6591 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_interface_definition_in_type_declaration6600 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_enum_definition_in_type_declaration6609 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_delegate_definition_in_type_declaration6618 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_qualified_alias_member6641 = new BitSet(new long[]{0x0000400000000000L});
    public static final BitSet FOLLOW_DOUBLE_COLON_in_qualified_alias_member6643 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_qualified_alias_member6647 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
    public static final BitSet FOLLOW_type_argument_list_opt_in_qualified_alias_member6649 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_class_declaration6681 = new BitSet(new long[]{0x0000000000800010L,0x0000000400020400L,0x00040200000001C0L,0x0000000000100000L});
    public static final BitSet FOLLOW_class_modifiers_in_class_declaration6684 = new BitSet(new long[]{0x0000000000800000L,0x0000000000000400L});
    public static final BitSet FOLLOW_partial_contextual_keyword_in_class_declaration6687 = new BitSet(new long[]{0x0000000000800000L});
    public static final BitSet FOLLOW_CLASS_in_class_declaration6690 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_class_declaration6692 = new BitSet(new long[]{0x0000000008000000L,0x0000020010000400L});
    public static final BitSet FOLLOW_type_parameter_list_in_class_declaration6694 = new BitSet(new long[]{0x0000000008000000L,0x0000020000000400L});
    public static final BitSet FOLLOW_class_base_in_class_declaration6702 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000400L});
    public static final BitSet FOLLOW_type_parameter_constraints_clauses_in_class_declaration6705 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_class_body_in_class_declaration6708 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_class_declaration6710 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_class_modifier_in_class_modifiers6722 = new BitSet(new long[]{0x0000000000000012L,0x0000000400020000L,0x00040200000001C0L,0x0000000000100000L});
    public static final BitSet FOLLOW_class_modifier_in_class_modifiers6726 = new BitSet(new long[]{0x0000000000000012L,0x0000000400020000L,0x00040200000001C0L,0x0000000000100000L});
    public static final BitSet FOLLOW_NEW_in_class_modifier6740 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PUBLIC_in_class_modifier6745 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PROTECTED_in_class_modifier6750 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INTERNAL_in_class_modifier6755 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PRIVATE_in_class_modifier6760 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_ABSTRACT_in_class_modifier6765 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_SEALED_in_class_modifier6770 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STATIC_in_class_modifier6775 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_class_modifier_unsafe_in_class_modifier6780 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_LT_in_type_parameter_list6791 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000400L});
    public static final BitSet FOLLOW_type_parameters_in_type_parameter_list6794 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000020L});
    public static final BitSet FOLLOW_GT_in_type_parameter_list6796 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributed_type_parameter_in_type_parameters6808 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_type_parameters6812 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000400L});
    public static final BitSet FOLLOW_attributed_type_parameter_in_type_parameters6815 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_attributes_in_attributed_type_parameter6842 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_type_parameter_in_attributed_type_parameter6845 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_type_parameter6871 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_COLON_in_class_base6886 = new BitSet(new long[]{0x0000000000000000L,0x0000010000000400L,0x0008000000000000L});
    public static final BitSet FOLLOW_class_type_in_class_base6888 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_class_base6892 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_interface_type_in_class_base6895 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_interface_type_in_interface_type_list6927 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_interface_type_list6931 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_interface_type_in_interface_type_list6934 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_type_parameter_constraints_clause_in_type_parameter_constraints_clauses6960 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000400L});
    public static final BitSet FOLLOW_where_contextual_keyword_in_type_parameter_constraints_clause6984 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_type_parameter_in_type_parameter_constraints_clause6986 = new BitSet(new long[]{0x0000000008000000L});
    public static final BitSet FOLLOW_COLON_in_type_parameter_constraints_clause6988 = new BitSet(new long[]{0x0000000000800000L,0x0000010400000400L,0x0028000000000000L});
    public static final BitSet FOLLOW_type_parameter_constraints_in_type_parameter_constraints_clause6990 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_constructor_constraint_in_type_parameter_constraints7019 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_primary_constraint_in_type_parameter_constraints7025 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_type_parameter_constraints7028 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_secondary_constraints_in_type_parameter_constraints7030 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_type_parameter_constraints7035 = new BitSet(new long[]{0x0000000000000000L,0x0000000400000000L});
    public static final BitSet FOLLOW_constructor_constraint_in_type_parameter_constraints7037 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_class_type_in_primary_constraint7051 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_CLASS_in_primary_constraint7056 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STRUCT_in_primary_constraint7061 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_interface_type_in_secondary_constraints7075 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_secondary_constraints7078 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_interface_type_in_secondary_constraints7080 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_NEW_in_constructor_constraint7094 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_constructor_constraint7096 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_constructor_constraint7098 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_class_body7109 = new BitSet(new long[]{0x21E0104821914010L,0x0000050408035400L,0x002C1302000001C4L,0x0000000007300061L});
    public static final BitSet FOLLOW_class_member_declarations_in_class_body7112 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_class_body7115 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_class_member_declaration_in_class_member_declarations7127 = new BitSet(new long[]{0x21E0104820914012L,0x0000050408035400L,0x002C1302000001C4L,0x0000000007300061L});
    public static final BitSet FOLLOW_attributes_in_class_member_declaration7156 = new BitSet(new long[]{0x21E0104820914010L,0x0000010408035400L,0x002C1302000001C4L,0x0000000007300061L});
    public static final BitSet FOLLOW_all_member_modifiers_in_class_member_declaration7167 = new BitSet(new long[]{0x20E0104820914000L,0x0000010008015400L,0x0028110000000000L,0x0000000002200061L});
    public static final BitSet FOLLOW_common_member_declaration_in_class_member_declaration7178 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_destructor_definition_in_class_member_declaration7186 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_all_member_modifier_in_all_member_modifiers7206 = new BitSet(new long[]{0x0100000000000012L,0x0000000400020400L,0x00040202000001C4L,0x0000000005100000L});
    public static final BitSet FOLLOW_NEW_in_all_member_modifier7232 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PUBLIC_in_all_member_modifier7238 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PROTECTED_in_all_member_modifier7244 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INTERNAL_in_all_member_modifier7250 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PRIVATE_in_all_member_modifier7256 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_READONLY_in_all_member_modifier7262 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_VOLATILE_in_all_member_modifier7268 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_VIRTUAL_in_all_member_modifier7274 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_SEALED_in_all_member_modifier7280 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OVERRIDE_in_all_member_modifier7286 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_ABSTRACT_in_all_member_modifier7292 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STATIC_in_all_member_modifier7298 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_UNSAFE_in_all_member_modifier7304 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_EXTERN_in_all_member_modifier7310 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_partial_contextual_keyword_in_all_member_modifier7316 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_constant_declaration2_in_common_member_declaration7337 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_typed_member_declaration_in_common_member_declaration7343 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_event_declaration2_in_common_member_declaration7349 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_conversion_operator_declarator_in_common_member_declaration7355 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_operator_body_in_common_member_declaration7358 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_constructor_declaration2_in_common_member_declaration7367 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_type_void_in_common_member_declaration7373 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_method_declaration2_in_common_member_declaration7377 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_class_definition_in_common_member_declaration7386 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_struct_definition_in_common_member_declaration7392 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_interface_definition_in_common_member_declaration7398 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_enum_definition_in_common_member_declaration7404 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_delegate_definition_in_common_member_declaration7410 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_type_in_typed_member_declaration7423 = new BitSet(new long[]{0x0000000000000000L,0x0000100000000400L,0x4000000000000000L});
    public static final BitSet FOLLOW_interface_type_in_typed_member_declaration7443 = new BitSet(new long[]{0x0000080000000000L});
    public static final BitSet FOLLOW_DOT_in_typed_member_declaration7445 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x4000000000000000L});
    public static final BitSet FOLLOW_indexer_declaration2_in_typed_member_declaration7448 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_method_declaration2_in_typed_member_declaration7468 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_property_declaration2_in_typed_member_declaration7485 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_indexer_declaration2_in_typed_member_declaration7494 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_operator_declaration2_in_typed_member_declaration7503 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_field_declaration2_in_typed_member_declaration7512 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_constant_declarator_in_constant_declarators7533 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_constant_declarators7538 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_constant_declarator_in_constant_declarators7541 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_constant_declarator7569 = new BitSet(new long[]{0x0000000000000080L});
    public static final BitSet FOLLOW_ASSIGNMENT_in_constant_declarator7571 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_constant_expression_in_constant_declarator7573 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_variable_declarator_in_variable_declarators7610 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_variable_declarators7614 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_variable_declarator_in_variable_declarators7618 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_variable_declarator2_in_variable_declarator7632 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_variable_declarator27662 = new BitSet(new long[]{0x0000000000000082L});
    public static final BitSet FOLLOW_ASSIGNMENT_in_variable_declarator27665 = new BitSet(new long[]{0x2400106800715820L,0x00220B250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_variable_initializer_in_variable_declarator27668 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_variable_initializer2_in_variable_initializer7681 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_expression_in_variable_initializer27701 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_array_initializer_in_variable_initializer27706 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_method_header_in_method_declaration7717 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_method_body_in_method_declaration7719 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_method_header7730 = new BitSet(new long[]{0x2100100800114010L,0x0000010408024400L,0x000C1300000001C4L,0x0000000003300060L});
    public static final BitSet FOLLOW_method_modifiers_in_method_header7733 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_partial_contextual_keyword_in_method_header7736 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_return_type_in_method_header7739 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_member_name_in_method_header7741 = new BitSet(new long[]{0x0000000000000000L,0x0000080010000000L});
    public static final BitSet FOLLOW_type_parameter_list_in_method_header7743 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_method_header7746 = new BitSet(new long[]{0x2000100804114000L,0x0000050008004400L,0x400811080000000AL,0x0000000002200060L});
    public static final BitSet FOLLOW_formal_parameter_list_in_method_header7748 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_method_header7751 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000400L});
    public static final BitSet FOLLOW_type_parameter_constraints_clauses_in_method_header7753 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_method_modifier_in_method_modifiers7765 = new BitSet(new long[]{0x0100000000000012L,0x0000000400020000L,0x00040200000001C4L,0x0000000001100000L});
    public static final BitSet FOLLOW_NEW_in_method_modifier7777 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PUBLIC_in_method_modifier7782 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PROTECTED_in_method_modifier7787 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INTERNAL_in_method_modifier7792 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PRIVATE_in_method_modifier7797 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STATIC_in_method_modifier7802 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_VIRTUAL_in_method_modifier7807 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_SEALED_in_method_modifier7812 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OVERRIDE_in_method_modifier7817 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_ABSTRACT_in_method_modifier7822 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_EXTERN_in_method_modifier7827 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_method_modifier_unsafe_in_method_modifier7832 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_type_in_return_type7845 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_VOID_in_return_type7850 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_interface_type_in_member_name7866 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_block_in_method_body7886 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_SEMICOLON_in_method_body7891 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_parameter_array_in_formal_parameter_list7915 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_fixed_parameters_in_formal_parameter_list7934 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_formal_parameter_list7946 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000000L,0x0000000000000008L});
    public static final BitSet FOLLOW_parameter_array_in_formal_parameter_list7948 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_fixed_parameter_in_fixed_parameters7980 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_fixed_parameters7992 = new BitSet(new long[]{0x2000100800114000L,0x0000050008004400L,0x4008110800000002L,0x0000000002200060L});
    public static final BitSet FOLLOW_fixed_parameter_in_fixed_parameters7995 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_attributes_in_fixed_parameter8013 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x4008110800000002L,0x0000000002200060L});
    public static final BitSet FOLLOW_parameter_modifier_in_fixed_parameter8016 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_type_in_fixed_parameter8019 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_fixed_parameter8021 = new BitSet(new long[]{0x0000000000000082L});
    public static final BitSet FOLLOW_default_argument_in_fixed_parameter8023 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_arglist_in_fixed_parameter8053 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_ASSIGNMENT_in_default_argument8077 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_expression_in_default_argument8080 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_parameter_modifier2_in_parameter_modifier8092 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_parameter_array8132 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
    public static final BitSet FOLLOW_PARAMS_in_parameter_array8135 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_array_type_in_parameter_array8137 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_parameter_array8139 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_property_declaration8166 = new BitSet(new long[]{0x2100100800114010L,0x0000010408024400L,0x000C1300000001C4L,0x0000000003300060L});
    public static final BitSet FOLLOW_property_modifiers_in_property_declaration8169 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_type_in_property_declaration8172 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_member_name_in_property_declaration8174 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_property_declaration8176 = new BitSet(new long[]{0x0000000000000000L,0x0000040000020400L,0x00000000000000C0L});
    public static final BitSet FOLLOW_accessor_declarations_in_property_declaration8178 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_property_declaration8180 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_property_modifier_in_property_modifiers8191 = new BitSet(new long[]{0x0100000000000012L,0x0000000400020000L,0x00040200000001C4L,0x0000000001100000L});
    public static final BitSet FOLLOW_NEW_in_property_modifier8203 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PUBLIC_in_property_modifier8208 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PROTECTED_in_property_modifier8213 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INTERNAL_in_property_modifier8218 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PRIVATE_in_property_modifier8223 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STATIC_in_property_modifier8228 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_VIRTUAL_in_property_modifier8233 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_SEALED_in_property_modifier8238 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OVERRIDE_in_property_modifier8243 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_ABSTRACT_in_property_modifier8248 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_EXTERN_in_property_modifier8253 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_property_modifier_unsafe_in_property_modifier8258 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_accessor_declarations8274 = new BitSet(new long[]{0x0000000000000000L,0x0000000000020400L,0x00000000000000C0L});
    public static final BitSet FOLLOW_accessor_modifier_in_accessor_declarations8283 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_get_contextual_keyword_in_accessor_declarations8293 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_accessor_body_in_accessor_declarations8295 = new BitSet(new long[]{0x0000000000000002L,0x0000040000020400L,0x00000000000000C0L});
    public static final BitSet FOLLOW_set_accessor_declaration_in_accessor_declarations8297 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_set_contextual_keyword_in_accessor_declarations8306 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_accessor_body_in_accessor_declarations8308 = new BitSet(new long[]{0x0000000000000002L,0x0000040000020400L,0x00000000000000C0L});
    public static final BitSet FOLLOW_get_accessor_declaration_in_accessor_declarations8310 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_get_accessor_declaration8329 = new BitSet(new long[]{0x0000000000000000L,0x0000000000020400L,0x00000000000000C0L});
    public static final BitSet FOLLOW_accessor_modifier_in_get_accessor_declaration8332 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_get_contextual_keyword_in_get_accessor_declaration8335 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_accessor_body_in_get_accessor_declaration8337 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_set_accessor_declaration8348 = new BitSet(new long[]{0x0000000000000000L,0x0000000000020400L,0x00000000000000C0L});
    public static final BitSet FOLLOW_accessor_modifier_in_set_accessor_declaration8351 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_set_contextual_keyword_in_set_accessor_declaration8354 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_accessor_body_in_set_accessor_declaration8356 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PROTECTED_in_accessor_modifier8367 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INTERNAL_in_accessor_modifier8372 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PRIVATE_in_accessor_modifier8377 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PROTECTED_in_accessor_modifier8382 = new BitSet(new long[]{0x0000000000000000L,0x0000000000020000L});
    public static final BitSet FOLLOW_INTERNAL_in_accessor_modifier8384 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INTERNAL_in_accessor_modifier8389 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000080L});
    public static final BitSet FOLLOW_PROTECTED_in_accessor_modifier8391 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_block_in_accessor_body8402 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_SEMICOLON_in_accessor_body8407 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_event_modifier_in_event_modifiers8422 = new BitSet(new long[]{0x0100000000000012L,0x0000000400020000L,0x00040200000001C4L,0x0000000001100000L});
    public static final BitSet FOLLOW_NEW_in_event_modifier8434 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PUBLIC_in_event_modifier8439 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PROTECTED_in_event_modifier8444 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INTERNAL_in_event_modifier8449 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PRIVATE_in_event_modifier8454 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STATIC_in_event_modifier8459 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_VIRTUAL_in_event_modifier8464 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_SEALED_in_event_modifier8469 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OVERRIDE_in_event_modifier8474 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_ABSTRACT_in_event_modifier8479 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_EXTERN_in_event_modifier8484 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_event_modifier_unsafe_in_event_modifier8489 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_event_accessor_declarations8500 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_add_contextual_keyword_in_event_accessor_declarations8508 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_block_in_event_accessor_declarations8510 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000400L});
    public static final BitSet FOLLOW_remove_accessor_declaration_in_event_accessor_declarations8512 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_remove_contextual_keyword_in_event_accessor_declarations8519 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_block_in_event_accessor_declarations8521 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000400L});
    public static final BitSet FOLLOW_add_accessor_declaration_in_event_accessor_declarations8523 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_add_accessor_declaration8539 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_add_contextual_keyword_in_add_accessor_declaration8542 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_block_in_add_accessor_declaration8544 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_remove_accessor_declaration8555 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_remove_contextual_keyword_in_remove_accessor_declaration8558 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_block_in_remove_accessor_declaration8560 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_indexer_declaration8571 = new BitSet(new long[]{0x2100100800114010L,0x0000010408024400L,0x00081300000001C4L,0x0000000003300060L});
    public static final BitSet FOLLOW_indexer_modifiers_in_indexer_declaration8574 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_indexer_declarator_in_indexer_declaration8577 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_indexer_declaration8579 = new BitSet(new long[]{0x0000000000000000L,0x0000040000020400L,0x00000000000000C0L});
    public static final BitSet FOLLOW_accessor_declarations_in_indexer_declaration8581 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_indexer_declaration8583 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_indexer_modifier_in_indexer_modifiers8594 = new BitSet(new long[]{0x0100000000000012L,0x0000000400020000L,0x00000200000001C4L,0x0000000001100000L});
    public static final BitSet FOLLOW_indexer_modifier_in_indexer_modifiers8598 = new BitSet(new long[]{0x0100000000000012L,0x0000000400020000L,0x00000200000001C4L,0x0000000001100000L});
    public static final BitSet FOLLOW_NEW_in_indexer_modifier8612 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PUBLIC_in_indexer_modifier8617 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PROTECTED_in_indexer_modifier8622 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INTERNAL_in_indexer_modifier8627 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PRIVATE_in_indexer_modifier8632 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_VIRTUAL_in_indexer_modifier8637 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_SEALED_in_indexer_modifier8642 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OVERRIDE_in_indexer_modifier8647 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_ABSTRACT_in_indexer_modifier8652 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_EXTERN_in_indexer_modifier8657 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_indexer_modifier_unsafe_in_indexer_modifier8662 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_type_in_indexer_declarator8676 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L,0x4000000000000000L});
    public static final BitSet FOLLOW_interface_type_in_indexer_declarator8679 = new BitSet(new long[]{0x0000080000000000L});
    public static final BitSet FOLLOW_DOT_in_indexer_declarator8681 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x4000000000000000L});
    public static final BitSet FOLLOW_THIS_in_indexer_declarator8685 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_OPEN_BRACKET_in_indexer_declarator8687 = new BitSet(new long[]{0x2000100800114000L,0x0000050008004400L,0x400811080000000AL,0x0000000002200060L});
    public static final BitSet FOLLOW_formal_parameter_list_in_indexer_declarator8689 = new BitSet(new long[]{0x0000000002000000L});
    public static final BitSet FOLLOW_CLOSE_BRACKET_in_indexer_declarator8691 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_operator_declaration8703 = new BitSet(new long[]{0x0100000000000000L,0x0000000000000000L,0x0004000000000100L,0x0000000000100000L});
    public static final BitSet FOLLOW_operator_modifiers_in_operator_declaration8706 = new BitSet(new long[]{0x2080100800114000L,0x0000010008005400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_operator_declarator_in_operator_declaration8708 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_operator_body_in_operator_declaration8710 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_operator_modifier_in_operator_modifiers8721 = new BitSet(new long[]{0x0100000000000002L,0x0000000000000000L,0x0004000000000100L,0x0000000000100000L});
    public static final BitSet FOLLOW_operator_modifier_in_operator_modifiers8725 = new BitSet(new long[]{0x0100000000000002L,0x0000000000000000L,0x0004000000000100L,0x0000000000100000L});
    public static final BitSet FOLLOW_PUBLIC_in_operator_modifier8739 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STATIC_in_operator_modifier8744 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_EXTERN_in_operator_modifier8749 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_operator_modifier_unsafe_in_operator_modifier8754 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_unary_operator_declarator_in_operator_declarator8774 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_binary_operator_declarator_in_operator_declarator8780 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_conversion_operator_declarator_in_operator_declarator8786 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_type_in_unary_operator_declarator8798 = new BitSet(new long[]{0x0000000000000000L,0x0000100000000000L});
    public static final BitSet FOLLOW_OPERATOR_in_unary_operator_declarator8800 = new BitSet(new long[]{0x0400000000000800L,0x0022000100000000L,0x0000000000000020L,0x0000000000000003L});
    public static final BitSet FOLLOW_overloadable_unary_operator_in_unary_operator_declarator8802 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_unary_operator_declarator8804 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_type_in_unary_operator_declarator8806 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_unary_operator_declarator8808 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_unary_operator_declarator8810 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_type_in_binary_operator_declarator8867 = new BitSet(new long[]{0x0000000000000000L,0x0000100000000000L});
    public static final BitSet FOLLOW_OPERATOR_in_binary_operator_declarator8869 = new BitSet(new long[]{0x0000020000022020L,0x08D8000110000020L,0x0002000000000030L});
    public static final BitSet FOLLOW_overloadable_binary_operator_in_binary_operator_declarator8871 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_binary_operator_declarator8873 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_type_in_binary_operator_declarator8875 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_binary_operator_declarator8877 = new BitSet(new long[]{0x0000000010000000L});
    public static final BitSet FOLLOW_COMMA_in_binary_operator_declarator8879 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_type_in_binary_operator_declarator8881 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_binary_operator_declarator8883 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_binary_operator_declarator8885 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PLUS_in_overloadable_binary_operator8896 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_MINUS_in_overloadable_binary_operator8901 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STAR_in_overloadable_binary_operator8906 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_DIV_in_overloadable_binary_operator8911 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PERCENT_in_overloadable_binary_operator8916 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_AMP_in_overloadable_binary_operator8921 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_BITWISE_OR_in_overloadable_binary_operator8926 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_CARET_in_overloadable_binary_operator8931 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_LEFT_SHIFT_in_overloadable_binary_operator8936 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_right_shift_in_overloadable_binary_operator8941 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_EQ_in_overloadable_binary_operator8946 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_NE_in_overloadable_binary_operator8951 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_GT_in_overloadable_binary_operator8956 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_LT_in_overloadable_binary_operator8961 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_GE_in_overloadable_binary_operator8966 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_LE_in_overloadable_binary_operator8971 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PLUS_in_overloadable_operator8985 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_MINUS_in_overloadable_operator8991 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_BANG_in_overloadable_operator8997 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_TILDE_in_overloadable_operator9003 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_INC_in_overloadable_operator9009 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_DEC_in_overloadable_operator9015 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_TRUE_in_overloadable_operator9021 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_FALSE_in_overloadable_operator9027 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STAR_in_overloadable_operator9033 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_DIV_in_overloadable_operator9039 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PERCENT_in_overloadable_operator9045 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_AMP_in_overloadable_operator9051 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_BITWISE_OR_in_overloadable_operator9057 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_CARET_in_overloadable_operator9063 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_LEFT_SHIFT_in_overloadable_operator9069 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_right_shift_in_overloadable_operator9075 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_EQ_in_overloadable_operator9081 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_NE_in_overloadable_operator9087 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_GT_in_overloadable_operator9093 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_LT_in_overloadable_operator9099 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_GE_in_overloadable_operator9105 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_LE_in_overloadable_operator9111 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IMPLICIT_in_conversion_operator_declarator9124 = new BitSet(new long[]{0x0000000000000000L,0x0000100000000000L});
    public static final BitSet FOLLOW_OPERATOR_in_conversion_operator_declarator9127 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_type_in_conversion_operator_declarator9129 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_conversion_operator_declarator9131 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_type_in_conversion_operator_declarator9133 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_conversion_operator_declarator9135 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_conversion_operator_declarator9137 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_EXPLICIT_in_conversion_operator_declarator9142 = new BitSet(new long[]{0x0000000000000000L,0x0000100000000000L});
    public static final BitSet FOLLOW_OPERATOR_in_conversion_operator_declarator9145 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_type_in_conversion_operator_declarator9147 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_conversion_operator_declarator9149 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_type_in_conversion_operator_declarator9151 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_conversion_operator_declarator9153 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_conversion_operator_declarator9155 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_block_in_operator_body9166 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_SEMICOLON_in_operator_body9171 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_constructor_declaration9182 = new BitSet(new long[]{0x0100000000000000L,0x0000000000020400L,0x00000000000001C0L,0x0000000000100000L});
    public static final BitSet FOLLOW_constructor_modifiers_in_constructor_declaration9185 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_constructor_declarator_in_constructor_declaration9188 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_constructor_body_in_constructor_declaration9190 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_constructor_modifier_in_constructor_modifiers9201 = new BitSet(new long[]{0x0100000000000002L,0x0000000000020000L,0x00000000000001C0L,0x0000000000100000L});
    public static final BitSet FOLLOW_PUBLIC_in_constructor_modifier9213 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PROTECTED_in_constructor_modifier9218 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INTERNAL_in_constructor_modifier9223 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PRIVATE_in_constructor_modifier9228 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_EXTERN_in_constructor_modifier9233 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_constructor_modifier_unsafe_in_constructor_modifier9238 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_constructor_declarator9249 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_constructor_declarator9251 = new BitSet(new long[]{0x2000100804114000L,0x0000050008004400L,0x400811080000000AL,0x0000000002200060L});
    public static final BitSet FOLLOW_formal_parameter_list_in_constructor_declarator9253 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_constructor_declarator9256 = new BitSet(new long[]{0x0000000008000002L});
    public static final BitSet FOLLOW_constructor_initializer_in_constructor_declarator9258 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_COLON_in_constructor_initializer9270 = new BitSet(new long[]{0x0000000000001000L});
    public static final BitSet FOLLOW_BASE_in_constructor_initializer9272 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_constructor_initializer9274 = new BitSet(new long[]{0x2400106804715820L,0x002209250800C400L,0x401A910C00000022L,0x00000000002000EBL});
    public static final BitSet FOLLOW_argument_list_in_constructor_initializer9276 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_constructor_initializer9279 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_COLON_in_constructor_initializer9284 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x4000000000000000L});
    public static final BitSet FOLLOW_THIS_in_constructor_initializer9286 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_constructor_initializer9288 = new BitSet(new long[]{0x2400106804715820L,0x002209250800C400L,0x401A910C00000022L,0x00000000002000EBL});
    public static final BitSet FOLLOW_argument_list_in_constructor_initializer9290 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_constructor_initializer9293 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_block_in_constructor_body9304 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_SEMICOLON_in_constructor_body9309 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_static_constructor_declaration9320 = new BitSet(new long[]{0x0100000000000000L,0x0000000000000000L,0x0004000000000000L,0x0000000000100000L});
    public static final BitSet FOLLOW_static_constructor_modifiers_in_static_constructor_declaration9323 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_static_constructor_declaration9325 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_static_constructor_declaration9327 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_static_constructor_declaration9329 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_static_constructor_body_in_static_constructor_declaration9331 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_static_constructor_modifiers_unsafe_in_static_constructor_modifiers9345 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_block_in_static_constructor_body9357 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_SEMICOLON_in_static_constructor_body9362 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_destructor_declaration_unsafe_in_destructor_declaration9375 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_block_in_destructor_body9386 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_SEMICOLON_in_destructor_body9391 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_block_in_body9403 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_SEMICOLON_in_body9409 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_struct_declaration9425 = new BitSet(new long[]{0x0000000000000000L,0x0000000400020400L,0x00200000000001C0L,0x0000000000100000L});
    public static final BitSet FOLLOW_struct_modifiers_in_struct_declaration9428 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L,0x0020000000000000L});
    public static final BitSet FOLLOW_partial_contextual_keyword_in_struct_declaration9431 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
    public static final BitSet FOLLOW_STRUCT_in_struct_declaration9438 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_struct_declaration9440 = new BitSet(new long[]{0x0000000008000000L,0x0000020010000400L});
    public static final BitSet FOLLOW_type_parameter_list_in_struct_declaration9442 = new BitSet(new long[]{0x0000000008000000L,0x0000020000000400L});
    public static final BitSet FOLLOW_struct_interfaces_in_struct_declaration9445 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000400L});
    public static final BitSet FOLLOW_type_parameter_constraints_clauses_in_struct_declaration9448 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_struct_body_in_struct_declaration9451 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_struct_declaration9453 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_struct_modifier_in_struct_modifiers9465 = new BitSet(new long[]{0x0000000000000002L,0x0000000400020000L,0x00000000000001C0L,0x0000000000100000L});
    public static final BitSet FOLLOW_struct_modifier_in_struct_modifiers9469 = new BitSet(new long[]{0x0000000000000002L,0x0000000400020000L,0x00000000000001C0L,0x0000000000100000L});
    public static final BitSet FOLLOW_NEW_in_struct_modifier9483 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PUBLIC_in_struct_modifier9488 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PROTECTED_in_struct_modifier9493 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INTERNAL_in_struct_modifier9498 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PRIVATE_in_struct_modifier9503 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_struct_modifier_unsafe_in_struct_modifier9508 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_COLON_in_struct_interfaces9519 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_interface_type_list_in_struct_interfaces9522 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_struct_body9533 = new BitSet(new long[]{0x31E0104821914010L,0x0000050408035400L,0x002C1302000001C4L,0x0000000007300060L});
    public static final BitSet FOLLOW_struct_member_declarations_in_struct_body9536 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_struct_body9539 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_struct_member_declaration_in_struct_member_declarations9551 = new BitSet(new long[]{0x31E0104820914012L,0x0000050408035400L,0x002C1302000001C4L,0x0000000007300060L});
    public static final BitSet FOLLOW_struct_member_declaration_in_struct_member_declarations9555 = new BitSet(new long[]{0x31E0104820914012L,0x0000050408035400L,0x002C1302000001C4L,0x0000000007300060L});
    public static final BitSet FOLLOW_attributes_in_struct_member_declaration9583 = new BitSet(new long[]{0x31E0104820914010L,0x0000010408035400L,0x002C1302000001C4L,0x0000000007300060L});
    public static final BitSet FOLLOW_all_member_modifiers_in_struct_member_declaration9593 = new BitSet(new long[]{0x30E0104820914000L,0x0000010008015400L,0x0028110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_common_member_declaration_in_struct_member_declaration9603 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_FIXED_in_struct_member_declaration9610 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_buffer_element_type_in_struct_member_declaration9613 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_fixed_size_buffer_declarators_in_struct_member_declaration9615 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_struct_member_declaration9617 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_array_type2_in_array_type9639 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_base_type_in_array_type29658 = new BitSet(new long[]{0x0000000000000000L,0x0000040000040000L,0x0002000000000000L});
    public static final BitSet FOLLOW_rank_specifier_in_array_type29670 = new BitSet(new long[]{0x0000000000000002L,0x0000040000040000L,0x0002000000000000L});
    public static final BitSet FOLLOW_non_array_type2_in_non_array_type9688 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_base_type_in_non_array_type29708 = new BitSet(new long[]{0x0000000000000002L,0x0000040000040000L,0x0002000000000000L});
    public static final BitSet FOLLOW_rank_specifier_in_non_array_type29711 = new BitSet(new long[]{0x0000000000000002L,0x0000040000040000L,0x0002000000000000L});
    public static final BitSet FOLLOW_INTERR_in_non_array_type29715 = new BitSet(new long[]{0x0000000000000002L,0x0000040000040000L,0x0002000000000000L});
    public static final BitSet FOLLOW_STAR_in_non_array_type29719 = new BitSet(new long[]{0x0000000000000002L,0x0000040000040000L,0x0002000000000000L});
    public static final BitSet FOLLOW_rank_specifier_in_rank_specifiers9737 = new BitSet(new long[]{0x0000000000000002L,0x0000040000000000L});
    public static final BitSet FOLLOW_OPEN_BRACKET_in_rank_specifier9752 = new BitSet(new long[]{0x0000000012000000L});
    public static final BitSet FOLLOW_dim_separators_in_rank_specifier9754 = new BitSet(new long[]{0x0000000002000000L});
    public static final BitSet FOLLOW_CLOSE_BRACKET_in_rank_specifier9757 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_COMMA_in_dim_separators9780 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_array_initializer9797 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_array_initializer9799 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_array_initializer9805 = new BitSet(new long[]{0x2400106800715820L,0x00220B250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_variable_initializer_list_in_array_initializer9807 = new BitSet(new long[]{0x0000000011000000L});
    public static final BitSet FOLLOW_COMMA_in_array_initializer9809 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_array_initializer9812 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_variable_initializer_in_variable_initializer_list9824 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_variable_initializer_list9828 = new BitSet(new long[]{0x2400106800715820L,0x00220B250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_variable_initializer_in_variable_initializer_list9831 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_attributes_in_interface_declaration9846 = new BitSet(new long[]{0x0000000000000000L,0x0000000400030400L,0x00000000000001C0L,0x0000000000100000L});
    public static final BitSet FOLLOW_interface_modifiers_in_interface_declaration9849 = new BitSet(new long[]{0x0000000000000000L,0x0000000000010400L});
    public static final BitSet FOLLOW_partial_contextual_keyword_in_interface_declaration9852 = new BitSet(new long[]{0x0000000000000000L,0x0000000000010000L});
    public static final BitSet FOLLOW_INTERFACE_in_interface_declaration9855 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_interface_declaration9857 = new BitSet(new long[]{0x0000000008000000L,0x0000020010000400L});
    public static final BitSet FOLLOW_variant_type_parameter_list_in_interface_declaration9859 = new BitSet(new long[]{0x0000000008000000L,0x0000020000000400L});
    public static final BitSet FOLLOW_interface_base_in_interface_declaration9862 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000400L});
    public static final BitSet FOLLOW_type_parameter_constraints_clauses_in_interface_declaration9865 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_interface_body_in_interface_declaration9868 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_interface_declaration9870 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_interface_modifier_in_interface_modifiers9882 = new BitSet(new long[]{0x0000000000000002L,0x0000000400020000L,0x00000000000001C0L,0x0000000000100000L});
    public static final BitSet FOLLOW_interface_modifier_in_interface_modifiers9886 = new BitSet(new long[]{0x0000000000000002L,0x0000000400020000L,0x00000000000001C0L,0x0000000000100000L});
    public static final BitSet FOLLOW_NEW_in_interface_modifier9900 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PUBLIC_in_interface_modifier9905 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PROTECTED_in_interface_modifier9910 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INTERNAL_in_interface_modifier9915 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PRIVATE_in_interface_modifier9920 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_interface_modifier_unsafe_in_interface_modifier9925 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_LT_in_variant_type_parameter_list9936 = new BitSet(new long[]{0x0000000000000000L,0x0000040000002400L,0x0000000000000002L});
    public static final BitSet FOLLOW_variant_type_parameters_in_variant_type_parameter_list9939 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000020L});
    public static final BitSet FOLLOW_GT_in_variant_type_parameter_list9941 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributed_variance_type_parameter_in_variant_type_parameters9953 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_variant_type_parameters9957 = new BitSet(new long[]{0x0000000000000000L,0x0000040000002400L,0x0000000000000002L});
    public static final BitSet FOLLOW_attributed_variance_type_parameter_in_variant_type_parameters9959 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_attributes_in_attributed_variance_type_parameter9987 = new BitSet(new long[]{0x0000000000000000L,0x0000000000002400L,0x0000000000000002L});
    public static final BitSet FOLLOW_variance_annotation_in_attributed_variance_type_parameter9990 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_type_parameter_in_attributed_variance_type_parameter9993 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IN_in_variance_annotation10005 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OUT_in_variance_annotation10020 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_COLON_in_interface_base10040 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_interface_type_list_in_interface_base10043 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_interface_body10054 = new BitSet(new long[]{0x2040100801114000L,0x0000050408004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_interface_member_declarations_in_interface_body10057 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_interface_body10060 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_interface_member_declaration_in_interface_member_declarations10072 = new BitSet(new long[]{0x2040100800114002L,0x0000050408004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_attributes_in_interface_member_declaration10100 = new BitSet(new long[]{0x2040100800114000L,0x0000010408004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_NEW_in_interface_member_declaration10103 = new BitSet(new long[]{0x2040100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_type_in_interface_member_declaration10112 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L,0x4000000000000000L});
    public static final BitSet FOLLOW_interface_method_declaration2_in_interface_member_declaration10122 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_interface_property_declaration2_in_interface_member_declaration10133 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_interface_indexer_declaration2_in_interface_member_declaration10144 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_type_void_in_interface_member_declaration10161 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_interface_method_declaration2_in_interface_member_declaration10163 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_interface_event_declaration2_in_interface_member_declaration10172 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_interface_method_declaration10191 = new BitSet(new long[]{0x2000100800114000L,0x0000010408004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_NEW_in_interface_method_declaration10194 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_return_type_in_interface_method_declaration10197 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_interface_method_declaration10199 = new BitSet(new long[]{0x0000000000000000L,0x0000080010000000L});
    public static final BitSet FOLLOW_type_parameter_list_in_interface_method_declaration10201 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_interface_method_declaration10204 = new BitSet(new long[]{0x2000100804114000L,0x0000050008004400L,0x400811080000000AL,0x0000000002200060L});
    public static final BitSet FOLLOW_formal_parameter_list_in_interface_method_declaration10206 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_interface_method_declaration10209 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L,0x0000040000000000L});
    public static final BitSet FOLLOW_type_parameter_constraints_clauses_in_interface_method_declaration10211 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_interface_method_declaration10214 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_interface_property_declaration10225 = new BitSet(new long[]{0x2000100800114000L,0x0000010408004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_NEW_in_interface_property_declaration10228 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_type_in_interface_property_declaration10231 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_interface_property_declaration10233 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_interface_property_declaration10235 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000400L});
    public static final BitSet FOLLOW_interface_accessors_in_interface_property_declaration10237 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_interface_property_declaration10239 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_interface_accessors10253 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_get_contextual_keyword_in_interface_accessors10262 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_interface_accessors10264 = new BitSet(new long[]{0x0000000000000002L,0x0000040000000400L});
    public static final BitSet FOLLOW_attributes_in_interface_accessors10267 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_set_contextual_keyword_in_interface_accessors10270 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_interface_accessors10272 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_set_contextual_keyword_in_interface_accessors10282 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_interface_accessors10284 = new BitSet(new long[]{0x0000000000000002L,0x0000040000000400L});
    public static final BitSet FOLLOW_attributes_in_interface_accessors10287 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_get_contextual_keyword_in_interface_accessors10290 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_interface_accessors10292 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_interface_event_declaration10312 = new BitSet(new long[]{0x0040000000000000L,0x0000000400000000L});
    public static final BitSet FOLLOW_NEW_in_interface_event_declaration10315 = new BitSet(new long[]{0x0040000000000000L});
    public static final BitSet FOLLOW_EVENT_in_interface_event_declaration10318 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_type_in_interface_event_declaration10320 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_interface_event_declaration10322 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_interface_event_declaration10324 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_interface_indexer_declaration10335 = new BitSet(new long[]{0x2000100800114000L,0x0000010408004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_NEW_in_interface_indexer_declaration10338 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_type_in_interface_indexer_declaration10341 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x4000000000000000L});
    public static final BitSet FOLLOW_THIS_in_interface_indexer_declaration10343 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_OPEN_BRACKET_in_interface_indexer_declaration10345 = new BitSet(new long[]{0x2000100800114000L,0x0000050008004400L,0x400811080000000AL,0x0000000002200060L});
    public static final BitSet FOLLOW_formal_parameter_list_in_interface_indexer_declaration10347 = new BitSet(new long[]{0x0000000002000000L});
    public static final BitSet FOLLOW_CLOSE_BRACKET_in_interface_indexer_declaration10349 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_interface_indexer_declaration10351 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000400L});
    public static final BitSet FOLLOW_interface_accessors_in_interface_indexer_declaration10353 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_interface_indexer_declaration10355 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_enum_declaration10369 = new BitSet(new long[]{0x0020000000000000L,0x0000000400020000L,0x00000000000001C0L});
    public static final BitSet FOLLOW_enum_modifiers_in_enum_declaration10372 = new BitSet(new long[]{0x0020000000000000L});
    public static final BitSet FOLLOW_ENUM_in_enum_declaration10375 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_enum_declaration10377 = new BitSet(new long[]{0x0000000008000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_enum_base_in_enum_declaration10379 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_enum_body_in_enum_declaration10382 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_enum_declaration10384 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_COLON_in_enum_base10396 = new BitSet(new long[]{0x0000000000110000L,0x0000000008004000L,0x0000110000000000L,0x0000000000200060L});
    public static final BitSet FOLLOW_integral_type_in_enum_base10398 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_enum_body10423 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_enum_body10426 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_enum_body10433 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000400L});
    public static final BitSet FOLLOW_enum_member_declarations_in_enum_body10436 = new BitSet(new long[]{0x0000000011000000L});
    public static final BitSet FOLLOW_COMMA_in_enum_body10438 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_enum_body10442 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_enum_modifier_in_enum_modifiers10455 = new BitSet(new long[]{0x0000000000000002L,0x0000000400020000L,0x00000000000001C0L});
    public static final BitSet FOLLOW_enum_member_declaration_in_enum_member_declarations10498 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_enum_member_declarations10502 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000400L});
    public static final BitSet FOLLOW_enum_member_declaration_in_enum_member_declarations10505 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_attributes_in_enum_member_declaration10534 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_enum_member_declaration10537 = new BitSet(new long[]{0x0000000000000082L});
    public static final BitSet FOLLOW_ASSIGNMENT_in_enum_member_declaration10540 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_constant_expression_in_enum_member_declaration10542 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_delegate_declaration10583 = new BitSet(new long[]{0x0000004000000000L,0x0000000400020000L,0x00000000000001C0L,0x0000000000100000L});
    public static final BitSet FOLLOW_delegate_modifiers_in_delegate_declaration10586 = new BitSet(new long[]{0x0000004000000000L});
    public static final BitSet FOLLOW_DELEGATE_in_delegate_declaration10589 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_return_type_in_delegate_declaration10591 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_delegate_declaration10593 = new BitSet(new long[]{0x0000000000000000L,0x0000080010000000L});
    public static final BitSet FOLLOW_variant_type_parameter_list_in_delegate_declaration10595 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_delegate_declaration10604 = new BitSet(new long[]{0x2000100804114000L,0x0000050008004400L,0x400811080000000AL,0x0000000002200060L});
    public static final BitSet FOLLOW_formal_parameter_list_in_delegate_declaration10606 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_delegate_declaration10609 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L,0x0000040000000000L});
    public static final BitSet FOLLOW_type_parameter_constraints_clauses_in_delegate_declaration10611 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_delegate_declaration10614 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_delegate_modifier_in_delegate_modifiers10625 = new BitSet(new long[]{0x0000000000000002L,0x0000000400020000L,0x00000000000001C0L,0x0000000000100000L});
    public static final BitSet FOLLOW_delegate_modifier_in_delegate_modifiers10629 = new BitSet(new long[]{0x0000000000000002L,0x0000000400020000L,0x00000000000001C0L,0x0000000000100000L});
    public static final BitSet FOLLOW_NEW_in_delegate_modifier10643 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PUBLIC_in_delegate_modifier10648 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PROTECTED_in_delegate_modifier10653 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INTERNAL_in_delegate_modifier10658 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PRIVATE_in_delegate_modifier10663 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_delegate_modifier_unsafe_in_delegate_modifier10668 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_global_attribute_sections_in_global_attributes10683 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_global_attribute_section_in_global_attribute_sections10694 = new BitSet(new long[]{0x0000000000000002L,0x0000040000000000L});
    public static final BitSet FOLLOW_OPEN_BRACKET_in_global_attribute_section10709 = new BitSet(new long[]{0xFDF0146860DDD050L,0x000011260C0B7C10L,0xC06D931A000001CEL,0x00000000277000EEL});
    public static final BitSet FOLLOW_global_attribute_target_specifier_in_global_attribute_section10712 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_attribute_list_in_global_attribute_section10714 = new BitSet(new long[]{0x0000000012000000L});
    public static final BitSet FOLLOW_COMMA_in_global_attribute_section10716 = new BitSet(new long[]{0x0000000002000000L});
    public static final BitSet FOLLOW_CLOSE_BRACKET_in_global_attribute_section10720 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_global_attribute_target_in_global_attribute_target_specifier10733 = new BitSet(new long[]{0x0000000008000000L});
    public static final BitSet FOLLOW_COLON_in_global_attribute_target_specifier10735 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_keyword_in_global_attribute_target10748 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_global_attribute_target10754 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attribute_sections_in_attributes10768 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attribute_section_in_attribute_sections10779 = new BitSet(new long[]{0x0000000000000002L,0x0000040000000000L});
    public static final BitSet FOLLOW_OPEN_BRACKET_in_attribute_section10806 = new BitSet(new long[]{0xFDF0146860DDD050L,0x000011260C0B7C10L,0xC06D931A000001CEL,0x00000000277000EEL});
    public static final BitSet FOLLOW_attribute_target_specifier_in_attribute_section10809 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_attribute_list_in_attribute_section10812 = new BitSet(new long[]{0x0000000012000000L});
    public static final BitSet FOLLOW_COMMA_in_attribute_section10814 = new BitSet(new long[]{0x0000000002000000L});
    public static final BitSet FOLLOW_CLOSE_BRACKET_in_attribute_section10818 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attribute_target_in_attribute_target_specifier10831 = new BitSet(new long[]{0x0000000008000000L});
    public static final BitSet FOLLOW_COLON_in_attribute_target_specifier10833 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_keyword_in_attribute_target10856 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_attribute_target10860 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attribute_in_attribute_list10874 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_attribute_list10878 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_attribute_in_attribute_list10881 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_attribute_name_in_attribute10908 = new BitSet(new long[]{0x0000000000000002L,0x0000080000000000L});
    public static final BitSet FOLLOW_attribute_arguments_in_attribute10910 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_type_name_in_attribute_name10940 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_attribute_arguments10969 = new BitSet(new long[]{0x2400106804715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_positional_argument_list_in_attribute_arguments10972 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_attribute_arguments10975 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_positional_argument_in_positional_argument_list10988 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_positional_argument_list10991 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_positional_argument_in_positional_argument_list10993 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_attribute_argument_expression_in_positional_argument11022 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_named_argument_in_named_argument_list11035 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_named_argument_list11039 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_named_argument_in_named_argument_list11042 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_named_argument11058 = new BitSet(new long[]{0x0000000000000080L});
    public static final BitSet FOLLOW_ASSIGNMENT_in_named_argument11060 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_attribute_argument_expression_in_named_argument11062 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_expression_in_attribute_argument_expression11073 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_UNSAFE_in_class_modifier_unsafe11087 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_UNSAFE_in_struct_modifier_unsafe11098 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_UNSAFE_in_interface_modifier_unsafe11109 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_UNSAFE_in_delegate_modifier_unsafe11120 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_UNSAFE_in_field_modifier_unsafe11131 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_UNSAFE_in_method_modifier_unsafe11142 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_UNSAFE_in_property_modifier_unsafe11153 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_UNSAFE_in_event_modifier_unsafe11164 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_UNSAFE_in_indexer_modifier_unsafe11175 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_UNSAFE_in_operator_modifier_unsafe11186 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_UNSAFE_in_constructor_modifier_unsafe11197 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_destructor_declaration_unsafe11211 = new BitSet(new long[]{0x0100000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000100001L});
    public static final BitSet FOLLOW_EXTERN_in_destructor_declaration_unsafe11220 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000100001L});
    public static final BitSet FOLLOW_UNSAFE_in_destructor_declaration_unsafe11223 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000001L});
    public static final BitSet FOLLOW_UNSAFE_in_destructor_declaration_unsafe11232 = new BitSet(new long[]{0x0100000000000000L});
    public static final BitSet FOLLOW_EXTERN_in_destructor_declaration_unsafe11234 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000001L});
    public static final BitSet FOLLOW_TILDE_in_destructor_declaration_unsafe11248 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_destructor_declaration_unsafe11251 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_destructor_declaration_unsafe11253 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_destructor_declaration_unsafe11255 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_destructor_body_in_destructor_declaration_unsafe11257 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STATIC_in_static_constructor_modifiers_unsafe11281 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_EXTERN_in_static_constructor_modifiers_unsafe11287 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000100000L});
    public static final BitSet FOLLOW_UNSAFE_in_static_constructor_modifiers_unsafe11289 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0004000000000000L});
    public static final BitSet FOLLOW_STATIC_in_static_constructor_modifiers_unsafe11291 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_UNSAFE_in_static_constructor_modifiers_unsafe11297 = new BitSet(new long[]{0x0100000000000000L});
    public static final BitSet FOLLOW_EXTERN_in_static_constructor_modifiers_unsafe11299 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0004000000000000L});
    public static final BitSet FOLLOW_STATIC_in_static_constructor_modifiers_unsafe11301 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_EXTERN_in_static_constructor_modifiers_unsafe11307 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0004000000000000L});
    public static final BitSet FOLLOW_STATIC_in_static_constructor_modifiers_unsafe11309 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000100000L});
    public static final BitSet FOLLOW_UNSAFE_in_static_constructor_modifiers_unsafe11311 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_UNSAFE_in_static_constructor_modifiers_unsafe11317 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0004000000000000L});
    public static final BitSet FOLLOW_STATIC_in_static_constructor_modifiers_unsafe11319 = new BitSet(new long[]{0x0100000000000000L});
    public static final BitSet FOLLOW_EXTERN_in_static_constructor_modifiers_unsafe11321 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STATIC_in_static_constructor_modifiers_unsafe11327 = new BitSet(new long[]{0x0100000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000100000L});
    public static final BitSet FOLLOW_set_in_static_constructor_modifiers_unsafe11329 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STATIC_in_static_constructor_modifiers_unsafe11341 = new BitSet(new long[]{0x0100000000000000L});
    public static final BitSet FOLLOW_EXTERN_in_static_constructor_modifiers_unsafe11343 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000100000L});
    public static final BitSet FOLLOW_UNSAFE_in_static_constructor_modifiers_unsafe11345 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STATIC_in_static_constructor_modifiers_unsafe11351 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000100000L});
    public static final BitSet FOLLOW_UNSAFE_in_static_constructor_modifiers_unsafe11353 = new BitSet(new long[]{0x0100000000000000L});
    public static final BitSet FOLLOW_EXTERN_in_static_constructor_modifiers_unsafe11355 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_unsafe_statement_in_embedded_statement_unsafe11369 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_fixed_statement_in_embedded_statement_unsafe11374 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_UNSAFE_in_unsafe_statement11385 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_block_in_unsafe_statement11387 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_pointer_type_in_type_unsafe11398 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_simple_type_in_pointer_type11420 = new BitSet(new long[]{0x0000000000000000L,0x0000040000040000L,0x0002000000000000L});
    public static final BitSet FOLLOW_class_type_in_pointer_type11427 = new BitSet(new long[]{0x0000000000000000L,0x0000040000040000L,0x0002000000000000L});
    public static final BitSet FOLLOW_VOID_in_pointer_type11434 = new BitSet(new long[]{0x0000000000000000L,0x0000040000040000L,0x0002000000000000L});
    public static final BitSet FOLLOW_rank_specifier_in_pointer_type11448 = new BitSet(new long[]{0x0000000000000000L,0x0000040000040000L,0x0002000000000000L});
    public static final BitSet FOLLOW_INTERR_in_pointer_type11460 = new BitSet(new long[]{0x0000000000000000L,0x0000040000040000L,0x0002000000000000L});
    public static final BitSet FOLLOW_STAR_in_pointer_type11468 = new BitSet(new long[]{0x0000000000000000L,0x0000040000040000L,0x0002000000000000L});
    public static final BitSet FOLLOW_STAR_in_pointer_type11479 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_type_in_unmanaged_type11502 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_primary_expression_in_primary_no_array_creation_expression_unsafe11515 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_pointer_indirection_expression_in_unary_expression_unsafe11528 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_addressof_expression_in_unary_expression_unsafe11533 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STAR_in_pointer_indirection_expression11544 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_unary_expression_in_pointer_indirection_expression11546 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_AMP_in_addressof_expression11563 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_unary_expression_in_addressof_expression11565 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_SIZEOF_in_sizeof_expression11576 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_sizeof_expression11578 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_unmanaged_type_in_sizeof_expression11580 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_sizeof_expression11582 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_FIXED_in_fixed_statement11593 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_fixed_statement11595 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_pointer_type_in_fixed_statement11597 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_fixed_pointer_declarators_in_fixed_statement11599 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_fixed_statement11601 = new BitSet(new long[]{0xF40014684071D820L,0x00220B250C00CC10L,0xC05A951400000020L,0x00000000207000EFL});
    public static final BitSet FOLLOW_embedded_statement_in_fixed_statement11603 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_fixed_pointer_declarator_in_fixed_pointer_declarators11614 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_fixed_pointer_declarators11618 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_fixed_pointer_declarator_in_fixed_pointer_declarators11621 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_fixed_pointer_declarator11635 = new BitSet(new long[]{0x0000000000000080L});
    public static final BitSet FOLLOW_ASSIGNMENT_in_fixed_pointer_declarator11637 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_fixed_pointer_initializer_in_fixed_pointer_declarator11639 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_AMP_in_fixed_pointer_initializer11659 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_variable_reference_in_fixed_pointer_initializer11661 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_expression_in_fixed_pointer_initializer11667 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_fixed_size_buffer_declaration_in_struct_member_declaration_unsafe11679 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_fixed_size_buffer_declaration11690 = new BitSet(new long[]{0x1000000000000000L,0x0000000400020000L,0x00000000000001C0L,0x0000000000100000L});
    public static final BitSet FOLLOW_fixed_size_buffer_modifiers_in_fixed_size_buffer_declaration11693 = new BitSet(new long[]{0x1000000000000000L});
    public static final BitSet FOLLOW_FIXED_in_fixed_size_buffer_declaration11696 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_buffer_element_type_in_fixed_size_buffer_declaration11698 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_fixed_size_buffer_declarators_in_fixed_size_buffer_declaration11700 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_fixed_size_buffer_declaration11702 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_fixed_size_buffer_modifier_in_fixed_size_buffer_modifiers11713 = new BitSet(new long[]{0x0000000000000002L,0x0000000400020000L,0x00000000000001C0L,0x0000000000100000L});
    public static final BitSet FOLLOW_type_in_buffer_element_type11761 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_fixed_size_buffer_declarator_in_fixed_size_buffer_declarators11772 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_fixed_size_buffer_declarator11784 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_OPEN_BRACKET_in_fixed_size_buffer_declarator11786 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_constant_expression_in_fixed_size_buffer_declarator11788 = new BitSet(new long[]{0x0000000002000000L});
    public static final BitSet FOLLOW_CLOSE_BRACKET_in_fixed_size_buffer_declarator11790 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_stackalloc_initializer_in_local_variable_initializer_unsafe11803 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STACKALLOC_in_stackalloc_initializer11814 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_unmanaged_type_in_stackalloc_initializer11816 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_OPEN_BRACKET_in_stackalloc_initializer11818 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x00000000002000EBL});
    public static final BitSet FOLLOW_expression_in_stackalloc_initializer11820 = new BitSet(new long[]{0x0000000002000000L});
    public static final BitSet FOLLOW_CLOSE_BRACKET_in_stackalloc_initializer11822 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_from_contextual_keyword11844 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_let_contextual_keyword11858 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_where_contextual_keyword11872 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_join_contextual_keyword11886 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_on_contextual_keyword11900 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_equals_contextual_keyword11914 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_into_contextual_keyword11928 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_orderby_contextual_keyword11942 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_ascending_contextual_keyword11956 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_descending_contextual_keyword11970 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_select_contextual_keyword11984 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_group_contextual_keyword11998 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_by_contextual_keyword12012 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_partial_contextual_keyword12026 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_alias_contextual_keyword12040 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_yield_contextual_keyword12054 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_get_contextual_keyword12068 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_set_contextual_keyword12082 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_add_contextual_keyword12096 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_remove_contextual_keyword12110 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_dynamic_contextual_keyword12124 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_arglist12138 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_ASSIGNMENT_in_right_arrow12152 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000020L});
    public static final BitSet FOLLOW_GT_in_right_arrow12156 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_GT_in_right_shift12173 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000020L});
    public static final BitSet FOLLOW_GT_in_right_shift12177 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_GT_in_right_shift_assignment12202 = new BitSet(new long[]{0x0000000000000000L,0x0010000000000000L});
    public static final BitSet FOLLOW_OP_GE_in_right_shift_assignment12206 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_boolean_literal_in_literal12229 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INTEGER_LITERAL_in_literal12235 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_REAL_LITERAL_in_literal12241 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_CHARACTER_LITERAL_in_literal12247 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STRING_LITERAL_in_literal12253 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_NULL_in_literal12259 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_CLASS_in_class_definition12761 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_class_definition12764 = new BitSet(new long[]{0x0000000008000000L,0x0000020010000400L});
    public static final BitSet FOLLOW_type_parameter_list_in_class_definition12766 = new BitSet(new long[]{0x0000000008000000L,0x0000020000000400L});
    public static final BitSet FOLLOW_class_base_in_class_definition12769 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000400L});
    public static final BitSet FOLLOW_type_parameter_constraints_clauses_in_class_definition12772 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_class_body_in_class_definition12781 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_class_definition12783 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STRUCT_in_struct_definition12797 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_struct_definition12800 = new BitSet(new long[]{0x0000000008000000L,0x0000020010000400L});
    public static final BitSet FOLLOW_type_parameter_list_in_struct_definition12802 = new BitSet(new long[]{0x0000000008000000L,0x0000020000000400L});
    public static final BitSet FOLLOW_struct_interfaces_in_struct_definition12805 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000400L});
    public static final BitSet FOLLOW_type_parameter_constraints_clauses_in_struct_definition12808 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_struct_body_in_struct_definition12817 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_struct_definition12819 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INTERFACE_in_interface_definition12833 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_interface_definition12836 = new BitSet(new long[]{0x0000000008000000L,0x0000020010000400L});
    public static final BitSet FOLLOW_variant_type_parameter_list_in_interface_definition12838 = new BitSet(new long[]{0x0000000008000000L,0x0000020000000400L});
    public static final BitSet FOLLOW_interface_base_in_interface_definition12841 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000400L});
    public static final BitSet FOLLOW_type_parameter_constraints_clauses_in_interface_definition12850 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_interface_body_in_interface_definition12853 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_interface_definition12855 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_ENUM_in_enum_definition12869 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_enum_definition12872 = new BitSet(new long[]{0x0000000008000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_enum_base_in_enum_definition12874 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_enum_body_in_enum_definition12877 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_enum_definition12879 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_DELEGATE_in_delegate_definition12893 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_return_type_in_delegate_definition12896 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_delegate_definition12898 = new BitSet(new long[]{0x0000000000000000L,0x0000080010000000L});
    public static final BitSet FOLLOW_variant_type_parameter_list_in_delegate_definition12900 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_delegate_definition12903 = new BitSet(new long[]{0x2000100804114000L,0x0000050008004400L,0x400811080000000AL,0x0000000002200060L});
    public static final BitSet FOLLOW_formal_parameter_list_in_delegate_definition12911 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_delegate_definition12914 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L,0x0000040000000000L});
    public static final BitSet FOLLOW_type_parameter_constraints_clauses_in_delegate_definition12916 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_delegate_definition12919 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_EVENT_in_event_declaration212932 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_type_in_event_declaration212934 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_variable_declarators_in_event_declaration212946 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_event_declaration212948 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_member_name_in_event_declaration212974 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_event_declaration212976 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000400L});
    public static final BitSet FOLLOW_event_accessor_declarations_in_event_declaration212978 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_event_declaration212980 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_variable_declarators_in_field_declaration213020 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_field_declaration213022 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_member_name_in_property_declaration213046 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_property_declaration213048 = new BitSet(new long[]{0x0000000000000000L,0x0000040000020400L,0x00000000000000C0L});
    public static final BitSet FOLLOW_accessor_declarations_in_property_declaration213050 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_property_declaration213052 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_CONST_in_constant_declaration213080 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_type_in_constant_declaration213085 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_constant_declarators_in_constant_declaration213088 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_constant_declaration213091 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_THIS_in_indexer_declaration213104 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_OPEN_BRACKET_in_indexer_declaration213106 = new BitSet(new long[]{0x2000100800114000L,0x0000050008004400L,0x400811080000000AL,0x0000000002200060L});
    public static final BitSet FOLLOW_formal_parameter_list_in_indexer_declaration213108 = new BitSet(new long[]{0x0000000002000000L});
    public static final BitSet FOLLOW_CLOSE_BRACKET_in_indexer_declaration213110 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_indexer_declaration213118 = new BitSet(new long[]{0x0000000000000000L,0x0000040000020400L,0x00000000000000C0L});
    public static final BitSet FOLLOW_accessor_declarations_in_indexer_declaration213120 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_indexer_declaration213122 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_TILDE_in_destructor_definition13149 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_destructor_definition13152 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_destructor_definition13154 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_destructor_definition13157 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_destructor_body_in_destructor_definition13160 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_constructor_declaration213172 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_constructor_declaration213174 = new BitSet(new long[]{0x2000100804114000L,0x0000050008004400L,0x400811080000000AL,0x0000000002200060L});
    public static final BitSet FOLLOW_formal_parameter_list_in_constructor_declaration213176 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_constructor_declaration213179 = new BitSet(new long[]{0x0000000008000000L,0x0000020000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_constructor_initializer_in_constructor_declaration213181 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_body_in_constructor_declaration213184 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_method_member_name_in_method_declaration213219 = new BitSet(new long[]{0x0000000000000000L,0x0000080010000000L});
    public static final BitSet FOLLOW_type_parameter_list_in_method_declaration213221 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_method_declaration213224 = new BitSet(new long[]{0x2000100804114000L,0x0000050008004400L,0x400811080000000AL,0x0000000002200060L});
    public static final BitSet FOLLOW_formal_parameter_list_in_method_declaration213226 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_method_declaration213229 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000400L,0x0000040000000000L});
    public static final BitSet FOLLOW_type_parameter_constraints_clauses_in_method_declaration213237 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_method_body_in_method_declaration213240 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_method_member_name2_in_method_member_name13297 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_method_member_name213323 = new BitSet(new long[]{0x0000080000000002L,0x0000000010000000L});
    public static final BitSet FOLLOW_IDENTIFIER_in_method_member_name213331 = new BitSet(new long[]{0x0000400000000000L});
    public static final BitSet FOLLOW_DOUBLE_COLON_in_method_member_name213333 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_method_member_name213335 = new BitSet(new long[]{0x0000080000000002L,0x0000000010000000L});
    public static final BitSet FOLLOW_type_argument_list_opt_in_method_member_name213344 = new BitSet(new long[]{0x0000080000000000L});
    public static final BitSet FOLLOW_DOT_in_method_member_name213346 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_method_member_name213348 = new BitSet(new long[]{0x0000080000000002L,0x0000000010000000L});
    public static final BitSet FOLLOW_OPERATOR_in_operator_declaration213362 = new BitSet(new long[]{0x0400020000022820L,0x08FA000110000020L,0x0002000000000030L,0x0000000000000003L});
    public static final BitSet FOLLOW_overloadable_operator_in_operator_declaration213364 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_operator_declaration213366 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_type_in_operator_declaration213370 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_operator_declaration213374 = new BitSet(new long[]{0x0000000014000000L});
    public static final BitSet FOLLOW_COMMA_in_operator_declaration213386 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_type_in_operator_declaration213390 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_operator_declaration213394 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_operator_declaration213398 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_operator_body_in_operator_declaration213400 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_interface_method_declaration213449 = new BitSet(new long[]{0x0000000000000000L,0x0000080010000000L});
    public static final BitSet FOLLOW_type_parameter_list_in_interface_method_declaration213451 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_interface_method_declaration213454 = new BitSet(new long[]{0x2000100804114000L,0x0000050008004400L,0x400811080000000AL,0x0000000002200060L});
    public static final BitSet FOLLOW_formal_parameter_list_in_interface_method_declaration213456 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_interface_method_declaration213459 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L,0x0000040000000000L});
    public static final BitSet FOLLOW_type_parameter_constraints_clauses_in_interface_method_declaration213461 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_interface_method_declaration213464 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_interface_property_declaration213502 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_interface_property_declaration213504 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000400L});
    public static final BitSet FOLLOW_interface_accessors_in_interface_property_declaration213506 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_interface_property_declaration213508 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_EVENT_in_interface_event_declaration213536 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000002200060L});
    public static final BitSet FOLLOW_type_in_interface_event_declaration213539 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_interface_event_declaration213541 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_interface_event_declaration213543 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_THIS_in_interface_indexer_declaration213556 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_OPEN_BRACKET_in_interface_indexer_declaration213558 = new BitSet(new long[]{0x2000100800114000L,0x0000050008004400L,0x400811080000000AL,0x0000000002200060L});
    public static final BitSet FOLLOW_formal_parameter_list_in_interface_indexer_declaration213560 = new BitSet(new long[]{0x0000000002000000L});
    public static final BitSet FOLLOW_CLOSE_BRACKET_in_interface_indexer_declaration213562 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_interface_indexer_declaration213564 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000400L});
    public static final BitSet FOLLOW_interface_accessors_in_interface_indexer_declaration213566 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_interface_indexer_declaration213568 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_DOT_in_member_access213596 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_member_access213599 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
    public static final BitSet FOLLOW_type_argument_list_opt_in_member_access213601 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_method_invocation213613 = new BitSet(new long[]{0x2400106804715820L,0x002209250800C400L,0x401A910C00000022L,0x00000000002000EBL});
    public static final BitSet FOLLOW_argument_list_in_method_invocation213616 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_method_invocation213619 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_object_creation_expression213632 = new BitSet(new long[]{0x2400106804715820L,0x002209250800C400L,0x401A910C00000022L,0x00000000002000EBL});
    public static final BitSet FOLLOW_argument_list_in_object_creation_expression213634 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_object_creation_expression213637 = new BitSet(new long[]{0x0000000000000002L,0x0000020000000000L});
    public static final BitSet FOLLOW_object_or_collection_initializer_in_object_creation_expression213639 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_type_argument_list_in_synpred1_CSharp4AST691 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INTERR_in_synpred2_CSharp4AST754 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_rank_specifier_in_synpred3_CSharp4AST788 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_rank_specifier_in_synpred4_CSharp4AST1019 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_array_type_in_synpred5_CSharp4AST2271 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_OPEN_BRACKET_in_synpred5_CSharp4AST2273 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_unbound_type_name_in_synpred6_CSharp4AST2462 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_scan_for_cast_generic_precedence_in_synpred7_CSharp4AST2695 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_synpred7_CSharp4AST2699 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004000L,0x0008110000000000L,0x0000000000200060L});
    public static final BitSet FOLLOW_predefined_type_in_synpred7_CSharp4AST2701 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INTERR_in_synpred8_CSharp4AST3659 = new BitSet(new long[]{0x0000000004000000L,0x1000400000040000L});
    public static final BitSet FOLLOW_is_disambiguation_token_in_synpred8_CSharp4AST3661 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_type_in_synpred9_CSharp4AST4372 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_synpred9_CSharp4AST4374 = new BitSet(new long[]{0x0000000000000000L,0x0000000000002000L});
    public static final BitSet FOLLOW_IN_in_synpred9_CSharp4AST4376 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_into_contextual_keyword_in_synpred10_CSharp4AST4410 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_assignment_in_synpred11_CSharp4AST4840 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_lambda_expression_in_synpred12_CSharp4AST4865 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_query_expression_in_synpred13_CSharp4AST4876 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_labeled_statement_in_synpred14_CSharp4AST4924 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_declaration_statement_in_synpred15_CSharp4AST4935 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_ELSE_in_synpred16_CSharp4AST5375 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_local_variable_declaration_in_synpred17_CSharp4AST5734 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_local_variable_declaration_in_synpred18_CSharp4AST6169 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_global_attribute_section_in_synpred19_CSharp4AST6275 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_interface_type_in_synpred20_CSharp4AST7434 = new BitSet(new long[]{0x0000080000000000L});
    public static final BitSet FOLLOW_DOT_in_synpred20_CSharp4AST7436 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x4000000000000000L});
    public static final BitSet FOLLOW_THIS_in_synpred20_CSharp4AST7438 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_member_name_in_synpred21_CSharp4AST7458 = new BitSet(new long[]{0x0000000000000000L,0x0000080010000000L});
    public static final BitSet FOLLOW_type_parameter_list_in_synpred21_CSharp4AST7460 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_synpred21_CSharp4AST7463 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_member_name_in_synpred22_CSharp4AST7478 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_synpred22_CSharp4AST7480 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_synpred23_CSharp4AST7907 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
    public static final BitSet FOLLOW_PARAMS_in_synpred23_CSharp4AST7910 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_COMMA_in_synpred24_CSharp4AST7939 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000000L,0x0000000000000008L});
    public static final BitSet FOLLOW_parameter_array_in_synpred24_CSharp4AST7941 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_COMMA_in_synpred25_CSharp4AST7985 = new BitSet(new long[]{0x2000100800114000L,0x0000050008004400L,0x4008110800000002L,0x0000000002200060L});
    public static final BitSet FOLLOW_fixed_parameter_in_synpred25_CSharp4AST7987 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_unary_operator_declarator_in_synpred26_CSharp4AST8769 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_AMP_in_synpred27_CSharp4AST11654 = new BitSet(new long[]{0x0000000000000002L});

}