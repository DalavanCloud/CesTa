// $ANTLR 3.4 E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g 2012-10-31 00:26:52

/*
[The BSD License]
Copyright (c) 2012 Christian Wulf
All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

    Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
    Neither the name of the author nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
*/
package lang.csharp;

import java.util.LinkedList;


import org.antlr.runtime.*;
import java.util.Stack;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;

@SuppressWarnings({"all", "warnings", "unchecked"})
public class CSharp4 extends Parser {
    public static final String[] tokenNames = new String[] {
        "<invalid>", "<EOR>", "<DOWN>", "<UP>", "ABSTRACT", "AMP", "AS", "ASSIGNMENT", "Asterisks", "Available_identifier", "BACK_SLASH", "BANG", "BASE", "BITWISE_OR", "BOOL", "BREAK", "BYTE", "CARET", "CASE", "CATCH", "CHAR", "CHARACTER_LITERAL", "CHECKED", "CLASS", "CLOSE_BRACE", "CLOSE_BRACKET", "CLOSE_PARENS", "COLON", "COMMA", "CONST", "CONTINUE", "Character", "Combining_character", "Conditional_symbol", "Connecting_character", "DECIMAL", "DECIMAL_DIGIT", "DEFAULT", "DELEGATE", "DELIMITED_COMMENT", "DELIMITED_DOC_COMMENT", "DIV", "DO", "DOT", "DOUBLE", "DOUBLE_BACK_SLASH", "DOUBLE_COLON", "DOUBLE_QUOTE", "Decimal_digit_character", "Decimal_digits", "Decimal_integer_literal", "Delimited_comment_section", "ELSE", "ENUM", "EVENT", "EXPLICIT", "EXTERN", "Exponent_part", "FALSE", "FINALLY", "FIXED", "FLOAT", "FOR", "FOREACH", "File_name", "File_name_character", "File_name_characters", "Formatting_character", "GOTO", "GT", "HEX_DIGIT", "Hex_digits", "Hexadecimal_escape_sequence", "Hexadecimal_integer_literal", "IDENTIFIER", "IF", "IMPLICIT", "IN", "INT", "INTEGER_LITERAL", "INTERFACE", "INTERNAL", "INTERR", "IS", "Identifier_or_keyword", "Identifier_part_character", "Identifier_start_character", "Input_character", "Input_characters", "Integer_type_suffix", "LOCK", "LONG", "LT", "Letter_character", "Line_indicator", "LiteralAccess", "MINUS", "NAMESPACE", "NEW", "NEW_LINE", "NEW_LINE_CHARACTER", "NULL", "Not_number_sign", "Not_slash_or_asterisk", "OBJECT", "OPEN_BRACE", "OPEN_BRACKET", "OPEN_PARENS", "OPERATOR", "OP_ADD_ASSIGNMENT", "OP_AND", "OP_AND_ASSIGNMENT", "OP_COALESCING", "OP_DEC", "OP_DIV_ASSIGNMENT", "OP_EQ", "OP_GE", "OP_INC", "OP_LE", "OP_LEFT_SHIFT", "OP_LEFT_SHIFT_ASSIGNMENT", "OP_MOD_ASSIGNMENT", "OP_MULT_ASSIGNMENT", "OP_NE", "OP_OR", "OP_OR_ASSIGNMENT", "OP_PTR", "OP_SUB_ASSIGNMENT", "OP_XOR_ASSIGNMENT", "OUT", "OVERRIDE", "PARAMS", "PERCENT", "PLUS", "PRIVATE", "PROTECTED", "PUBLIC", "Pp_and_expression", "Pp_conditional", "Pp_declaration", "Pp_diagnostic", "Pp_directive", "Pp_elif_section", "Pp_else_section", "Pp_end_region", "Pp_endif", "Pp_equality_expression", "Pp_expression", "Pp_if_section", "Pp_line", "Pp_message", "Pp_new_line", "Pp_or_expression", "Pp_pragma", "Pp_pragma_text", "Pp_primary_expression", "Pp_region", "Pp_start_region", "Pp_unary_expression", "QUOTE", "Quote_escape_sequence", "READONLY", "REAL_LITERAL", "REF", "RETURN", "Real_type_suffix", "Regular_string_literal", "Regular_string_literal_character", "SBYTE", "SEALED", "SEMICOLON", "SHARP", "SHORT", "SINGLE_LINE_COMMENT", "SINGLE_LINE_DOC_COMMENT", "SIZEOF", "STACKALLOC", "STAR", "STATIC", "STRING", "STRING_LITERAL", "STRUCT", "SWITCH", "Sign", "Simple_escape_sequence", "Single_character", "Single_regular_string_literal_character", "Single_verbatim_string_literal_character", "SkiPped_characters", "SkiPped_section_part", "THIS", "THROW", "TILDE", "TRUE", "TRY", "TYPEOF", "UINT", "ULONG", "UNCHECKED", "UNICODE_CLASS_Cf", "UNICODE_CLASS_Ll", "UNICODE_CLASS_Lm", "UNICODE_CLASS_Lo", "UNICODE_CLASS_Lt", "UNICODE_CLASS_Lu", "UNICODE_CLASS_Mc", "UNICODE_CLASS_Mn", "UNICODE_CLASS_Nd", "UNICODE_CLASS_Nl", "UNICODE_CLASS_Pc", "UNICODE_CLASS_Zs", "UNSAFE", "USHORT", "USING", "Unicode_escape_sequence", "VIRTUAL", "VOID", "VOLATILE", "Verbatim_string_literal", "Verbatim_string_literal_character", "WHILE", "WHITESPACE", "Whitespace_character", "Whitespace_characters"
    };

    public static final int EOF=-1;
    public static final int ABSTRACT=4;
    public static final int AMP=5;
    public static final int AS=6;
    public static final int ASSIGNMENT=7;
    public static final int Asterisks=8;
    public static final int Available_identifier=9;
    public static final int BACK_SLASH=10;
    public static final int BANG=11;
    public static final int BASE=12;
    public static final int BITWISE_OR=13;
    public static final int BOOL=14;
    public static final int BREAK=15;
    public static final int BYTE=16;
    public static final int CARET=17;
    public static final int CASE=18;
    public static final int CATCH=19;
    public static final int CHAR=20;
    public static final int CHARACTER_LITERAL=21;
    public static final int CHECKED=22;
    public static final int CLASS=23;
    public static final int CLOSE_BRACE=24;
    public static final int CLOSE_BRACKET=25;
    public static final int CLOSE_PARENS=26;
    public static final int COLON=27;
    public static final int COMMA=28;
    public static final int CONST=29;
    public static final int CONTINUE=30;
    public static final int Character=31;
    public static final int Combining_character=32;
    public static final int Conditional_symbol=33;
    public static final int Connecting_character=34;
    public static final int DECIMAL=35;
    public static final int DECIMAL_DIGIT=36;
    public static final int DEFAULT=37;
    public static final int DELEGATE=38;
    public static final int DELIMITED_COMMENT=39;
    public static final int DELIMITED_DOC_COMMENT=40;
    public static final int DIV=41;
    public static final int DO=42;
    public static final int DOT=43;
    public static final int DOUBLE=44;
    public static final int DOUBLE_BACK_SLASH=45;
    public static final int DOUBLE_COLON=46;
    public static final int DOUBLE_QUOTE=47;
    public static final int Decimal_digit_character=48;
    public static final int Decimal_digits=49;
    public static final int Decimal_integer_literal=50;
    public static final int Delimited_comment_section=51;
    public static final int ELSE=52;
    public static final int ENUM=53;
    public static final int EVENT=54;
    public static final int EXPLICIT=55;
    public static final int EXTERN=56;
    public static final int Exponent_part=57;
    public static final int FALSE=58;
    public static final int FINALLY=59;
    public static final int FIXED=60;
    public static final int FLOAT=61;
    public static final int FOR=62;
    public static final int FOREACH=63;
    public static final int File_name=64;
    public static final int File_name_character=65;
    public static final int File_name_characters=66;
    public static final int Formatting_character=67;
    public static final int GOTO=68;
    public static final int GT=69;
    public static final int HEX_DIGIT=70;
    public static final int Hex_digits=71;
    public static final int Hexadecimal_escape_sequence=72;
    public static final int Hexadecimal_integer_literal=73;
    public static final int IDENTIFIER=74;
    public static final int IF=75;
    public static final int IMPLICIT=76;
    public static final int IN=77;
    public static final int INT=78;
    public static final int INTEGER_LITERAL=79;
    public static final int INTERFACE=80;
    public static final int INTERNAL=81;
    public static final int INTERR=82;
    public static final int IS=83;
    public static final int Identifier_or_keyword=84;
    public static final int Identifier_part_character=85;
    public static final int Identifier_start_character=86;
    public static final int Input_character=87;
    public static final int Input_characters=88;
    public static final int Integer_type_suffix=89;
    public static final int LOCK=90;
    public static final int LONG=91;
    public static final int LT=92;
    public static final int Letter_character=93;
    public static final int Line_indicator=94;
    public static final int LiteralAccess=95;
    public static final int MINUS=96;
    public static final int NAMESPACE=97;
    public static final int NEW=98;
    public static final int NEW_LINE=99;
    public static final int NEW_LINE_CHARACTER=100;
    public static final int NULL=101;
    public static final int Not_number_sign=102;
    public static final int Not_slash_or_asterisk=103;
    public static final int OBJECT=104;
    public static final int OPEN_BRACE=105;
    public static final int OPEN_BRACKET=106;
    public static final int OPEN_PARENS=107;
    public static final int OPERATOR=108;
    public static final int OP_ADD_ASSIGNMENT=109;
    public static final int OP_AND=110;
    public static final int OP_AND_ASSIGNMENT=111;
    public static final int OP_COALESCING=112;
    public static final int OP_DEC=113;
    public static final int OP_DIV_ASSIGNMENT=114;
    public static final int OP_EQ=115;
    public static final int OP_GE=116;
    public static final int OP_INC=117;
    public static final int OP_LE=118;
    public static final int OP_LEFT_SHIFT=119;
    public static final int OP_LEFT_SHIFT_ASSIGNMENT=120;
    public static final int OP_MOD_ASSIGNMENT=121;
    public static final int OP_MULT_ASSIGNMENT=122;
    public static final int OP_NE=123;
    public static final int OP_OR=124;
    public static final int OP_OR_ASSIGNMENT=125;
    public static final int OP_PTR=126;
    public static final int OP_SUB_ASSIGNMENT=127;
    public static final int OP_XOR_ASSIGNMENT=128;
    public static final int OUT=129;
    public static final int OVERRIDE=130;
    public static final int PARAMS=131;
    public static final int PERCENT=132;
    public static final int PLUS=133;
    public static final int PRIVATE=134;
    public static final int PROTECTED=135;
    public static final int PUBLIC=136;
    public static final int Pp_and_expression=137;
    public static final int Pp_conditional=138;
    public static final int Pp_declaration=139;
    public static final int Pp_diagnostic=140;
    public static final int Pp_directive=141;
    public static final int Pp_elif_section=142;
    public static final int Pp_else_section=143;
    public static final int Pp_end_region=144;
    public static final int Pp_endif=145;
    public static final int Pp_equality_expression=146;
    public static final int Pp_expression=147;
    public static final int Pp_if_section=148;
    public static final int Pp_line=149;
    public static final int Pp_message=150;
    public static final int Pp_new_line=151;
    public static final int Pp_or_expression=152;
    public static final int Pp_pragma=153;
    public static final int Pp_pragma_text=154;
    public static final int Pp_primary_expression=155;
    public static final int Pp_region=156;
    public static final int Pp_start_region=157;
    public static final int Pp_unary_expression=158;
    public static final int QUOTE=159;
    public static final int Quote_escape_sequence=160;
    public static final int READONLY=161;
    public static final int REAL_LITERAL=162;
    public static final int REF=163;
    public static final int RETURN=164;
    public static final int Real_type_suffix=165;
    public static final int Regular_string_literal=166;
    public static final int Regular_string_literal_character=167;
    public static final int SBYTE=168;
    public static final int SEALED=169;
    public static final int SEMICOLON=170;
    public static final int SHARP=171;
    public static final int SHORT=172;
    public static final int SINGLE_LINE_COMMENT=173;
    public static final int SINGLE_LINE_DOC_COMMENT=174;
    public static final int SIZEOF=175;
    public static final int STACKALLOC=176;
    public static final int STAR=177;
    public static final int STATIC=178;
    public static final int STRING=179;
    public static final int STRING_LITERAL=180;
    public static final int STRUCT=181;
    public static final int SWITCH=182;
    public static final int Sign=183;
    public static final int Simple_escape_sequence=184;
    public static final int Single_character=185;
    public static final int Single_regular_string_literal_character=186;
    public static final int Single_verbatim_string_literal_character=187;
    public static final int SkiPped_characters=188;
    public static final int SkiPped_section_part=189;
    public static final int THIS=190;
    public static final int THROW=191;
    public static final int TILDE=192;
    public static final int TRUE=193;
    public static final int TRY=194;
    public static final int TYPEOF=195;
    public static final int UINT=196;
    public static final int ULONG=197;
    public static final int UNCHECKED=198;
    public static final int UNICODE_CLASS_Cf=199;
    public static final int UNICODE_CLASS_Ll=200;
    public static final int UNICODE_CLASS_Lm=201;
    public static final int UNICODE_CLASS_Lo=202;
    public static final int UNICODE_CLASS_Lt=203;
    public static final int UNICODE_CLASS_Lu=204;
    public static final int UNICODE_CLASS_Mc=205;
    public static final int UNICODE_CLASS_Mn=206;
    public static final int UNICODE_CLASS_Nd=207;
    public static final int UNICODE_CLASS_Nl=208;
    public static final int UNICODE_CLASS_Pc=209;
    public static final int UNICODE_CLASS_Zs=210;
    public static final int UNSAFE=211;
    public static final int USHORT=212;
    public static final int USING=213;
    public static final int Unicode_escape_sequence=214;
    public static final int VIRTUAL=215;
    public static final int VOID=216;
    public static final int VOLATILE=217;
    public static final int Verbatim_string_literal=218;
    public static final int Verbatim_string_literal_character=219;
    public static final int WHILE=220;
    public static final int WHITESPACE=221;
    public static final int Whitespace_character=222;
    public static final int Whitespace_characters=223;

    // delegates
    public Parser[] getDelegates() {
        return new Parser[] {};
    }

    // delegators


    public CSharp4(TokenStream input) {
        this(input, new RecognizerSharedState());
    }
    public CSharp4(TokenStream input, RecognizerSharedState state) {
        super(input, state);
    }

    public String[] getTokenNames() { return CSharp4.tokenNames; }
    public String getGrammarFileName() { return "E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g"; }


    // the following methods are only used for debug purposes
    private List<String> errors = new LinkedList<String>();

    @Override
    public void displayRecognitionError(String[] tokenNames, RecognitionException e) {
        super.displayRecognitionError(tokenNames, e);
        String hdr = getErrorHeader(e);
        String msg = getErrorMessage(e, tokenNames);
        errors.add(hdr + " " + msg);
    }

    public List<String> getErrors() {
        return errors;
    }

    private void next(int n) {
      System.err.print("next: ");
      for (int i=1; i<=n; i++) {
        System.err.print(" | " + input.LT(i).getType() + "=" + input.LT(i).getText());
      }
      System.err.println();
    }




    // $ANTLR start "namespace_name"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:68:1: namespace_name : namespace_or_type_name ;
    public final void namespace_name() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:69:2: ( namespace_or_type_name )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:69:4: namespace_or_type_name
            {
            pushFollow(FOLLOW_namespace_or_type_name_in_namespace_name56);
            namespace_or_type_name();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "namespace_name"



    // $ANTLR start "type_name"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:71:1: type_name : namespace_or_type_name ;
    public final void type_name() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:72:2: ( namespace_or_type_name )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:72:4: namespace_or_type_name
            {
            pushFollow(FOLLOW_namespace_or_type_name_in_type_name67);
            namespace_or_type_name();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "type_name"



    // $ANTLR start "namespace_or_type_name"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:81:1: namespace_or_type_name : ( IDENTIFIER type_argument_list_opt | qualified_alias_member ) ( DOT IDENTIFIER type_argument_list_opt )* ;
    public final void namespace_or_type_name() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:82:3: ( ( IDENTIFIER type_argument_list_opt | qualified_alias_member ) ( DOT IDENTIFIER type_argument_list_opt )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:82:5: ( IDENTIFIER type_argument_list_opt | qualified_alias_member ) ( DOT IDENTIFIER type_argument_list_opt )*
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:82:5: ( IDENTIFIER type_argument_list_opt | qualified_alias_member )
            int alt1=2;
            int LA1_0 = input.LA(1);

            if ( (LA1_0==IDENTIFIER) ) {
                int LA1_1 = input.LA(2);

                if ( (LA1_1==DOUBLE_COLON) ) {
                    alt1=2;
                }
                else if ( (LA1_1==EOF||(LA1_1 >= AMP && LA1_1 <= AS)||LA1_1==BITWISE_OR||LA1_1==CARET||(LA1_1 >= CLOSE_BRACE && LA1_1 <= COMMA)||LA1_1==DOT||LA1_1==GT||LA1_1==IDENTIFIER||(LA1_1 >= INTERR && LA1_1 <= IS)||LA1_1==LT||(LA1_1 >= OPEN_BRACE && LA1_1 <= OPERATOR)||LA1_1==OP_AND||LA1_1==OP_COALESCING||(LA1_1 >= OP_EQ && LA1_1 <= OP_GE)||LA1_1==OP_LE||(LA1_1 >= OP_NE && LA1_1 <= OP_OR)||LA1_1==SEMICOLON||LA1_1==STAR||LA1_1==THIS) ) {
                    alt1=1;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 1, 1, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 1, 0, input);

                throw nvae;

            }
            switch (alt1) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:82:7: IDENTIFIER type_argument_list_opt
                    {
                    match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_namespace_or_type_name83); if (state.failed) return ;

                    pushFollow(FOLLOW_type_argument_list_opt_in_namespace_or_type_name85);
                    type_argument_list_opt();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:83:7: qualified_alias_member
                    {
                    pushFollow(FOLLOW_qualified_alias_member_in_namespace_or_type_name93);
                    qualified_alias_member();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:84:7: ( DOT IDENTIFIER type_argument_list_opt )*
            loop2:
            do {
                int alt2=2;
                int LA2_0 = input.LA(1);

                if ( (LA2_0==DOT) ) {
                    int LA2_2 = input.LA(2);

                    if ( (LA2_2==IDENTIFIER) ) {
                        alt2=1;
                    }


                }


                switch (alt2) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:84:8: DOT IDENTIFIER type_argument_list_opt
            	    {
            	    match(input,DOT,FOLLOW_DOT_in_namespace_or_type_name102); if (state.failed) return ;

            	    match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_namespace_or_type_name104); if (state.failed) return ;

            	    pushFollow(FOLLOW_type_argument_list_opt_in_namespace_or_type_name106);
            	    type_argument_list_opt();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop2;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "namespace_or_type_name"



    // $ANTLR start "type_argument_list_opt"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:88:1: type_argument_list_opt : ( ( type_argument_list )=> type_argument_list |);
    public final void type_argument_list_opt() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:89:3: ( ( type_argument_list )=> type_argument_list |)
            int alt3=2;
            int LA3_0 = input.LA(1);

            if ( (LA3_0==LT) ) {
                int LA3_1 = input.LA(2);

                if ( (synpred1_CSharp4()) ) {
                    alt3=1;
                }
                else if ( (true) ) {
                    alt3=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 3, 1, input);

                    throw nvae;

                }
            }
            else if ( (LA3_0==EOF||(LA3_0 >= AMP && LA3_0 <= ASSIGNMENT)||LA3_0==BITWISE_OR||LA3_0==CARET||(LA3_0 >= CLOSE_BRACE && LA3_0 <= COMMA)||LA3_0==DIV||LA3_0==DOT||LA3_0==GT||LA3_0==IDENTIFIER||(LA3_0 >= INTERR && LA3_0 <= IS)||LA3_0==MINUS||(LA3_0 >= OPEN_BRACE && LA3_0 <= OP_XOR_ASSIGNMENT)||(LA3_0 >= PERCENT && LA3_0 <= PLUS)||LA3_0==SEMICOLON||LA3_0==STAR||LA3_0==THIS) ) {
                alt3=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 3, 0, input);

                throw nvae;

            }
            switch (alt3) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:89:5: ( type_argument_list )=> type_argument_list
                    {
                    pushFollow(FOLLOW_type_argument_list_in_type_argument_list_opt130);
                    type_argument_list();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:91:3: 
                    {
                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "type_argument_list_opt"



    // $ANTLR start "type"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:101:1: type : base_type ( ( INTERR )=> INTERR | ( rank_specifier )=> rank_specifier | STAR )* ;
    public final void type() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:102:3: ( base_type ( ( INTERR )=> INTERR | ( rank_specifier )=> rank_specifier | STAR )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:102:5: base_type ( ( INTERR )=> INTERR | ( rank_specifier )=> rank_specifier | STAR )*
            {
            pushFollow(FOLLOW_base_type_in_type152);
            base_type();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:103:5: ( ( INTERR )=> INTERR | ( rank_specifier )=> rank_specifier | STAR )*
            loop4:
            do {
                int alt4=4;
                switch ( input.LA(1) ) {
                case OPEN_BRACKET:
                    {
                    int LA4_5 = input.LA(2);

                    if ( (synpred3_CSharp4()) ) {
                        alt4=2;
                    }


                    }
                    break;
                case INTERR:
                    {
                    int LA4_15 = input.LA(2);

                    if ( (synpred2_CSharp4()) ) {
                        alt4=1;
                    }


                    }
                    break;
                case STAR:
                    {
                    alt4=3;
                    }
                    break;

                }

                switch (alt4) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:103:7: ( INTERR )=> INTERR
            	    {
            	    match(input,INTERR,FOLLOW_INTERR_in_type166); if (state.failed) return ;

            	    }
            	    break;
            	case 2 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:104:7: ( rank_specifier )=> rank_specifier
            	    {
            	    pushFollow(FOLLOW_rank_specifier_in_type180);
            	    rank_specifier();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;
            	case 3 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:105:7: STAR
            	    {
            	    match(input,STAR,FOLLOW_STAR_in_type188); if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop4;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "type"



    // $ANTLR start "base_type"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:109:1: base_type : ( simple_type | class_type | VOID STAR );
    public final void base_type() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:110:3: ( simple_type | class_type | VOID STAR )
            int alt5=3;
            switch ( input.LA(1) ) {
            case BOOL:
            case BYTE:
            case CHAR:
            case DECIMAL:
            case DOUBLE:
            case FLOAT:
            case INT:
            case LONG:
            case SBYTE:
            case SHORT:
            case UINT:
            case ULONG:
            case USHORT:
                {
                alt5=1;
                }
                break;
            case IDENTIFIER:
            case OBJECT:
            case STRING:
                {
                alt5=2;
                }
                break;
            case VOID:
                {
                alt5=3;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 5, 0, input);

                throw nvae;

            }

            switch (alt5) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:110:5: simple_type
                    {
                    pushFollow(FOLLOW_simple_type_in_base_type208);
                    simple_type();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:111:5: class_type
                    {
                    pushFollow(FOLLOW_class_type_in_base_type214);
                    class_type();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:112:5: VOID STAR
                    {
                    match(input,VOID,FOLLOW_VOID_in_base_type222); if (state.failed) return ;

                    match(input,STAR,FOLLOW_STAR_in_base_type224); if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "base_type"



    // $ANTLR start "simple_type"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:126:1: simple_type : ( numeric_type | BOOL );
    public final void simple_type() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:127:2: ( numeric_type | BOOL )
            int alt6=2;
            int LA6_0 = input.LA(1);

            if ( (LA6_0==BYTE||LA6_0==CHAR||LA6_0==DECIMAL||LA6_0==DOUBLE||LA6_0==FLOAT||LA6_0==INT||LA6_0==LONG||LA6_0==SBYTE||LA6_0==SHORT||(LA6_0 >= UINT && LA6_0 <= ULONG)||LA6_0==USHORT) ) {
                alt6=1;
            }
            else if ( (LA6_0==BOOL) ) {
                alt6=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 6, 0, input);

                throw nvae;

            }
            switch (alt6) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:127:4: numeric_type
                    {
                    pushFollow(FOLLOW_numeric_type_in_simple_type240);
                    numeric_type();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:128:4: BOOL
                    {
                    match(input,BOOL,FOLLOW_BOOL_in_simple_type245); if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "simple_type"



    // $ANTLR start "numeric_type"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:130:1: numeric_type : ( integral_type | floating_point_type | DECIMAL );
    public final void numeric_type() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:131:2: ( integral_type | floating_point_type | DECIMAL )
            int alt7=3;
            switch ( input.LA(1) ) {
            case BYTE:
            case CHAR:
            case INT:
            case LONG:
            case SBYTE:
            case SHORT:
            case UINT:
            case ULONG:
            case USHORT:
                {
                alt7=1;
                }
                break;
            case DOUBLE:
            case FLOAT:
                {
                alt7=2;
                }
                break;
            case DECIMAL:
                {
                alt7=3;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 7, 0, input);

                throw nvae;

            }

            switch (alt7) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:131:4: integral_type
                    {
                    pushFollow(FOLLOW_integral_type_in_numeric_type256);
                    integral_type();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:132:4: floating_point_type
                    {
                    pushFollow(FOLLOW_floating_point_type_in_numeric_type261);
                    floating_point_type();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:133:4: DECIMAL
                    {
                    match(input,DECIMAL,FOLLOW_DECIMAL_in_numeric_type266); if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "numeric_type"



    // $ANTLR start "integral_type"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:135:1: integral_type : ( SBYTE | BYTE | SHORT | USHORT | INT | UINT | LONG | ULONG | CHAR );
    public final void integral_type() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:136:2: ( SBYTE | BYTE | SHORT | USHORT | INT | UINT | LONG | ULONG | CHAR )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:
            {
            if ( input.LA(1)==BYTE||input.LA(1)==CHAR||input.LA(1)==INT||input.LA(1)==LONG||input.LA(1)==SBYTE||input.LA(1)==SHORT||(input.LA(1) >= UINT && input.LA(1) <= ULONG)||input.LA(1)==USHORT ) {
                input.consume();
                state.errorRecovery=false;
                state.failed=false;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                MismatchedSetException mse = new MismatchedSetException(null,input);
                throw mse;
            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "integral_type"



    // $ANTLR start "floating_point_type"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:146:1: floating_point_type : ( FLOAT | DOUBLE );
    public final void floating_point_type() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:147:2: ( FLOAT | DOUBLE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:
            {
            if ( input.LA(1)==DOUBLE||input.LA(1)==FLOAT ) {
                input.consume();
                state.errorRecovery=false;
                state.failed=false;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                MismatchedSetException mse = new MismatchedSetException(null,input);
                throw mse;
            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "floating_point_type"



    // $ANTLR start "nullable_type"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:150:1: nullable_type : non_nullable_value_type INTERR ;
    public final void nullable_type() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:151:2: ( non_nullable_value_type INTERR )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:151:4: non_nullable_value_type INTERR
            {
            pushFollow(FOLLOW_non_nullable_value_type_in_nullable_type344);
            non_nullable_value_type();

            state._fsp--;
            if (state.failed) return ;

            match(input,INTERR,FOLLOW_INTERR_in_nullable_type346); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "nullable_type"



    // $ANTLR start "non_nullable_value_type"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:159:1: non_nullable_value_type : base_type ( ( rank_specifier )=> rank_specifier | STAR )* ;
    public final void non_nullable_value_type() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:160:2: ( base_type ( ( rank_specifier )=> rank_specifier | STAR )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:160:4: base_type ( ( rank_specifier )=> rank_specifier | STAR )*
            {
            pushFollow(FOLLOW_base_type_in_non_nullable_value_type360);
            base_type();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:161:5: ( ( rank_specifier )=> rank_specifier | STAR )*
            loop8:
            do {
                int alt8=3;
                int LA8_0 = input.LA(1);

                if ( (LA8_0==OPEN_BRACKET) && (synpred4_CSharp4())) {
                    alt8=1;
                }
                else if ( (LA8_0==STAR) ) {
                    alt8=2;
                }


                switch (alt8) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:161:7: ( rank_specifier )=> rank_specifier
            	    {
            	    pushFollow(FOLLOW_rank_specifier_in_non_nullable_value_type374);
            	    rank_specifier();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;
            	case 2 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:162:7: STAR
            	    {
            	    match(input,STAR,FOLLOW_STAR_in_non_nullable_value_type382); if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop8;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "non_nullable_value_type"



    // $ANTLR start "reference_type"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:178:1: reference_type : ( simple_type | class_type | VOID STAR ) ( ( STAR | INTERR )* rank_specifier )* ({...}? ( STAR | INTERR )* rank_specifier ) ;
    public final void reference_type() throws RecognitionException {
        boolean oneOrMore = false;
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:180:3: ( ( simple_type | class_type | VOID STAR ) ( ( STAR | INTERR )* rank_specifier )* ({...}? ( STAR | INTERR )* rank_specifier ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:180:5: ( simple_type | class_type | VOID STAR ) ( ( STAR | INTERR )* rank_specifier )* ({...}? ( STAR | INTERR )* rank_specifier )
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:180:5: ( simple_type | class_type | VOID STAR )
            int alt9=3;
            switch ( input.LA(1) ) {
            case BOOL:
            case BYTE:
            case CHAR:
            case DECIMAL:
            case DOUBLE:
            case FLOAT:
            case INT:
            case LONG:
            case SBYTE:
            case SHORT:
            case UINT:
            case ULONG:
            case USHORT:
                {
                alt9=1;
                }
                break;
            case IDENTIFIER:
            case OBJECT:
            case STRING:
                {
                alt9=2;
                }
                break;
            case VOID:
                {
                alt9=3;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 9, 0, input);

                throw nvae;

            }

            switch (alt9) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:180:7: simple_type
                    {
                    pushFollow(FOLLOW_simple_type_in_reference_type412);
                    simple_type();

                    state._fsp--;
                    if (state.failed) return ;

                    if ( state.backtracking==0 ) {oneOrMore=true;}

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:181:7: class_type
                    {
                    pushFollow(FOLLOW_class_type_in_reference_type422);
                    class_type();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:182:7: VOID STAR
                    {
                    match(input,VOID,FOLLOW_VOID_in_reference_type430); if (state.failed) return ;

                    match(input,STAR,FOLLOW_STAR_in_reference_type432); if (state.failed) return ;

                    if ( state.backtracking==0 ) {oneOrMore=true;}

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:183:5: ( ( STAR | INTERR )* rank_specifier )*
            loop11:
            do {
                int alt11=2;
                alt11 = dfa11.predict(input);
                switch (alt11) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:183:6: ( STAR | INTERR )* rank_specifier
            	    {
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:183:6: ( STAR | INTERR )*
            	    loop10:
            	    do {
            	        int alt10=2;
            	        int LA10_0 = input.LA(1);

            	        if ( (LA10_0==INTERR||LA10_0==STAR) ) {
            	            alt10=1;
            	        }


            	        switch (alt10) {
            	    	case 1 :
            	    	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:
            	    	    {
            	    	    if ( input.LA(1)==INTERR||input.LA(1)==STAR ) {
            	    	        input.consume();
            	    	        state.errorRecovery=false;
            	    	        state.failed=false;
            	    	    }
            	    	    else {
            	    	        if (state.backtracking>0) {state.failed=true; return ;}
            	    	        MismatchedSetException mse = new MismatchedSetException(null,input);
            	    	        throw mse;
            	    	    }


            	    	    }
            	    	    break;

            	    	default :
            	    	    break loop10;
            	        }
            	    } while (true);


            	    pushFollow(FOLLOW_rank_specifier_in_reference_type450);
            	    rank_specifier();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop11;
                }
            } while (true);


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:184:5: ({...}? ( STAR | INTERR )* rank_specifier )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:184:6: {...}? ( STAR | INTERR )* rank_specifier
            {
            if ( !((oneOrMore)) ) {
                if (state.backtracking>0) {state.failed=true; return ;}
                throw new FailedPredicateException(input, "reference_type", "oneOrMore");
            }

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:184:19: ( STAR | INTERR )*
            loop12:
            do {
                int alt12=2;
                int LA12_0 = input.LA(1);

                if ( (LA12_0==INTERR||LA12_0==STAR) ) {
                    alt12=1;
                }


                switch (alt12) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:
            	    {
            	    if ( input.LA(1)==INTERR||input.LA(1)==STAR ) {
            	        input.consume();
            	        state.errorRecovery=false;
            	        state.failed=false;
            	    }
            	    else {
            	        if (state.backtracking>0) {state.failed=true; return ;}
            	        MismatchedSetException mse = new MismatchedSetException(null,input);
            	        throw mse;
            	    }


            	    }
            	    break;

            	default :
            	    break loop12;
                }
            } while (true);


            pushFollow(FOLLOW_rank_specifier_in_reference_type470);
            rank_specifier();

            state._fsp--;
            if (state.failed) return ;

            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "reference_type"



    // $ANTLR start "class_type"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:187:1: class_type : ( type_name | OBJECT | dynamic_contextual_keyword | STRING );
    public final void class_type() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:188:2: ( type_name | OBJECT | dynamic_contextual_keyword | STRING )
            int alt13=4;
            switch ( input.LA(1) ) {
            case IDENTIFIER:
                {
                int LA13_1 = input.LA(2);

                if ( (!(((input.LT(1).getText().equals("dynamic"))))) ) {
                    alt13=1;
                }
                else if ( ((input.LT(1).getText().equals("dynamic"))) ) {
                    alt13=3;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 13, 1, input);

                    throw nvae;

                }
                }
                break;
            case OBJECT:
                {
                alt13=2;
                }
                break;
            case STRING:
                {
                alt13=4;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 13, 0, input);

                throw nvae;

            }

            switch (alt13) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:188:4: type_name
                    {
                    pushFollow(FOLLOW_type_name_in_class_type485);
                    type_name();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:189:4: OBJECT
                    {
                    match(input,OBJECT,FOLLOW_OBJECT_in_class_type490); if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:190:4: dynamic_contextual_keyword
                    {
                    pushFollow(FOLLOW_dynamic_contextual_keyword_in_class_type495);
                    dynamic_contextual_keyword();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:191:4: STRING
                    {
                    match(input,STRING,FOLLOW_STRING_in_class_type500); if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "class_type"



    // $ANTLR start "interface_type"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:194:1: interface_type : type_name ;
    public final void interface_type() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:195:2: ( type_name )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:195:4: type_name
            {
            pushFollow(FOLLOW_type_name_in_interface_type513);
            type_name();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "interface_type"



    // $ANTLR start "delegate_type"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:198:1: delegate_type : type_name ;
    public final void delegate_type() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:199:2: ( type_name )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:199:4: type_name
            {
            pushFollow(FOLLOW_type_name_in_delegate_type526);
            type_name();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "delegate_type"



    // $ANTLR start "type_argument_list"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:201:1: type_argument_list : LT type_arguments GT ;
    public final void type_argument_list() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:202:2: ( LT type_arguments GT )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:202:4: LT type_arguments GT
            {
            match(input,LT,FOLLOW_LT_in_type_argument_list537); if (state.failed) return ;

            pushFollow(FOLLOW_type_arguments_in_type_argument_list539);
            type_arguments();

            state._fsp--;
            if (state.failed) return ;

            match(input,GT,FOLLOW_GT_in_type_argument_list541); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "type_argument_list"



    // $ANTLR start "type_arguments"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:204:1: type_arguments : type_argument ( COMMA type_argument )* ;
    public final void type_arguments() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:205:2: ( type_argument ( COMMA type_argument )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:205:4: type_argument ( COMMA type_argument )*
            {
            pushFollow(FOLLOW_type_argument_in_type_arguments552);
            type_argument();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:205:18: ( COMMA type_argument )*
            loop14:
            do {
                int alt14=2;
                int LA14_0 = input.LA(1);

                if ( (LA14_0==COMMA) ) {
                    alt14=1;
                }


                switch (alt14) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:205:20: COMMA type_argument
            	    {
            	    match(input,COMMA,FOLLOW_COMMA_in_type_arguments556); if (state.failed) return ;

            	    pushFollow(FOLLOW_type_argument_in_type_arguments558);
            	    type_argument();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop14;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "type_arguments"



    // $ANTLR start "type_argument"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:207:1: type_argument : type ;
    public final void type_argument() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:208:2: ( type )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:208:4: type
            {
            pushFollow(FOLLOW_type_in_type_argument571);
            type();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "type_argument"



    // $ANTLR start "variable_reference"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:213:1: variable_reference : expression ;
    public final void variable_reference() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:214:2: ( expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:214:4: expression
            {
            pushFollow(FOLLOW_expression_in_variable_reference586);
            expression();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "variable_reference"



    // $ANTLR start "argument_list"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:218:1: argument_list : argument ( COMMA argument )* ;
    public final void argument_list() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:219:2: ( argument ( COMMA argument )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:219:4: argument ( COMMA argument )*
            {
            pushFollow(FOLLOW_argument_in_argument_list599);
            argument();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:219:13: ( COMMA argument )*
            loop15:
            do {
                int alt15=2;
                int LA15_0 = input.LA(1);

                if ( (LA15_0==COMMA) ) {
                    alt15=1;
                }


                switch (alt15) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:219:15: COMMA argument
            	    {
            	    match(input,COMMA,FOLLOW_COMMA_in_argument_list603); if (state.failed) return ;

            	    pushFollow(FOLLOW_argument_in_argument_list605);
            	    argument();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop15;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "argument_list"



    // $ANTLR start "argument"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:221:1: argument : ( argument_name )? argument_value ;
    public final void argument() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:222:2: ( ( argument_name )? argument_value )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:222:4: ( argument_name )? argument_value
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:222:4: ( argument_name )?
            int alt16=2;
            int LA16_0 = input.LA(1);

            if ( (LA16_0==IDENTIFIER) ) {
                int LA16_1 = input.LA(2);

                if ( (LA16_1==COLON) ) {
                    alt16=1;
                }
            }
            switch (alt16) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:222:4: argument_name
                    {
                    pushFollow(FOLLOW_argument_name_in_argument617);
                    argument_name();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            pushFollow(FOLLOW_argument_value_in_argument620);
            argument_value();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "argument"



    // $ANTLR start "argument_name"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:224:1: argument_name : IDENTIFIER COLON ;
    public final void argument_name() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:225:2: ( IDENTIFIER COLON )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:225:4: IDENTIFIER COLON
            {
            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_argument_name631); if (state.failed) return ;

            match(input,COLON,FOLLOW_COLON_in_argument_name633); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "argument_name"



    // $ANTLR start "argument_value"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:227:1: argument_value : ( expression | REF variable_reference | OUT variable_reference );
    public final void argument_value() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:228:2: ( expression | REF variable_reference | OUT variable_reference )
            int alt17=3;
            switch ( input.LA(1) ) {
            case AMP:
            case BANG:
            case BASE:
            case BOOL:
            case BYTE:
            case CHAR:
            case CHARACTER_LITERAL:
            case CHECKED:
            case DECIMAL:
            case DEFAULT:
            case DELEGATE:
            case DOUBLE:
            case FALSE:
            case FLOAT:
            case IDENTIFIER:
            case INT:
            case INTEGER_LITERAL:
            case LONG:
            case MINUS:
            case NEW:
            case NULL:
            case OBJECT:
            case OPEN_PARENS:
            case OP_DEC:
            case OP_INC:
            case PLUS:
            case REAL_LITERAL:
            case SBYTE:
            case SHORT:
            case SIZEOF:
            case STAR:
            case STRING:
            case STRING_LITERAL:
            case THIS:
            case TILDE:
            case TRUE:
            case TYPEOF:
            case UINT:
            case ULONG:
            case UNCHECKED:
            case USHORT:
                {
                alt17=1;
                }
                break;
            case REF:
                {
                alt17=2;
                }
                break;
            case OUT:
                {
                alt17=3;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 17, 0, input);

                throw nvae;

            }

            switch (alt17) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:228:4: expression
                    {
                    pushFollow(FOLLOW_expression_in_argument_value644);
                    expression();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:229:4: REF variable_reference
                    {
                    match(input,REF,FOLLOW_REF_in_argument_value649); if (state.failed) return ;

                    pushFollow(FOLLOW_variable_reference_in_argument_value651);
                    variable_reference();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:230:4: OUT variable_reference
                    {
                    match(input,OUT,FOLLOW_OUT_in_argument_value656); if (state.failed) return ;

                    pushFollow(FOLLOW_variable_reference_in_argument_value658);
                    variable_reference();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "argument_value"



    // $ANTLR start "primary_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:238:1: primary_expression : pe= primary_expression_start ( bracket_expression )* ( ( member_access2 | method_invocation2 | OP_INC | OP_DEC | OP_PTR IDENTIFIER ) ( bracket_expression )* )* ;
    public final void primary_expression() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:239:3: (pe= primary_expression_start ( bracket_expression )* ( ( member_access2 | method_invocation2 | OP_INC | OP_DEC | OP_PTR IDENTIFIER ) ( bracket_expression )* )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:239:5: pe= primary_expression_start ( bracket_expression )* ( ( member_access2 | method_invocation2 | OP_INC | OP_DEC | OP_PTR IDENTIFIER ) ( bracket_expression )* )*
            {
            pushFollow(FOLLOW_primary_expression_start_in_primary_expression674);
            primary_expression_start();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:239:34: ( bracket_expression )*
            loop18:
            do {
                int alt18=2;
                int LA18_0 = input.LA(1);

                if ( (LA18_0==OPEN_BRACKET) ) {
                    alt18=1;
                }


                switch (alt18) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:239:34: bracket_expression
            	    {
            	    pushFollow(FOLLOW_bracket_expression_in_primary_expression677);
            	    bracket_expression();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop18;
                }
            } while (true);


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:239:54: ( ( member_access2 | method_invocation2 | OP_INC | OP_DEC | OP_PTR IDENTIFIER ) ( bracket_expression )* )*
            loop21:
            do {
                int alt21=2;
                int LA21_0 = input.LA(1);

                if ( (LA21_0==DOT||LA21_0==OPEN_PARENS||LA21_0==OP_DEC||LA21_0==OP_INC||LA21_0==OP_PTR) ) {
                    alt21=1;
                }


                switch (alt21) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:240:9: ( member_access2 | method_invocation2 | OP_INC | OP_DEC | OP_PTR IDENTIFIER ) ( bracket_expression )*
            	    {
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:240:9: ( member_access2 | method_invocation2 | OP_INC | OP_DEC | OP_PTR IDENTIFIER )
            	    int alt19=5;
            	    switch ( input.LA(1) ) {
            	    case DOT:
            	        {
            	        alt19=1;
            	        }
            	        break;
            	    case OPEN_PARENS:
            	        {
            	        alt19=2;
            	        }
            	        break;
            	    case OP_INC:
            	        {
            	        alt19=3;
            	        }
            	        break;
            	    case OP_DEC:
            	        {
            	        alt19=4;
            	        }
            	        break;
            	    case OP_PTR:
            	        {
            	        alt19=5;
            	        }
            	        break;
            	    default:
            	        if (state.backtracking>0) {state.failed=true; return ;}
            	        NoViableAltException nvae =
            	            new NoViableAltException("", 19, 0, input);

            	        throw nvae;

            	    }

            	    switch (alt19) {
            	        case 1 :
            	            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:240:11: member_access2
            	            {
            	            pushFollow(FOLLOW_member_access2_in_primary_expression692);
            	            member_access2();

            	            state._fsp--;
            	            if (state.failed) return ;

            	            }
            	            break;
            	        case 2 :
            	            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:241:9: method_invocation2
            	            {
            	            pushFollow(FOLLOW_method_invocation2_in_primary_expression702);
            	            method_invocation2();

            	            state._fsp--;
            	            if (state.failed) return ;

            	            }
            	            break;
            	        case 3 :
            	            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:242:9: OP_INC
            	            {
            	            match(input,OP_INC,FOLLOW_OP_INC_in_primary_expression712); if (state.failed) return ;

            	            }
            	            break;
            	        case 4 :
            	            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:243:9: OP_DEC
            	            {
            	            match(input,OP_DEC,FOLLOW_OP_DEC_in_primary_expression722); if (state.failed) return ;

            	            }
            	            break;
            	        case 5 :
            	            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:244:9: OP_PTR IDENTIFIER
            	            {
            	            match(input,OP_PTR,FOLLOW_OP_PTR_in_primary_expression732); if (state.failed) return ;

            	            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_primary_expression734); if (state.failed) return ;

            	            }
            	            break;

            	    }


            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:246:7: ( bracket_expression )*
            	    loop20:
            	    do {
            	        int alt20=2;
            	        int LA20_0 = input.LA(1);

            	        if ( (LA20_0==OPEN_BRACKET) ) {
            	            alt20=1;
            	        }


            	        switch (alt20) {
            	    	case 1 :
            	    	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:246:7: bracket_expression
            	    	    {
            	    	    pushFollow(FOLLOW_bracket_expression_in_primary_expression751);
            	    	    bracket_expression();

            	    	    state._fsp--;
            	    	    if (state.failed) return ;

            	    	    }
            	    	    break;

            	    	default :
            	    	    break loop20;
            	        }
            	    } while (true);


            	    }
            	    break;

            	default :
            	    break loop21;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "primary_expression"



    // $ANTLR start "primary_expression_start"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:249:1: primary_expression_start : ( literal | simple_name | parenthesized_expression | predefined_type | qualified_alias_member | this_access | base_access | NEW ( type ( object_creation_expression2 | object_or_collection_initializer | OPEN_BRACKET expression_list CLOSE_BRACKET ( rank_specifiers )? ( array_initializer )? | rank_specifiers array_initializer ) | anonymous_object_initializer | rank_specifier array_initializer ) | typeof_expression | checked_expression | unchecked_expression | default_value_expression | anonymous_method_expression | sizeof_expression );
    public final void primary_expression_start() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:250:3: ( literal | simple_name | parenthesized_expression | predefined_type | qualified_alias_member | this_access | base_access | NEW ( type ( object_creation_expression2 | object_or_collection_initializer | OPEN_BRACKET expression_list CLOSE_BRACKET ( rank_specifiers )? ( array_initializer )? | rank_specifiers array_initializer ) | anonymous_object_initializer | rank_specifier array_initializer ) | typeof_expression | checked_expression | unchecked_expression | default_value_expression | anonymous_method_expression | sizeof_expression )
            int alt26=14;
            switch ( input.LA(1) ) {
            case CHARACTER_LITERAL:
            case FALSE:
            case INTEGER_LITERAL:
            case NULL:
            case REAL_LITERAL:
            case STRING_LITERAL:
            case TRUE:
                {
                alt26=1;
                }
                break;
            case IDENTIFIER:
                {
                int LA26_2 = input.LA(2);

                if ( (LA26_2==DOUBLE_COLON) ) {
                    alt26=5;
                }
                else if ( (LA26_2==EOF||(LA26_2 >= AMP && LA26_2 <= ASSIGNMENT)||LA26_2==BITWISE_OR||LA26_2==CARET||(LA26_2 >= CLOSE_BRACE && LA26_2 <= COMMA)||LA26_2==DIV||LA26_2==DOT||LA26_2==GT||LA26_2==IDENTIFIER||(LA26_2 >= INTERR && LA26_2 <= IS)||LA26_2==LT||LA26_2==MINUS||(LA26_2 >= OPEN_BRACKET && LA26_2 <= OPEN_PARENS)||(LA26_2 >= OP_ADD_ASSIGNMENT && LA26_2 <= OP_XOR_ASSIGNMENT)||(LA26_2 >= PERCENT && LA26_2 <= PLUS)||LA26_2==SEMICOLON||LA26_2==STAR) ) {
                    alt26=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 26, 2, input);

                    throw nvae;

                }
                }
                break;
            case OPEN_PARENS:
                {
                alt26=3;
                }
                break;
            case BOOL:
            case BYTE:
            case CHAR:
            case DECIMAL:
            case DOUBLE:
            case FLOAT:
            case INT:
            case LONG:
            case OBJECT:
            case SBYTE:
            case SHORT:
            case STRING:
            case UINT:
            case ULONG:
            case USHORT:
                {
                alt26=4;
                }
                break;
            case THIS:
                {
                alt26=6;
                }
                break;
            case BASE:
                {
                alt26=7;
                }
                break;
            case NEW:
                {
                alt26=8;
                }
                break;
            case TYPEOF:
                {
                alt26=9;
                }
                break;
            case CHECKED:
                {
                alt26=10;
                }
                break;
            case UNCHECKED:
                {
                alt26=11;
                }
                break;
            case DEFAULT:
                {
                alt26=12;
                }
                break;
            case DELEGATE:
                {
                alt26=13;
                }
                break;
            case SIZEOF:
                {
                alt26=14;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 26, 0, input);

                throw nvae;

            }

            switch (alt26) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:250:5: literal
                    {
                    pushFollow(FOLLOW_literal_in_primary_expression_start769);
                    literal();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:251:5: simple_name
                    {
                    pushFollow(FOLLOW_simple_name_in_primary_expression_start775);
                    simple_name();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:252:5: parenthesized_expression
                    {
                    pushFollow(FOLLOW_parenthesized_expression_in_primary_expression_start781);
                    parenthesized_expression();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:253:5: predefined_type
                    {
                    pushFollow(FOLLOW_predefined_type_in_primary_expression_start787);
                    predefined_type();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:254:5: qualified_alias_member
                    {
                    pushFollow(FOLLOW_qualified_alias_member_in_primary_expression_start794);
                    qualified_alias_member();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 6 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:255:5: this_access
                    {
                    pushFollow(FOLLOW_this_access_in_primary_expression_start802);
                    this_access();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 7 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:256:5: base_access
                    {
                    pushFollow(FOLLOW_base_access_in_primary_expression_start808);
                    base_access();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 8 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:257:5: NEW ( type ( object_creation_expression2 | object_or_collection_initializer | OPEN_BRACKET expression_list CLOSE_BRACKET ( rank_specifiers )? ( array_initializer )? | rank_specifiers array_initializer ) | anonymous_object_initializer | rank_specifier array_initializer )
                    {
                    match(input,NEW,FOLLOW_NEW_in_primary_expression_start814); if (state.failed) return ;

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:257:9: ( type ( object_creation_expression2 | object_or_collection_initializer | OPEN_BRACKET expression_list CLOSE_BRACKET ( rank_specifiers )? ( array_initializer )? | rank_specifiers array_initializer ) | anonymous_object_initializer | rank_specifier array_initializer )
                    int alt25=3;
                    switch ( input.LA(1) ) {
                    case BOOL:
                    case BYTE:
                    case CHAR:
                    case DECIMAL:
                    case DOUBLE:
                    case FLOAT:
                    case IDENTIFIER:
                    case INT:
                    case LONG:
                    case OBJECT:
                    case SBYTE:
                    case SHORT:
                    case STRING:
                    case UINT:
                    case ULONG:
                    case USHORT:
                    case VOID:
                        {
                        alt25=1;
                        }
                        break;
                    case OPEN_BRACE:
                        {
                        alt25=2;
                        }
                        break;
                    case OPEN_BRACKET:
                        {
                        alt25=3;
                        }
                        break;
                    default:
                        if (state.backtracking>0) {state.failed=true; return ;}
                        NoViableAltException nvae =
                            new NoViableAltException("", 25, 0, input);

                        throw nvae;

                    }

                    switch (alt25) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:257:11: type ( object_creation_expression2 | object_or_collection_initializer | OPEN_BRACKET expression_list CLOSE_BRACKET ( rank_specifiers )? ( array_initializer )? | rank_specifiers array_initializer )
                            {
                            pushFollow(FOLLOW_type_in_primary_expression_start818);
                            type();

                            state._fsp--;
                            if (state.failed) return ;

                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:257:16: ( object_creation_expression2 | object_or_collection_initializer | OPEN_BRACKET expression_list CLOSE_BRACKET ( rank_specifiers )? ( array_initializer )? | rank_specifiers array_initializer )
                            int alt24=4;
                            switch ( input.LA(1) ) {
                            case OPEN_PARENS:
                                {
                                alt24=1;
                                }
                                break;
                            case OPEN_BRACE:
                                {
                                alt24=2;
                                }
                                break;
                            case OPEN_BRACKET:
                                {
                                int LA24_3 = input.LA(2);

                                if ( (LA24_3==AMP||(LA24_3 >= BANG && LA24_3 <= BASE)||LA24_3==BOOL||LA24_3==BYTE||(LA24_3 >= CHAR && LA24_3 <= CHECKED)||LA24_3==DECIMAL||(LA24_3 >= DEFAULT && LA24_3 <= DELEGATE)||LA24_3==DOUBLE||LA24_3==FALSE||LA24_3==FLOAT||LA24_3==IDENTIFIER||(LA24_3 >= INT && LA24_3 <= INTEGER_LITERAL)||LA24_3==LONG||LA24_3==MINUS||LA24_3==NEW||LA24_3==NULL||LA24_3==OBJECT||LA24_3==OPEN_PARENS||LA24_3==OP_DEC||LA24_3==OP_INC||LA24_3==PLUS||LA24_3==REAL_LITERAL||LA24_3==SBYTE||LA24_3==SHORT||LA24_3==SIZEOF||LA24_3==STAR||(LA24_3 >= STRING && LA24_3 <= STRING_LITERAL)||LA24_3==THIS||(LA24_3 >= TILDE && LA24_3 <= TRUE)||(LA24_3 >= TYPEOF && LA24_3 <= UNCHECKED)||LA24_3==USHORT) ) {
                                    alt24=3;
                                }
                                else if ( (LA24_3==CLOSE_BRACKET||LA24_3==COMMA) ) {
                                    alt24=4;
                                }
                                else {
                                    if (state.backtracking>0) {state.failed=true; return ;}
                                    NoViableAltException nvae =
                                        new NoViableAltException("", 24, 3, input);

                                    throw nvae;

                                }
                                }
                                break;
                            default:
                                if (state.backtracking>0) {state.failed=true; return ;}
                                NoViableAltException nvae =
                                    new NoViableAltException("", 24, 0, input);

                                throw nvae;

                            }

                            switch (alt24) {
                                case 1 :
                                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:257:18: object_creation_expression2
                                    {
                                    pushFollow(FOLLOW_object_creation_expression2_in_primary_expression_start822);
                                    object_creation_expression2();

                                    state._fsp--;
                                    if (state.failed) return ;

                                    }
                                    break;
                                case 2 :
                                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:258:18: object_or_collection_initializer
                                    {
                                    pushFollow(FOLLOW_object_or_collection_initializer_in_primary_expression_start841);
                                    object_or_collection_initializer();

                                    state._fsp--;
                                    if (state.failed) return ;

                                    }
                                    break;
                                case 3 :
                                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:259:18: OPEN_BRACKET expression_list CLOSE_BRACKET ( rank_specifiers )? ( array_initializer )?
                                    {
                                    match(input,OPEN_BRACKET,FOLLOW_OPEN_BRACKET_in_primary_expression_start860); if (state.failed) return ;

                                    pushFollow(FOLLOW_expression_list_in_primary_expression_start862);
                                    expression_list();

                                    state._fsp--;
                                    if (state.failed) return ;

                                    match(input,CLOSE_BRACKET,FOLLOW_CLOSE_BRACKET_in_primary_expression_start864); if (state.failed) return ;

                                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:259:61: ( rank_specifiers )?
                                    int alt22=2;
                                    int LA22_0 = input.LA(1);

                                    if ( (LA22_0==OPEN_BRACKET) ) {
                                        int LA22_1 = input.LA(2);

                                        if ( (LA22_1==CLOSE_BRACKET||LA22_1==COMMA) ) {
                                            alt22=1;
                                        }
                                    }
                                    switch (alt22) {
                                        case 1 :
                                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:259:61: rank_specifiers
                                            {
                                            pushFollow(FOLLOW_rank_specifiers_in_primary_expression_start866);
                                            rank_specifiers();

                                            state._fsp--;
                                            if (state.failed) return ;

                                            }
                                            break;

                                    }


                                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:259:78: ( array_initializer )?
                                    int alt23=2;
                                    int LA23_0 = input.LA(1);

                                    if ( (LA23_0==OPEN_BRACE) ) {
                                        alt23=1;
                                    }
                                    switch (alt23) {
                                        case 1 :
                                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:259:78: array_initializer
                                            {
                                            pushFollow(FOLLOW_array_initializer_in_primary_expression_start869);
                                            array_initializer();

                                            state._fsp--;
                                            if (state.failed) return ;

                                            }
                                            break;

                                    }


                                    }
                                    break;
                                case 4 :
                                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:260:18: rank_specifiers array_initializer
                                    {
                                    pushFollow(FOLLOW_rank_specifiers_in_primary_expression_start889);
                                    rank_specifiers();

                                    state._fsp--;
                                    if (state.failed) return ;

                                    pushFollow(FOLLOW_array_initializer_in_primary_expression_start891);
                                    array_initializer();

                                    state._fsp--;
                                    if (state.failed) return ;

                                    }
                                    break;

                            }


                            }
                            break;
                        case 2 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:262:11: anonymous_object_initializer
                            {
                            pushFollow(FOLLOW_anonymous_object_initializer_in_primary_expression_start920);
                            anonymous_object_initializer();

                            state._fsp--;
                            if (state.failed) return ;

                            }
                            break;
                        case 3 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:263:11: rank_specifier array_initializer
                            {
                            pushFollow(FOLLOW_rank_specifier_in_primary_expression_start932);
                            rank_specifier();

                            state._fsp--;
                            if (state.failed) return ;

                            pushFollow(FOLLOW_array_initializer_in_primary_expression_start934);
                            array_initializer();

                            state._fsp--;
                            if (state.failed) return ;

                            }
                            break;

                    }


                    }
                    break;
                case 9 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:265:5: typeof_expression
                    {
                    pushFollow(FOLLOW_typeof_expression_in_primary_expression_start950);
                    typeof_expression();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 10 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:266:5: checked_expression
                    {
                    pushFollow(FOLLOW_checked_expression_in_primary_expression_start956);
                    checked_expression();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 11 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:267:5: unchecked_expression
                    {
                    pushFollow(FOLLOW_unchecked_expression_in_primary_expression_start962);
                    unchecked_expression();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 12 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:268:5: default_value_expression
                    {
                    pushFollow(FOLLOW_default_value_expression_in_primary_expression_start968);
                    default_value_expression();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 13 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:269:5: anonymous_method_expression
                    {
                    pushFollow(FOLLOW_anonymous_method_expression_in_primary_expression_start974);
                    anonymous_method_expression();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 14 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:270:5: sizeof_expression
                    {
                    pushFollow(FOLLOW_sizeof_expression_in_primary_expression_start980);
                    sizeof_expression();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "primary_expression_start"



    // $ANTLR start "bracket_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:278:1: bracket_expression : OPEN_BRACKET expression_list CLOSE_BRACKET ;
    public final void bracket_expression() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:279:3: ( OPEN_BRACKET expression_list CLOSE_BRACKET )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:279:5: OPEN_BRACKET expression_list CLOSE_BRACKET
            {
            match(input,OPEN_BRACKET,FOLLOW_OPEN_BRACKET_in_bracket_expression994); if (state.failed) return ;

            pushFollow(FOLLOW_expression_list_in_bracket_expression996);
            expression_list();

            state._fsp--;
            if (state.failed) return ;

            match(input,CLOSE_BRACKET,FOLLOW_CLOSE_BRACKET_in_bracket_expression998); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "bracket_expression"



    // $ANTLR start "simple_name"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:354:1: simple_name : IDENTIFIER type_argument_list_opt ;
    public final void simple_name() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:355:2: ( IDENTIFIER type_argument_list_opt )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:355:4: IDENTIFIER type_argument_list_opt
            {
            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_simple_name1016); if (state.failed) return ;

            pushFollow(FOLLOW_type_argument_list_opt_in_simple_name1018);
            type_argument_list_opt();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "simple_name"



    // $ANTLR start "parenthesized_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:358:1: parenthesized_expression : OPEN_PARENS expression CLOSE_PARENS ;
    public final void parenthesized_expression() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:359:2: ( OPEN_PARENS expression CLOSE_PARENS )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:359:4: OPEN_PARENS expression CLOSE_PARENS
            {
            match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_parenthesized_expression1031); if (state.failed) return ;

            pushFollow(FOLLOW_expression_in_parenthesized_expression1033);
            expression();

            state._fsp--;
            if (state.failed) return ;

            match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_parenthesized_expression1035); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "parenthesized_expression"



    // $ANTLR start "member_access"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:369:1: member_access : primary_expression ;
    public final void member_access() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:370:3: ( primary_expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:370:5: primary_expression
            {
            pushFollow(FOLLOW_primary_expression_in_member_access1051);
            primary_expression();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "member_access"



    // $ANTLR start "predefined_type"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:372:1: predefined_type : ( BOOL | BYTE | CHAR | DECIMAL | DOUBLE | FLOAT | INT | LONG | OBJECT | SBYTE | SHORT | STRING | UINT | ULONG | USHORT );
    public final void predefined_type() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:373:2: ( BOOL | BYTE | CHAR | DECIMAL | DOUBLE | FLOAT | INT | LONG | OBJECT | SBYTE | SHORT | STRING | UINT | ULONG | USHORT )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:
            {
            if ( input.LA(1)==BOOL||input.LA(1)==BYTE||input.LA(1)==CHAR||input.LA(1)==DECIMAL||input.LA(1)==DOUBLE||input.LA(1)==FLOAT||input.LA(1)==INT||input.LA(1)==LONG||input.LA(1)==OBJECT||input.LA(1)==SBYTE||input.LA(1)==SHORT||input.LA(1)==STRING||(input.LA(1) >= UINT && input.LA(1) <= ULONG)||input.LA(1)==USHORT ) {
                input.consume();
                state.errorRecovery=false;
                state.failed=false;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                MismatchedSetException mse = new MismatchedSetException(null,input);
                throw mse;
            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "predefined_type"



    // $ANTLR start "expression_list"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:400:1: expression_list : expression ( COMMA expression )* ;
    public final void expression_list() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:401:2: ( expression ( COMMA expression )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:401:4: expression ( COMMA expression )*
            {
            pushFollow(FOLLOW_expression_in_expression_list1150);
            expression();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:401:15: ( COMMA expression )*
            loop27:
            do {
                int alt27=2;
                int LA27_0 = input.LA(1);

                if ( (LA27_0==COMMA) ) {
                    alt27=1;
                }


                switch (alt27) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:401:17: COMMA expression
            	    {
            	    match(input,COMMA,FOLLOW_COMMA_in_expression_list1154); if (state.failed) return ;

            	    pushFollow(FOLLOW_expression_in_expression_list1156);
            	    expression();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop27;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "expression_list"



    // $ANTLR start "this_access"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:403:1: this_access : THIS ;
    public final void this_access() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:404:2: ( THIS )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:404:4: THIS
            {
            match(input,THIS,FOLLOW_THIS_in_this_access1169); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "this_access"



    // $ANTLR start "base_access"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:407:1: base_access : ( BASE DOT IDENTIFIER type_argument_list_opt | BASE OPEN_BRACKET expression_list CLOSE_BRACKET );
    public final void base_access() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:408:2: ( BASE DOT IDENTIFIER type_argument_list_opt | BASE OPEN_BRACKET expression_list CLOSE_BRACKET )
            int alt28=2;
            int LA28_0 = input.LA(1);

            if ( (LA28_0==BASE) ) {
                int LA28_1 = input.LA(2);

                if ( (LA28_1==DOT) ) {
                    alt28=1;
                }
                else if ( (LA28_1==OPEN_BRACKET) ) {
                    alt28=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 28, 1, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 28, 0, input);

                throw nvae;

            }
            switch (alt28) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:408:4: BASE DOT IDENTIFIER type_argument_list_opt
                    {
                    match(input,BASE,FOLLOW_BASE_in_base_access1181); if (state.failed) return ;

                    match(input,DOT,FOLLOW_DOT_in_base_access1183); if (state.failed) return ;

                    match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_base_access1185); if (state.failed) return ;

                    pushFollow(FOLLOW_type_argument_list_opt_in_base_access1187);
                    type_argument_list_opt();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:409:4: BASE OPEN_BRACKET expression_list CLOSE_BRACKET
                    {
                    match(input,BASE,FOLLOW_BASE_in_base_access1192); if (state.failed) return ;

                    match(input,OPEN_BRACKET,FOLLOW_OPEN_BRACKET_in_base_access1194); if (state.failed) return ;

                    pushFollow(FOLLOW_expression_list_in_base_access1196);
                    expression_list();

                    state._fsp--;
                    if (state.failed) return ;

                    match(input,CLOSE_BRACKET,FOLLOW_CLOSE_BRACKET_in_base_access1198); if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "base_access"



    // $ANTLR start "object_creation_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:426:1: object_creation_expression : NEW type ( OPEN_PARENS ( argument_list )? CLOSE_PARENS ( object_or_collection_initializer )? | object_or_collection_initializer ) ;
    public final void object_creation_expression() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:427:3: ( NEW type ( OPEN_PARENS ( argument_list )? CLOSE_PARENS ( object_or_collection_initializer )? | object_or_collection_initializer ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:427:5: NEW type ( OPEN_PARENS ( argument_list )? CLOSE_PARENS ( object_or_collection_initializer )? | object_or_collection_initializer )
            {
            match(input,NEW,FOLLOW_NEW_in_object_creation_expression1216); if (state.failed) return ;

            pushFollow(FOLLOW_type_in_object_creation_expression1218);
            type();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:427:14: ( OPEN_PARENS ( argument_list )? CLOSE_PARENS ( object_or_collection_initializer )? | object_or_collection_initializer )
            int alt31=2;
            int LA31_0 = input.LA(1);

            if ( (LA31_0==OPEN_PARENS) ) {
                alt31=1;
            }
            else if ( (LA31_0==OPEN_BRACE) ) {
                alt31=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 31, 0, input);

                throw nvae;

            }
            switch (alt31) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:427:16: OPEN_PARENS ( argument_list )? CLOSE_PARENS ( object_or_collection_initializer )?
                    {
                    match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_object_creation_expression1222); if (state.failed) return ;

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:427:28: ( argument_list )?
                    int alt29=2;
                    int LA29_0 = input.LA(1);

                    if ( (LA29_0==AMP||(LA29_0 >= BANG && LA29_0 <= BASE)||LA29_0==BOOL||LA29_0==BYTE||(LA29_0 >= CHAR && LA29_0 <= CHECKED)||LA29_0==DECIMAL||(LA29_0 >= DEFAULT && LA29_0 <= DELEGATE)||LA29_0==DOUBLE||LA29_0==FALSE||LA29_0==FLOAT||LA29_0==IDENTIFIER||(LA29_0 >= INT && LA29_0 <= INTEGER_LITERAL)||LA29_0==LONG||LA29_0==MINUS||LA29_0==NEW||LA29_0==NULL||LA29_0==OBJECT||LA29_0==OPEN_PARENS||LA29_0==OP_DEC||LA29_0==OP_INC||LA29_0==OUT||LA29_0==PLUS||(LA29_0 >= REAL_LITERAL && LA29_0 <= REF)||LA29_0==SBYTE||LA29_0==SHORT||LA29_0==SIZEOF||LA29_0==STAR||(LA29_0 >= STRING && LA29_0 <= STRING_LITERAL)||LA29_0==THIS||(LA29_0 >= TILDE && LA29_0 <= TRUE)||(LA29_0 >= TYPEOF && LA29_0 <= UNCHECKED)||LA29_0==USHORT) ) {
                        alt29=1;
                    }
                    switch (alt29) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:427:28: argument_list
                            {
                            pushFollow(FOLLOW_argument_list_in_object_creation_expression1224);
                            argument_list();

                            state._fsp--;
                            if (state.failed) return ;

                            }
                            break;

                    }


                    match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_object_creation_expression1227); if (state.failed) return ;

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:427:56: ( object_or_collection_initializer )?
                    int alt30=2;
                    int LA30_0 = input.LA(1);

                    if ( (LA30_0==OPEN_BRACE) ) {
                        alt30=1;
                    }
                    switch (alt30) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:427:56: object_or_collection_initializer
                            {
                            pushFollow(FOLLOW_object_or_collection_initializer_in_object_creation_expression1229);
                            object_or_collection_initializer();

                            state._fsp--;
                            if (state.failed) return ;

                            }
                            break;

                    }


                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:428:16: object_or_collection_initializer
                    {
                    pushFollow(FOLLOW_object_or_collection_initializer_in_object_creation_expression1247);
                    object_or_collection_initializer();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "object_creation_expression"



    // $ANTLR start "object_or_collection_initializer"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:432:1: object_or_collection_initializer : ( object_initializer | collection_initializer );
    public final void object_or_collection_initializer() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:433:2: ( object_initializer | collection_initializer )
            int alt32=2;
            int LA32_0 = input.LA(1);

            if ( (LA32_0==OPEN_BRACE) ) {
                switch ( input.LA(2) ) {
                case CLOSE_BRACE:
                    {
                    alt32=1;
                    }
                    break;
                case IDENTIFIER:
                    {
                    int LA32_3 = input.LA(3);

                    if ( (LA32_3==ASSIGNMENT) ) {
                        int LA32_5 = input.LA(4);

                        if ( (LA32_5==GT) ) {
                            alt32=2;
                        }
                        else if ( (LA32_5==AMP||(LA32_5 >= BANG && LA32_5 <= BASE)||LA32_5==BOOL||LA32_5==BYTE||(LA32_5 >= CHAR && LA32_5 <= CHECKED)||LA32_5==DECIMAL||(LA32_5 >= DEFAULT && LA32_5 <= DELEGATE)||LA32_5==DOUBLE||LA32_5==FALSE||LA32_5==FLOAT||LA32_5==IDENTIFIER||(LA32_5 >= INT && LA32_5 <= INTEGER_LITERAL)||LA32_5==LONG||LA32_5==MINUS||LA32_5==NEW||LA32_5==NULL||(LA32_5 >= OBJECT && LA32_5 <= OPEN_BRACE)||LA32_5==OPEN_PARENS||LA32_5==OP_DEC||LA32_5==OP_INC||LA32_5==PLUS||LA32_5==REAL_LITERAL||LA32_5==SBYTE||LA32_5==SHORT||LA32_5==SIZEOF||LA32_5==STAR||(LA32_5 >= STRING && LA32_5 <= STRING_LITERAL)||LA32_5==THIS||(LA32_5 >= TILDE && LA32_5 <= TRUE)||(LA32_5 >= TYPEOF && LA32_5 <= UNCHECKED)||LA32_5==USHORT) ) {
                            alt32=1;
                        }
                        else {
                            if (state.backtracking>0) {state.failed=true; return ;}
                            NoViableAltException nvae =
                                new NoViableAltException("", 32, 5, input);

                            throw nvae;

                        }
                    }
                    else if ( ((LA32_3 >= AMP && LA32_3 <= AS)||(LA32_3 >= BITWISE_OR && LA32_3 <= BOOL)||(LA32_3 >= BYTE && LA32_3 <= CARET)||LA32_3==CHAR||LA32_3==CLOSE_BRACE||LA32_3==COMMA||LA32_3==DECIMAL||LA32_3==DIV||(LA32_3 >= DOT && LA32_3 <= DOUBLE)||LA32_3==DOUBLE_COLON||LA32_3==FLOAT||LA32_3==GT||LA32_3==IDENTIFIER||LA32_3==INT||(LA32_3 >= INTERR && LA32_3 <= IS)||(LA32_3 >= LONG && LA32_3 <= LT)||LA32_3==MINUS||LA32_3==OBJECT||(LA32_3 >= OPEN_BRACKET && LA32_3 <= OPEN_PARENS)||LA32_3==OP_AND||(LA32_3 >= OP_COALESCING && LA32_3 <= OP_DEC)||(LA32_3 >= OP_EQ && LA32_3 <= OP_LEFT_SHIFT)||(LA32_3 >= OP_NE && LA32_3 <= OP_OR)||LA32_3==OP_PTR||(LA32_3 >= PERCENT && LA32_3 <= PLUS)||LA32_3==SBYTE||LA32_3==SHORT||LA32_3==STAR||LA32_3==STRING||(LA32_3 >= UINT && LA32_3 <= ULONG)||LA32_3==USHORT||LA32_3==VOID) ) {
                        alt32=2;
                    }
                    else {
                        if (state.backtracking>0) {state.failed=true; return ;}
                        NoViableAltException nvae =
                            new NoViableAltException("", 32, 3, input);

                        throw nvae;

                    }
                    }
                    break;
                case AMP:
                case BANG:
                case BASE:
                case BOOL:
                case BYTE:
                case CHAR:
                case CHARACTER_LITERAL:
                case CHECKED:
                case DECIMAL:
                case DEFAULT:
                case DELEGATE:
                case DOUBLE:
                case FALSE:
                case FLOAT:
                case INT:
                case INTEGER_LITERAL:
                case LONG:
                case MINUS:
                case NEW:
                case NULL:
                case OBJECT:
                case OPEN_BRACE:
                case OPEN_PARENS:
                case OP_DEC:
                case OP_INC:
                case PLUS:
                case REAL_LITERAL:
                case SBYTE:
                case SHORT:
                case SIZEOF:
                case STAR:
                case STRING:
                case STRING_LITERAL:
                case THIS:
                case TILDE:
                case TRUE:
                case TYPEOF:
                case UINT:
                case ULONG:
                case UNCHECKED:
                case USHORT:
                    {
                    alt32=2;
                    }
                    break;
                default:
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 32, 1, input);

                    throw nvae;

                }

            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 32, 0, input);

                throw nvae;

            }
            switch (alt32) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:433:4: object_initializer
                    {
                    pushFollow(FOLLOW_object_initializer_in_object_or_collection_initializer1276);
                    object_initializer();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:434:4: collection_initializer
                    {
                    pushFollow(FOLLOW_collection_initializer_in_object_or_collection_initializer1281);
                    collection_initializer();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "object_or_collection_initializer"



    // $ANTLR start "object_initializer"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:443:1: object_initializer : ( OPEN_BRACE CLOSE_BRACE | OPEN_BRACE member_initializer_list ( COMMA )? CLOSE_BRACE );
    public final void object_initializer() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:444:3: ( OPEN_BRACE CLOSE_BRACE | OPEN_BRACE member_initializer_list ( COMMA )? CLOSE_BRACE )
            int alt34=2;
            int LA34_0 = input.LA(1);

            if ( (LA34_0==OPEN_BRACE) ) {
                int LA34_1 = input.LA(2);

                if ( (LA34_1==CLOSE_BRACE) ) {
                    alt34=1;
                }
                else if ( (LA34_1==IDENTIFIER) ) {
                    alt34=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 34, 1, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 34, 0, input);

                throw nvae;

            }
            switch (alt34) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:444:5: OPEN_BRACE CLOSE_BRACE
                    {
                    match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_object_initializer1297); if (state.failed) return ;

                    match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_object_initializer1299); if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:445:5: OPEN_BRACE member_initializer_list ( COMMA )? CLOSE_BRACE
                    {
                    match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_object_initializer1305); if (state.failed) return ;

                    pushFollow(FOLLOW_member_initializer_list_in_object_initializer1307);
                    member_initializer_list();

                    state._fsp--;
                    if (state.failed) return ;

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:445:40: ( COMMA )?
                    int alt33=2;
                    int LA33_0 = input.LA(1);

                    if ( (LA33_0==COMMA) ) {
                        alt33=1;
                    }
                    switch (alt33) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:445:40: COMMA
                            {
                            match(input,COMMA,FOLLOW_COMMA_in_object_initializer1309); if (state.failed) return ;

                            }
                            break;

                    }


                    match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_object_initializer1312); if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "object_initializer"



    // $ANTLR start "member_initializer_list"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:447:1: member_initializer_list : member_initializer ( COMMA member_initializer )* ;
    public final void member_initializer_list() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:448:2: ( member_initializer ( COMMA member_initializer )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:448:4: member_initializer ( COMMA member_initializer )*
            {
            pushFollow(FOLLOW_member_initializer_in_member_initializer_list1324);
            member_initializer();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:448:23: ( COMMA member_initializer )*
            loop35:
            do {
                int alt35=2;
                int LA35_0 = input.LA(1);

                if ( (LA35_0==COMMA) ) {
                    int LA35_1 = input.LA(2);

                    if ( (LA35_1==IDENTIFIER) ) {
                        alt35=1;
                    }


                }


                switch (alt35) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:448:25: COMMA member_initializer
            	    {
            	    match(input,COMMA,FOLLOW_COMMA_in_member_initializer_list1328); if (state.failed) return ;

            	    pushFollow(FOLLOW_member_initializer_in_member_initializer_list1330);
            	    member_initializer();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop35;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "member_initializer_list"



    // $ANTLR start "member_initializer"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:450:1: member_initializer : IDENTIFIER ASSIGNMENT initializer_value ;
    public final void member_initializer() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:451:2: ( IDENTIFIER ASSIGNMENT initializer_value )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:451:4: IDENTIFIER ASSIGNMENT initializer_value
            {
            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_member_initializer1343); if (state.failed) return ;

            match(input,ASSIGNMENT,FOLLOW_ASSIGNMENT_in_member_initializer1345); if (state.failed) return ;

            pushFollow(FOLLOW_initializer_value_in_member_initializer1347);
            initializer_value();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "member_initializer"



    // $ANTLR start "initializer_value"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:453:1: initializer_value : ( expression | object_or_collection_initializer );
    public final void initializer_value() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:454:2: ( expression | object_or_collection_initializer )
            int alt36=2;
            int LA36_0 = input.LA(1);

            if ( (LA36_0==AMP||(LA36_0 >= BANG && LA36_0 <= BASE)||LA36_0==BOOL||LA36_0==BYTE||(LA36_0 >= CHAR && LA36_0 <= CHECKED)||LA36_0==DECIMAL||(LA36_0 >= DEFAULT && LA36_0 <= DELEGATE)||LA36_0==DOUBLE||LA36_0==FALSE||LA36_0==FLOAT||LA36_0==IDENTIFIER||(LA36_0 >= INT && LA36_0 <= INTEGER_LITERAL)||LA36_0==LONG||LA36_0==MINUS||LA36_0==NEW||LA36_0==NULL||LA36_0==OBJECT||LA36_0==OPEN_PARENS||LA36_0==OP_DEC||LA36_0==OP_INC||LA36_0==PLUS||LA36_0==REAL_LITERAL||LA36_0==SBYTE||LA36_0==SHORT||LA36_0==SIZEOF||LA36_0==STAR||(LA36_0 >= STRING && LA36_0 <= STRING_LITERAL)||LA36_0==THIS||(LA36_0 >= TILDE && LA36_0 <= TRUE)||(LA36_0 >= TYPEOF && LA36_0 <= UNCHECKED)||LA36_0==USHORT) ) {
                alt36=1;
            }
            else if ( (LA36_0==OPEN_BRACE) ) {
                alt36=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 36, 0, input);

                throw nvae;

            }
            switch (alt36) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:454:4: expression
                    {
                    pushFollow(FOLLOW_expression_in_initializer_value1358);
                    expression();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:455:4: object_or_collection_initializer
                    {
                    pushFollow(FOLLOW_object_or_collection_initializer_in_initializer_value1363);
                    object_or_collection_initializer();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "initializer_value"



    // $ANTLR start "collection_initializer"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:464:1: collection_initializer : OPEN_BRACE element_initializer_list ( COMMA )? CLOSE_BRACE ;
    public final void collection_initializer() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:465:3: ( OPEN_BRACE element_initializer_list ( COMMA )? CLOSE_BRACE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:465:5: OPEN_BRACE element_initializer_list ( COMMA )? CLOSE_BRACE
            {
            match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_collection_initializer1379); if (state.failed) return ;

            pushFollow(FOLLOW_element_initializer_list_in_collection_initializer1381);
            element_initializer_list();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:465:41: ( COMMA )?
            int alt37=2;
            int LA37_0 = input.LA(1);

            if ( (LA37_0==COMMA) ) {
                alt37=1;
            }
            switch (alt37) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:465:41: COMMA
                    {
                    match(input,COMMA,FOLLOW_COMMA_in_collection_initializer1383); if (state.failed) return ;

                    }
                    break;

            }


            match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_collection_initializer1386); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "collection_initializer"



    // $ANTLR start "element_initializer_list"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:467:1: element_initializer_list : element_initializer ( COMMA element_initializer )* ;
    public final void element_initializer_list() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:468:2: ( element_initializer ( COMMA element_initializer )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:468:4: element_initializer ( COMMA element_initializer )*
            {
            pushFollow(FOLLOW_element_initializer_in_element_initializer_list1398);
            element_initializer();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:468:24: ( COMMA element_initializer )*
            loop38:
            do {
                int alt38=2;
                int LA38_0 = input.LA(1);

                if ( (LA38_0==COMMA) ) {
                    int LA38_1 = input.LA(2);

                    if ( (LA38_1==AMP||(LA38_1 >= BANG && LA38_1 <= BASE)||LA38_1==BOOL||LA38_1==BYTE||(LA38_1 >= CHAR && LA38_1 <= CHECKED)||LA38_1==DECIMAL||(LA38_1 >= DEFAULT && LA38_1 <= DELEGATE)||LA38_1==DOUBLE||LA38_1==FALSE||LA38_1==FLOAT||LA38_1==IDENTIFIER||(LA38_1 >= INT && LA38_1 <= INTEGER_LITERAL)||LA38_1==LONG||LA38_1==MINUS||LA38_1==NEW||LA38_1==NULL||(LA38_1 >= OBJECT && LA38_1 <= OPEN_BRACE)||LA38_1==OPEN_PARENS||LA38_1==OP_DEC||LA38_1==OP_INC||LA38_1==PLUS||LA38_1==REAL_LITERAL||LA38_1==SBYTE||LA38_1==SHORT||LA38_1==SIZEOF||LA38_1==STAR||(LA38_1 >= STRING && LA38_1 <= STRING_LITERAL)||LA38_1==THIS||(LA38_1 >= TILDE && LA38_1 <= TRUE)||(LA38_1 >= TYPEOF && LA38_1 <= UNCHECKED)||LA38_1==USHORT) ) {
                        alt38=1;
                    }


                }


                switch (alt38) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:468:26: COMMA element_initializer
            	    {
            	    match(input,COMMA,FOLLOW_COMMA_in_element_initializer_list1402); if (state.failed) return ;

            	    pushFollow(FOLLOW_element_initializer_in_element_initializer_list1404);
            	    element_initializer();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop38;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "element_initializer_list"



    // $ANTLR start "element_initializer"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:470:1: element_initializer : ( non_assignment_expression | OPEN_BRACE expression_list CLOSE_BRACE );
    public final void element_initializer() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:471:2: ( non_assignment_expression | OPEN_BRACE expression_list CLOSE_BRACE )
            int alt39=2;
            int LA39_0 = input.LA(1);

            if ( (LA39_0==AMP||(LA39_0 >= BANG && LA39_0 <= BASE)||LA39_0==BOOL||LA39_0==BYTE||(LA39_0 >= CHAR && LA39_0 <= CHECKED)||LA39_0==DECIMAL||(LA39_0 >= DEFAULT && LA39_0 <= DELEGATE)||LA39_0==DOUBLE||LA39_0==FALSE||LA39_0==FLOAT||LA39_0==IDENTIFIER||(LA39_0 >= INT && LA39_0 <= INTEGER_LITERAL)||LA39_0==LONG||LA39_0==MINUS||LA39_0==NEW||LA39_0==NULL||LA39_0==OBJECT||LA39_0==OPEN_PARENS||LA39_0==OP_DEC||LA39_0==OP_INC||LA39_0==PLUS||LA39_0==REAL_LITERAL||LA39_0==SBYTE||LA39_0==SHORT||LA39_0==SIZEOF||LA39_0==STAR||(LA39_0 >= STRING && LA39_0 <= STRING_LITERAL)||LA39_0==THIS||(LA39_0 >= TILDE && LA39_0 <= TRUE)||(LA39_0 >= TYPEOF && LA39_0 <= UNCHECKED)||LA39_0==USHORT) ) {
                alt39=1;
            }
            else if ( (LA39_0==OPEN_BRACE) ) {
                alt39=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 39, 0, input);

                throw nvae;

            }
            switch (alt39) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:471:4: non_assignment_expression
                    {
                    pushFollow(FOLLOW_non_assignment_expression_in_element_initializer1417);
                    non_assignment_expression();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:472:4: OPEN_BRACE expression_list CLOSE_BRACE
                    {
                    match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_element_initializer1422); if (state.failed) return ;

                    pushFollow(FOLLOW_expression_list_in_element_initializer1424);
                    expression_list();

                    state._fsp--;
                    if (state.failed) return ;

                    match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_element_initializer1426); if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "element_initializer"



    // $ANTLR start "array_creation_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:481:1: array_creation_expression : NEW ( ( array_type OPEN_BRACKET )=> array_type array_initializer | non_array_type OPEN_BRACKET expression_list CLOSE_BRACKET ( rank_specifiers )? ( array_initializer )? | rank_specifier array_initializer ) ;
    public final void array_creation_expression() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:482:3: ( NEW ( ( array_type OPEN_BRACKET )=> array_type array_initializer | non_array_type OPEN_BRACKET expression_list CLOSE_BRACKET ( rank_specifiers )? ( array_initializer )? | rank_specifier array_initializer ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:482:5: NEW ( ( array_type OPEN_BRACKET )=> array_type array_initializer | non_array_type OPEN_BRACKET expression_list CLOSE_BRACKET ( rank_specifiers )? ( array_initializer )? | rank_specifier array_initializer )
            {
            match(input,NEW,FOLLOW_NEW_in_array_creation_expression1440); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:482:9: ( ( array_type OPEN_BRACKET )=> array_type array_initializer | non_array_type OPEN_BRACKET expression_list CLOSE_BRACKET ( rank_specifiers )? ( array_initializer )? | rank_specifier array_initializer )
            int alt42=3;
            switch ( input.LA(1) ) {
            case BYTE:
            case CHAR:
            case INT:
            case LONG:
            case SBYTE:
            case SHORT:
            case UINT:
            case ULONG:
            case USHORT:
                {
                int LA42_1 = input.LA(2);

                if ( (synpred5_CSharp4()) ) {
                    alt42=1;
                }
                else if ( (true) ) {
                    alt42=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 42, 1, input);

                    throw nvae;

                }
                }
                break;
            case DOUBLE:
            case FLOAT:
                {
                int LA42_2 = input.LA(2);

                if ( (synpred5_CSharp4()) ) {
                    alt42=1;
                }
                else if ( (true) ) {
                    alt42=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 42, 2, input);

                    throw nvae;

                }
                }
                break;
            case DECIMAL:
                {
                int LA42_3 = input.LA(2);

                if ( (synpred5_CSharp4()) ) {
                    alt42=1;
                }
                else if ( (true) ) {
                    alt42=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 42, 3, input);

                    throw nvae;

                }
                }
                break;
            case BOOL:
                {
                int LA42_4 = input.LA(2);

                if ( (synpred5_CSharp4()) ) {
                    alt42=1;
                }
                else if ( (true) ) {
                    alt42=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 42, 4, input);

                    throw nvae;

                }
                }
                break;
            case IDENTIFIER:
                {
                int LA42_5 = input.LA(2);

                if ( (synpred5_CSharp4()) ) {
                    alt42=1;
                }
                else if ( (true) ) {
                    alt42=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 42, 5, input);

                    throw nvae;

                }
                }
                break;
            case OBJECT:
                {
                int LA42_6 = input.LA(2);

                if ( (synpred5_CSharp4()) ) {
                    alt42=1;
                }
                else if ( (true) ) {
                    alt42=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 42, 6, input);

                    throw nvae;

                }
                }
                break;
            case STRING:
                {
                int LA42_7 = input.LA(2);

                if ( (synpred5_CSharp4()) ) {
                    alt42=1;
                }
                else if ( (true) ) {
                    alt42=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 42, 7, input);

                    throw nvae;

                }
                }
                break;
            case VOID:
                {
                int LA42_8 = input.LA(2);

                if ( (synpred5_CSharp4()) ) {
                    alt42=1;
                }
                else if ( (true) ) {
                    alt42=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 42, 8, input);

                    throw nvae;

                }
                }
                break;
            case OPEN_BRACKET:
                {
                alt42=3;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 42, 0, input);

                throw nvae;

            }

            switch (alt42) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:482:11: ( array_type OPEN_BRACKET )=> array_type array_initializer
                    {
                    pushFollow(FOLLOW_array_type_in_array_creation_expression1452);
                    array_type();

                    state._fsp--;
                    if (state.failed) return ;

                    pushFollow(FOLLOW_array_initializer_in_array_creation_expression1454);
                    array_initializer();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:483:11: non_array_type OPEN_BRACKET expression_list CLOSE_BRACKET ( rank_specifiers )? ( array_initializer )?
                    {
                    pushFollow(FOLLOW_non_array_type_in_array_creation_expression1466);
                    non_array_type();

                    state._fsp--;
                    if (state.failed) return ;

                    match(input,OPEN_BRACKET,FOLLOW_OPEN_BRACKET_in_array_creation_expression1468); if (state.failed) return ;

                    pushFollow(FOLLOW_expression_list_in_array_creation_expression1470);
                    expression_list();

                    state._fsp--;
                    if (state.failed) return ;

                    match(input,CLOSE_BRACKET,FOLLOW_CLOSE_BRACKET_in_array_creation_expression1472); if (state.failed) return ;

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:483:69: ( rank_specifiers )?
                    int alt40=2;
                    int LA40_0 = input.LA(1);

                    if ( (LA40_0==OPEN_BRACKET) ) {
                        alt40=1;
                    }
                    switch (alt40) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:483:69: rank_specifiers
                            {
                            pushFollow(FOLLOW_rank_specifiers_in_array_creation_expression1474);
                            rank_specifiers();

                            state._fsp--;
                            if (state.failed) return ;

                            }
                            break;

                    }


                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:483:86: ( array_initializer )?
                    int alt41=2;
                    int LA41_0 = input.LA(1);

                    if ( (LA41_0==OPEN_BRACE) ) {
                        alt41=1;
                    }
                    switch (alt41) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:483:86: array_initializer
                            {
                            pushFollow(FOLLOW_array_initializer_in_array_creation_expression1477);
                            array_initializer();

                            state._fsp--;
                            if (state.failed) return ;

                            }
                            break;

                    }


                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:484:11: rank_specifier array_initializer
                    {
                    pushFollow(FOLLOW_rank_specifier_in_array_creation_expression1490);
                    rank_specifier();

                    state._fsp--;
                    if (state.failed) return ;

                    pushFollow(FOLLOW_array_initializer_in_array_creation_expression1492);
                    array_initializer();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "array_creation_expression"



    // $ANTLR start "delegate_creation_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:488:1: delegate_creation_expression : NEW delegate_type OPEN_PARENS expression CLOSE_PARENS ;
    public final void delegate_creation_expression() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:489:2: ( NEW delegate_type OPEN_PARENS expression CLOSE_PARENS )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:489:4: NEW delegate_type OPEN_PARENS expression CLOSE_PARENS
            {
            match(input,NEW,FOLLOW_NEW_in_delegate_creation_expression1516); if (state.failed) return ;

            pushFollow(FOLLOW_delegate_type_in_delegate_creation_expression1518);
            delegate_type();

            state._fsp--;
            if (state.failed) return ;

            match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_delegate_creation_expression1520); if (state.failed) return ;

            pushFollow(FOLLOW_expression_in_delegate_creation_expression1522);
            expression();

            state._fsp--;
            if (state.failed) return ;

            match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_delegate_creation_expression1524); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "delegate_creation_expression"



    // $ANTLR start "anonymous_object_creation_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:492:1: anonymous_object_creation_expression : NEW anonymous_object_initializer ;
    public final void anonymous_object_creation_expression() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:493:2: ( NEW anonymous_object_initializer )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:493:4: NEW anonymous_object_initializer
            {
            match(input,NEW,FOLLOW_NEW_in_anonymous_object_creation_expression1537); if (state.failed) return ;

            pushFollow(FOLLOW_anonymous_object_initializer_in_anonymous_object_creation_expression1539);
            anonymous_object_initializer();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "anonymous_object_creation_expression"



    // $ANTLR start "anonymous_object_initializer"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:502:1: anonymous_object_initializer : ( OPEN_BRACE CLOSE_BRACE | OPEN_BRACE member_declarator_list ( COMMA )? CLOSE_BRACE );
    public final void anonymous_object_initializer() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:503:3: ( OPEN_BRACE CLOSE_BRACE | OPEN_BRACE member_declarator_list ( COMMA )? CLOSE_BRACE )
            int alt44=2;
            int LA44_0 = input.LA(1);

            if ( (LA44_0==OPEN_BRACE) ) {
                int LA44_1 = input.LA(2);

                if ( (LA44_1==CLOSE_BRACE) ) {
                    alt44=1;
                }
                else if ( (LA44_1==BASE||LA44_1==BOOL||LA44_1==BYTE||(LA44_1 >= CHAR && LA44_1 <= CHECKED)||LA44_1==DECIMAL||(LA44_1 >= DEFAULT && LA44_1 <= DELEGATE)||LA44_1==DOUBLE||LA44_1==FALSE||LA44_1==FLOAT||LA44_1==IDENTIFIER||(LA44_1 >= INT && LA44_1 <= INTEGER_LITERAL)||LA44_1==LONG||LA44_1==NEW||LA44_1==NULL||LA44_1==OBJECT||LA44_1==OPEN_PARENS||LA44_1==REAL_LITERAL||LA44_1==SBYTE||LA44_1==SHORT||LA44_1==SIZEOF||(LA44_1 >= STRING && LA44_1 <= STRING_LITERAL)||LA44_1==THIS||LA44_1==TRUE||(LA44_1 >= TYPEOF && LA44_1 <= UNCHECKED)||LA44_1==USHORT) ) {
                    alt44=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 44, 1, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 44, 0, input);

                throw nvae;

            }
            switch (alt44) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:503:5: OPEN_BRACE CLOSE_BRACE
                    {
                    match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_anonymous_object_initializer1555); if (state.failed) return ;

                    match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_anonymous_object_initializer1557); if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:504:5: OPEN_BRACE member_declarator_list ( COMMA )? CLOSE_BRACE
                    {
                    match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_anonymous_object_initializer1563); if (state.failed) return ;

                    pushFollow(FOLLOW_member_declarator_list_in_anonymous_object_initializer1565);
                    member_declarator_list();

                    state._fsp--;
                    if (state.failed) return ;

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:504:39: ( COMMA )?
                    int alt43=2;
                    int LA43_0 = input.LA(1);

                    if ( (LA43_0==COMMA) ) {
                        alt43=1;
                    }
                    switch (alt43) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:504:39: COMMA
                            {
                            match(input,COMMA,FOLLOW_COMMA_in_anonymous_object_initializer1567); if (state.failed) return ;

                            }
                            break;

                    }


                    match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_anonymous_object_initializer1570); if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "anonymous_object_initializer"



    // $ANTLR start "member_declarator_list"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:506:1: member_declarator_list : member_declarator ( COMMA member_declarator )* ;
    public final void member_declarator_list() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:507:2: ( member_declarator ( COMMA member_declarator )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:507:4: member_declarator ( COMMA member_declarator )*
            {
            pushFollow(FOLLOW_member_declarator_in_member_declarator_list1582);
            member_declarator();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:507:22: ( COMMA member_declarator )*
            loop45:
            do {
                int alt45=2;
                int LA45_0 = input.LA(1);

                if ( (LA45_0==COMMA) ) {
                    int LA45_1 = input.LA(2);

                    if ( (LA45_1==BASE||LA45_1==BOOL||LA45_1==BYTE||(LA45_1 >= CHAR && LA45_1 <= CHECKED)||LA45_1==DECIMAL||(LA45_1 >= DEFAULT && LA45_1 <= DELEGATE)||LA45_1==DOUBLE||LA45_1==FALSE||LA45_1==FLOAT||LA45_1==IDENTIFIER||(LA45_1 >= INT && LA45_1 <= INTEGER_LITERAL)||LA45_1==LONG||LA45_1==NEW||LA45_1==NULL||LA45_1==OBJECT||LA45_1==OPEN_PARENS||LA45_1==REAL_LITERAL||LA45_1==SBYTE||LA45_1==SHORT||LA45_1==SIZEOF||(LA45_1 >= STRING && LA45_1 <= STRING_LITERAL)||LA45_1==THIS||LA45_1==TRUE||(LA45_1 >= TYPEOF && LA45_1 <= UNCHECKED)||LA45_1==USHORT) ) {
                        alt45=1;
                    }


                }


                switch (alt45) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:507:24: COMMA member_declarator
            	    {
            	    match(input,COMMA,FOLLOW_COMMA_in_member_declarator_list1586); if (state.failed) return ;

            	    pushFollow(FOLLOW_member_declarator_in_member_declarator_list1588);
            	    member_declarator();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop45;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "member_declarator_list"



    // $ANTLR start "member_declarator"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:517:1: member_declarator : ( primary_expression | IDENTIFIER ASSIGNMENT expression );
    public final void member_declarator() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:518:3: ( primary_expression | IDENTIFIER ASSIGNMENT expression )
            int alt46=2;
            int LA46_0 = input.LA(1);

            if ( (LA46_0==BASE||LA46_0==BOOL||LA46_0==BYTE||(LA46_0 >= CHAR && LA46_0 <= CHECKED)||LA46_0==DECIMAL||(LA46_0 >= DEFAULT && LA46_0 <= DELEGATE)||LA46_0==DOUBLE||LA46_0==FALSE||LA46_0==FLOAT||(LA46_0 >= INT && LA46_0 <= INTEGER_LITERAL)||LA46_0==LONG||LA46_0==NEW||LA46_0==NULL||LA46_0==OBJECT||LA46_0==OPEN_PARENS||LA46_0==REAL_LITERAL||LA46_0==SBYTE||LA46_0==SHORT||LA46_0==SIZEOF||(LA46_0 >= STRING && LA46_0 <= STRING_LITERAL)||LA46_0==THIS||LA46_0==TRUE||(LA46_0 >= TYPEOF && LA46_0 <= UNCHECKED)||LA46_0==USHORT) ) {
                alt46=1;
            }
            else if ( (LA46_0==IDENTIFIER) ) {
                int LA46_2 = input.LA(2);

                if ( (LA46_2==CLOSE_BRACE||LA46_2==COMMA||LA46_2==DOT||LA46_2==DOUBLE_COLON||LA46_2==LT||(LA46_2 >= OPEN_BRACKET && LA46_2 <= OPEN_PARENS)||LA46_2==OP_DEC||LA46_2==OP_INC||LA46_2==OP_PTR) ) {
                    alt46=1;
                }
                else if ( (LA46_2==ASSIGNMENT) ) {
                    alt46=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 46, 2, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 46, 0, input);

                throw nvae;

            }
            switch (alt46) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:518:5: primary_expression
                    {
                    pushFollow(FOLLOW_primary_expression_in_member_declarator1604);
                    primary_expression();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:519:5: IDENTIFIER ASSIGNMENT expression
                    {
                    match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_member_declarator1610); if (state.failed) return ;

                    match(input,ASSIGNMENT,FOLLOW_ASSIGNMENT_in_member_declarator1612); if (state.failed) return ;

                    pushFollow(FOLLOW_expression_in_member_declarator1614);
                    expression();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "member_declarator"



    // $ANTLR start "typeof_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:521:1: typeof_expression : TYPEOF OPEN_PARENS ( ( unbound_type_name )=> unbound_type_name CLOSE_PARENS | type CLOSE_PARENS | VOID CLOSE_PARENS ) ;
    public final void typeof_expression() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:522:2: ( TYPEOF OPEN_PARENS ( ( unbound_type_name )=> unbound_type_name CLOSE_PARENS | type CLOSE_PARENS | VOID CLOSE_PARENS ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:522:4: TYPEOF OPEN_PARENS ( ( unbound_type_name )=> unbound_type_name CLOSE_PARENS | type CLOSE_PARENS | VOID CLOSE_PARENS )
            {
            match(input,TYPEOF,FOLLOW_TYPEOF_in_typeof_expression1626); if (state.failed) return ;

            match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_typeof_expression1628); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:523:4: ( ( unbound_type_name )=> unbound_type_name CLOSE_PARENS | type CLOSE_PARENS | VOID CLOSE_PARENS )
            int alt47=3;
            alt47 = dfa47.predict(input);
            switch (alt47) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:523:6: ( unbound_type_name )=> unbound_type_name CLOSE_PARENS
                    {
                    pushFollow(FOLLOW_unbound_type_name_in_typeof_expression1641);
                    unbound_type_name();

                    state._fsp--;
                    if (state.failed) return ;

                    match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_typeof_expression1643); if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:524:6: type CLOSE_PARENS
                    {
                    pushFollow(FOLLOW_type_in_typeof_expression1650);
                    type();

                    state._fsp--;
                    if (state.failed) return ;

                    match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_typeof_expression1652); if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:525:6: VOID CLOSE_PARENS
                    {
                    match(input,VOID,FOLLOW_VOID_in_typeof_expression1659); if (state.failed) return ;

                    match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_typeof_expression1661); if (state.failed) return ;

                    }
                    break;

            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "typeof_expression"



    // $ANTLR start "unbound_type_name"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:535:1: unbound_type_name : IDENTIFIER ( ( generic_dimension_specifier )? | DOUBLE_COLON IDENTIFIER ( generic_dimension_specifier )? ) ( DOT IDENTIFIER ( generic_dimension_specifier )? )* ;
    public final void unbound_type_name() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:536:3: ( IDENTIFIER ( ( generic_dimension_specifier )? | DOUBLE_COLON IDENTIFIER ( generic_dimension_specifier )? ) ( DOT IDENTIFIER ( generic_dimension_specifier )? )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:536:5: IDENTIFIER ( ( generic_dimension_specifier )? | DOUBLE_COLON IDENTIFIER ( generic_dimension_specifier )? ) ( DOT IDENTIFIER ( generic_dimension_specifier )? )*
            {
            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_unbound_type_name1680); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:536:16: ( ( generic_dimension_specifier )? | DOUBLE_COLON IDENTIFIER ( generic_dimension_specifier )? )
            int alt50=2;
            int LA50_0 = input.LA(1);

            if ( (LA50_0==EOF||LA50_0==CLOSE_PARENS||LA50_0==DOT||LA50_0==LT) ) {
                alt50=1;
            }
            else if ( (LA50_0==DOUBLE_COLON) ) {
                alt50=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 50, 0, input);

                throw nvae;

            }
            switch (alt50) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:536:18: ( generic_dimension_specifier )?
                    {
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:536:18: ( generic_dimension_specifier )?
                    int alt48=2;
                    int LA48_0 = input.LA(1);

                    if ( (LA48_0==LT) ) {
                        alt48=1;
                    }
                    switch (alt48) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:536:18: generic_dimension_specifier
                            {
                            pushFollow(FOLLOW_generic_dimension_specifier_in_unbound_type_name1684);
                            generic_dimension_specifier();

                            state._fsp--;
                            if (state.failed) return ;

                            }
                            break;

                    }


                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:537:18: DOUBLE_COLON IDENTIFIER ( generic_dimension_specifier )?
                    {
                    match(input,DOUBLE_COLON,FOLLOW_DOUBLE_COLON_in_unbound_type_name1704); if (state.failed) return ;

                    match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_unbound_type_name1706); if (state.failed) return ;

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:537:42: ( generic_dimension_specifier )?
                    int alt49=2;
                    int LA49_0 = input.LA(1);

                    if ( (LA49_0==LT) ) {
                        alt49=1;
                    }
                    switch (alt49) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:537:42: generic_dimension_specifier
                            {
                            pushFollow(FOLLOW_generic_dimension_specifier_in_unbound_type_name1708);
                            generic_dimension_specifier();

                            state._fsp--;
                            if (state.failed) return ;

                            }
                            break;

                    }


                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:539:5: ( DOT IDENTIFIER ( generic_dimension_specifier )? )*
            loop52:
            do {
                int alt52=2;
                int LA52_0 = input.LA(1);

                if ( (LA52_0==DOT) ) {
                    alt52=1;
                }


                switch (alt52) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:539:6: DOT IDENTIFIER ( generic_dimension_specifier )?
            	    {
            	    match(input,DOT,FOLLOW_DOT_in_unbound_type_name1733); if (state.failed) return ;

            	    match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_unbound_type_name1735); if (state.failed) return ;

            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:539:21: ( generic_dimension_specifier )?
            	    int alt51=2;
            	    int LA51_0 = input.LA(1);

            	    if ( (LA51_0==LT) ) {
            	        alt51=1;
            	    }
            	    switch (alt51) {
            	        case 1 :
            	            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:539:21: generic_dimension_specifier
            	            {
            	            pushFollow(FOLLOW_generic_dimension_specifier_in_unbound_type_name1737);
            	            generic_dimension_specifier();

            	            state._fsp--;
            	            if (state.failed) return ;

            	            }
            	            break;

            	    }


            	    }
            	    break;

            	default :
            	    break loop52;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "unbound_type_name"



    // $ANTLR start "generic_dimension_specifier"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:541:1: generic_dimension_specifier : LT ( commas )? GT ;
    public final void generic_dimension_specifier() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:542:2: ( LT ( commas )? GT )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:542:4: LT ( commas )? GT
            {
            match(input,LT,FOLLOW_LT_in_generic_dimension_specifier1752); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:542:7: ( commas )?
            int alt53=2;
            int LA53_0 = input.LA(1);

            if ( (LA53_0==COMMA) ) {
                alt53=1;
            }
            switch (alt53) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:542:7: commas
                    {
                    pushFollow(FOLLOW_commas_in_generic_dimension_specifier1754);
                    commas();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,GT,FOLLOW_GT_in_generic_dimension_specifier1757); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "generic_dimension_specifier"



    // $ANTLR start "commas"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:544:1: commas : COMMA ( COMMA )* ;
    public final void commas() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:545:2: ( COMMA ( COMMA )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:545:4: COMMA ( COMMA )*
            {
            match(input,COMMA,FOLLOW_COMMA_in_commas1768); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:545:10: ( COMMA )*
            loop54:
            do {
                int alt54=2;
                int LA54_0 = input.LA(1);

                if ( (LA54_0==COMMA) ) {
                    alt54=1;
                }


                switch (alt54) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:545:12: COMMA
            	    {
            	    match(input,COMMA,FOLLOW_COMMA_in_commas1772); if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop54;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "commas"



    // $ANTLR start "checked_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:547:1: checked_expression : CHECKED OPEN_PARENS expression CLOSE_PARENS ;
    public final void checked_expression() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:548:2: ( CHECKED OPEN_PARENS expression CLOSE_PARENS )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:548:4: CHECKED OPEN_PARENS expression CLOSE_PARENS
            {
            match(input,CHECKED,FOLLOW_CHECKED_in_checked_expression1786); if (state.failed) return ;

            match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_checked_expression1788); if (state.failed) return ;

            pushFollow(FOLLOW_expression_in_checked_expression1790);
            expression();

            state._fsp--;
            if (state.failed) return ;

            match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_checked_expression1792); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "checked_expression"



    // $ANTLR start "unchecked_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:550:1: unchecked_expression : UNCHECKED OPEN_PARENS expression CLOSE_PARENS ;
    public final void unchecked_expression() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:551:2: ( UNCHECKED OPEN_PARENS expression CLOSE_PARENS )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:551:4: UNCHECKED OPEN_PARENS expression CLOSE_PARENS
            {
            match(input,UNCHECKED,FOLLOW_UNCHECKED_in_unchecked_expression1803); if (state.failed) return ;

            match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_unchecked_expression1805); if (state.failed) return ;

            pushFollow(FOLLOW_expression_in_unchecked_expression1807);
            expression();

            state._fsp--;
            if (state.failed) return ;

            match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_unchecked_expression1809); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "unchecked_expression"



    // $ANTLR start "default_value_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:553:1: default_value_expression : DEFAULT OPEN_PARENS type CLOSE_PARENS ;
    public final void default_value_expression() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:554:2: ( DEFAULT OPEN_PARENS type CLOSE_PARENS )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:554:4: DEFAULT OPEN_PARENS type CLOSE_PARENS
            {
            match(input,DEFAULT,FOLLOW_DEFAULT_in_default_value_expression1820); if (state.failed) return ;

            match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_default_value_expression1822); if (state.failed) return ;

            pushFollow(FOLLOW_type_in_default_value_expression1824);
            type();

            state._fsp--;
            if (state.failed) return ;

            match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_default_value_expression1826); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "default_value_expression"



    // $ANTLR start "unary_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:569:1: unary_expression : ( ( scan_for_cast_generic_precedence | OPEN_PARENS predefined_type )=> cast_expression | primary_expression | PLUS unary_expression | MINUS unary_expression | BANG unary_expression | TILDE unary_expression | pre_increment_expression | pre_decrement_expression | unary_expression_unsafe );
    public final void unary_expression() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:570:2: ( ( scan_for_cast_generic_precedence | OPEN_PARENS predefined_type )=> cast_expression | primary_expression | PLUS unary_expression | MINUS unary_expression | BANG unary_expression | TILDE unary_expression | pre_increment_expression | pre_decrement_expression | unary_expression_unsafe )
            int alt55=9;
            switch ( input.LA(1) ) {
            case OPEN_PARENS:
                {
                int LA55_1 = input.LA(2);

                if ( (synpred7_CSharp4()) ) {
                    alt55=1;
                }
                else if ( (true) ) {
                    alt55=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 55, 1, input);

                    throw nvae;

                }
                }
                break;
            case BASE:
            case BOOL:
            case BYTE:
            case CHAR:
            case CHARACTER_LITERAL:
            case CHECKED:
            case DECIMAL:
            case DEFAULT:
            case DELEGATE:
            case DOUBLE:
            case FALSE:
            case FLOAT:
            case IDENTIFIER:
            case INT:
            case INTEGER_LITERAL:
            case LONG:
            case NEW:
            case NULL:
            case OBJECT:
            case REAL_LITERAL:
            case SBYTE:
            case SHORT:
            case SIZEOF:
            case STRING:
            case STRING_LITERAL:
            case THIS:
            case TRUE:
            case TYPEOF:
            case UINT:
            case ULONG:
            case UNCHECKED:
            case USHORT:
                {
                alt55=2;
                }
                break;
            case PLUS:
                {
                alt55=3;
                }
                break;
            case MINUS:
                {
                alt55=4;
                }
                break;
            case BANG:
                {
                alt55=5;
                }
                break;
            case TILDE:
                {
                alt55=6;
                }
                break;
            case OP_INC:
                {
                alt55=7;
                }
                break;
            case OP_DEC:
                {
                alt55=8;
                }
                break;
            case AMP:
            case STAR:
                {
                alt55=9;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 55, 0, input);

                throw nvae;

            }

            switch (alt55) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:570:4: ( scan_for_cast_generic_precedence | OPEN_PARENS predefined_type )=> cast_expression
                    {
                    pushFollow(FOLLOW_cast_expression_in_unary_expression1851);
                    cast_expression();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:571:4: primary_expression
                    {
                    pushFollow(FOLLOW_primary_expression_in_unary_expression1856);
                    primary_expression();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:572:4: PLUS unary_expression
                    {
                    match(input,PLUS,FOLLOW_PLUS_in_unary_expression1861); if (state.failed) return ;

                    pushFollow(FOLLOW_unary_expression_in_unary_expression1863);
                    unary_expression();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:573:4: MINUS unary_expression
                    {
                    match(input,MINUS,FOLLOW_MINUS_in_unary_expression1868); if (state.failed) return ;

                    pushFollow(FOLLOW_unary_expression_in_unary_expression1870);
                    unary_expression();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:574:4: BANG unary_expression
                    {
                    match(input,BANG,FOLLOW_BANG_in_unary_expression1875); if (state.failed) return ;

                    pushFollow(FOLLOW_unary_expression_in_unary_expression1877);
                    unary_expression();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 6 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:575:4: TILDE unary_expression
                    {
                    match(input,TILDE,FOLLOW_TILDE_in_unary_expression1882); if (state.failed) return ;

                    pushFollow(FOLLOW_unary_expression_in_unary_expression1884);
                    unary_expression();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 7 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:576:4: pre_increment_expression
                    {
                    pushFollow(FOLLOW_pre_increment_expression_in_unary_expression1889);
                    pre_increment_expression();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 8 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:577:4: pre_decrement_expression
                    {
                    pushFollow(FOLLOW_pre_decrement_expression_in_unary_expression1894);
                    pre_decrement_expression();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 9 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:578:4: unary_expression_unsafe
                    {
                    pushFollow(FOLLOW_unary_expression_unsafe_in_unary_expression1899);
                    unary_expression_unsafe();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "unary_expression"



    // $ANTLR start "scan_for_cast_generic_precedence"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:583:1: scan_for_cast_generic_precedence : OPEN_PARENS type CLOSE_PARENS cast_disambiguation_token ;
    public final void scan_for_cast_generic_precedence() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:584:3: ( OPEN_PARENS type CLOSE_PARENS cast_disambiguation_token )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:584:5: OPEN_PARENS type CLOSE_PARENS cast_disambiguation_token
            {
            match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_scan_for_cast_generic_precedence1913); if (state.failed) return ;

            pushFollow(FOLLOW_type_in_scan_for_cast_generic_precedence1915);
            type();

            state._fsp--;
            if (state.failed) return ;

            match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_scan_for_cast_generic_precedence1917); if (state.failed) return ;

            pushFollow(FOLLOW_cast_disambiguation_token_in_scan_for_cast_generic_precedence1919);
            cast_disambiguation_token();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "scan_for_cast_generic_precedence"



    // $ANTLR start "cast_disambiguation_token"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:589:1: cast_disambiguation_token : ( TILDE | BANG | OPEN_PARENS | IDENTIFIER | literal | ABSTRACT | BASE | BOOL | BREAK | BYTE | CASE | CATCH | CHAR | CHECKED | CLASS | CONST | CONTINUE | DECIMAL | DEFAULT | DELEGATE | DO | DOUBLE | ELSE | ENUM | EVENT | EXPLICIT | EXTERN | FINALLY | FIXED | FLOAT | FOR | FOREACH | GOTO | IF | IMPLICIT | IN | INT | INTERFACE | INTERNAL | LOCK | LONG | NAMESPACE | NEW | OBJECT | OPERATOR | OUT | OVERRIDE | PARAMS | PRIVATE | PROTECTED | PUBLIC | READONLY | REF | RETURN | SBYTE | SEALED | SHORT | SIZEOF | STACKALLOC | STATIC | STRING | STRUCT | SWITCH | THIS | THROW | TRY | TYPEOF | UINT | ULONG | UNCHECKED | UNSAFE | USHORT | USING | VIRTUAL | VOID | VOLATILE | WHILE ) ;
    public final void cast_disambiguation_token() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:590:3: ( ( TILDE | BANG | OPEN_PARENS | IDENTIFIER | literal | ABSTRACT | BASE | BOOL | BREAK | BYTE | CASE | CATCH | CHAR | CHECKED | CLASS | CONST | CONTINUE | DECIMAL | DEFAULT | DELEGATE | DO | DOUBLE | ELSE | ENUM | EVENT | EXPLICIT | EXTERN | FINALLY | FIXED | FLOAT | FOR | FOREACH | GOTO | IF | IMPLICIT | IN | INT | INTERFACE | INTERNAL | LOCK | LONG | NAMESPACE | NEW | OBJECT | OPERATOR | OUT | OVERRIDE | PARAMS | PRIVATE | PROTECTED | PUBLIC | READONLY | REF | RETURN | SBYTE | SEALED | SHORT | SIZEOF | STACKALLOC | STATIC | STRING | STRUCT | SWITCH | THIS | THROW | TRY | TYPEOF | UINT | ULONG | UNCHECKED | UNSAFE | USHORT | USING | VIRTUAL | VOID | VOLATILE | WHILE ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:590:5: ( TILDE | BANG | OPEN_PARENS | IDENTIFIER | literal | ABSTRACT | BASE | BOOL | BREAK | BYTE | CASE | CATCH | CHAR | CHECKED | CLASS | CONST | CONTINUE | DECIMAL | DEFAULT | DELEGATE | DO | DOUBLE | ELSE | ENUM | EVENT | EXPLICIT | EXTERN | FINALLY | FIXED | FLOAT | FOR | FOREACH | GOTO | IF | IMPLICIT | IN | INT | INTERFACE | INTERNAL | LOCK | LONG | NAMESPACE | NEW | OBJECT | OPERATOR | OUT | OVERRIDE | PARAMS | PRIVATE | PROTECTED | PUBLIC | READONLY | REF | RETURN | SBYTE | SEALED | SHORT | SIZEOF | STACKALLOC | STATIC | STRING | STRUCT | SWITCH | THIS | THROW | TRY | TYPEOF | UINT | ULONG | UNCHECKED | UNSAFE | USHORT | USING | VIRTUAL | VOID | VOLATILE | WHILE )
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:590:5: ( TILDE | BANG | OPEN_PARENS | IDENTIFIER | literal | ABSTRACT | BASE | BOOL | BREAK | BYTE | CASE | CATCH | CHAR | CHECKED | CLASS | CONST | CONTINUE | DECIMAL | DEFAULT | DELEGATE | DO | DOUBLE | ELSE | ENUM | EVENT | EXPLICIT | EXTERN | FINALLY | FIXED | FLOAT | FOR | FOREACH | GOTO | IF | IMPLICIT | IN | INT | INTERFACE | INTERNAL | LOCK | LONG | NAMESPACE | NEW | OBJECT | OPERATOR | OUT | OVERRIDE | PARAMS | PRIVATE | PROTECTED | PUBLIC | READONLY | REF | RETURN | SBYTE | SEALED | SHORT | SIZEOF | STACKALLOC | STATIC | STRING | STRUCT | SWITCH | THIS | THROW | TRY | TYPEOF | UINT | ULONG | UNCHECKED | UNSAFE | USHORT | USING | VIRTUAL | VOID | VOLATILE | WHILE )
            int alt56=77;
            alt56 = dfa56.predict(input);
            switch (alt56) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:590:6: TILDE
                    {
                    match(input,TILDE,FOLLOW_TILDE_in_cast_disambiguation_token1935); if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:590:14: BANG
                    {
                    match(input,BANG,FOLLOW_BANG_in_cast_disambiguation_token1939); if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:590:21: OPEN_PARENS
                    {
                    match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_cast_disambiguation_token1943); if (state.failed) return ;

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:590:35: IDENTIFIER
                    {
                    match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_cast_disambiguation_token1947); if (state.failed) return ;

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:590:48: literal
                    {
                    pushFollow(FOLLOW_literal_in_cast_disambiguation_token1951);
                    literal();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 6 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:590:58: ABSTRACT
                    {
                    match(input,ABSTRACT,FOLLOW_ABSTRACT_in_cast_disambiguation_token1955); if (state.failed) return ;

                    }
                    break;
                case 7 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:590:69: BASE
                    {
                    match(input,BASE,FOLLOW_BASE_in_cast_disambiguation_token1959); if (state.failed) return ;

                    }
                    break;
                case 8 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:590:76: BOOL
                    {
                    match(input,BOOL,FOLLOW_BOOL_in_cast_disambiguation_token1963); if (state.failed) return ;

                    }
                    break;
                case 9 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:590:83: BREAK
                    {
                    match(input,BREAK,FOLLOW_BREAK_in_cast_disambiguation_token1967); if (state.failed) return ;

                    }
                    break;
                case 10 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:590:91: BYTE
                    {
                    match(input,BYTE,FOLLOW_BYTE_in_cast_disambiguation_token1971); if (state.failed) return ;

                    }
                    break;
                case 11 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:590:98: CASE
                    {
                    match(input,CASE,FOLLOW_CASE_in_cast_disambiguation_token1975); if (state.failed) return ;

                    }
                    break;
                case 12 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:590:105: CATCH
                    {
                    match(input,CATCH,FOLLOW_CATCH_in_cast_disambiguation_token1979); if (state.failed) return ;

                    }
                    break;
                case 13 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:591:7: CHAR
                    {
                    match(input,CHAR,FOLLOW_CHAR_in_cast_disambiguation_token1987); if (state.failed) return ;

                    }
                    break;
                case 14 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:591:14: CHECKED
                    {
                    match(input,CHECKED,FOLLOW_CHECKED_in_cast_disambiguation_token1991); if (state.failed) return ;

                    }
                    break;
                case 15 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:591:24: CLASS
                    {
                    match(input,CLASS,FOLLOW_CLASS_in_cast_disambiguation_token1995); if (state.failed) return ;

                    }
                    break;
                case 16 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:591:32: CONST
                    {
                    match(input,CONST,FOLLOW_CONST_in_cast_disambiguation_token1999); if (state.failed) return ;

                    }
                    break;
                case 17 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:591:40: CONTINUE
                    {
                    match(input,CONTINUE,FOLLOW_CONTINUE_in_cast_disambiguation_token2003); if (state.failed) return ;

                    }
                    break;
                case 18 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:591:51: DECIMAL
                    {
                    match(input,DECIMAL,FOLLOW_DECIMAL_in_cast_disambiguation_token2007); if (state.failed) return ;

                    }
                    break;
                case 19 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:591:61: DEFAULT
                    {
                    match(input,DEFAULT,FOLLOW_DEFAULT_in_cast_disambiguation_token2011); if (state.failed) return ;

                    }
                    break;
                case 20 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:591:71: DELEGATE
                    {
                    match(input,DELEGATE,FOLLOW_DELEGATE_in_cast_disambiguation_token2015); if (state.failed) return ;

                    }
                    break;
                case 21 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:591:82: DO
                    {
                    match(input,DO,FOLLOW_DO_in_cast_disambiguation_token2019); if (state.failed) return ;

                    }
                    break;
                case 22 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:591:87: DOUBLE
                    {
                    match(input,DOUBLE,FOLLOW_DOUBLE_in_cast_disambiguation_token2023); if (state.failed) return ;

                    }
                    break;
                case 23 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:591:96: ELSE
                    {
                    match(input,ELSE,FOLLOW_ELSE_in_cast_disambiguation_token2027); if (state.failed) return ;

                    }
                    break;
                case 24 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:591:103: ENUM
                    {
                    match(input,ENUM,FOLLOW_ENUM_in_cast_disambiguation_token2031); if (state.failed) return ;

                    }
                    break;
                case 25 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:592:7: EVENT
                    {
                    match(input,EVENT,FOLLOW_EVENT_in_cast_disambiguation_token2039); if (state.failed) return ;

                    }
                    break;
                case 26 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:592:15: EXPLICIT
                    {
                    match(input,EXPLICIT,FOLLOW_EXPLICIT_in_cast_disambiguation_token2043); if (state.failed) return ;

                    }
                    break;
                case 27 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:592:26: EXTERN
                    {
                    match(input,EXTERN,FOLLOW_EXTERN_in_cast_disambiguation_token2047); if (state.failed) return ;

                    }
                    break;
                case 28 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:592:35: FINALLY
                    {
                    match(input,FINALLY,FOLLOW_FINALLY_in_cast_disambiguation_token2051); if (state.failed) return ;

                    }
                    break;
                case 29 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:592:45: FIXED
                    {
                    match(input,FIXED,FOLLOW_FIXED_in_cast_disambiguation_token2055); if (state.failed) return ;

                    }
                    break;
                case 30 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:592:53: FLOAT
                    {
                    match(input,FLOAT,FOLLOW_FLOAT_in_cast_disambiguation_token2059); if (state.failed) return ;

                    }
                    break;
                case 31 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:592:61: FOR
                    {
                    match(input,FOR,FOLLOW_FOR_in_cast_disambiguation_token2063); if (state.failed) return ;

                    }
                    break;
                case 32 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:592:67: FOREACH
                    {
                    match(input,FOREACH,FOLLOW_FOREACH_in_cast_disambiguation_token2067); if (state.failed) return ;

                    }
                    break;
                case 33 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:592:77: GOTO
                    {
                    match(input,GOTO,FOLLOW_GOTO_in_cast_disambiguation_token2071); if (state.failed) return ;

                    }
                    break;
                case 34 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:592:84: IF
                    {
                    match(input,IF,FOLLOW_IF_in_cast_disambiguation_token2075); if (state.failed) return ;

                    }
                    break;
                case 35 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:592:89: IMPLICIT
                    {
                    match(input,IMPLICIT,FOLLOW_IMPLICIT_in_cast_disambiguation_token2079); if (state.failed) return ;

                    }
                    break;
                case 36 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:592:100: IN
                    {
                    match(input,IN,FOLLOW_IN_in_cast_disambiguation_token2083); if (state.failed) return ;

                    }
                    break;
                case 37 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:592:105: INT
                    {
                    match(input,INT,FOLLOW_INT_in_cast_disambiguation_token2087); if (state.failed) return ;

                    }
                    break;
                case 38 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:593:7: INTERFACE
                    {
                    match(input,INTERFACE,FOLLOW_INTERFACE_in_cast_disambiguation_token2095); if (state.failed) return ;

                    }
                    break;
                case 39 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:593:19: INTERNAL
                    {
                    match(input,INTERNAL,FOLLOW_INTERNAL_in_cast_disambiguation_token2099); if (state.failed) return ;

                    }
                    break;
                case 40 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:593:30: LOCK
                    {
                    match(input,LOCK,FOLLOW_LOCK_in_cast_disambiguation_token2103); if (state.failed) return ;

                    }
                    break;
                case 41 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:593:37: LONG
                    {
                    match(input,LONG,FOLLOW_LONG_in_cast_disambiguation_token2107); if (state.failed) return ;

                    }
                    break;
                case 42 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:593:44: NAMESPACE
                    {
                    match(input,NAMESPACE,FOLLOW_NAMESPACE_in_cast_disambiguation_token2111); if (state.failed) return ;

                    }
                    break;
                case 43 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:593:56: NEW
                    {
                    match(input,NEW,FOLLOW_NEW_in_cast_disambiguation_token2115); if (state.failed) return ;

                    }
                    break;
                case 44 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:593:62: OBJECT
                    {
                    match(input,OBJECT,FOLLOW_OBJECT_in_cast_disambiguation_token2119); if (state.failed) return ;

                    }
                    break;
                case 45 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:593:71: OPERATOR
                    {
                    match(input,OPERATOR,FOLLOW_OPERATOR_in_cast_disambiguation_token2123); if (state.failed) return ;

                    }
                    break;
                case 46 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:593:82: OUT
                    {
                    match(input,OUT,FOLLOW_OUT_in_cast_disambiguation_token2127); if (state.failed) return ;

                    }
                    break;
                case 47 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:593:88: OVERRIDE
                    {
                    match(input,OVERRIDE,FOLLOW_OVERRIDE_in_cast_disambiguation_token2131); if (state.failed) return ;

                    }
                    break;
                case 48 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:593:99: PARAMS
                    {
                    match(input,PARAMS,FOLLOW_PARAMS_in_cast_disambiguation_token2135); if (state.failed) return ;

                    }
                    break;
                case 49 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:594:7: PRIVATE
                    {
                    match(input,PRIVATE,FOLLOW_PRIVATE_in_cast_disambiguation_token2143); if (state.failed) return ;

                    }
                    break;
                case 50 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:594:17: PROTECTED
                    {
                    match(input,PROTECTED,FOLLOW_PROTECTED_in_cast_disambiguation_token2147); if (state.failed) return ;

                    }
                    break;
                case 51 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:594:29: PUBLIC
                    {
                    match(input,PUBLIC,FOLLOW_PUBLIC_in_cast_disambiguation_token2151); if (state.failed) return ;

                    }
                    break;
                case 52 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:594:38: READONLY
                    {
                    match(input,READONLY,FOLLOW_READONLY_in_cast_disambiguation_token2155); if (state.failed) return ;

                    }
                    break;
                case 53 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:594:49: REF
                    {
                    match(input,REF,FOLLOW_REF_in_cast_disambiguation_token2159); if (state.failed) return ;

                    }
                    break;
                case 54 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:594:55: RETURN
                    {
                    match(input,RETURN,FOLLOW_RETURN_in_cast_disambiguation_token2163); if (state.failed) return ;

                    }
                    break;
                case 55 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:594:64: SBYTE
                    {
                    match(input,SBYTE,FOLLOW_SBYTE_in_cast_disambiguation_token2167); if (state.failed) return ;

                    }
                    break;
                case 56 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:594:72: SEALED
                    {
                    match(input,SEALED,FOLLOW_SEALED_in_cast_disambiguation_token2171); if (state.failed) return ;

                    }
                    break;
                case 57 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:594:81: SHORT
                    {
                    match(input,SHORT,FOLLOW_SHORT_in_cast_disambiguation_token2175); if (state.failed) return ;

                    }
                    break;
                case 58 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:594:89: SIZEOF
                    {
                    match(input,SIZEOF,FOLLOW_SIZEOF_in_cast_disambiguation_token2179); if (state.failed) return ;

                    }
                    break;
                case 59 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:594:98: STACKALLOC
                    {
                    match(input,STACKALLOC,FOLLOW_STACKALLOC_in_cast_disambiguation_token2183); if (state.failed) return ;

                    }
                    break;
                case 60 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:595:7: STATIC
                    {
                    match(input,STATIC,FOLLOW_STATIC_in_cast_disambiguation_token2191); if (state.failed) return ;

                    }
                    break;
                case 61 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:595:16: STRING
                    {
                    match(input,STRING,FOLLOW_STRING_in_cast_disambiguation_token2195); if (state.failed) return ;

                    }
                    break;
                case 62 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:595:25: STRUCT
                    {
                    match(input,STRUCT,FOLLOW_STRUCT_in_cast_disambiguation_token2199); if (state.failed) return ;

                    }
                    break;
                case 63 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:595:34: SWITCH
                    {
                    match(input,SWITCH,FOLLOW_SWITCH_in_cast_disambiguation_token2203); if (state.failed) return ;

                    }
                    break;
                case 64 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:595:43: THIS
                    {
                    match(input,THIS,FOLLOW_THIS_in_cast_disambiguation_token2207); if (state.failed) return ;

                    }
                    break;
                case 65 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:595:50: THROW
                    {
                    match(input,THROW,FOLLOW_THROW_in_cast_disambiguation_token2211); if (state.failed) return ;

                    }
                    break;
                case 66 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:595:58: TRY
                    {
                    match(input,TRY,FOLLOW_TRY_in_cast_disambiguation_token2215); if (state.failed) return ;

                    }
                    break;
                case 67 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:595:64: TYPEOF
                    {
                    match(input,TYPEOF,FOLLOW_TYPEOF_in_cast_disambiguation_token2219); if (state.failed) return ;

                    }
                    break;
                case 68 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:595:73: UINT
                    {
                    match(input,UINT,FOLLOW_UINT_in_cast_disambiguation_token2223); if (state.failed) return ;

                    }
                    break;
                case 69 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:595:80: ULONG
                    {
                    match(input,ULONG,FOLLOW_ULONG_in_cast_disambiguation_token2227); if (state.failed) return ;

                    }
                    break;
                case 70 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:595:88: UNCHECKED
                    {
                    match(input,UNCHECKED,FOLLOW_UNCHECKED_in_cast_disambiguation_token2231); if (state.failed) return ;

                    }
                    break;
                case 71 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:595:100: UNSAFE
                    {
                    match(input,UNSAFE,FOLLOW_UNSAFE_in_cast_disambiguation_token2235); if (state.failed) return ;

                    }
                    break;
                case 72 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:596:7: USHORT
                    {
                    match(input,USHORT,FOLLOW_USHORT_in_cast_disambiguation_token2243); if (state.failed) return ;

                    }
                    break;
                case 73 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:596:16: USING
                    {
                    match(input,USING,FOLLOW_USING_in_cast_disambiguation_token2247); if (state.failed) return ;

                    }
                    break;
                case 74 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:596:24: VIRTUAL
                    {
                    match(input,VIRTUAL,FOLLOW_VIRTUAL_in_cast_disambiguation_token2251); if (state.failed) return ;

                    }
                    break;
                case 75 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:596:34: VOID
                    {
                    match(input,VOID,FOLLOW_VOID_in_cast_disambiguation_token2255); if (state.failed) return ;

                    }
                    break;
                case 76 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:596:41: VOLATILE
                    {
                    match(input,VOLATILE,FOLLOW_VOLATILE_in_cast_disambiguation_token2259); if (state.failed) return ;

                    }
                    break;
                case 77 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:596:52: WHILE
                    {
                    match(input,WHILE,FOLLOW_WHILE_in_cast_disambiguation_token2263); if (state.failed) return ;

                    }
                    break;

            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "cast_disambiguation_token"



    // $ANTLR start "pre_increment_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:599:1: pre_increment_expression : OP_INC unary_expression ;
    public final void pre_increment_expression() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:600:2: ( OP_INC unary_expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:600:4: OP_INC unary_expression
            {
            match(input,OP_INC,FOLLOW_OP_INC_in_pre_increment_expression2281); if (state.failed) return ;

            pushFollow(FOLLOW_unary_expression_in_pre_increment_expression2283);
            unary_expression();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "pre_increment_expression"



    // $ANTLR start "pre_decrement_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:602:1: pre_decrement_expression : OP_DEC unary_expression ;
    public final void pre_decrement_expression() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:603:2: ( OP_DEC unary_expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:603:4: OP_DEC unary_expression
            {
            match(input,OP_DEC,FOLLOW_OP_DEC_in_pre_decrement_expression2294); if (state.failed) return ;

            pushFollow(FOLLOW_unary_expression_in_pre_decrement_expression2296);
            unary_expression();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "pre_decrement_expression"



    // $ANTLR start "cast_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:605:1: cast_expression : OPEN_PARENS type CLOSE_PARENS unary_expression ;
    public final void cast_expression() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:606:2: ( OPEN_PARENS type CLOSE_PARENS unary_expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:606:4: OPEN_PARENS type CLOSE_PARENS unary_expression
            {
            match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_cast_expression2307); if (state.failed) return ;

            pushFollow(FOLLOW_type_in_cast_expression2309);
            type();

            state._fsp--;
            if (state.failed) return ;

            match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_cast_expression2311); if (state.failed) return ;

            pushFollow(FOLLOW_unary_expression_in_cast_expression2313);
            unary_expression();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "cast_expression"



    // $ANTLR start "multiplicative_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:608:1: multiplicative_expression : unary_expression ( ( STAR unary_expression ) | ( DIV unary_expression ) | ( PERCENT unary_expression ) )* ;
    public final void multiplicative_expression() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:609:2: ( unary_expression ( ( STAR unary_expression ) | ( DIV unary_expression ) | ( PERCENT unary_expression ) )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:609:4: unary_expression ( ( STAR unary_expression ) | ( DIV unary_expression ) | ( PERCENT unary_expression ) )*
            {
            pushFollow(FOLLOW_unary_expression_in_multiplicative_expression2324);
            unary_expression();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:609:21: ( ( STAR unary_expression ) | ( DIV unary_expression ) | ( PERCENT unary_expression ) )*
            loop57:
            do {
                int alt57=4;
                switch ( input.LA(1) ) {
                case STAR:
                    {
                    alt57=1;
                    }
                    break;
                case DIV:
                    {
                    alt57=2;
                    }
                    break;
                case PERCENT:
                    {
                    alt57=3;
                    }
                    break;

                }

                switch (alt57) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:609:23: ( STAR unary_expression )
            	    {
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:609:23: ( STAR unary_expression )
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:609:25: STAR unary_expression
            	    {
            	    match(input,STAR,FOLLOW_STAR_in_multiplicative_expression2330); if (state.failed) return ;

            	    pushFollow(FOLLOW_unary_expression_in_multiplicative_expression2333);
            	    unary_expression();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }


            	    }
            	    break;
            	case 2 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:609:52: ( DIV unary_expression )
            	    {
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:609:52: ( DIV unary_expression )
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:609:54: DIV unary_expression
            	    {
            	    match(input,DIV,FOLLOW_DIV_in_multiplicative_expression2341); if (state.failed) return ;

            	    pushFollow(FOLLOW_unary_expression_in_multiplicative_expression2344);
            	    unary_expression();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }


            	    }
            	    break;
            	case 3 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:609:80: ( PERCENT unary_expression )
            	    {
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:609:80: ( PERCENT unary_expression )
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:609:82: PERCENT unary_expression
            	    {
            	    match(input,PERCENT,FOLLOW_PERCENT_in_multiplicative_expression2352); if (state.failed) return ;

            	    pushFollow(FOLLOW_unary_expression_in_multiplicative_expression2355);
            	    unary_expression();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }


            	    }
            	    break;

            	default :
            	    break loop57;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "multiplicative_expression"



    // $ANTLR start "additive_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:611:1: additive_expression : multiplicative_expression ( ( PLUS multiplicative_expression ) | ( MINUS multiplicative_expression ) )* ;
    public final void additive_expression() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:612:2: ( multiplicative_expression ( ( PLUS multiplicative_expression ) | ( MINUS multiplicative_expression ) )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:612:4: multiplicative_expression ( ( PLUS multiplicative_expression ) | ( MINUS multiplicative_expression ) )*
            {
            pushFollow(FOLLOW_multiplicative_expression_in_additive_expression2371);
            multiplicative_expression();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:612:30: ( ( PLUS multiplicative_expression ) | ( MINUS multiplicative_expression ) )*
            loop58:
            do {
                int alt58=3;
                int LA58_0 = input.LA(1);

                if ( (LA58_0==PLUS) ) {
                    alt58=1;
                }
                else if ( (LA58_0==MINUS) ) {
                    alt58=2;
                }


                switch (alt58) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:612:32: ( PLUS multiplicative_expression )
            	    {
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:612:32: ( PLUS multiplicative_expression )
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:612:34: PLUS multiplicative_expression
            	    {
            	    match(input,PLUS,FOLLOW_PLUS_in_additive_expression2377); if (state.failed) return ;

            	    pushFollow(FOLLOW_multiplicative_expression_in_additive_expression2380);
            	    multiplicative_expression();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }


            	    }
            	    break;
            	case 2 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:612:70: ( MINUS multiplicative_expression )
            	    {
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:612:70: ( MINUS multiplicative_expression )
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:612:72: MINUS multiplicative_expression
            	    {
            	    match(input,MINUS,FOLLOW_MINUS_in_additive_expression2388); if (state.failed) return ;

            	    pushFollow(FOLLOW_multiplicative_expression_in_additive_expression2391);
            	    multiplicative_expression();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }


            	    }
            	    break;

            	default :
            	    break loop58;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "additive_expression"



    // $ANTLR start "shift_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:614:1: shift_expression : additive_expression ( ( OP_LEFT_SHIFT additive_expression ) | ( right_shift additive_expression ) )* ;
    public final void shift_expression() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:615:2: ( additive_expression ( ( OP_LEFT_SHIFT additive_expression ) | ( right_shift additive_expression ) )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:615:4: additive_expression ( ( OP_LEFT_SHIFT additive_expression ) | ( right_shift additive_expression ) )*
            {
            pushFollow(FOLLOW_additive_expression_in_shift_expression2407);
            additive_expression();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:615:24: ( ( OP_LEFT_SHIFT additive_expression ) | ( right_shift additive_expression ) )*
            loop59:
            do {
                int alt59=3;
                int LA59_0 = input.LA(1);

                if ( (LA59_0==GT) ) {
                    int LA59_2 = input.LA(2);

                    if ( (LA59_2==GT) ) {
                        alt59=2;
                    }


                }
                else if ( (LA59_0==OP_LEFT_SHIFT) ) {
                    alt59=1;
                }


                switch (alt59) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:615:26: ( OP_LEFT_SHIFT additive_expression )
            	    {
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:615:26: ( OP_LEFT_SHIFT additive_expression )
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:615:28: OP_LEFT_SHIFT additive_expression
            	    {
            	    match(input,OP_LEFT_SHIFT,FOLLOW_OP_LEFT_SHIFT_in_shift_expression2413); if (state.failed) return ;

            	    pushFollow(FOLLOW_additive_expression_in_shift_expression2416);
            	    additive_expression();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }


            	    }
            	    break;
            	case 2 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:615:67: ( right_shift additive_expression )
            	    {
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:615:67: ( right_shift additive_expression )
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:615:69: right_shift additive_expression
            	    {
            	    pushFollow(FOLLOW_right_shift_in_shift_expression2424);
            	    right_shift();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    pushFollow(FOLLOW_additive_expression_in_shift_expression2427);
            	    additive_expression();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }


            	    }
            	    break;

            	default :
            	    break loop59;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "shift_expression"



    // $ANTLR start "relational_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:617:1: relational_expression : shift_expression ( LT shift_expression | GT shift_expression | OP_LE shift_expression | OP_GE shift_expression | IS isType | AS type )* ;
    public final void relational_expression() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:618:3: ( shift_expression ( LT shift_expression | GT shift_expression | OP_LE shift_expression | OP_GE shift_expression | IS isType | AS type )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:619:6: shift_expression ( LT shift_expression | GT shift_expression | OP_LE shift_expression | OP_GE shift_expression | IS isType | AS type )*
            {
            pushFollow(FOLLOW_shift_expression_in_relational_expression2445);
            shift_expression();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:619:23: ( LT shift_expression | GT shift_expression | OP_LE shift_expression | OP_GE shift_expression | IS isType | AS type )*
            loop60:
            do {
                int alt60=7;
                switch ( input.LA(1) ) {
                case LT:
                    {
                    alt60=1;
                    }
                    break;
                case GT:
                    {
                    alt60=2;
                    }
                    break;
                case OP_LE:
                    {
                    alt60=3;
                    }
                    break;
                case OP_GE:
                    {
                    alt60=4;
                    }
                    break;
                case IS:
                    {
                    alt60=5;
                    }
                    break;
                case AS:
                    {
                    alt60=6;
                    }
                    break;

                }

                switch (alt60) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:619:25: LT shift_expression
            	    {
            	    match(input,LT,FOLLOW_LT_in_relational_expression2449); if (state.failed) return ;

            	    pushFollow(FOLLOW_shift_expression_in_relational_expression2451);
            	    shift_expression();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;
            	case 2 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:620:24: GT shift_expression
            	    {
            	    match(input,GT,FOLLOW_GT_in_relational_expression2476); if (state.failed) return ;

            	    pushFollow(FOLLOW_shift_expression_in_relational_expression2478);
            	    shift_expression();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;
            	case 3 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:621:24: OP_LE shift_expression
            	    {
            	    match(input,OP_LE,FOLLOW_OP_LE_in_relational_expression2503); if (state.failed) return ;

            	    pushFollow(FOLLOW_shift_expression_in_relational_expression2505);
            	    shift_expression();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;
            	case 4 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:622:24: OP_GE shift_expression
            	    {
            	    match(input,OP_GE,FOLLOW_OP_GE_in_relational_expression2530); if (state.failed) return ;

            	    pushFollow(FOLLOW_shift_expression_in_relational_expression2532);
            	    shift_expression();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;
            	case 5 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:623:24: IS isType
            	    {
            	    match(input,IS,FOLLOW_IS_in_relational_expression2557); if (state.failed) return ;

            	    pushFollow(FOLLOW_isType_in_relational_expression2559);
            	    isType();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;
            	case 6 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:624:24: AS type
            	    {
            	    match(input,AS,FOLLOW_AS_in_relational_expression2584); if (state.failed) return ;

            	    pushFollow(FOLLOW_type_in_relational_expression2586);
            	    type();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop60;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "relational_expression"



    // $ANTLR start "scan_for_shift_generic_precedence"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:629:1: scan_for_shift_generic_precedence : IDENTIFIER LT type ( COMMA type )* GT shift_disambiguation_token ;
    public final void scan_for_shift_generic_precedence() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:630:3: ( IDENTIFIER LT type ( COMMA type )* GT shift_disambiguation_token )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:630:5: IDENTIFIER LT type ( COMMA type )* GT shift_disambiguation_token
            {
            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_scan_for_shift_generic_precedence2622); if (state.failed) return ;

            match(input,LT,FOLLOW_LT_in_scan_for_shift_generic_precedence2624); if (state.failed) return ;

            pushFollow(FOLLOW_type_in_scan_for_shift_generic_precedence2626);
            type();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:630:24: ( COMMA type )*
            loop61:
            do {
                int alt61=2;
                int LA61_0 = input.LA(1);

                if ( (LA61_0==COMMA) ) {
                    alt61=1;
                }


                switch (alt61) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:630:25: COMMA type
            	    {
            	    match(input,COMMA,FOLLOW_COMMA_in_scan_for_shift_generic_precedence2629); if (state.failed) return ;

            	    pushFollow(FOLLOW_type_in_scan_for_shift_generic_precedence2631);
            	    type();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop61;
                }
            } while (true);


            match(input,GT,FOLLOW_GT_in_scan_for_shift_generic_precedence2635); if (state.failed) return ;

            pushFollow(FOLLOW_shift_disambiguation_token_in_scan_for_shift_generic_precedence2637);
            shift_disambiguation_token();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "scan_for_shift_generic_precedence"



    // $ANTLR start "shift_disambiguation_token"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:635:1: shift_disambiguation_token : ( OPEN_PARENS | CLOSE_PARENS | CLOSE_BRACKET | COLON | SEMICOLON | COMMA | DOT | INTERR | OP_EQ | OP_NE | GT );
    public final void shift_disambiguation_token() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:636:3: ( OPEN_PARENS | CLOSE_PARENS | CLOSE_BRACKET | COLON | SEMICOLON | COMMA | DOT | INTERR | OP_EQ | OP_NE | GT )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:
            {
            if ( (input.LA(1) >= CLOSE_BRACKET && input.LA(1) <= COMMA)||input.LA(1)==DOT||input.LA(1)==GT||input.LA(1)==INTERR||input.LA(1)==OPEN_PARENS||input.LA(1)==OP_EQ||input.LA(1)==OP_NE||input.LA(1)==SEMICOLON ) {
                input.consume();
                state.errorRecovery=false;
                state.failed=false;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                MismatchedSetException mse = new MismatchedSetException(null,input);
                throw mse;
            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "shift_disambiguation_token"



    // $ANTLR start "isType"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:639:1: isType : non_nullable_value_type ( ( INTERR is_disambiguation_token )=> INTERR )? ;
    public final void isType() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:640:3: ( non_nullable_value_type ( ( INTERR is_disambiguation_token )=> INTERR )? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:640:5: non_nullable_value_type ( ( INTERR is_disambiguation_token )=> INTERR )?
            {
            pushFollow(FOLLOW_non_nullable_value_type_in_isType2705);
            non_nullable_value_type();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:640:29: ( ( INTERR is_disambiguation_token )=> INTERR )?
            int alt62=2;
            int LA62_0 = input.LA(1);

            if ( (LA62_0==INTERR) ) {
                int LA62_1 = input.LA(2);

                if ( (synpred8_CSharp4()) ) {
                    alt62=1;
                }
            }
            switch (alt62) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:640:31: ( INTERR is_disambiguation_token )=> INTERR
                    {
                    match(input,INTERR,FOLLOW_INTERR_in_isType2717); if (state.failed) return ;

                    }
                    break;

            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "isType"



    // $ANTLR start "is_disambiguation_token"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:642:1: is_disambiguation_token : ( CLOSE_PARENS | OP_AND | OP_OR | INTERR );
    public final void is_disambiguation_token() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:643:3: ( CLOSE_PARENS | OP_AND | OP_OR | INTERR )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:
            {
            if ( input.LA(1)==CLOSE_PARENS||input.LA(1)==INTERR||input.LA(1)==OP_AND||input.LA(1)==OP_OR ) {
                input.consume();
                state.errorRecovery=false;
                state.failed=false;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                MismatchedSetException mse = new MismatchedSetException(null,input);
                throw mse;
            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "is_disambiguation_token"



    // $ANTLR start "equality_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:645:1: equality_expression : relational_expression ( ( OP_EQ relational_expression ) | ( OP_NE relational_expression ) )* ;
    public final void equality_expression() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:646:2: ( relational_expression ( ( OP_EQ relational_expression ) | ( OP_NE relational_expression ) )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:646:4: relational_expression ( ( OP_EQ relational_expression ) | ( OP_NE relational_expression ) )*
            {
            pushFollow(FOLLOW_relational_expression_in_equality_expression2754);
            relational_expression();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:646:26: ( ( OP_EQ relational_expression ) | ( OP_NE relational_expression ) )*
            loop63:
            do {
                int alt63=3;
                int LA63_0 = input.LA(1);

                if ( (LA63_0==OP_EQ) ) {
                    alt63=1;
                }
                else if ( (LA63_0==OP_NE) ) {
                    alt63=2;
                }


                switch (alt63) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:646:28: ( OP_EQ relational_expression )
            	    {
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:646:28: ( OP_EQ relational_expression )
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:646:30: OP_EQ relational_expression
            	    {
            	    match(input,OP_EQ,FOLLOW_OP_EQ_in_equality_expression2760); if (state.failed) return ;

            	    pushFollow(FOLLOW_relational_expression_in_equality_expression2763);
            	    relational_expression();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }


            	    }
            	    break;
            	case 2 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:646:63: ( OP_NE relational_expression )
            	    {
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:646:63: ( OP_NE relational_expression )
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:646:65: OP_NE relational_expression
            	    {
            	    match(input,OP_NE,FOLLOW_OP_NE_in_equality_expression2771); if (state.failed) return ;

            	    pushFollow(FOLLOW_relational_expression_in_equality_expression2774);
            	    relational_expression();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }


            	    }
            	    break;

            	default :
            	    break loop63;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "equality_expression"



    // $ANTLR start "and_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:648:1: and_expression : equality_expression ( AMP equality_expression )* ;
    public final void and_expression() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:649:2: ( equality_expression ( AMP equality_expression )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:649:4: equality_expression ( AMP equality_expression )*
            {
            pushFollow(FOLLOW_equality_expression_in_and_expression2790);
            equality_expression();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:649:24: ( AMP equality_expression )*
            loop64:
            do {
                int alt64=2;
                int LA64_0 = input.LA(1);

                if ( (LA64_0==AMP) ) {
                    alt64=1;
                }


                switch (alt64) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:649:26: AMP equality_expression
            	    {
            	    match(input,AMP,FOLLOW_AMP_in_and_expression2794); if (state.failed) return ;

            	    pushFollow(FOLLOW_equality_expression_in_and_expression2796);
            	    equality_expression();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop64;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "and_expression"



    // $ANTLR start "exclusive_or_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:651:1: exclusive_or_expression : and_expression ( CARET and_expression )* ;
    public final void exclusive_or_expression() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:652:2: ( and_expression ( CARET and_expression )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:652:4: and_expression ( CARET and_expression )*
            {
            pushFollow(FOLLOW_and_expression_in_exclusive_or_expression2809);
            and_expression();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:652:19: ( CARET and_expression )*
            loop65:
            do {
                int alt65=2;
                int LA65_0 = input.LA(1);

                if ( (LA65_0==CARET) ) {
                    alt65=1;
                }


                switch (alt65) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:652:21: CARET and_expression
            	    {
            	    match(input,CARET,FOLLOW_CARET_in_exclusive_or_expression2813); if (state.failed) return ;

            	    pushFollow(FOLLOW_and_expression_in_exclusive_or_expression2815);
            	    and_expression();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop65;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "exclusive_or_expression"



    // $ANTLR start "inclusive_or_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:654:1: inclusive_or_expression : exclusive_or_expression ( BITWISE_OR exclusive_or_expression )* ;
    public final void inclusive_or_expression() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:655:2: ( exclusive_or_expression ( BITWISE_OR exclusive_or_expression )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:655:4: exclusive_or_expression ( BITWISE_OR exclusive_or_expression )*
            {
            pushFollow(FOLLOW_exclusive_or_expression_in_inclusive_or_expression2828);
            exclusive_or_expression();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:655:28: ( BITWISE_OR exclusive_or_expression )*
            loop66:
            do {
                int alt66=2;
                int LA66_0 = input.LA(1);

                if ( (LA66_0==BITWISE_OR) ) {
                    alt66=1;
                }


                switch (alt66) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:655:30: BITWISE_OR exclusive_or_expression
            	    {
            	    match(input,BITWISE_OR,FOLLOW_BITWISE_OR_in_inclusive_or_expression2832); if (state.failed) return ;

            	    pushFollow(FOLLOW_exclusive_or_expression_in_inclusive_or_expression2834);
            	    exclusive_or_expression();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop66;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "inclusive_or_expression"



    // $ANTLR start "conditional_and_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:657:1: conditional_and_expression : inclusive_or_expression ( OP_AND inclusive_or_expression )* ;
    public final void conditional_and_expression() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:658:2: ( inclusive_or_expression ( OP_AND inclusive_or_expression )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:658:4: inclusive_or_expression ( OP_AND inclusive_or_expression )*
            {
            pushFollow(FOLLOW_inclusive_or_expression_in_conditional_and_expression2847);
            inclusive_or_expression();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:658:28: ( OP_AND inclusive_or_expression )*
            loop67:
            do {
                int alt67=2;
                int LA67_0 = input.LA(1);

                if ( (LA67_0==OP_AND) ) {
                    alt67=1;
                }


                switch (alt67) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:658:30: OP_AND inclusive_or_expression
            	    {
            	    match(input,OP_AND,FOLLOW_OP_AND_in_conditional_and_expression2851); if (state.failed) return ;

            	    pushFollow(FOLLOW_inclusive_or_expression_in_conditional_and_expression2853);
            	    inclusive_or_expression();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop67;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "conditional_and_expression"



    // $ANTLR start "conditional_or_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:660:1: conditional_or_expression : conditional_and_expression ( OP_OR conditional_and_expression )* ;
    public final void conditional_or_expression() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:661:2: ( conditional_and_expression ( OP_OR conditional_and_expression )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:661:4: conditional_and_expression ( OP_OR conditional_and_expression )*
            {
            pushFollow(FOLLOW_conditional_and_expression_in_conditional_or_expression2866);
            conditional_and_expression();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:661:31: ( OP_OR conditional_and_expression )*
            loop68:
            do {
                int alt68=2;
                int LA68_0 = input.LA(1);

                if ( (LA68_0==OP_OR) ) {
                    alt68=1;
                }


                switch (alt68) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:661:33: OP_OR conditional_and_expression
            	    {
            	    match(input,OP_OR,FOLLOW_OP_OR_in_conditional_or_expression2870); if (state.failed) return ;

            	    pushFollow(FOLLOW_conditional_and_expression_in_conditional_or_expression2872);
            	    conditional_and_expression();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop68;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "conditional_or_expression"



    // $ANTLR start "null_coalescing_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:669:1: null_coalescing_expression : conditional_or_expression ( OP_COALESCING null_coalescing_expression )? ;
    public final void null_coalescing_expression() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:670:3: ( conditional_or_expression ( OP_COALESCING null_coalescing_expression )? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:670:5: conditional_or_expression ( OP_COALESCING null_coalescing_expression )?
            {
            pushFollow(FOLLOW_conditional_or_expression_in_null_coalescing_expression2888);
            conditional_or_expression();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:670:31: ( OP_COALESCING null_coalescing_expression )?
            int alt69=2;
            int LA69_0 = input.LA(1);

            if ( (LA69_0==OP_COALESCING) ) {
                alt69=1;
            }
            switch (alt69) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:670:32: OP_COALESCING null_coalescing_expression
                    {
                    match(input,OP_COALESCING,FOLLOW_OP_COALESCING_in_null_coalescing_expression2891); if (state.failed) return ;

                    pushFollow(FOLLOW_null_coalescing_expression_in_null_coalescing_expression2893);
                    null_coalescing_expression();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "null_coalescing_expression"



    // $ANTLR start "conditional_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:679:1: conditional_expression : null_coalescing_expression ( INTERR expression COLON expression )? ;
    public final void conditional_expression() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:680:3: ( null_coalescing_expression ( INTERR expression COLON expression )? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:680:5: null_coalescing_expression ( INTERR expression COLON expression )?
            {
            pushFollow(FOLLOW_null_coalescing_expression_in_conditional_expression2912);
            null_coalescing_expression();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:680:32: ( INTERR expression COLON expression )?
            int alt70=2;
            int LA70_0 = input.LA(1);

            if ( (LA70_0==INTERR) ) {
                alt70=1;
            }
            switch (alt70) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:680:33: INTERR expression COLON expression
                    {
                    match(input,INTERR,FOLLOW_INTERR_in_conditional_expression2915); if (state.failed) return ;

                    pushFollow(FOLLOW_expression_in_conditional_expression2917);
                    expression();

                    state._fsp--;
                    if (state.failed) return ;

                    match(input,COLON,FOLLOW_COLON_in_conditional_expression2919); if (state.failed) return ;

                    pushFollow(FOLLOW_expression_in_conditional_expression2921);
                    expression();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "conditional_expression"



    // $ANTLR start "lambda_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:683:1: lambda_expression : anonymous_function_signature right_arrow anonymous_function_body ;
    public final void lambda_expression() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:684:2: ( anonymous_function_signature right_arrow anonymous_function_body )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:684:4: anonymous_function_signature right_arrow anonymous_function_body
            {
            pushFollow(FOLLOW_anonymous_function_signature_in_lambda_expression2937);
            anonymous_function_signature();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_right_arrow_in_lambda_expression2939);
            right_arrow();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_anonymous_function_body_in_lambda_expression2941);
            anonymous_function_body();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "lambda_expression"



    // $ANTLR start "anonymous_method_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:687:1: anonymous_method_expression : DELEGATE ( explicit_anonymous_function_signature )? block ;
    public final void anonymous_method_expression() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:688:2: ( DELEGATE ( explicit_anonymous_function_signature )? block )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:688:4: DELEGATE ( explicit_anonymous_function_signature )? block
            {
            match(input,DELEGATE,FOLLOW_DELEGATE_in_anonymous_method_expression2954); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:688:13: ( explicit_anonymous_function_signature )?
            int alt71=2;
            int LA71_0 = input.LA(1);

            if ( (LA71_0==OPEN_PARENS) ) {
                alt71=1;
            }
            switch (alt71) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:688:13: explicit_anonymous_function_signature
                    {
                    pushFollow(FOLLOW_explicit_anonymous_function_signature_in_anonymous_method_expression2956);
                    explicit_anonymous_function_signature();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            pushFollow(FOLLOW_block_in_anonymous_method_expression2959);
            block();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "anonymous_method_expression"



    // $ANTLR start "anonymous_function_signature"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:697:1: anonymous_function_signature : ( OPEN_PARENS CLOSE_PARENS | OPEN_PARENS explicit_anonymous_function_parameter_list CLOSE_PARENS | OPEN_PARENS implicit_anonymous_function_parameter_list CLOSE_PARENS | implicit_anonymous_function_parameter );
    public final void anonymous_function_signature() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:698:3: ( OPEN_PARENS CLOSE_PARENS | OPEN_PARENS explicit_anonymous_function_parameter_list CLOSE_PARENS | OPEN_PARENS implicit_anonymous_function_parameter_list CLOSE_PARENS | implicit_anonymous_function_parameter )
            int alt72=4;
            int LA72_0 = input.LA(1);

            if ( (LA72_0==OPEN_PARENS) ) {
                switch ( input.LA(2) ) {
                case CLOSE_PARENS:
                    {
                    alt72=1;
                    }
                    break;
                case BOOL:
                case BYTE:
                case CHAR:
                case DECIMAL:
                case DOUBLE:
                case FLOAT:
                case INT:
                case LONG:
                case OBJECT:
                case OUT:
                case REF:
                case SBYTE:
                case SHORT:
                case STRING:
                case UINT:
                case ULONG:
                case USHORT:
                case VOID:
                    {
                    alt72=2;
                    }
                    break;
                case IDENTIFIER:
                    {
                    int LA72_5 = input.LA(3);

                    if ( (LA72_5==DOT||LA72_5==DOUBLE_COLON||LA72_5==IDENTIFIER||LA72_5==INTERR||LA72_5==LT||LA72_5==OPEN_BRACKET||LA72_5==STAR) ) {
                        alt72=2;
                    }
                    else if ( (LA72_5==CLOSE_PARENS||LA72_5==COMMA) ) {
                        alt72=3;
                    }
                    else {
                        if (state.backtracking>0) {state.failed=true; return ;}
                        NoViableAltException nvae =
                            new NoViableAltException("", 72, 5, input);

                        throw nvae;

                    }
                    }
                    break;
                default:
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 72, 1, input);

                    throw nvae;

                }

            }
            else if ( (LA72_0==IDENTIFIER) ) {
                alt72=4;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 72, 0, input);

                throw nvae;

            }
            switch (alt72) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:698:5: OPEN_PARENS CLOSE_PARENS
                    {
                    match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_anonymous_function_signature2975); if (state.failed) return ;

                    match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_anonymous_function_signature2977); if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:699:5: OPEN_PARENS explicit_anonymous_function_parameter_list CLOSE_PARENS
                    {
                    match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_anonymous_function_signature2983); if (state.failed) return ;

                    pushFollow(FOLLOW_explicit_anonymous_function_parameter_list_in_anonymous_function_signature2985);
                    explicit_anonymous_function_parameter_list();

                    state._fsp--;
                    if (state.failed) return ;

                    match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_anonymous_function_signature2987); if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:700:5: OPEN_PARENS implicit_anonymous_function_parameter_list CLOSE_PARENS
                    {
                    match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_anonymous_function_signature2993); if (state.failed) return ;

                    pushFollow(FOLLOW_implicit_anonymous_function_parameter_list_in_anonymous_function_signature2995);
                    implicit_anonymous_function_parameter_list();

                    state._fsp--;
                    if (state.failed) return ;

                    match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_anonymous_function_signature2997); if (state.failed) return ;

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:701:5: implicit_anonymous_function_parameter
                    {
                    pushFollow(FOLLOW_implicit_anonymous_function_parameter_in_anonymous_function_signature3003);
                    implicit_anonymous_function_parameter();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "anonymous_function_signature"



    // $ANTLR start "explicit_anonymous_function_signature"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:703:1: explicit_anonymous_function_signature : OPEN_PARENS ( explicit_anonymous_function_parameter_list )? CLOSE_PARENS ;
    public final void explicit_anonymous_function_signature() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:704:2: ( OPEN_PARENS ( explicit_anonymous_function_parameter_list )? CLOSE_PARENS )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:704:4: OPEN_PARENS ( explicit_anonymous_function_parameter_list )? CLOSE_PARENS
            {
            match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_explicit_anonymous_function_signature3015); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:704:16: ( explicit_anonymous_function_parameter_list )?
            int alt73=2;
            int LA73_0 = input.LA(1);

            if ( (LA73_0==BOOL||LA73_0==BYTE||LA73_0==CHAR||LA73_0==DECIMAL||LA73_0==DOUBLE||LA73_0==FLOAT||LA73_0==IDENTIFIER||LA73_0==INT||LA73_0==LONG||LA73_0==OBJECT||LA73_0==OUT||LA73_0==REF||LA73_0==SBYTE||LA73_0==SHORT||LA73_0==STRING||(LA73_0 >= UINT && LA73_0 <= ULONG)||LA73_0==USHORT||LA73_0==VOID) ) {
                alt73=1;
            }
            switch (alt73) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:704:16: explicit_anonymous_function_parameter_list
                    {
                    pushFollow(FOLLOW_explicit_anonymous_function_parameter_list_in_explicit_anonymous_function_signature3017);
                    explicit_anonymous_function_parameter_list();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_explicit_anonymous_function_signature3020); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "explicit_anonymous_function_signature"



    // $ANTLR start "explicit_anonymous_function_parameter_list"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:706:1: explicit_anonymous_function_parameter_list : explicit_anonymous_function_parameter ( COMMA explicit_anonymous_function_parameter )* ;
    public final void explicit_anonymous_function_parameter_list() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:707:2: ( explicit_anonymous_function_parameter ( COMMA explicit_anonymous_function_parameter )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:707:4: explicit_anonymous_function_parameter ( COMMA explicit_anonymous_function_parameter )*
            {
            pushFollow(FOLLOW_explicit_anonymous_function_parameter_in_explicit_anonymous_function_parameter_list3031);
            explicit_anonymous_function_parameter();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:707:42: ( COMMA explicit_anonymous_function_parameter )*
            loop74:
            do {
                int alt74=2;
                int LA74_0 = input.LA(1);

                if ( (LA74_0==COMMA) ) {
                    alt74=1;
                }


                switch (alt74) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:707:44: COMMA explicit_anonymous_function_parameter
            	    {
            	    match(input,COMMA,FOLLOW_COMMA_in_explicit_anonymous_function_parameter_list3035); if (state.failed) return ;

            	    pushFollow(FOLLOW_explicit_anonymous_function_parameter_in_explicit_anonymous_function_parameter_list3037);
            	    explicit_anonymous_function_parameter();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop74;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "explicit_anonymous_function_parameter_list"



    // $ANTLR start "explicit_anonymous_function_parameter"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:709:1: explicit_anonymous_function_parameter : ( anonymous_function_parameter_modifier )? type IDENTIFIER ;
    public final void explicit_anonymous_function_parameter() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:710:2: ( ( anonymous_function_parameter_modifier )? type IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:710:4: ( anonymous_function_parameter_modifier )? type IDENTIFIER
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:710:4: ( anonymous_function_parameter_modifier )?
            int alt75=2;
            int LA75_0 = input.LA(1);

            if ( (LA75_0==OUT||LA75_0==REF) ) {
                alt75=1;
            }
            switch (alt75) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:710:4: anonymous_function_parameter_modifier
                    {
                    pushFollow(FOLLOW_anonymous_function_parameter_modifier_in_explicit_anonymous_function_parameter3050);
                    anonymous_function_parameter_modifier();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            pushFollow(FOLLOW_type_in_explicit_anonymous_function_parameter3053);
            type();

            state._fsp--;
            if (state.failed) return ;

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_explicit_anonymous_function_parameter3055); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "explicit_anonymous_function_parameter"



    // $ANTLR start "anonymous_function_parameter_modifier"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:712:1: anonymous_function_parameter_modifier : ( REF | OUT );
    public final void anonymous_function_parameter_modifier() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:713:2: ( REF | OUT )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:
            {
            if ( input.LA(1)==OUT||input.LA(1)==REF ) {
                input.consume();
                state.errorRecovery=false;
                state.failed=false;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                MismatchedSetException mse = new MismatchedSetException(null,input);
                throw mse;
            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "anonymous_function_parameter_modifier"



    // $ANTLR start "implicit_anonymous_function_signature"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:716:1: implicit_anonymous_function_signature : ( OPEN_PARENS ( implicit_anonymous_function_parameter_list )? CLOSE_PARENS | implicit_anonymous_function_parameter );
    public final void implicit_anonymous_function_signature() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:717:2: ( OPEN_PARENS ( implicit_anonymous_function_parameter_list )? CLOSE_PARENS | implicit_anonymous_function_parameter )
            int alt77=2;
            int LA77_0 = input.LA(1);

            if ( (LA77_0==OPEN_PARENS) ) {
                alt77=1;
            }
            else if ( (LA77_0==IDENTIFIER) ) {
                alt77=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 77, 0, input);

                throw nvae;

            }
            switch (alt77) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:717:4: OPEN_PARENS ( implicit_anonymous_function_parameter_list )? CLOSE_PARENS
                    {
                    match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_implicit_anonymous_function_signature3082); if (state.failed) return ;

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:717:16: ( implicit_anonymous_function_parameter_list )?
                    int alt76=2;
                    int LA76_0 = input.LA(1);

                    if ( (LA76_0==IDENTIFIER) ) {
                        alt76=1;
                    }
                    switch (alt76) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:717:16: implicit_anonymous_function_parameter_list
                            {
                            pushFollow(FOLLOW_implicit_anonymous_function_parameter_list_in_implicit_anonymous_function_signature3084);
                            implicit_anonymous_function_parameter_list();

                            state._fsp--;
                            if (state.failed) return ;

                            }
                            break;

                    }


                    match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_implicit_anonymous_function_signature3087); if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:718:4: implicit_anonymous_function_parameter
                    {
                    pushFollow(FOLLOW_implicit_anonymous_function_parameter_in_implicit_anonymous_function_signature3092);
                    implicit_anonymous_function_parameter();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "implicit_anonymous_function_signature"



    // $ANTLR start "implicit_anonymous_function_parameter_list"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:720:1: implicit_anonymous_function_parameter_list : implicit_anonymous_function_parameter ( COMMA implicit_anonymous_function_parameter )* ;
    public final void implicit_anonymous_function_parameter_list() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:721:2: ( implicit_anonymous_function_parameter ( COMMA implicit_anonymous_function_parameter )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:721:4: implicit_anonymous_function_parameter ( COMMA implicit_anonymous_function_parameter )*
            {
            pushFollow(FOLLOW_implicit_anonymous_function_parameter_in_implicit_anonymous_function_parameter_list3103);
            implicit_anonymous_function_parameter();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:721:42: ( COMMA implicit_anonymous_function_parameter )*
            loop78:
            do {
                int alt78=2;
                int LA78_0 = input.LA(1);

                if ( (LA78_0==COMMA) ) {
                    alt78=1;
                }


                switch (alt78) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:721:44: COMMA implicit_anonymous_function_parameter
            	    {
            	    match(input,COMMA,FOLLOW_COMMA_in_implicit_anonymous_function_parameter_list3107); if (state.failed) return ;

            	    pushFollow(FOLLOW_implicit_anonymous_function_parameter_in_implicit_anonymous_function_parameter_list3109);
            	    implicit_anonymous_function_parameter();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop78;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "implicit_anonymous_function_parameter_list"



    // $ANTLR start "implicit_anonymous_function_parameter"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:724:1: implicit_anonymous_function_parameter : IDENTIFIER ;
    public final void implicit_anonymous_function_parameter() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:725:2: ( IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:725:4: IDENTIFIER
            {
            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_implicit_anonymous_function_parameter3124); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "implicit_anonymous_function_parameter"



    // $ANTLR start "anonymous_function_body"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:727:1: anonymous_function_body : ( expression | block );
    public final void anonymous_function_body() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:728:2: ( expression | block )
            int alt79=2;
            int LA79_0 = input.LA(1);

            if ( (LA79_0==AMP||(LA79_0 >= BANG && LA79_0 <= BASE)||LA79_0==BOOL||LA79_0==BYTE||(LA79_0 >= CHAR && LA79_0 <= CHECKED)||LA79_0==DECIMAL||(LA79_0 >= DEFAULT && LA79_0 <= DELEGATE)||LA79_0==DOUBLE||LA79_0==FALSE||LA79_0==FLOAT||LA79_0==IDENTIFIER||(LA79_0 >= INT && LA79_0 <= INTEGER_LITERAL)||LA79_0==LONG||LA79_0==MINUS||LA79_0==NEW||LA79_0==NULL||LA79_0==OBJECT||LA79_0==OPEN_PARENS||LA79_0==OP_DEC||LA79_0==OP_INC||LA79_0==PLUS||LA79_0==REAL_LITERAL||LA79_0==SBYTE||LA79_0==SHORT||LA79_0==SIZEOF||LA79_0==STAR||(LA79_0 >= STRING && LA79_0 <= STRING_LITERAL)||LA79_0==THIS||(LA79_0 >= TILDE && LA79_0 <= TRUE)||(LA79_0 >= TYPEOF && LA79_0 <= UNCHECKED)||LA79_0==USHORT) ) {
                alt79=1;
            }
            else if ( (LA79_0==OPEN_BRACE) ) {
                alt79=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 79, 0, input);

                throw nvae;

            }
            switch (alt79) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:728:4: expression
                    {
                    pushFollow(FOLLOW_expression_in_anonymous_function_body3135);
                    expression();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:729:4: block
                    {
                    pushFollow(FOLLOW_block_in_anonymous_function_body3140);
                    block();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "anonymous_function_body"



    // $ANTLR start "query_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:732:1: query_expression : from_clause query_body ;
    public final void query_expression() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:733:2: ( from_clause query_body )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:733:4: from_clause query_body
            {
            pushFollow(FOLLOW_from_clause_in_query_expression3153);
            from_clause();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_query_body_in_query_expression3155);
            query_body();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "query_expression"



    // $ANTLR start "from_clause"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:735:1: from_clause : from_contextual_keyword ( ( type IDENTIFIER IN )=> type )? IDENTIFIER IN expression ;
    public final void from_clause() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:736:2: ( from_contextual_keyword ( ( type IDENTIFIER IN )=> type )? IDENTIFIER IN expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:736:4: from_contextual_keyword ( ( type IDENTIFIER IN )=> type )? IDENTIFIER IN expression
            {
            pushFollow(FOLLOW_from_contextual_keyword_in_from_clause3166);
            from_contextual_keyword();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:736:28: ( ( type IDENTIFIER IN )=> type )?
            int alt80=2;
            int LA80_0 = input.LA(1);

            if ( (LA80_0==BYTE||LA80_0==CHAR||LA80_0==INT||LA80_0==LONG||LA80_0==SBYTE||LA80_0==SHORT||(LA80_0 >= UINT && LA80_0 <= ULONG)||LA80_0==USHORT) && (synpred9_CSharp4())) {
                alt80=1;
            }
            else if ( (LA80_0==DOUBLE||LA80_0==FLOAT) && (synpred9_CSharp4())) {
                alt80=1;
            }
            else if ( (LA80_0==DECIMAL) && (synpred9_CSharp4())) {
                alt80=1;
            }
            else if ( (LA80_0==BOOL) && (synpred9_CSharp4())) {
                alt80=1;
            }
            else if ( (LA80_0==IDENTIFIER) ) {
                int LA80_5 = input.LA(2);

                if ( (LA80_5==DOUBLE_COLON) && (synpred9_CSharp4())) {
                    alt80=1;
                }
                else if ( (LA80_5==LT) && (synpred9_CSharp4())) {
                    alt80=1;
                }
                else if ( (LA80_5==DOT) && (synpred9_CSharp4())) {
                    alt80=1;
                }
                else if ( (LA80_5==INTERR) && (synpred9_CSharp4())) {
                    alt80=1;
                }
                else if ( (LA80_5==OPEN_BRACKET) && (synpred9_CSharp4())) {
                    alt80=1;
                }
                else if ( (LA80_5==STAR) && (synpred9_CSharp4())) {
                    alt80=1;
                }
                else if ( (LA80_5==IDENTIFIER) && (synpred9_CSharp4())) {
                    alt80=1;
                }
            }
            else if ( (LA80_0==OBJECT) && (synpred9_CSharp4())) {
                alt80=1;
            }
            else if ( (LA80_0==STRING) && (synpred9_CSharp4())) {
                alt80=1;
            }
            else if ( (LA80_0==VOID) && (synpred9_CSharp4())) {
                alt80=1;
            }
            switch (alt80) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:736:29: ( type IDENTIFIER IN )=> type
                    {
                    pushFollow(FOLLOW_type_in_from_clause3179);
                    type();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_from_clause3183); if (state.failed) return ;

            match(input,IN,FOLLOW_IN_in_from_clause3185); if (state.failed) return ;

            pushFollow(FOLLOW_expression_in_from_clause3187);
            expression();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "from_clause"



    // $ANTLR start "query_body"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:743:1: query_body : ( query_body_clauses )? select_or_group_clause ( ( into_contextual_keyword )=> query_continuation )? ;
    public final void query_body() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:744:3: ( ( query_body_clauses )? select_or_group_clause ( ( into_contextual_keyword )=> query_continuation )? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:744:5: ( query_body_clauses )? select_or_group_clause ( ( into_contextual_keyword )=> query_continuation )?
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:744:5: ( query_body_clauses )?
            int alt81=2;
            int LA81_0 = input.LA(1);

            if ( (LA81_0==IDENTIFIER) ) {
                int LA81_1 = input.LA(2);

                if ( (((input.LT(1).getText().equals("where"))||(input.LT(1).getText().equals("orderby"))||(input.LT(1).getText().equals("let"))||(input.LT(1).getText().equals("join"))||(input.LT(1).getText().equals("from")))) ) {
                    alt81=1;
                }
            }
            switch (alt81) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:744:5: query_body_clauses
                    {
                    pushFollow(FOLLOW_query_body_clauses_in_query_body3201);
                    query_body_clauses();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            pushFollow(FOLLOW_select_or_group_clause_in_query_body3204);
            select_or_group_clause();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:744:48: ( ( into_contextual_keyword )=> query_continuation )?
            int alt82=2;
            int LA82_0 = input.LA(1);

            if ( (LA82_0==IDENTIFIER) ) {
                int LA82_1 = input.LA(2);

                if ( (((synpred10_CSharp4()&&synpred10_CSharp4())&&(input.LT(1).getText().equals("into")))) ) {
                    alt82=1;
                }
            }
            switch (alt82) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:744:49: ( into_contextual_keyword )=> query_continuation
                    {
                    pushFollow(FOLLOW_query_continuation_in_query_body3213);
                    query_continuation();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "query_body"



    // $ANTLR start "query_body_clauses"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:746:1: query_body_clauses : query_body_clause ( query_body_clause )* ;
    public final void query_body_clauses() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:747:2: ( query_body_clause ( query_body_clause )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:747:4: query_body_clause ( query_body_clause )*
            {
            pushFollow(FOLLOW_query_body_clause_in_query_body_clauses3227);
            query_body_clause();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:747:22: ( query_body_clause )*
            loop83:
            do {
                int alt83=2;
                int LA83_0 = input.LA(1);

                if ( (LA83_0==IDENTIFIER) ) {
                    int LA83_1 = input.LA(2);

                    if ( (((input.LT(1).getText().equals("where"))||(input.LT(1).getText().equals("orderby"))||(input.LT(1).getText().equals("let"))||(input.LT(1).getText().equals("join"))||(input.LT(1).getText().equals("from")))) ) {
                        alt83=1;
                    }


                }


                switch (alt83) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:747:24: query_body_clause
            	    {
            	    pushFollow(FOLLOW_query_body_clause_in_query_body_clauses3231);
            	    query_body_clause();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop83;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "query_body_clauses"



    // $ANTLR start "query_body_clause"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:759:1: query_body_clause : ( from_clause | let_clause | where_clause | combined_join_clause | orderby_clause );
    public final void query_body_clause() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:760:3: ( from_clause | let_clause | where_clause | combined_join_clause | orderby_clause )
            int alt84=5;
            int LA84_0 = input.LA(1);

            if ( (LA84_0==IDENTIFIER) ) {
                int LA84_1 = input.LA(2);

                if ( ((input.LT(1).getText().equals("from"))) ) {
                    alt84=1;
                }
                else if ( ((input.LT(1).getText().equals("let"))) ) {
                    alt84=2;
                }
                else if ( ((input.LT(1).getText().equals("where"))) ) {
                    alt84=3;
                }
                else if ( ((input.LT(1).getText().equals("join"))) ) {
                    alt84=4;
                }
                else if ( ((input.LT(1).getText().equals("orderby"))) ) {
                    alt84=5;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 84, 1, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 84, 0, input);

                throw nvae;

            }
            switch (alt84) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:760:5: from_clause
                    {
                    pushFollow(FOLLOW_from_clause_in_query_body_clause3248);
                    from_clause();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:761:5: let_clause
                    {
                    pushFollow(FOLLOW_let_clause_in_query_body_clause3254);
                    let_clause();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:762:5: where_clause
                    {
                    pushFollow(FOLLOW_where_clause_in_query_body_clause3260);
                    where_clause();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:763:5: combined_join_clause
                    {
                    pushFollow(FOLLOW_combined_join_clause_in_query_body_clause3266);
                    combined_join_clause();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:764:5: orderby_clause
                    {
                    pushFollow(FOLLOW_orderby_clause_in_query_body_clause3272);
                    orderby_clause();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "query_body_clause"



    // $ANTLR start "let_clause"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:766:1: let_clause : let_contextual_keyword IDENTIFIER ASSIGNMENT expression ;
    public final void let_clause() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:767:2: ( let_contextual_keyword IDENTIFIER ASSIGNMENT expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:767:4: let_contextual_keyword IDENTIFIER ASSIGNMENT expression
            {
            pushFollow(FOLLOW_let_contextual_keyword_in_let_clause3284);
            let_contextual_keyword();

            state._fsp--;
            if (state.failed) return ;

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_let_clause3286); if (state.failed) return ;

            match(input,ASSIGNMENT,FOLLOW_ASSIGNMENT_in_let_clause3288); if (state.failed) return ;

            pushFollow(FOLLOW_expression_in_let_clause3290);
            expression();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "let_clause"



    // $ANTLR start "where_clause"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:769:1: where_clause : where_contextual_keyword boolean_expression ;
    public final void where_clause() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:770:2: ( where_contextual_keyword boolean_expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:770:4: where_contextual_keyword boolean_expression
            {
            pushFollow(FOLLOW_where_contextual_keyword_in_where_clause3301);
            where_contextual_keyword();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_boolean_expression_in_where_clause3303);
            boolean_expression();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "where_clause"



    // $ANTLR start "join_clause"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:772:1: join_clause : join_contextual_keyword ( type )? IDENTIFIER IN expression on_contextual_keyword expression equals_contextual_keyword expression ;
    public final void join_clause() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:773:2: ( join_contextual_keyword ( type )? IDENTIFIER IN expression on_contextual_keyword expression equals_contextual_keyword expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:773:4: join_contextual_keyword ( type )? IDENTIFIER IN expression on_contextual_keyword expression equals_contextual_keyword expression
            {
            pushFollow(FOLLOW_join_contextual_keyword_in_join_clause3314);
            join_contextual_keyword();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:773:28: ( type )?
            int alt85=2;
            int LA85_0 = input.LA(1);

            if ( (LA85_0==BOOL||LA85_0==BYTE||LA85_0==CHAR||LA85_0==DECIMAL||LA85_0==DOUBLE||LA85_0==FLOAT||LA85_0==INT||LA85_0==LONG||LA85_0==OBJECT||LA85_0==SBYTE||LA85_0==SHORT||LA85_0==STRING||(LA85_0 >= UINT && LA85_0 <= ULONG)||LA85_0==USHORT||LA85_0==VOID) ) {
                alt85=1;
            }
            else if ( (LA85_0==IDENTIFIER) ) {
                int LA85_2 = input.LA(2);

                if ( (LA85_2==DOT||LA85_2==DOUBLE_COLON||LA85_2==IDENTIFIER||LA85_2==INTERR||LA85_2==LT||LA85_2==OPEN_BRACKET||LA85_2==STAR) ) {
                    alt85=1;
                }
            }
            switch (alt85) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:773:28: type
                    {
                    pushFollow(FOLLOW_type_in_join_clause3316);
                    type();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_join_clause3319); if (state.failed) return ;

            match(input,IN,FOLLOW_IN_in_join_clause3321); if (state.failed) return ;

            pushFollow(FOLLOW_expression_in_join_clause3323);
            expression();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_on_contextual_keyword_in_join_clause3325);
            on_contextual_keyword();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_expression_in_join_clause3327);
            expression();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_equals_contextual_keyword_in_join_clause3329);
            equals_contextual_keyword();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_expression_in_join_clause3331);
            expression();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "join_clause"



    // $ANTLR start "join_into_clause"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:775:1: join_into_clause : join_contextual_keyword ( type )? IDENTIFIER IN expression on_contextual_keyword expression equals_contextual_keyword expression into_contextual_keyword IDENTIFIER ;
    public final void join_into_clause() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:776:2: ( join_contextual_keyword ( type )? IDENTIFIER IN expression on_contextual_keyword expression equals_contextual_keyword expression into_contextual_keyword IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:776:4: join_contextual_keyword ( type )? IDENTIFIER IN expression on_contextual_keyword expression equals_contextual_keyword expression into_contextual_keyword IDENTIFIER
            {
            pushFollow(FOLLOW_join_contextual_keyword_in_join_into_clause3342);
            join_contextual_keyword();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:776:28: ( type )?
            int alt86=2;
            int LA86_0 = input.LA(1);

            if ( (LA86_0==BOOL||LA86_0==BYTE||LA86_0==CHAR||LA86_0==DECIMAL||LA86_0==DOUBLE||LA86_0==FLOAT||LA86_0==INT||LA86_0==LONG||LA86_0==OBJECT||LA86_0==SBYTE||LA86_0==SHORT||LA86_0==STRING||(LA86_0 >= UINT && LA86_0 <= ULONG)||LA86_0==USHORT||LA86_0==VOID) ) {
                alt86=1;
            }
            else if ( (LA86_0==IDENTIFIER) ) {
                int LA86_2 = input.LA(2);

                if ( (LA86_2==DOT||LA86_2==DOUBLE_COLON||LA86_2==IDENTIFIER||LA86_2==INTERR||LA86_2==LT||LA86_2==OPEN_BRACKET||LA86_2==STAR) ) {
                    alt86=1;
                }
            }
            switch (alt86) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:776:28: type
                    {
                    pushFollow(FOLLOW_type_in_join_into_clause3344);
                    type();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_join_into_clause3347); if (state.failed) return ;

            match(input,IN,FOLLOW_IN_in_join_into_clause3349); if (state.failed) return ;

            pushFollow(FOLLOW_expression_in_join_into_clause3351);
            expression();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_on_contextual_keyword_in_join_into_clause3353);
            on_contextual_keyword();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_expression_in_join_into_clause3355);
            expression();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_equals_contextual_keyword_in_join_into_clause3357);
            equals_contextual_keyword();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_expression_in_join_into_clause3359);
            expression();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_into_contextual_keyword_in_join_into_clause3361);
            into_contextual_keyword();

            state._fsp--;
            if (state.failed) return ;

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_join_into_clause3363); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "join_into_clause"



    // $ANTLR start "combined_join_clause"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:779:1: combined_join_clause : join_contextual_keyword ( type )? IDENTIFIER IN expression on_contextual_keyword expression equals_contextual_keyword expression ( into_contextual_keyword IDENTIFIER )? ;
    public final void combined_join_clause() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:780:3: ( join_contextual_keyword ( type )? IDENTIFIER IN expression on_contextual_keyword expression equals_contextual_keyword expression ( into_contextual_keyword IDENTIFIER )? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:780:5: join_contextual_keyword ( type )? IDENTIFIER IN expression on_contextual_keyword expression equals_contextual_keyword expression ( into_contextual_keyword IDENTIFIER )?
            {
            pushFollow(FOLLOW_join_contextual_keyword_in_combined_join_clause3375);
            join_contextual_keyword();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:780:29: ( type )?
            int alt87=2;
            int LA87_0 = input.LA(1);

            if ( (LA87_0==BOOL||LA87_0==BYTE||LA87_0==CHAR||LA87_0==DECIMAL||LA87_0==DOUBLE||LA87_0==FLOAT||LA87_0==INT||LA87_0==LONG||LA87_0==OBJECT||LA87_0==SBYTE||LA87_0==SHORT||LA87_0==STRING||(LA87_0 >= UINT && LA87_0 <= ULONG)||LA87_0==USHORT||LA87_0==VOID) ) {
                alt87=1;
            }
            else if ( (LA87_0==IDENTIFIER) ) {
                int LA87_2 = input.LA(2);

                if ( (LA87_2==DOT||LA87_2==DOUBLE_COLON||LA87_2==IDENTIFIER||LA87_2==INTERR||LA87_2==LT||LA87_2==OPEN_BRACKET||LA87_2==STAR) ) {
                    alt87=1;
                }
            }
            switch (alt87) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:780:29: type
                    {
                    pushFollow(FOLLOW_type_in_combined_join_clause3377);
                    type();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_combined_join_clause3380); if (state.failed) return ;

            match(input,IN,FOLLOW_IN_in_combined_join_clause3382); if (state.failed) return ;

            pushFollow(FOLLOW_expression_in_combined_join_clause3384);
            expression();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_on_contextual_keyword_in_combined_join_clause3386);
            on_contextual_keyword();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_expression_in_combined_join_clause3388);
            expression();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_equals_contextual_keyword_in_combined_join_clause3390);
            equals_contextual_keyword();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_expression_in_combined_join_clause3392);
            expression();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:780:130: ( into_contextual_keyword IDENTIFIER )?
            int alt88=2;
            int LA88_0 = input.LA(1);

            if ( (LA88_0==IDENTIFIER) ) {
                int LA88_1 = input.LA(2);

                if ( (LA88_1==IDENTIFIER) ) {
                    int LA88_2 = input.LA(3);

                    if ( ((input.LT(1).getText().equals("into"))) ) {
                        alt88=1;
                    }
                }
            }
            switch (alt88) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:780:131: into_contextual_keyword IDENTIFIER
                    {
                    pushFollow(FOLLOW_into_contextual_keyword_in_combined_join_clause3395);
                    into_contextual_keyword();

                    state._fsp--;
                    if (state.failed) return ;

                    match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_combined_join_clause3397); if (state.failed) return ;

                    }
                    break;

            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "combined_join_clause"



    // $ANTLR start "orderby_clause"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:782:1: orderby_clause : orderby_contextual_keyword orderings ;
    public final void orderby_clause() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:783:2: ( orderby_contextual_keyword orderings )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:783:4: orderby_contextual_keyword orderings
            {
            pushFollow(FOLLOW_orderby_contextual_keyword_in_orderby_clause3411);
            orderby_contextual_keyword();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_orderings_in_orderby_clause3413);
            orderings();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "orderby_clause"



    // $ANTLR start "orderings"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:785:1: orderings : ordering ( COMMA ordering )* ;
    public final void orderings() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:786:2: ( ordering ( COMMA ordering )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:786:4: ordering ( COMMA ordering )*
            {
            pushFollow(FOLLOW_ordering_in_orderings3424);
            ordering();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:786:13: ( COMMA ordering )*
            loop89:
            do {
                int alt89=2;
                int LA89_0 = input.LA(1);

                if ( (LA89_0==COMMA) ) {
                    alt89=1;
                }


                switch (alt89) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:786:15: COMMA ordering
            	    {
            	    match(input,COMMA,FOLLOW_COMMA_in_orderings3428); if (state.failed) return ;

            	    pushFollow(FOLLOW_ordering_in_orderings3431);
            	    ordering();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop89;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "orderings"



    // $ANTLR start "ordering"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:788:1: ordering : expression ( ordering_direction )? ;
    public final void ordering() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:789:2: ( expression ( ordering_direction )? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:789:4: expression ( ordering_direction )?
            {
            pushFollow(FOLLOW_expression_in_ordering3445);
            expression();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:789:15: ( ordering_direction )?
            int alt90=2;
            int LA90_0 = input.LA(1);

            if ( (LA90_0==IDENTIFIER) ) {
                int LA90_1 = input.LA(2);

                if ( (LA90_1==COMMA) ) {
                    alt90=1;
                }
                else if ( (LA90_1==IDENTIFIER) ) {
                    int LA90_4 = input.LA(3);

                    if ( (((input.LT(1).getText().equals("ascending"))||(input.LT(1).getText().equals("descending")))) ) {
                        alt90=1;
                    }
                }
            }
            switch (alt90) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:789:15: ordering_direction
                    {
                    pushFollow(FOLLOW_ordering_direction_in_ordering3447);
                    ordering_direction();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "ordering"



    // $ANTLR start "ordering_direction"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:791:1: ordering_direction : ( ascending_contextual_keyword | descending_contextual_keyword );
    public final void ordering_direction() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:792:2: ( ascending_contextual_keyword | descending_contextual_keyword )
            int alt91=2;
            int LA91_0 = input.LA(1);

            if ( (LA91_0==IDENTIFIER) ) {
                int LA91_1 = input.LA(2);

                if ( ((input.LT(1).getText().equals("ascending"))) ) {
                    alt91=1;
                }
                else if ( ((input.LT(1).getText().equals("descending"))) ) {
                    alt91=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 91, 1, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 91, 0, input);

                throw nvae;

            }
            switch (alt91) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:792:4: ascending_contextual_keyword
                    {
                    pushFollow(FOLLOW_ascending_contextual_keyword_in_ordering_direction3459);
                    ascending_contextual_keyword();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:793:4: descending_contextual_keyword
                    {
                    pushFollow(FOLLOW_descending_contextual_keyword_in_ordering_direction3464);
                    descending_contextual_keyword();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "ordering_direction"



    // $ANTLR start "select_or_group_clause"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:795:1: select_or_group_clause : ( select_clause | group_clause );
    public final void select_or_group_clause() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:796:2: ( select_clause | group_clause )
            int alt92=2;
            int LA92_0 = input.LA(1);

            if ( (LA92_0==IDENTIFIER) ) {
                int LA92_1 = input.LA(2);

                if ( ((input.LT(1).getText().equals("select"))) ) {
                    alt92=1;
                }
                else if ( ((input.LT(1).getText().equals("group"))) ) {
                    alt92=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 92, 1, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 92, 0, input);

                throw nvae;

            }
            switch (alt92) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:796:4: select_clause
                    {
                    pushFollow(FOLLOW_select_clause_in_select_or_group_clause3475);
                    select_clause();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:797:4: group_clause
                    {
                    pushFollow(FOLLOW_group_clause_in_select_or_group_clause3480);
                    group_clause();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "select_or_group_clause"



    // $ANTLR start "select_clause"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:799:1: select_clause : select_contextual_keyword expression ;
    public final void select_clause() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:800:2: ( select_contextual_keyword expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:800:4: select_contextual_keyword expression
            {
            pushFollow(FOLLOW_select_contextual_keyword_in_select_clause3491);
            select_contextual_keyword();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_expression_in_select_clause3493);
            expression();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "select_clause"



    // $ANTLR start "group_clause"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:802:1: group_clause : group_contextual_keyword expression by_contextual_keyword expression ;
    public final void group_clause() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:803:2: ( group_contextual_keyword expression by_contextual_keyword expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:803:4: group_contextual_keyword expression by_contextual_keyword expression
            {
            pushFollow(FOLLOW_group_contextual_keyword_in_group_clause3504);
            group_contextual_keyword();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_expression_in_group_clause3506);
            expression();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_by_contextual_keyword_in_group_clause3508);
            by_contextual_keyword();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_expression_in_group_clause3510);
            expression();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "group_clause"



    // $ANTLR start "query_continuation"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:806:1: query_continuation : into_contextual_keyword IDENTIFIER query_body ;
    public final void query_continuation() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:807:2: ( into_contextual_keyword IDENTIFIER query_body )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:807:4: into_contextual_keyword IDENTIFIER query_body
            {
            pushFollow(FOLLOW_into_contextual_keyword_in_query_continuation3523);
            into_contextual_keyword();

            state._fsp--;
            if (state.failed) return ;

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_query_continuation3525); if (state.failed) return ;

            pushFollow(FOLLOW_query_body_in_query_continuation3527);
            query_body();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "query_continuation"



    // $ANTLR start "assignment"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:810:1: assignment : unary_expression assignment_operator expression ;
    public final void assignment() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:811:2: ( unary_expression assignment_operator expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:811:4: unary_expression assignment_operator expression
            {
            pushFollow(FOLLOW_unary_expression_in_assignment3540);
            unary_expression();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_assignment_operator_in_assignment3542);
            assignment_operator();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_expression_in_assignment3544);
            expression();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "assignment"



    // $ANTLR start "assignment_operator"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:813:1: assignment_operator : ( ASSIGNMENT | OP_ADD_ASSIGNMENT | OP_SUB_ASSIGNMENT | OP_MULT_ASSIGNMENT | OP_DIV_ASSIGNMENT | OP_MOD_ASSIGNMENT | OP_AND_ASSIGNMENT | OP_OR_ASSIGNMENT | OP_XOR_ASSIGNMENT | OP_LEFT_SHIFT_ASSIGNMENT | right_shift_assignment );
    public final void assignment_operator() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:814:2: ( ASSIGNMENT | OP_ADD_ASSIGNMENT | OP_SUB_ASSIGNMENT | OP_MULT_ASSIGNMENT | OP_DIV_ASSIGNMENT | OP_MOD_ASSIGNMENT | OP_AND_ASSIGNMENT | OP_OR_ASSIGNMENT | OP_XOR_ASSIGNMENT | OP_LEFT_SHIFT_ASSIGNMENT | right_shift_assignment )
            int alt93=11;
            switch ( input.LA(1) ) {
            case ASSIGNMENT:
                {
                alt93=1;
                }
                break;
            case OP_ADD_ASSIGNMENT:
                {
                alt93=2;
                }
                break;
            case OP_SUB_ASSIGNMENT:
                {
                alt93=3;
                }
                break;
            case OP_MULT_ASSIGNMENT:
                {
                alt93=4;
                }
                break;
            case OP_DIV_ASSIGNMENT:
                {
                alt93=5;
                }
                break;
            case OP_MOD_ASSIGNMENT:
                {
                alt93=6;
                }
                break;
            case OP_AND_ASSIGNMENT:
                {
                alt93=7;
                }
                break;
            case OP_OR_ASSIGNMENT:
                {
                alt93=8;
                }
                break;
            case OP_XOR_ASSIGNMENT:
                {
                alt93=9;
                }
                break;
            case OP_LEFT_SHIFT_ASSIGNMENT:
                {
                alt93=10;
                }
                break;
            case GT:
                {
                alt93=11;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 93, 0, input);

                throw nvae;

            }

            switch (alt93) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:814:4: ASSIGNMENT
                    {
                    match(input,ASSIGNMENT,FOLLOW_ASSIGNMENT_in_assignment_operator3555); if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:815:4: OP_ADD_ASSIGNMENT
                    {
                    match(input,OP_ADD_ASSIGNMENT,FOLLOW_OP_ADD_ASSIGNMENT_in_assignment_operator3560); if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:816:4: OP_SUB_ASSIGNMENT
                    {
                    match(input,OP_SUB_ASSIGNMENT,FOLLOW_OP_SUB_ASSIGNMENT_in_assignment_operator3565); if (state.failed) return ;

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:817:4: OP_MULT_ASSIGNMENT
                    {
                    match(input,OP_MULT_ASSIGNMENT,FOLLOW_OP_MULT_ASSIGNMENT_in_assignment_operator3570); if (state.failed) return ;

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:818:4: OP_DIV_ASSIGNMENT
                    {
                    match(input,OP_DIV_ASSIGNMENT,FOLLOW_OP_DIV_ASSIGNMENT_in_assignment_operator3575); if (state.failed) return ;

                    }
                    break;
                case 6 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:819:4: OP_MOD_ASSIGNMENT
                    {
                    match(input,OP_MOD_ASSIGNMENT,FOLLOW_OP_MOD_ASSIGNMENT_in_assignment_operator3580); if (state.failed) return ;

                    }
                    break;
                case 7 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:820:4: OP_AND_ASSIGNMENT
                    {
                    match(input,OP_AND_ASSIGNMENT,FOLLOW_OP_AND_ASSIGNMENT_in_assignment_operator3585); if (state.failed) return ;

                    }
                    break;
                case 8 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:821:4: OP_OR_ASSIGNMENT
                    {
                    match(input,OP_OR_ASSIGNMENT,FOLLOW_OP_OR_ASSIGNMENT_in_assignment_operator3590); if (state.failed) return ;

                    }
                    break;
                case 9 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:822:4: OP_XOR_ASSIGNMENT
                    {
                    match(input,OP_XOR_ASSIGNMENT,FOLLOW_OP_XOR_ASSIGNMENT_in_assignment_operator3595); if (state.failed) return ;

                    }
                    break;
                case 10 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:823:4: OP_LEFT_SHIFT_ASSIGNMENT
                    {
                    match(input,OP_LEFT_SHIFT_ASSIGNMENT,FOLLOW_OP_LEFT_SHIFT_ASSIGNMENT_in_assignment_operator3600); if (state.failed) return ;

                    }
                    break;
                case 11 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:824:4: right_shift_assignment
                    {
                    pushFollow(FOLLOW_right_shift_assignment_in_assignment_operator3605);
                    right_shift_assignment();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "assignment_operator"



    // $ANTLR start "expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:826:1: expression : ( ( assignment )=> assignment | non_assignment_expression );
    public final void expression() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:827:2: ( ( assignment )=> assignment | non_assignment_expression )
            int alt94=2;
            switch ( input.LA(1) ) {
            case OPEN_PARENS:
                {
                int LA94_1 = input.LA(2);

                if ( (synpred11_CSharp4()) ) {
                    alt94=1;
                }
                else if ( (true) ) {
                    alt94=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 94, 1, input);

                    throw nvae;

                }
                }
                break;
            case FALSE:
            case TRUE:
                {
                int LA94_2 = input.LA(2);

                if ( (synpred11_CSharp4()) ) {
                    alt94=1;
                }
                else if ( (true) ) {
                    alt94=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 94, 2, input);

                    throw nvae;

                }
                }
                break;
            case INTEGER_LITERAL:
                {
                int LA94_3 = input.LA(2);

                if ( (synpred11_CSharp4()) ) {
                    alt94=1;
                }
                else if ( (true) ) {
                    alt94=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 94, 3, input);

                    throw nvae;

                }
                }
                break;
            case REAL_LITERAL:
                {
                int LA94_4 = input.LA(2);

                if ( (synpred11_CSharp4()) ) {
                    alt94=1;
                }
                else if ( (true) ) {
                    alt94=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 94, 4, input);

                    throw nvae;

                }
                }
                break;
            case CHARACTER_LITERAL:
                {
                int LA94_5 = input.LA(2);

                if ( (synpred11_CSharp4()) ) {
                    alt94=1;
                }
                else if ( (true) ) {
                    alt94=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 94, 5, input);

                    throw nvae;

                }
                }
                break;
            case STRING_LITERAL:
                {
                int LA94_6 = input.LA(2);

                if ( (synpred11_CSharp4()) ) {
                    alt94=1;
                }
                else if ( (true) ) {
                    alt94=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 94, 6, input);

                    throw nvae;

                }
                }
                break;
            case NULL:
                {
                int LA94_7 = input.LA(2);

                if ( (synpred11_CSharp4()) ) {
                    alt94=1;
                }
                else if ( (true) ) {
                    alt94=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 94, 7, input);

                    throw nvae;

                }
                }
                break;
            case IDENTIFIER:
                {
                int LA94_8 = input.LA(2);

                if ( (synpred11_CSharp4()) ) {
                    alt94=1;
                }
                else if ( (true) ) {
                    alt94=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 94, 8, input);

                    throw nvae;

                }
                }
                break;
            case BOOL:
            case BYTE:
            case CHAR:
            case DECIMAL:
            case DOUBLE:
            case FLOAT:
            case INT:
            case LONG:
            case OBJECT:
            case SBYTE:
            case SHORT:
            case STRING:
            case UINT:
            case ULONG:
            case USHORT:
                {
                int LA94_9 = input.LA(2);

                if ( (synpred11_CSharp4()) ) {
                    alt94=1;
                }
                else if ( (true) ) {
                    alt94=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 94, 9, input);

                    throw nvae;

                }
                }
                break;
            case THIS:
                {
                int LA94_10 = input.LA(2);

                if ( (synpred11_CSharp4()) ) {
                    alt94=1;
                }
                else if ( (true) ) {
                    alt94=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 94, 10, input);

                    throw nvae;

                }
                }
                break;
            case BASE:
                {
                int LA94_11 = input.LA(2);

                if ( (synpred11_CSharp4()) ) {
                    alt94=1;
                }
                else if ( (true) ) {
                    alt94=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 94, 11, input);

                    throw nvae;

                }
                }
                break;
            case NEW:
                {
                int LA94_12 = input.LA(2);

                if ( (synpred11_CSharp4()) ) {
                    alt94=1;
                }
                else if ( (true) ) {
                    alt94=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 94, 12, input);

                    throw nvae;

                }
                }
                break;
            case TYPEOF:
                {
                int LA94_13 = input.LA(2);

                if ( (synpred11_CSharp4()) ) {
                    alt94=1;
                }
                else if ( (true) ) {
                    alt94=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 94, 13, input);

                    throw nvae;

                }
                }
                break;
            case CHECKED:
                {
                int LA94_14 = input.LA(2);

                if ( (synpred11_CSharp4()) ) {
                    alt94=1;
                }
                else if ( (true) ) {
                    alt94=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 94, 14, input);

                    throw nvae;

                }
                }
                break;
            case UNCHECKED:
                {
                int LA94_15 = input.LA(2);

                if ( (synpred11_CSharp4()) ) {
                    alt94=1;
                }
                else if ( (true) ) {
                    alt94=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 94, 15, input);

                    throw nvae;

                }
                }
                break;
            case DEFAULT:
                {
                int LA94_16 = input.LA(2);

                if ( (synpred11_CSharp4()) ) {
                    alt94=1;
                }
                else if ( (true) ) {
                    alt94=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 94, 16, input);

                    throw nvae;

                }
                }
                break;
            case DELEGATE:
                {
                int LA94_17 = input.LA(2);

                if ( (synpred11_CSharp4()) ) {
                    alt94=1;
                }
                else if ( (true) ) {
                    alt94=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 94, 17, input);

                    throw nvae;

                }
                }
                break;
            case SIZEOF:
                {
                int LA94_18 = input.LA(2);

                if ( (synpred11_CSharp4()) ) {
                    alt94=1;
                }
                else if ( (true) ) {
                    alt94=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 94, 18, input);

                    throw nvae;

                }
                }
                break;
            case PLUS:
                {
                int LA94_19 = input.LA(2);

                if ( (synpred11_CSharp4()) ) {
                    alt94=1;
                }
                else if ( (true) ) {
                    alt94=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 94, 19, input);

                    throw nvae;

                }
                }
                break;
            case MINUS:
                {
                int LA94_20 = input.LA(2);

                if ( (synpred11_CSharp4()) ) {
                    alt94=1;
                }
                else if ( (true) ) {
                    alt94=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 94, 20, input);

                    throw nvae;

                }
                }
                break;
            case BANG:
                {
                int LA94_21 = input.LA(2);

                if ( (synpred11_CSharp4()) ) {
                    alt94=1;
                }
                else if ( (true) ) {
                    alt94=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 94, 21, input);

                    throw nvae;

                }
                }
                break;
            case TILDE:
                {
                int LA94_22 = input.LA(2);

                if ( (synpred11_CSharp4()) ) {
                    alt94=1;
                }
                else if ( (true) ) {
                    alt94=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 94, 22, input);

                    throw nvae;

                }
                }
                break;
            case OP_INC:
                {
                int LA94_23 = input.LA(2);

                if ( (synpred11_CSharp4()) ) {
                    alt94=1;
                }
                else if ( (true) ) {
                    alt94=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 94, 23, input);

                    throw nvae;

                }
                }
                break;
            case OP_DEC:
                {
                int LA94_24 = input.LA(2);

                if ( (synpred11_CSharp4()) ) {
                    alt94=1;
                }
                else if ( (true) ) {
                    alt94=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 94, 24, input);

                    throw nvae;

                }
                }
                break;
            case STAR:
                {
                int LA94_25 = input.LA(2);

                if ( (synpred11_CSharp4()) ) {
                    alt94=1;
                }
                else if ( (true) ) {
                    alt94=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 94, 25, input);

                    throw nvae;

                }
                }
                break;
            case AMP:
                {
                int LA94_26 = input.LA(2);

                if ( (synpred11_CSharp4()) ) {
                    alt94=1;
                }
                else if ( (true) ) {
                    alt94=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 94, 26, input);

                    throw nvae;

                }
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 94, 0, input);

                throw nvae;

            }

            switch (alt94) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:827:4: ( assignment )=> assignment
                    {
                    pushFollow(FOLLOW_assignment_in_expression3622);
                    assignment();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:828:4: non_assignment_expression
                    {
                    pushFollow(FOLLOW_non_assignment_expression_in_expression3627);
                    non_assignment_expression();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "expression"



    // $ANTLR start "non_assignment_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:830:1: non_assignment_expression : ( ( lambda_expression )=> lambda_expression | ( query_expression )=> query_expression | conditional_expression );
    public final void non_assignment_expression() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:831:2: ( ( lambda_expression )=> lambda_expression | ( query_expression )=> query_expression | conditional_expression )
            int alt95=3;
            switch ( input.LA(1) ) {
            case OPEN_PARENS:
                {
                int LA95_1 = input.LA(2);

                if ( (synpred12_CSharp4()) ) {
                    alt95=1;
                }
                else if ( (true) ) {
                    alt95=3;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 95, 1, input);

                    throw nvae;

                }
                }
                break;
            case IDENTIFIER:
                {
                int LA95_2 = input.LA(2);

                if ( (synpred12_CSharp4()) ) {
                    alt95=1;
                }
                else if ( ((((input.LT(1).getText().equals("from"))&&(input.LT(1).getText().equals("from")))&&synpred13_CSharp4())) ) {
                    alt95=2;
                }
                else if ( (true) ) {
                    alt95=3;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 95, 2, input);

                    throw nvae;

                }
                }
                break;
            case AMP:
            case BANG:
            case BASE:
            case BOOL:
            case BYTE:
            case CHAR:
            case CHARACTER_LITERAL:
            case CHECKED:
            case DECIMAL:
            case DEFAULT:
            case DELEGATE:
            case DOUBLE:
            case FALSE:
            case FLOAT:
            case INT:
            case INTEGER_LITERAL:
            case LONG:
            case MINUS:
            case NEW:
            case NULL:
            case OBJECT:
            case OP_DEC:
            case OP_INC:
            case PLUS:
            case REAL_LITERAL:
            case SBYTE:
            case SHORT:
            case SIZEOF:
            case STAR:
            case STRING:
            case STRING_LITERAL:
            case THIS:
            case TILDE:
            case TRUE:
            case TYPEOF:
            case UINT:
            case ULONG:
            case UNCHECKED:
            case USHORT:
                {
                alt95=3;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 95, 0, input);

                throw nvae;

            }

            switch (alt95) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:831:4: ( lambda_expression )=> lambda_expression
                    {
                    pushFollow(FOLLOW_lambda_expression_in_non_assignment_expression3643);
                    lambda_expression();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:832:4: ( query_expression )=> query_expression
                    {
                    pushFollow(FOLLOW_query_expression_in_non_assignment_expression3654);
                    query_expression();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:833:4: conditional_expression
                    {
                    pushFollow(FOLLOW_conditional_expression_in_non_assignment_expression3659);
                    conditional_expression();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "non_assignment_expression"



    // $ANTLR start "constant_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:835:1: constant_expression : expression ;
    public final void constant_expression() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:836:2: ( expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:836:4: expression
            {
            pushFollow(FOLLOW_expression_in_constant_expression3670);
            expression();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "constant_expression"



    // $ANTLR start "boolean_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:838:1: boolean_expression : expression ;
    public final void boolean_expression() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:839:2: ( expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:839:4: expression
            {
            pushFollow(FOLLOW_expression_in_boolean_expression3681);
            expression();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "boolean_expression"



    // $ANTLR start "statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:843:1: statement : ( ( labeled_statement )=> labeled_statement | ( declaration_statement )=> declaration_statement | embedded_statement );
    public final void statement() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:844:2: ( ( labeled_statement )=> labeled_statement | ( declaration_statement )=> declaration_statement | embedded_statement )
            int alt96=3;
            int LA96_0 = input.LA(1);

            if ( (LA96_0==IDENTIFIER) ) {
                int LA96_1 = input.LA(2);

                if ( (synpred14_CSharp4()) ) {
                    alt96=1;
                }
                else if ( (synpred15_CSharp4()) ) {
                    alt96=2;
                }
                else if ( (true) ) {
                    alt96=3;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 96, 1, input);

                    throw nvae;

                }
            }
            else if ( (LA96_0==BYTE||LA96_0==CHAR||LA96_0==INT||LA96_0==LONG||LA96_0==SBYTE||LA96_0==SHORT||(LA96_0 >= UINT && LA96_0 <= ULONG)||LA96_0==USHORT) ) {
                int LA96_2 = input.LA(2);

                if ( (synpred15_CSharp4()) ) {
                    alt96=2;
                }
                else if ( (true) ) {
                    alt96=3;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 96, 2, input);

                    throw nvae;

                }
            }
            else if ( (LA96_0==DOUBLE||LA96_0==FLOAT) ) {
                int LA96_3 = input.LA(2);

                if ( (synpred15_CSharp4()) ) {
                    alt96=2;
                }
                else if ( (true) ) {
                    alt96=3;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 96, 3, input);

                    throw nvae;

                }
            }
            else if ( (LA96_0==DECIMAL) ) {
                int LA96_4 = input.LA(2);

                if ( (synpred15_CSharp4()) ) {
                    alt96=2;
                }
                else if ( (true) ) {
                    alt96=3;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 96, 4, input);

                    throw nvae;

                }
            }
            else if ( (LA96_0==BOOL) ) {
                int LA96_5 = input.LA(2);

                if ( (synpred15_CSharp4()) ) {
                    alt96=2;
                }
                else if ( (true) ) {
                    alt96=3;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 96, 5, input);

                    throw nvae;

                }
            }
            else if ( (LA96_0==OBJECT) ) {
                int LA96_6 = input.LA(2);

                if ( (synpred15_CSharp4()) ) {
                    alt96=2;
                }
                else if ( (true) ) {
                    alt96=3;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 96, 6, input);

                    throw nvae;

                }
            }
            else if ( (LA96_0==STRING) ) {
                int LA96_7 = input.LA(2);

                if ( (synpred15_CSharp4()) ) {
                    alt96=2;
                }
                else if ( (true) ) {
                    alt96=3;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 96, 7, input);

                    throw nvae;

                }
            }
            else if ( (LA96_0==VOID) && (synpred15_CSharp4())) {
                alt96=2;
            }
            else if ( (LA96_0==CONST) && (synpred15_CSharp4())) {
                alt96=2;
            }
            else if ( (LA96_0==AMP||(LA96_0 >= BANG && LA96_0 <= BASE)||LA96_0==BREAK||(LA96_0 >= CHARACTER_LITERAL && LA96_0 <= CHECKED)||LA96_0==CONTINUE||(LA96_0 >= DEFAULT && LA96_0 <= DELEGATE)||LA96_0==DO||LA96_0==FALSE||LA96_0==FIXED||(LA96_0 >= FOR && LA96_0 <= FOREACH)||LA96_0==GOTO||LA96_0==IF||LA96_0==INTEGER_LITERAL||LA96_0==LOCK||LA96_0==MINUS||LA96_0==NEW||LA96_0==NULL||LA96_0==OPEN_BRACE||LA96_0==OPEN_PARENS||LA96_0==OP_DEC||LA96_0==OP_INC||LA96_0==PLUS||LA96_0==REAL_LITERAL||LA96_0==RETURN||LA96_0==SEMICOLON||LA96_0==SIZEOF||LA96_0==STAR||LA96_0==STRING_LITERAL||LA96_0==SWITCH||(LA96_0 >= THIS && LA96_0 <= TYPEOF)||LA96_0==UNCHECKED||LA96_0==UNSAFE||LA96_0==USING||LA96_0==WHILE) ) {
                alt96=3;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 96, 0, input);

                throw nvae;

            }
            switch (alt96) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:844:4: ( labeled_statement )=> labeled_statement
                    {
                    pushFollow(FOLLOW_labeled_statement_in_statement3700);
                    labeled_statement();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:845:4: ( declaration_statement )=> declaration_statement
                    {
                    pushFollow(FOLLOW_declaration_statement_in_statement3711);
                    declaration_statement();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:846:4: embedded_statement
                    {
                    pushFollow(FOLLOW_embedded_statement_in_statement3716);
                    embedded_statement();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "statement"



    // $ANTLR start "embedded_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:848:1: embedded_statement : ( block | empty_statement | expression_statement | selection_statement | iteration_statement | jump_statement | try_statement | checked_statement | unchecked_statement | lock_statement | using_statement | yield_statement | embedded_statement_unsafe );
    public final void embedded_statement() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:849:2: ( block | empty_statement | expression_statement | selection_statement | iteration_statement | jump_statement | try_statement | checked_statement | unchecked_statement | lock_statement | using_statement | yield_statement | embedded_statement_unsafe )
            int alt97=13;
            switch ( input.LA(1) ) {
            case OPEN_BRACE:
                {
                alt97=1;
                }
                break;
            case SEMICOLON:
                {
                alt97=2;
                }
                break;
            case AMP:
            case BANG:
            case BASE:
            case BOOL:
            case BYTE:
            case CHAR:
            case CHARACTER_LITERAL:
            case DECIMAL:
            case DEFAULT:
            case DELEGATE:
            case DOUBLE:
            case FALSE:
            case FLOAT:
            case INT:
            case INTEGER_LITERAL:
            case LONG:
            case MINUS:
            case NEW:
            case NULL:
            case OBJECT:
            case OPEN_PARENS:
            case OP_DEC:
            case OP_INC:
            case PLUS:
            case REAL_LITERAL:
            case SBYTE:
            case SHORT:
            case SIZEOF:
            case STAR:
            case STRING:
            case STRING_LITERAL:
            case THIS:
            case TILDE:
            case TRUE:
            case TYPEOF:
            case UINT:
            case ULONG:
            case USHORT:
                {
                alt97=3;
                }
                break;
            case IDENTIFIER:
                {
                int LA97_4 = input.LA(2);

                if ( ((LA97_4 >= AMP && LA97_4 <= ASSIGNMENT)||(LA97_4 >= BITWISE_OR && LA97_4 <= BOOL)||(LA97_4 >= BYTE && LA97_4 <= CARET)||LA97_4==CHAR||LA97_4==DECIMAL||LA97_4==DIV||(LA97_4 >= DOT && LA97_4 <= DOUBLE)||LA97_4==DOUBLE_COLON||LA97_4==FLOAT||LA97_4==GT||LA97_4==IDENTIFIER||LA97_4==INT||(LA97_4 >= INTERR && LA97_4 <= IS)||(LA97_4 >= LONG && LA97_4 <= LT)||LA97_4==MINUS||LA97_4==OBJECT||(LA97_4 >= OPEN_BRACKET && LA97_4 <= OPEN_PARENS)||(LA97_4 >= OP_ADD_ASSIGNMENT && LA97_4 <= OP_XOR_ASSIGNMENT)||(LA97_4 >= PERCENT && LA97_4 <= PLUS)||LA97_4==SBYTE||LA97_4==SEMICOLON||LA97_4==SHORT||LA97_4==STAR||LA97_4==STRING||(LA97_4 >= UINT && LA97_4 <= ULONG)||LA97_4==USHORT||LA97_4==VOID) ) {
                    alt97=3;
                }
                else if ( (LA97_4==BREAK||LA97_4==RETURN) ) {
                    alt97=12;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 97, 4, input);

                    throw nvae;

                }
                }
                break;
            case CHECKED:
                {
                int LA97_5 = input.LA(2);

                if ( (LA97_5==OPEN_PARENS) ) {
                    alt97=3;
                }
                else if ( (LA97_5==OPEN_BRACE) ) {
                    alt97=8;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 97, 5, input);

                    throw nvae;

                }
                }
                break;
            case UNCHECKED:
                {
                int LA97_6 = input.LA(2);

                if ( (LA97_6==OPEN_PARENS) ) {
                    alt97=3;
                }
                else if ( (LA97_6==OPEN_BRACE) ) {
                    alt97=9;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 97, 6, input);

                    throw nvae;

                }
                }
                break;
            case IF:
            case SWITCH:
                {
                alt97=4;
                }
                break;
            case DO:
            case FOR:
            case FOREACH:
            case WHILE:
                {
                alt97=5;
                }
                break;
            case BREAK:
            case CONTINUE:
            case GOTO:
            case RETURN:
            case THROW:
                {
                alt97=6;
                }
                break;
            case TRY:
                {
                alt97=7;
                }
                break;
            case LOCK:
                {
                alt97=10;
                }
                break;
            case USING:
                {
                alt97=11;
                }
                break;
            case FIXED:
            case UNSAFE:
                {
                alt97=13;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 97, 0, input);

                throw nvae;

            }

            switch (alt97) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:849:4: block
                    {
                    pushFollow(FOLLOW_block_in_embedded_statement3727);
                    block();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:850:4: empty_statement
                    {
                    pushFollow(FOLLOW_empty_statement_in_embedded_statement3732);
                    empty_statement();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:851:4: expression_statement
                    {
                    pushFollow(FOLLOW_expression_statement_in_embedded_statement3737);
                    expression_statement();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:852:4: selection_statement
                    {
                    pushFollow(FOLLOW_selection_statement_in_embedded_statement3742);
                    selection_statement();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:853:4: iteration_statement
                    {
                    pushFollow(FOLLOW_iteration_statement_in_embedded_statement3747);
                    iteration_statement();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 6 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:854:4: jump_statement
                    {
                    pushFollow(FOLLOW_jump_statement_in_embedded_statement3752);
                    jump_statement();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 7 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:855:4: try_statement
                    {
                    pushFollow(FOLLOW_try_statement_in_embedded_statement3757);
                    try_statement();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 8 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:856:4: checked_statement
                    {
                    pushFollow(FOLLOW_checked_statement_in_embedded_statement3762);
                    checked_statement();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 9 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:857:4: unchecked_statement
                    {
                    pushFollow(FOLLOW_unchecked_statement_in_embedded_statement3767);
                    unchecked_statement();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 10 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:858:4: lock_statement
                    {
                    pushFollow(FOLLOW_lock_statement_in_embedded_statement3772);
                    lock_statement();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 11 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:859:4: using_statement
                    {
                    pushFollow(FOLLOW_using_statement_in_embedded_statement3777);
                    using_statement();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 12 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:860:4: yield_statement
                    {
                    pushFollow(FOLLOW_yield_statement_in_embedded_statement3782);
                    yield_statement();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 13 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:861:4: embedded_statement_unsafe
                    {
                    pushFollow(FOLLOW_embedded_statement_unsafe_in_embedded_statement3787);
                    embedded_statement_unsafe();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "embedded_statement"



    // $ANTLR start "block"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:864:1: block : OPEN_BRACE ( statement_list )? CLOSE_BRACE ;
    public final void block() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:865:2: ( OPEN_BRACE ( statement_list )? CLOSE_BRACE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:865:4: OPEN_BRACE ( statement_list )? CLOSE_BRACE
            {
            match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_block3800); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:865:15: ( statement_list )?
            int alt98=2;
            int LA98_0 = input.LA(1);

            if ( (LA98_0==AMP||(LA98_0 >= BANG && LA98_0 <= BASE)||(LA98_0 >= BOOL && LA98_0 <= BYTE)||(LA98_0 >= CHAR && LA98_0 <= CHECKED)||(LA98_0 >= CONST && LA98_0 <= CONTINUE)||LA98_0==DECIMAL||(LA98_0 >= DEFAULT && LA98_0 <= DELEGATE)||LA98_0==DO||LA98_0==DOUBLE||LA98_0==FALSE||(LA98_0 >= FIXED && LA98_0 <= FOREACH)||LA98_0==GOTO||(LA98_0 >= IDENTIFIER && LA98_0 <= IF)||(LA98_0 >= INT && LA98_0 <= INTEGER_LITERAL)||(LA98_0 >= LOCK && LA98_0 <= LONG)||LA98_0==MINUS||LA98_0==NEW||LA98_0==NULL||(LA98_0 >= OBJECT && LA98_0 <= OPEN_BRACE)||LA98_0==OPEN_PARENS||LA98_0==OP_DEC||LA98_0==OP_INC||LA98_0==PLUS||LA98_0==REAL_LITERAL||LA98_0==RETURN||LA98_0==SBYTE||LA98_0==SEMICOLON||LA98_0==SHORT||LA98_0==SIZEOF||LA98_0==STAR||(LA98_0 >= STRING && LA98_0 <= STRING_LITERAL)||LA98_0==SWITCH||(LA98_0 >= THIS && LA98_0 <= UNCHECKED)||(LA98_0 >= UNSAFE && LA98_0 <= USING)||LA98_0==VOID||LA98_0==WHILE) ) {
                alt98=1;
            }
            switch (alt98) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:865:15: statement_list
                    {
                    pushFollow(FOLLOW_statement_list_in_block3802);
                    statement_list();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_block3805); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "block"



    // $ANTLR start "statement_list"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:867:1: statement_list : ( statement )+ ;
    public final void statement_list() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:868:2: ( ( statement )+ )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:868:4: ( statement )+
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:868:4: ( statement )+
            int cnt99=0;
            loop99:
            do {
                int alt99=2;
                int LA99_0 = input.LA(1);

                if ( (LA99_0==DEFAULT) ) {
                    int LA99_2 = input.LA(2);

                    if ( (LA99_2==OPEN_PARENS) ) {
                        alt99=1;
                    }


                }
                else if ( (LA99_0==AMP||(LA99_0 >= BANG && LA99_0 <= BASE)||(LA99_0 >= BOOL && LA99_0 <= BYTE)||(LA99_0 >= CHAR && LA99_0 <= CHECKED)||(LA99_0 >= CONST && LA99_0 <= CONTINUE)||LA99_0==DECIMAL||LA99_0==DELEGATE||LA99_0==DO||LA99_0==DOUBLE||LA99_0==FALSE||(LA99_0 >= FIXED && LA99_0 <= FOREACH)||LA99_0==GOTO||(LA99_0 >= IDENTIFIER && LA99_0 <= IF)||(LA99_0 >= INT && LA99_0 <= INTEGER_LITERAL)||(LA99_0 >= LOCK && LA99_0 <= LONG)||LA99_0==MINUS||LA99_0==NEW||LA99_0==NULL||(LA99_0 >= OBJECT && LA99_0 <= OPEN_BRACE)||LA99_0==OPEN_PARENS||LA99_0==OP_DEC||LA99_0==OP_INC||LA99_0==PLUS||LA99_0==REAL_LITERAL||LA99_0==RETURN||LA99_0==SBYTE||LA99_0==SEMICOLON||LA99_0==SHORT||LA99_0==SIZEOF||LA99_0==STAR||(LA99_0 >= STRING && LA99_0 <= STRING_LITERAL)||LA99_0==SWITCH||(LA99_0 >= THIS && LA99_0 <= UNCHECKED)||(LA99_0 >= UNSAFE && LA99_0 <= USING)||LA99_0==VOID||LA99_0==WHILE) ) {
                    alt99=1;
                }


                switch (alt99) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:868:4: statement
            	    {
            	    pushFollow(FOLLOW_statement_in_statement_list3816);
            	    statement();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    if ( cnt99 >= 1 ) break loop99;
            	    if (state.backtracking>0) {state.failed=true; return ;}
                        EarlyExitException eee =
                            new EarlyExitException(99, input);
                        throw eee;
                }
                cnt99++;
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "statement_list"



    // $ANTLR start "empty_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:870:1: empty_statement : SEMICOLON ;
    public final void empty_statement() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:871:2: ( SEMICOLON )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:871:4: SEMICOLON
            {
            match(input,SEMICOLON,FOLLOW_SEMICOLON_in_empty_statement3828); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "empty_statement"



    // $ANTLR start "labeled_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:874:1: labeled_statement : IDENTIFIER COLON statement ;
    public final void labeled_statement() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:875:2: ( IDENTIFIER COLON statement )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:875:4: IDENTIFIER COLON statement
            {
            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_labeled_statement3841); if (state.failed) return ;

            match(input,COLON,FOLLOW_COLON_in_labeled_statement3843); if (state.failed) return ;

            pushFollow(FOLLOW_statement_in_labeled_statement3845);
            statement();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "labeled_statement"



    // $ANTLR start "declaration_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:878:1: declaration_statement : ( local_variable_declaration SEMICOLON | local_constant_declaration SEMICOLON );
    public final void declaration_statement() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:879:2: ( local_variable_declaration SEMICOLON | local_constant_declaration SEMICOLON )
            int alt100=2;
            int LA100_0 = input.LA(1);

            if ( (LA100_0==BOOL||LA100_0==BYTE||LA100_0==CHAR||LA100_0==DECIMAL||LA100_0==DOUBLE||LA100_0==FLOAT||LA100_0==IDENTIFIER||LA100_0==INT||LA100_0==LONG||LA100_0==OBJECT||LA100_0==SBYTE||LA100_0==SHORT||LA100_0==STRING||(LA100_0 >= UINT && LA100_0 <= ULONG)||LA100_0==USHORT||LA100_0==VOID) ) {
                alt100=1;
            }
            else if ( (LA100_0==CONST) ) {
                alt100=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 100, 0, input);

                throw nvae;

            }
            switch (alt100) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:879:4: local_variable_declaration SEMICOLON
                    {
                    pushFollow(FOLLOW_local_variable_declaration_in_declaration_statement3858);
                    local_variable_declaration();

                    state._fsp--;
                    if (state.failed) return ;

                    match(input,SEMICOLON,FOLLOW_SEMICOLON_in_declaration_statement3860); if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:880:4: local_constant_declaration SEMICOLON
                    {
                    pushFollow(FOLLOW_local_constant_declaration_in_declaration_statement3865);
                    local_constant_declaration();

                    state._fsp--;
                    if (state.failed) return ;

                    match(input,SEMICOLON,FOLLOW_SEMICOLON_in_declaration_statement3867); if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "declaration_statement"



    // $ANTLR start "local_variable_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:882:1: local_variable_declaration : t= local_variable_type local_variable_declarators ;
    public final void local_variable_declaration() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:883:2: (t= local_variable_type local_variable_declarators )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:883:4: t= local_variable_type local_variable_declarators
            {
            pushFollow(FOLLOW_local_variable_type_in_local_variable_declaration3880);
            local_variable_type();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_local_variable_declarators_in_local_variable_declaration3883);
            local_variable_declarators();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "local_variable_declaration"



    // $ANTLR start "local_variable_type"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:891:1: local_variable_type : type ;
    public final void local_variable_type() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:892:2: ( type )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:892:4: type
            {
            pushFollow(FOLLOW_type_in_local_variable_type3896);
            type();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "local_variable_type"



    // $ANTLR start "local_variable_declarators"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:895:1: local_variable_declarators : local_variable_declarator ( COMMA local_variable_declarator )* ;
    public final void local_variable_declarators() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:896:2: ( local_variable_declarator ( COMMA local_variable_declarator )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:896:4: local_variable_declarator ( COMMA local_variable_declarator )*
            {
            pushFollow(FOLLOW_local_variable_declarator_in_local_variable_declarators3910);
            local_variable_declarator();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:896:30: ( COMMA local_variable_declarator )*
            loop101:
            do {
                int alt101=2;
                int LA101_0 = input.LA(1);

                if ( (LA101_0==COMMA) ) {
                    alt101=1;
                }


                switch (alt101) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:896:32: COMMA local_variable_declarator
            	    {
            	    match(input,COMMA,FOLLOW_COMMA_in_local_variable_declarators3914); if (state.failed) return ;

            	    pushFollow(FOLLOW_local_variable_declarator_in_local_variable_declarators3917);
            	    local_variable_declarator();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop101;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "local_variable_declarators"



    // $ANTLR start "local_variable_declarator"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:904:1: local_variable_declarator : IDENTIFIER ( ASSIGNMENT local_variable_initializer )? ;
    public final void local_variable_declarator() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:905:3: ( IDENTIFIER ( ASSIGNMENT local_variable_initializer )? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:905:5: IDENTIFIER ( ASSIGNMENT local_variable_initializer )?
            {
            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_local_variable_declarator3934); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:905:17: ( ASSIGNMENT local_variable_initializer )?
            int alt102=2;
            int LA102_0 = input.LA(1);

            if ( (LA102_0==ASSIGNMENT) ) {
                alt102=1;
            }
            switch (alt102) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:905:18: ASSIGNMENT local_variable_initializer
                    {
                    match(input,ASSIGNMENT,FOLLOW_ASSIGNMENT_in_local_variable_declarator3938); if (state.failed) return ;

                    pushFollow(FOLLOW_local_variable_initializer_in_local_variable_declarator3940);
                    local_variable_initializer();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "local_variable_declarator"



    // $ANTLR start "local_variable_initializer"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:907:1: local_variable_initializer : ( expression | array_initializer | local_variable_initializer_unsafe );
    public final void local_variable_initializer() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:908:2: ( expression | array_initializer | local_variable_initializer_unsafe )
            int alt103=3;
            switch ( input.LA(1) ) {
            case AMP:
            case BANG:
            case BASE:
            case BOOL:
            case BYTE:
            case CHAR:
            case CHARACTER_LITERAL:
            case CHECKED:
            case DECIMAL:
            case DEFAULT:
            case DELEGATE:
            case DOUBLE:
            case FALSE:
            case FLOAT:
            case IDENTIFIER:
            case INT:
            case INTEGER_LITERAL:
            case LONG:
            case MINUS:
            case NEW:
            case NULL:
            case OBJECT:
            case OPEN_PARENS:
            case OP_DEC:
            case OP_INC:
            case PLUS:
            case REAL_LITERAL:
            case SBYTE:
            case SHORT:
            case SIZEOF:
            case STAR:
            case STRING:
            case STRING_LITERAL:
            case THIS:
            case TILDE:
            case TRUE:
            case TYPEOF:
            case UINT:
            case ULONG:
            case UNCHECKED:
            case USHORT:
                {
                alt103=1;
                }
                break;
            case OPEN_BRACE:
                {
                alt103=2;
                }
                break;
            case STACKALLOC:
                {
                alt103=3;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 103, 0, input);

                throw nvae;

            }

            switch (alt103) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:908:4: expression
                    {
                    pushFollow(FOLLOW_expression_in_local_variable_initializer3953);
                    expression();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:909:4: array_initializer
                    {
                    pushFollow(FOLLOW_array_initializer_in_local_variable_initializer3958);
                    array_initializer();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:910:4: local_variable_initializer_unsafe
                    {
                    pushFollow(FOLLOW_local_variable_initializer_unsafe_in_local_variable_initializer3963);
                    local_variable_initializer_unsafe();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "local_variable_initializer"



    // $ANTLR start "local_constant_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:912:1: local_constant_declaration : CONST type constant_declarators ;
    public final void local_constant_declaration() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:913:2: ( CONST type constant_declarators )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:913:4: CONST type constant_declarators
            {
            match(input,CONST,FOLLOW_CONST_in_local_constant_declaration3974); if (state.failed) return ;

            pushFollow(FOLLOW_type_in_local_constant_declaration3976);
            type();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_constant_declarators_in_local_constant_declaration3978);
            constant_declarators();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "local_constant_declaration"



    // $ANTLR start "expression_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:915:1: expression_statement : statement_expression SEMICOLON ;
    public final void expression_statement() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:916:2: ( statement_expression SEMICOLON )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:916:4: statement_expression SEMICOLON
            {
            pushFollow(FOLLOW_statement_expression_in_expression_statement3988);
            statement_expression();

            state._fsp--;
            if (state.failed) return ;

            match(input,SEMICOLON,FOLLOW_SEMICOLON_in_expression_statement3990); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "expression_statement"



    // $ANTLR start "statement_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:931:1: statement_expression : expression ;
    public final void statement_expression() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:932:2: ( expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:932:4: expression
            {
            pushFollow(FOLLOW_expression_in_statement_expression4005);
            expression();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "statement_expression"



    // $ANTLR start "selection_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:933:1: selection_statement : ( if_statement | switch_statement );
    public final void selection_statement() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:934:2: ( if_statement | switch_statement )
            int alt104=2;
            int LA104_0 = input.LA(1);

            if ( (LA104_0==IF) ) {
                alt104=1;
            }
            else if ( (LA104_0==SWITCH) ) {
                alt104=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 104, 0, input);

                throw nvae;

            }
            switch (alt104) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:934:4: if_statement
                    {
                    pushFollow(FOLLOW_if_statement_in_selection_statement4014);
                    if_statement();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:935:4: switch_statement
                    {
                    pushFollow(FOLLOW_switch_statement_in_selection_statement4019);
                    switch_statement();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "selection_statement"



    // $ANTLR start "if_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:943:1: if_statement : IF OPEN_PARENS boolean_expression CLOSE_PARENS embedded_statement ( ( ELSE )=> ELSE embedded_statement )? ;
    public final void if_statement() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:944:3: ( IF OPEN_PARENS boolean_expression CLOSE_PARENS embedded_statement ( ( ELSE )=> ELSE embedded_statement )? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:944:5: IF OPEN_PARENS boolean_expression CLOSE_PARENS embedded_statement ( ( ELSE )=> ELSE embedded_statement )?
            {
            match(input,IF,FOLLOW_IF_in_if_statement4033); if (state.failed) return ;

            match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_if_statement4035); if (state.failed) return ;

            pushFollow(FOLLOW_boolean_expression_in_if_statement4037);
            boolean_expression();

            state._fsp--;
            if (state.failed) return ;

            match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_if_statement4039); if (state.failed) return ;

            pushFollow(FOLLOW_embedded_statement_in_if_statement4041);
            embedded_statement();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:944:71: ( ( ELSE )=> ELSE embedded_statement )?
            int alt105=2;
            int LA105_0 = input.LA(1);

            if ( (LA105_0==ELSE) ) {
                int LA105_1 = input.LA(2);

                if ( (synpred16_CSharp4()) ) {
                    alt105=1;
                }
            }
            switch (alt105) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:944:73: ( ELSE )=> ELSE embedded_statement
                    {
                    match(input,ELSE,FOLLOW_ELSE_in_if_statement4051); if (state.failed) return ;

                    pushFollow(FOLLOW_embedded_statement_in_if_statement4053);
                    embedded_statement();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "if_statement"



    // $ANTLR start "switch_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:946:1: switch_statement : SWITCH OPEN_PARENS expression CLOSE_PARENS switch_block ;
    public final void switch_statement() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:947:2: ( SWITCH OPEN_PARENS expression CLOSE_PARENS switch_block )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:947:4: SWITCH OPEN_PARENS expression CLOSE_PARENS switch_block
            {
            match(input,SWITCH,FOLLOW_SWITCH_in_switch_statement4068); if (state.failed) return ;

            match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_switch_statement4070); if (state.failed) return ;

            pushFollow(FOLLOW_expression_in_switch_statement4072);
            expression();

            state._fsp--;
            if (state.failed) return ;

            match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_switch_statement4074); if (state.failed) return ;

            pushFollow(FOLLOW_switch_block_in_switch_statement4076);
            switch_block();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "switch_statement"



    // $ANTLR start "switch_block"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:949:1: switch_block : OPEN_BRACE ( switch_sections )? CLOSE_BRACE ;
    public final void switch_block() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:950:2: ( OPEN_BRACE ( switch_sections )? CLOSE_BRACE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:950:4: OPEN_BRACE ( switch_sections )? CLOSE_BRACE
            {
            match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_switch_block4087); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:950:15: ( switch_sections )?
            int alt106=2;
            int LA106_0 = input.LA(1);

            if ( (LA106_0==CASE||LA106_0==DEFAULT) ) {
                alt106=1;
            }
            switch (alt106) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:950:15: switch_sections
                    {
                    pushFollow(FOLLOW_switch_sections_in_switch_block4089);
                    switch_sections();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_switch_block4092); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "switch_block"



    // $ANTLR start "switch_sections"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:952:1: switch_sections : switch_section ( switch_section )* ;
    public final void switch_sections() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:953:2: ( switch_section ( switch_section )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:953:4: switch_section ( switch_section )*
            {
            pushFollow(FOLLOW_switch_section_in_switch_sections4103);
            switch_section();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:953:19: ( switch_section )*
            loop107:
            do {
                int alt107=2;
                int LA107_0 = input.LA(1);

                if ( (LA107_0==CASE||LA107_0==DEFAULT) ) {
                    alt107=1;
                }


                switch (alt107) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:953:21: switch_section
            	    {
            	    pushFollow(FOLLOW_switch_section_in_switch_sections4107);
            	    switch_section();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop107;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "switch_sections"



    // $ANTLR start "switch_section"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:955:1: switch_section : switch_labels statement_list ;
    public final void switch_section() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:956:2: ( switch_labels statement_list )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:956:4: switch_labels statement_list
            {
            pushFollow(FOLLOW_switch_labels_in_switch_section4121);
            switch_labels();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_statement_list_in_switch_section4123);
            statement_list();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "switch_section"



    // $ANTLR start "switch_labels"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:958:1: switch_labels : switch_label ( switch_label )* ;
    public final void switch_labels() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:959:2: ( switch_label ( switch_label )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:959:4: switch_label ( switch_label )*
            {
            pushFollow(FOLLOW_switch_label_in_switch_labels4134);
            switch_label();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:959:17: ( switch_label )*
            loop108:
            do {
                int alt108=2;
                int LA108_0 = input.LA(1);

                if ( (LA108_0==DEFAULT) ) {
                    int LA108_2 = input.LA(2);

                    if ( (LA108_2==COLON) ) {
                        alt108=1;
                    }


                }
                else if ( (LA108_0==CASE) ) {
                    alt108=1;
                }


                switch (alt108) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:959:19: switch_label
            	    {
            	    pushFollow(FOLLOW_switch_label_in_switch_labels4138);
            	    switch_label();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop108;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "switch_labels"



    // $ANTLR start "switch_label"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:961:1: switch_label : ( CASE constant_expression COLON | DEFAULT COLON );
    public final void switch_label() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:962:2: ( CASE constant_expression COLON | DEFAULT COLON )
            int alt109=2;
            int LA109_0 = input.LA(1);

            if ( (LA109_0==CASE) ) {
                alt109=1;
            }
            else if ( (LA109_0==DEFAULT) ) {
                alt109=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 109, 0, input);

                throw nvae;

            }
            switch (alt109) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:962:4: CASE constant_expression COLON
                    {
                    match(input,CASE,FOLLOW_CASE_in_switch_label4152); if (state.failed) return ;

                    pushFollow(FOLLOW_constant_expression_in_switch_label4154);
                    constant_expression();

                    state._fsp--;
                    if (state.failed) return ;

                    match(input,COLON,FOLLOW_COLON_in_switch_label4156); if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:963:4: DEFAULT COLON
                    {
                    match(input,DEFAULT,FOLLOW_DEFAULT_in_switch_label4161); if (state.failed) return ;

                    match(input,COLON,FOLLOW_COLON_in_switch_label4163); if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "switch_label"



    // $ANTLR start "iteration_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:965:1: iteration_statement : ( while_statement | do_statement | for_statement | foreach_statement );
    public final void iteration_statement() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:966:2: ( while_statement | do_statement | for_statement | foreach_statement )
            int alt110=4;
            switch ( input.LA(1) ) {
            case WHILE:
                {
                alt110=1;
                }
                break;
            case DO:
                {
                alt110=2;
                }
                break;
            case FOR:
                {
                alt110=3;
                }
                break;
            case FOREACH:
                {
                alt110=4;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 110, 0, input);

                throw nvae;

            }

            switch (alt110) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:966:4: while_statement
                    {
                    pushFollow(FOLLOW_while_statement_in_iteration_statement4174);
                    while_statement();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:967:4: do_statement
                    {
                    pushFollow(FOLLOW_do_statement_in_iteration_statement4179);
                    do_statement();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:968:4: for_statement
                    {
                    pushFollow(FOLLOW_for_statement_in_iteration_statement4184);
                    for_statement();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:969:4: foreach_statement
                    {
                    pushFollow(FOLLOW_foreach_statement_in_iteration_statement4189);
                    foreach_statement();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "iteration_statement"



    // $ANTLR start "while_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:971:1: while_statement : WHILE OPEN_PARENS boolean_expression CLOSE_PARENS embedded_statement ;
    public final void while_statement() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:972:2: ( WHILE OPEN_PARENS boolean_expression CLOSE_PARENS embedded_statement )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:972:4: WHILE OPEN_PARENS boolean_expression CLOSE_PARENS embedded_statement
            {
            match(input,WHILE,FOLLOW_WHILE_in_while_statement4200); if (state.failed) return ;

            match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_while_statement4202); if (state.failed) return ;

            pushFollow(FOLLOW_boolean_expression_in_while_statement4204);
            boolean_expression();

            state._fsp--;
            if (state.failed) return ;

            match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_while_statement4206); if (state.failed) return ;

            pushFollow(FOLLOW_embedded_statement_in_while_statement4208);
            embedded_statement();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "while_statement"



    // $ANTLR start "do_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:974:1: do_statement : DO embedded_statement WHILE OPEN_PARENS boolean_expression CLOSE_PARENS SEMICOLON ;
    public final void do_statement() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:975:2: ( DO embedded_statement WHILE OPEN_PARENS boolean_expression CLOSE_PARENS SEMICOLON )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:975:4: DO embedded_statement WHILE OPEN_PARENS boolean_expression CLOSE_PARENS SEMICOLON
            {
            match(input,DO,FOLLOW_DO_in_do_statement4219); if (state.failed) return ;

            pushFollow(FOLLOW_embedded_statement_in_do_statement4221);
            embedded_statement();

            state._fsp--;
            if (state.failed) return ;

            match(input,WHILE,FOLLOW_WHILE_in_do_statement4223); if (state.failed) return ;

            match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_do_statement4225); if (state.failed) return ;

            pushFollow(FOLLOW_boolean_expression_in_do_statement4227);
            boolean_expression();

            state._fsp--;
            if (state.failed) return ;

            match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_do_statement4229); if (state.failed) return ;

            match(input,SEMICOLON,FOLLOW_SEMICOLON_in_do_statement4231); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "do_statement"



    // $ANTLR start "for_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:977:1: for_statement : FOR OPEN_PARENS ( for_initializer )? SEMICOLON ( for_condition )? SEMICOLON ( for_iterator )? CLOSE_PARENS embedded_statement ;
    public final void for_statement() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:978:2: ( FOR OPEN_PARENS ( for_initializer )? SEMICOLON ( for_condition )? SEMICOLON ( for_iterator )? CLOSE_PARENS embedded_statement )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:978:4: FOR OPEN_PARENS ( for_initializer )? SEMICOLON ( for_condition )? SEMICOLON ( for_iterator )? CLOSE_PARENS embedded_statement
            {
            match(input,FOR,FOLLOW_FOR_in_for_statement4242); if (state.failed) return ;

            match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_for_statement4244); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:978:20: ( for_initializer )?
            int alt111=2;
            int LA111_0 = input.LA(1);

            if ( (LA111_0==AMP||(LA111_0 >= BANG && LA111_0 <= BASE)||LA111_0==BOOL||LA111_0==BYTE||(LA111_0 >= CHAR && LA111_0 <= CHECKED)||LA111_0==DECIMAL||(LA111_0 >= DEFAULT && LA111_0 <= DELEGATE)||LA111_0==DOUBLE||LA111_0==FALSE||LA111_0==FLOAT||LA111_0==IDENTIFIER||(LA111_0 >= INT && LA111_0 <= INTEGER_LITERAL)||LA111_0==LONG||LA111_0==MINUS||LA111_0==NEW||LA111_0==NULL||LA111_0==OBJECT||LA111_0==OPEN_PARENS||LA111_0==OP_DEC||LA111_0==OP_INC||LA111_0==PLUS||LA111_0==REAL_LITERAL||LA111_0==SBYTE||LA111_0==SHORT||LA111_0==SIZEOF||LA111_0==STAR||(LA111_0 >= STRING && LA111_0 <= STRING_LITERAL)||LA111_0==THIS||(LA111_0 >= TILDE && LA111_0 <= TRUE)||(LA111_0 >= TYPEOF && LA111_0 <= UNCHECKED)||LA111_0==USHORT||LA111_0==VOID) ) {
                alt111=1;
            }
            switch (alt111) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:978:20: for_initializer
                    {
                    pushFollow(FOLLOW_for_initializer_in_for_statement4246);
                    for_initializer();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,SEMICOLON,FOLLOW_SEMICOLON_in_for_statement4249); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:978:47: ( for_condition )?
            int alt112=2;
            int LA112_0 = input.LA(1);

            if ( (LA112_0==AMP||(LA112_0 >= BANG && LA112_0 <= BASE)||LA112_0==BOOL||LA112_0==BYTE||(LA112_0 >= CHAR && LA112_0 <= CHECKED)||LA112_0==DECIMAL||(LA112_0 >= DEFAULT && LA112_0 <= DELEGATE)||LA112_0==DOUBLE||LA112_0==FALSE||LA112_0==FLOAT||LA112_0==IDENTIFIER||(LA112_0 >= INT && LA112_0 <= INTEGER_LITERAL)||LA112_0==LONG||LA112_0==MINUS||LA112_0==NEW||LA112_0==NULL||LA112_0==OBJECT||LA112_0==OPEN_PARENS||LA112_0==OP_DEC||LA112_0==OP_INC||LA112_0==PLUS||LA112_0==REAL_LITERAL||LA112_0==SBYTE||LA112_0==SHORT||LA112_0==SIZEOF||LA112_0==STAR||(LA112_0 >= STRING && LA112_0 <= STRING_LITERAL)||LA112_0==THIS||(LA112_0 >= TILDE && LA112_0 <= TRUE)||(LA112_0 >= TYPEOF && LA112_0 <= UNCHECKED)||LA112_0==USHORT) ) {
                alt112=1;
            }
            switch (alt112) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:978:47: for_condition
                    {
                    pushFollow(FOLLOW_for_condition_in_for_statement4251);
                    for_condition();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,SEMICOLON,FOLLOW_SEMICOLON_in_for_statement4254); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:978:72: ( for_iterator )?
            int alt113=2;
            int LA113_0 = input.LA(1);

            if ( (LA113_0==AMP||(LA113_0 >= BANG && LA113_0 <= BASE)||LA113_0==BOOL||LA113_0==BYTE||(LA113_0 >= CHAR && LA113_0 <= CHECKED)||LA113_0==DECIMAL||(LA113_0 >= DEFAULT && LA113_0 <= DELEGATE)||LA113_0==DOUBLE||LA113_0==FALSE||LA113_0==FLOAT||LA113_0==IDENTIFIER||(LA113_0 >= INT && LA113_0 <= INTEGER_LITERAL)||LA113_0==LONG||LA113_0==MINUS||LA113_0==NEW||LA113_0==NULL||LA113_0==OBJECT||LA113_0==OPEN_PARENS||LA113_0==OP_DEC||LA113_0==OP_INC||LA113_0==PLUS||LA113_0==REAL_LITERAL||LA113_0==SBYTE||LA113_0==SHORT||LA113_0==SIZEOF||LA113_0==STAR||(LA113_0 >= STRING && LA113_0 <= STRING_LITERAL)||LA113_0==THIS||(LA113_0 >= TILDE && LA113_0 <= TRUE)||(LA113_0 >= TYPEOF && LA113_0 <= UNCHECKED)||LA113_0==USHORT) ) {
                alt113=1;
            }
            switch (alt113) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:978:72: for_iterator
                    {
                    pushFollow(FOLLOW_for_iterator_in_for_statement4256);
                    for_iterator();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_for_statement4259); if (state.failed) return ;

            pushFollow(FOLLOW_embedded_statement_in_for_statement4261);
            embedded_statement();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "for_statement"



    // $ANTLR start "for_initializer"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:980:1: for_initializer : ( ( local_variable_declaration )=> local_variable_declaration | statement_expression_list );
    public final void for_initializer() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:981:2: ( ( local_variable_declaration )=> local_variable_declaration | statement_expression_list )
            int alt114=2;
            int LA114_0 = input.LA(1);

            if ( (LA114_0==BYTE||LA114_0==CHAR||LA114_0==INT||LA114_0==LONG||LA114_0==SBYTE||LA114_0==SHORT||(LA114_0 >= UINT && LA114_0 <= ULONG)||LA114_0==USHORT) ) {
                int LA114_1 = input.LA(2);

                if ( (synpred17_CSharp4()) ) {
                    alt114=1;
                }
                else if ( (true) ) {
                    alt114=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 114, 1, input);

                    throw nvae;

                }
            }
            else if ( (LA114_0==DOUBLE||LA114_0==FLOAT) ) {
                int LA114_2 = input.LA(2);

                if ( (synpred17_CSharp4()) ) {
                    alt114=1;
                }
                else if ( (true) ) {
                    alt114=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 114, 2, input);

                    throw nvae;

                }
            }
            else if ( (LA114_0==DECIMAL) ) {
                int LA114_3 = input.LA(2);

                if ( (synpred17_CSharp4()) ) {
                    alt114=1;
                }
                else if ( (true) ) {
                    alt114=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 114, 3, input);

                    throw nvae;

                }
            }
            else if ( (LA114_0==BOOL) ) {
                int LA114_4 = input.LA(2);

                if ( (synpred17_CSharp4()) ) {
                    alt114=1;
                }
                else if ( (true) ) {
                    alt114=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 114, 4, input);

                    throw nvae;

                }
            }
            else if ( (LA114_0==IDENTIFIER) ) {
                int LA114_5 = input.LA(2);

                if ( (synpred17_CSharp4()) ) {
                    alt114=1;
                }
                else if ( (true) ) {
                    alt114=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 114, 5, input);

                    throw nvae;

                }
            }
            else if ( (LA114_0==OBJECT) ) {
                int LA114_6 = input.LA(2);

                if ( (synpred17_CSharp4()) ) {
                    alt114=1;
                }
                else if ( (true) ) {
                    alt114=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 114, 6, input);

                    throw nvae;

                }
            }
            else if ( (LA114_0==STRING) ) {
                int LA114_7 = input.LA(2);

                if ( (synpred17_CSharp4()) ) {
                    alt114=1;
                }
                else if ( (true) ) {
                    alt114=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 114, 7, input);

                    throw nvae;

                }
            }
            else if ( (LA114_0==VOID) && (synpred17_CSharp4())) {
                alt114=1;
            }
            else if ( (LA114_0==AMP||(LA114_0 >= BANG && LA114_0 <= BASE)||(LA114_0 >= CHARACTER_LITERAL && LA114_0 <= CHECKED)||(LA114_0 >= DEFAULT && LA114_0 <= DELEGATE)||LA114_0==FALSE||LA114_0==INTEGER_LITERAL||LA114_0==MINUS||LA114_0==NEW||LA114_0==NULL||LA114_0==OPEN_PARENS||LA114_0==OP_DEC||LA114_0==OP_INC||LA114_0==PLUS||LA114_0==REAL_LITERAL||LA114_0==SIZEOF||LA114_0==STAR||LA114_0==STRING_LITERAL||LA114_0==THIS||(LA114_0 >= TILDE && LA114_0 <= TRUE)||LA114_0==TYPEOF||LA114_0==UNCHECKED) ) {
                alt114=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 114, 0, input);

                throw nvae;

            }
            switch (alt114) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:981:4: ( local_variable_declaration )=> local_variable_declaration
                    {
                    pushFollow(FOLLOW_local_variable_declaration_in_for_initializer4278);
                    local_variable_declaration();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:982:4: statement_expression_list
                    {
                    pushFollow(FOLLOW_statement_expression_list_in_for_initializer4283);
                    statement_expression_list();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "for_initializer"



    // $ANTLR start "for_condition"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:984:1: for_condition : boolean_expression ;
    public final void for_condition() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:985:2: ( boolean_expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:985:4: boolean_expression
            {
            pushFollow(FOLLOW_boolean_expression_in_for_condition4294);
            boolean_expression();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "for_condition"



    // $ANTLR start "for_iterator"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:987:1: for_iterator : statement_expression_list ;
    public final void for_iterator() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:988:2: ( statement_expression_list )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:988:4: statement_expression_list
            {
            pushFollow(FOLLOW_statement_expression_list_in_for_iterator4305);
            statement_expression_list();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "for_iterator"



    // $ANTLR start "statement_expression_list"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:990:1: statement_expression_list : statement_expression ( COMMA statement_expression )* ;
    public final void statement_expression_list() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:991:2: ( statement_expression ( COMMA statement_expression )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:991:4: statement_expression ( COMMA statement_expression )*
            {
            pushFollow(FOLLOW_statement_expression_in_statement_expression_list4316);
            statement_expression();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:991:25: ( COMMA statement_expression )*
            loop115:
            do {
                int alt115=2;
                int LA115_0 = input.LA(1);

                if ( (LA115_0==COMMA) ) {
                    alt115=1;
                }


                switch (alt115) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:991:27: COMMA statement_expression
            	    {
            	    match(input,COMMA,FOLLOW_COMMA_in_statement_expression_list4320); if (state.failed) return ;

            	    pushFollow(FOLLOW_statement_expression_in_statement_expression_list4323);
            	    statement_expression();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop115;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "statement_expression_list"



    // $ANTLR start "foreach_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:993:1: foreach_statement : FOREACH OPEN_PARENS local_variable_type IDENTIFIER IN expression CLOSE_PARENS embedded_statement ;
    public final void foreach_statement() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:994:2: ( FOREACH OPEN_PARENS local_variable_type IDENTIFIER IN expression CLOSE_PARENS embedded_statement )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:994:4: FOREACH OPEN_PARENS local_variable_type IDENTIFIER IN expression CLOSE_PARENS embedded_statement
            {
            match(input,FOREACH,FOLLOW_FOREACH_in_foreach_statement4337); if (state.failed) return ;

            match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_foreach_statement4339); if (state.failed) return ;

            pushFollow(FOLLOW_local_variable_type_in_foreach_statement4341);
            local_variable_type();

            state._fsp--;
            if (state.failed) return ;

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_foreach_statement4343); if (state.failed) return ;

            match(input,IN,FOLLOW_IN_in_foreach_statement4345); if (state.failed) return ;

            pushFollow(FOLLOW_expression_in_foreach_statement4347);
            expression();

            state._fsp--;
            if (state.failed) return ;

            match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_foreach_statement4349); if (state.failed) return ;

            pushFollow(FOLLOW_embedded_statement_in_foreach_statement4351);
            embedded_statement();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "foreach_statement"



    // $ANTLR start "jump_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:996:1: jump_statement : ( break_statement | continue_statement | goto_statement | return_statement | throw_statement );
    public final void jump_statement() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:997:2: ( break_statement | continue_statement | goto_statement | return_statement | throw_statement )
            int alt116=5;
            switch ( input.LA(1) ) {
            case BREAK:
                {
                alt116=1;
                }
                break;
            case CONTINUE:
                {
                alt116=2;
                }
                break;
            case GOTO:
                {
                alt116=3;
                }
                break;
            case RETURN:
                {
                alt116=4;
                }
                break;
            case THROW:
                {
                alt116=5;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 116, 0, input);

                throw nvae;

            }

            switch (alt116) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:997:4: break_statement
                    {
                    pushFollow(FOLLOW_break_statement_in_jump_statement4362);
                    break_statement();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:998:4: continue_statement
                    {
                    pushFollow(FOLLOW_continue_statement_in_jump_statement4367);
                    continue_statement();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:999:4: goto_statement
                    {
                    pushFollow(FOLLOW_goto_statement_in_jump_statement4372);
                    goto_statement();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1000:4: return_statement
                    {
                    pushFollow(FOLLOW_return_statement_in_jump_statement4377);
                    return_statement();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1001:4: throw_statement
                    {
                    pushFollow(FOLLOW_throw_statement_in_jump_statement4382);
                    throw_statement();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "jump_statement"



    // $ANTLR start "break_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1003:1: break_statement : BREAK SEMICOLON ;
    public final void break_statement() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1004:2: ( BREAK SEMICOLON )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1004:4: BREAK SEMICOLON
            {
            match(input,BREAK,FOLLOW_BREAK_in_break_statement4393); if (state.failed) return ;

            match(input,SEMICOLON,FOLLOW_SEMICOLON_in_break_statement4395); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "break_statement"



    // $ANTLR start "continue_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1006:1: continue_statement : CONTINUE SEMICOLON ;
    public final void continue_statement() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1007:2: ( CONTINUE SEMICOLON )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1007:4: CONTINUE SEMICOLON
            {
            match(input,CONTINUE,FOLLOW_CONTINUE_in_continue_statement4406); if (state.failed) return ;

            match(input,SEMICOLON,FOLLOW_SEMICOLON_in_continue_statement4408); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "continue_statement"



    // $ANTLR start "goto_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1009:1: goto_statement : ( GOTO IDENTIFIER SEMICOLON | GOTO CASE constant_expression SEMICOLON | GOTO DEFAULT SEMICOLON );
    public final void goto_statement() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1010:2: ( GOTO IDENTIFIER SEMICOLON | GOTO CASE constant_expression SEMICOLON | GOTO DEFAULT SEMICOLON )
            int alt117=3;
            int LA117_0 = input.LA(1);

            if ( (LA117_0==GOTO) ) {
                switch ( input.LA(2) ) {
                case IDENTIFIER:
                    {
                    alt117=1;
                    }
                    break;
                case CASE:
                    {
                    alt117=2;
                    }
                    break;
                case DEFAULT:
                    {
                    alt117=3;
                    }
                    break;
                default:
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 117, 1, input);

                    throw nvae;

                }

            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 117, 0, input);

                throw nvae;

            }
            switch (alt117) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1010:4: GOTO IDENTIFIER SEMICOLON
                    {
                    match(input,GOTO,FOLLOW_GOTO_in_goto_statement4419); if (state.failed) return ;

                    match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_goto_statement4421); if (state.failed) return ;

                    match(input,SEMICOLON,FOLLOW_SEMICOLON_in_goto_statement4423); if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1011:4: GOTO CASE constant_expression SEMICOLON
                    {
                    match(input,GOTO,FOLLOW_GOTO_in_goto_statement4428); if (state.failed) return ;

                    match(input,CASE,FOLLOW_CASE_in_goto_statement4430); if (state.failed) return ;

                    pushFollow(FOLLOW_constant_expression_in_goto_statement4432);
                    constant_expression();

                    state._fsp--;
                    if (state.failed) return ;

                    match(input,SEMICOLON,FOLLOW_SEMICOLON_in_goto_statement4434); if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1012:4: GOTO DEFAULT SEMICOLON
                    {
                    match(input,GOTO,FOLLOW_GOTO_in_goto_statement4439); if (state.failed) return ;

                    match(input,DEFAULT,FOLLOW_DEFAULT_in_goto_statement4441); if (state.failed) return ;

                    match(input,SEMICOLON,FOLLOW_SEMICOLON_in_goto_statement4443); if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "goto_statement"



    // $ANTLR start "return_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1014:1: return_statement : RETURN ( expression )? SEMICOLON ;
    public final void return_statement() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1015:2: ( RETURN ( expression )? SEMICOLON )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1015:4: RETURN ( expression )? SEMICOLON
            {
            match(input,RETURN,FOLLOW_RETURN_in_return_statement4454); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1015:11: ( expression )?
            int alt118=2;
            int LA118_0 = input.LA(1);

            if ( (LA118_0==AMP||(LA118_0 >= BANG && LA118_0 <= BASE)||LA118_0==BOOL||LA118_0==BYTE||(LA118_0 >= CHAR && LA118_0 <= CHECKED)||LA118_0==DECIMAL||(LA118_0 >= DEFAULT && LA118_0 <= DELEGATE)||LA118_0==DOUBLE||LA118_0==FALSE||LA118_0==FLOAT||LA118_0==IDENTIFIER||(LA118_0 >= INT && LA118_0 <= INTEGER_LITERAL)||LA118_0==LONG||LA118_0==MINUS||LA118_0==NEW||LA118_0==NULL||LA118_0==OBJECT||LA118_0==OPEN_PARENS||LA118_0==OP_DEC||LA118_0==OP_INC||LA118_0==PLUS||LA118_0==REAL_LITERAL||LA118_0==SBYTE||LA118_0==SHORT||LA118_0==SIZEOF||LA118_0==STAR||(LA118_0 >= STRING && LA118_0 <= STRING_LITERAL)||LA118_0==THIS||(LA118_0 >= TILDE && LA118_0 <= TRUE)||(LA118_0 >= TYPEOF && LA118_0 <= UNCHECKED)||LA118_0==USHORT) ) {
                alt118=1;
            }
            switch (alt118) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1015:11: expression
                    {
                    pushFollow(FOLLOW_expression_in_return_statement4456);
                    expression();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,SEMICOLON,FOLLOW_SEMICOLON_in_return_statement4459); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "return_statement"



    // $ANTLR start "throw_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1017:1: throw_statement : THROW ( expression )? SEMICOLON ;
    public final void throw_statement() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1018:2: ( THROW ( expression )? SEMICOLON )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1018:4: THROW ( expression )? SEMICOLON
            {
            match(input,THROW,FOLLOW_THROW_in_throw_statement4470); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1018:10: ( expression )?
            int alt119=2;
            int LA119_0 = input.LA(1);

            if ( (LA119_0==AMP||(LA119_0 >= BANG && LA119_0 <= BASE)||LA119_0==BOOL||LA119_0==BYTE||(LA119_0 >= CHAR && LA119_0 <= CHECKED)||LA119_0==DECIMAL||(LA119_0 >= DEFAULT && LA119_0 <= DELEGATE)||LA119_0==DOUBLE||LA119_0==FALSE||LA119_0==FLOAT||LA119_0==IDENTIFIER||(LA119_0 >= INT && LA119_0 <= INTEGER_LITERAL)||LA119_0==LONG||LA119_0==MINUS||LA119_0==NEW||LA119_0==NULL||LA119_0==OBJECT||LA119_0==OPEN_PARENS||LA119_0==OP_DEC||LA119_0==OP_INC||LA119_0==PLUS||LA119_0==REAL_LITERAL||LA119_0==SBYTE||LA119_0==SHORT||LA119_0==SIZEOF||LA119_0==STAR||(LA119_0 >= STRING && LA119_0 <= STRING_LITERAL)||LA119_0==THIS||(LA119_0 >= TILDE && LA119_0 <= TRUE)||(LA119_0 >= TYPEOF && LA119_0 <= UNCHECKED)||LA119_0==USHORT) ) {
                alt119=1;
            }
            switch (alt119) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1018:10: expression
                    {
                    pushFollow(FOLLOW_expression_in_throw_statement4472);
                    expression();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,SEMICOLON,FOLLOW_SEMICOLON_in_throw_statement4475); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "throw_statement"



    // $ANTLR start "try_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1027:1: try_statement : TRY block ( catch_clauses )? ( finally_clause )? ;
    public final void try_statement() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1028:3: ( TRY block ( catch_clauses )? ( finally_clause )? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1028:5: TRY block ( catch_clauses )? ( finally_clause )?
            {
            match(input,TRY,FOLLOW_TRY_in_try_statement4489); if (state.failed) return ;

            pushFollow(FOLLOW_block_in_try_statement4491);
            block();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1028:15: ( catch_clauses )?
            int alt120=2;
            int LA120_0 = input.LA(1);

            if ( (LA120_0==CATCH) ) {
                alt120=1;
            }
            switch (alt120) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1028:15: catch_clauses
                    {
                    pushFollow(FOLLOW_catch_clauses_in_try_statement4493);
                    catch_clauses();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1028:30: ( finally_clause )?
            int alt121=2;
            int LA121_0 = input.LA(1);

            if ( (LA121_0==FINALLY) ) {
                alt121=1;
            }
            switch (alt121) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1028:30: finally_clause
                    {
                    pushFollow(FOLLOW_finally_clause_in_try_statement4496);
                    finally_clause();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "try_statement"



    // $ANTLR start "catch_clauses"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1036:1: catch_clauses : ( specific_catch_clauses ( general_catch_clause )? | general_catch_clause );
    public final void catch_clauses() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1037:3: ( specific_catch_clauses ( general_catch_clause )? | general_catch_clause )
            int alt123=2;
            int LA123_0 = input.LA(1);

            if ( (LA123_0==CATCH) ) {
                int LA123_1 = input.LA(2);

                if ( (LA123_1==OPEN_PARENS) ) {
                    alt123=1;
                }
                else if ( (LA123_1==OPEN_BRACE) ) {
                    alt123=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 123, 1, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 123, 0, input);

                throw nvae;

            }
            switch (alt123) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1037:5: specific_catch_clauses ( general_catch_clause )?
                    {
                    pushFollow(FOLLOW_specific_catch_clauses_in_catch_clauses4512);
                    specific_catch_clauses();

                    state._fsp--;
                    if (state.failed) return ;

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1037:28: ( general_catch_clause )?
                    int alt122=2;
                    int LA122_0 = input.LA(1);

                    if ( (LA122_0==CATCH) ) {
                        alt122=1;
                    }
                    switch (alt122) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1037:28: general_catch_clause
                            {
                            pushFollow(FOLLOW_general_catch_clause_in_catch_clauses4514);
                            general_catch_clause();

                            state._fsp--;
                            if (state.failed) return ;

                            }
                            break;

                    }


                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1038:5: general_catch_clause
                    {
                    pushFollow(FOLLOW_general_catch_clause_in_catch_clauses4521);
                    general_catch_clause();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "catch_clauses"



    // $ANTLR start "specific_catch_clauses"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1040:1: specific_catch_clauses : specific_catch_clause ( specific_catch_clause )* ;
    public final void specific_catch_clauses() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1041:2: ( specific_catch_clause ( specific_catch_clause )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1041:4: specific_catch_clause ( specific_catch_clause )*
            {
            pushFollow(FOLLOW_specific_catch_clause_in_specific_catch_clauses4533);
            specific_catch_clause();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1041:26: ( specific_catch_clause )*
            loop124:
            do {
                int alt124=2;
                int LA124_0 = input.LA(1);

                if ( (LA124_0==CATCH) ) {
                    int LA124_1 = input.LA(2);

                    if ( (LA124_1==OPEN_PARENS) ) {
                        alt124=1;
                    }


                }


                switch (alt124) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1041:28: specific_catch_clause
            	    {
            	    pushFollow(FOLLOW_specific_catch_clause_in_specific_catch_clauses4537);
            	    specific_catch_clause();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop124;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "specific_catch_clauses"



    // $ANTLR start "specific_catch_clause"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1043:1: specific_catch_clause : CATCH OPEN_PARENS class_type ( IDENTIFIER )? CLOSE_PARENS block ;
    public final void specific_catch_clause() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1044:2: ( CATCH OPEN_PARENS class_type ( IDENTIFIER )? CLOSE_PARENS block )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1044:4: CATCH OPEN_PARENS class_type ( IDENTIFIER )? CLOSE_PARENS block
            {
            match(input,CATCH,FOLLOW_CATCH_in_specific_catch_clause4551); if (state.failed) return ;

            match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_specific_catch_clause4553); if (state.failed) return ;

            pushFollow(FOLLOW_class_type_in_specific_catch_clause4555);
            class_type();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1044:33: ( IDENTIFIER )?
            int alt125=2;
            int LA125_0 = input.LA(1);

            if ( (LA125_0==IDENTIFIER) ) {
                alt125=1;
            }
            switch (alt125) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1044:33: IDENTIFIER
                    {
                    match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_specific_catch_clause4557); if (state.failed) return ;

                    }
                    break;

            }


            match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_specific_catch_clause4560); if (state.failed) return ;

            pushFollow(FOLLOW_block_in_specific_catch_clause4562);
            block();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "specific_catch_clause"



    // $ANTLR start "general_catch_clause"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1046:1: general_catch_clause : CATCH block ;
    public final void general_catch_clause() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1047:2: ( CATCH block )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1047:4: CATCH block
            {
            match(input,CATCH,FOLLOW_CATCH_in_general_catch_clause4573); if (state.failed) return ;

            pushFollow(FOLLOW_block_in_general_catch_clause4575);
            block();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "general_catch_clause"



    // $ANTLR start "finally_clause"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1049:1: finally_clause : FINALLY block ;
    public final void finally_clause() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1050:2: ( FINALLY block )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1050:4: FINALLY block
            {
            match(input,FINALLY,FOLLOW_FINALLY_in_finally_clause4586); if (state.failed) return ;

            pushFollow(FOLLOW_block_in_finally_clause4588);
            block();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "finally_clause"



    // $ANTLR start "checked_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1052:1: checked_statement : CHECKED block ;
    public final void checked_statement() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1053:2: ( CHECKED block )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1053:4: CHECKED block
            {
            match(input,CHECKED,FOLLOW_CHECKED_in_checked_statement4599); if (state.failed) return ;

            pushFollow(FOLLOW_block_in_checked_statement4601);
            block();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "checked_statement"



    // $ANTLR start "unchecked_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1055:1: unchecked_statement : UNCHECKED block ;
    public final void unchecked_statement() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1056:2: ( UNCHECKED block )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1056:4: UNCHECKED block
            {
            match(input,UNCHECKED,FOLLOW_UNCHECKED_in_unchecked_statement4612); if (state.failed) return ;

            pushFollow(FOLLOW_block_in_unchecked_statement4614);
            block();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "unchecked_statement"



    // $ANTLR start "lock_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1058:1: lock_statement : LOCK OPEN_PARENS expression CLOSE_PARENS embedded_statement ;
    public final void lock_statement() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1059:2: ( LOCK OPEN_PARENS expression CLOSE_PARENS embedded_statement )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1059:4: LOCK OPEN_PARENS expression CLOSE_PARENS embedded_statement
            {
            match(input,LOCK,FOLLOW_LOCK_in_lock_statement4625); if (state.failed) return ;

            match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_lock_statement4627); if (state.failed) return ;

            pushFollow(FOLLOW_expression_in_lock_statement4629);
            expression();

            state._fsp--;
            if (state.failed) return ;

            match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_lock_statement4631); if (state.failed) return ;

            pushFollow(FOLLOW_embedded_statement_in_lock_statement4633);
            embedded_statement();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "lock_statement"



    // $ANTLR start "using_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1061:1: using_statement : USING OPEN_PARENS resource_acquisition CLOSE_PARENS embedded_statement ;
    public final void using_statement() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1062:2: ( USING OPEN_PARENS resource_acquisition CLOSE_PARENS embedded_statement )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1062:4: USING OPEN_PARENS resource_acquisition CLOSE_PARENS embedded_statement
            {
            match(input,USING,FOLLOW_USING_in_using_statement4644); if (state.failed) return ;

            match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_using_statement4646); if (state.failed) return ;

            pushFollow(FOLLOW_resource_acquisition_in_using_statement4648);
            resource_acquisition();

            state._fsp--;
            if (state.failed) return ;

            match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_using_statement4650); if (state.failed) return ;

            pushFollow(FOLLOW_embedded_statement_in_using_statement4652);
            embedded_statement();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "using_statement"



    // $ANTLR start "resource_acquisition"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1070:1: resource_acquisition : ( ( local_variable_declaration )=> local_variable_declaration | expression );
    public final void resource_acquisition() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1071:2: ( ( local_variable_declaration )=> local_variable_declaration | expression )
            int alt126=2;
            int LA126_0 = input.LA(1);

            if ( (LA126_0==BYTE||LA126_0==CHAR||LA126_0==INT||LA126_0==LONG||LA126_0==SBYTE||LA126_0==SHORT||(LA126_0 >= UINT && LA126_0 <= ULONG)||LA126_0==USHORT) ) {
                int LA126_1 = input.LA(2);

                if ( (synpred18_CSharp4()) ) {
                    alt126=1;
                }
                else if ( (true) ) {
                    alt126=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 126, 1, input);

                    throw nvae;

                }
            }
            else if ( (LA126_0==DOUBLE||LA126_0==FLOAT) ) {
                int LA126_2 = input.LA(2);

                if ( (synpred18_CSharp4()) ) {
                    alt126=1;
                }
                else if ( (true) ) {
                    alt126=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 126, 2, input);

                    throw nvae;

                }
            }
            else if ( (LA126_0==DECIMAL) ) {
                int LA126_3 = input.LA(2);

                if ( (synpred18_CSharp4()) ) {
                    alt126=1;
                }
                else if ( (true) ) {
                    alt126=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 126, 3, input);

                    throw nvae;

                }
            }
            else if ( (LA126_0==BOOL) ) {
                int LA126_4 = input.LA(2);

                if ( (synpred18_CSharp4()) ) {
                    alt126=1;
                }
                else if ( (true) ) {
                    alt126=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 126, 4, input);

                    throw nvae;

                }
            }
            else if ( (LA126_0==IDENTIFIER) ) {
                int LA126_5 = input.LA(2);

                if ( (synpred18_CSharp4()) ) {
                    alt126=1;
                }
                else if ( (true) ) {
                    alt126=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 126, 5, input);

                    throw nvae;

                }
            }
            else if ( (LA126_0==OBJECT) ) {
                int LA126_6 = input.LA(2);

                if ( (synpred18_CSharp4()) ) {
                    alt126=1;
                }
                else if ( (true) ) {
                    alt126=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 126, 6, input);

                    throw nvae;

                }
            }
            else if ( (LA126_0==STRING) ) {
                int LA126_7 = input.LA(2);

                if ( (synpred18_CSharp4()) ) {
                    alt126=1;
                }
                else if ( (true) ) {
                    alt126=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 126, 7, input);

                    throw nvae;

                }
            }
            else if ( (LA126_0==VOID) && (synpred18_CSharp4())) {
                alt126=1;
            }
            else if ( (LA126_0==AMP||(LA126_0 >= BANG && LA126_0 <= BASE)||(LA126_0 >= CHARACTER_LITERAL && LA126_0 <= CHECKED)||(LA126_0 >= DEFAULT && LA126_0 <= DELEGATE)||LA126_0==FALSE||LA126_0==INTEGER_LITERAL||LA126_0==MINUS||LA126_0==NEW||LA126_0==NULL||LA126_0==OPEN_PARENS||LA126_0==OP_DEC||LA126_0==OP_INC||LA126_0==PLUS||LA126_0==REAL_LITERAL||LA126_0==SIZEOF||LA126_0==STAR||LA126_0==STRING_LITERAL||LA126_0==THIS||(LA126_0 >= TILDE && LA126_0 <= TRUE)||LA126_0==TYPEOF||LA126_0==UNCHECKED) ) {
                alt126=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 126, 0, input);

                throw nvae;

            }
            switch (alt126) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1071:4: ( local_variable_declaration )=> local_variable_declaration
                    {
                    pushFollow(FOLLOW_local_variable_declaration_in_resource_acquisition4671);
                    local_variable_declaration();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1072:4: expression
                    {
                    pushFollow(FOLLOW_expression_in_resource_acquisition4676);
                    expression();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "resource_acquisition"



    // $ANTLR start "yield_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1074:1: yield_statement : ( yield_contextual_keyword RETURN expression SEMICOLON | yield_contextual_keyword BREAK SEMICOLON );
    public final void yield_statement() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1075:2: ( yield_contextual_keyword RETURN expression SEMICOLON | yield_contextual_keyword BREAK SEMICOLON )
            int alt127=2;
            int LA127_0 = input.LA(1);

            if ( (LA127_0==IDENTIFIER) ) {
                int LA127_1 = input.LA(2);

                if ( (LA127_1==RETURN) ) {
                    alt127=1;
                }
                else if ( (LA127_1==BREAK) ) {
                    alt127=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 127, 1, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 127, 0, input);

                throw nvae;

            }
            switch (alt127) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1075:4: yield_contextual_keyword RETURN expression SEMICOLON
                    {
                    pushFollow(FOLLOW_yield_contextual_keyword_in_yield_statement4687);
                    yield_contextual_keyword();

                    state._fsp--;
                    if (state.failed) return ;

                    match(input,RETURN,FOLLOW_RETURN_in_yield_statement4689); if (state.failed) return ;

                    pushFollow(FOLLOW_expression_in_yield_statement4691);
                    expression();

                    state._fsp--;
                    if (state.failed) return ;

                    match(input,SEMICOLON,FOLLOW_SEMICOLON_in_yield_statement4693); if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1076:4: yield_contextual_keyword BREAK SEMICOLON
                    {
                    pushFollow(FOLLOW_yield_contextual_keyword_in_yield_statement4698);
                    yield_contextual_keyword();

                    state._fsp--;
                    if (state.failed) return ;

                    match(input,BREAK,FOLLOW_BREAK_in_yield_statement4700); if (state.failed) return ;

                    match(input,SEMICOLON,FOLLOW_SEMICOLON_in_yield_statement4702); if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "yield_statement"



    // $ANTLR start "compilation_unit"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1088:1: compilation_unit : ( extern_alias_directives )? ( using_directives )? ( ( global_attribute_section )=> global_attribute_section )* ( namespace_member_declarations )? EOF ;
    public final void compilation_unit() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1089:3: ( ( extern_alias_directives )? ( using_directives )? ( ( global_attribute_section )=> global_attribute_section )* ( namespace_member_declarations )? EOF )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1089:5: ( extern_alias_directives )? ( using_directives )? ( ( global_attribute_section )=> global_attribute_section )* ( namespace_member_declarations )? EOF
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1089:5: ( extern_alias_directives )?
            int alt128=2;
            int LA128_0 = input.LA(1);

            if ( (LA128_0==EXTERN) ) {
                int LA128_1 = input.LA(2);

                if ( (LA128_1==IDENTIFIER) ) {
                    int LA128_3 = input.LA(3);

                    if ( (LA128_3==IDENTIFIER) ) {
                        int LA128_4 = input.LA(4);

                        if ( (LA128_4==SEMICOLON) ) {
                            alt128=1;
                        }
                    }
                }
            }
            switch (alt128) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1089:5: extern_alias_directives
                    {
                    pushFollow(FOLLOW_extern_alias_directives_in_compilation_unit4721);
                    extern_alias_directives();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1089:30: ( using_directives )?
            int alt129=2;
            int LA129_0 = input.LA(1);

            if ( (LA129_0==USING) ) {
                alt129=1;
            }
            switch (alt129) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1089:30: using_directives
                    {
                    pushFollow(FOLLOW_using_directives_in_compilation_unit4724);
                    using_directives();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1090:5: ( ( global_attribute_section )=> global_attribute_section )*
            loop130:
            do {
                int alt130=2;
                int LA130_0 = input.LA(1);

                if ( (LA130_0==OPEN_BRACKET) ) {
                    int LA130_2 = input.LA(2);

                    if ( (synpred19_CSharp4()) ) {
                        alt130=1;
                    }


                }


                switch (alt130) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1090:7: ( global_attribute_section )=> global_attribute_section
            	    {
            	    pushFollow(FOLLOW_global_attribute_section_in_compilation_unit4739);
            	    global_attribute_section();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop130;
                }
            } while (true);


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1091:5: ( namespace_member_declarations )?
            int alt131=2;
            int LA131_0 = input.LA(1);

            if ( (LA131_0==ABSTRACT||LA131_0==CLASS||LA131_0==DELEGATE||LA131_0==ENUM||LA131_0==EXTERN||LA131_0==IDENTIFIER||(LA131_0 >= INTERFACE && LA131_0 <= INTERNAL)||(LA131_0 >= NAMESPACE && LA131_0 <= NEW)||LA131_0==OPEN_BRACKET||LA131_0==OVERRIDE||(LA131_0 >= PRIVATE && LA131_0 <= PUBLIC)||LA131_0==READONLY||LA131_0==SEALED||LA131_0==STATIC||LA131_0==STRUCT||LA131_0==UNSAFE||LA131_0==VIRTUAL||LA131_0==VOLATILE) ) {
                alt131=1;
            }
            switch (alt131) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1091:5: namespace_member_declarations
                    {
                    pushFollow(FOLLOW_namespace_member_declarations_in_compilation_unit4748);
                    namespace_member_declarations();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,EOF,FOLLOW_EOF_in_compilation_unit4751); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "compilation_unit"



    // $ANTLR start "namespace_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1093:1: namespace_declaration : NAMESPACE qi= qualified_identifier namespace_body ( SEMICOLON )? ;
    public final void namespace_declaration() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1094:2: ( NAMESPACE qi= qualified_identifier namespace_body ( SEMICOLON )? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1094:4: NAMESPACE qi= qualified_identifier namespace_body ( SEMICOLON )?
            {
            match(input,NAMESPACE,FOLLOW_NAMESPACE_in_namespace_declaration4763); if (state.failed) return ;

            pushFollow(FOLLOW_qualified_identifier_in_namespace_declaration4767);
            qualified_identifier();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_namespace_body_in_namespace_declaration4769);
            namespace_body();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1094:53: ( SEMICOLON )?
            int alt132=2;
            int LA132_0 = input.LA(1);

            if ( (LA132_0==SEMICOLON) ) {
                alt132=1;
            }
            switch (alt132) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1094:53: SEMICOLON
                    {
                    match(input,SEMICOLON,FOLLOW_SEMICOLON_in_namespace_declaration4771); if (state.failed) return ;

                    }
                    break;

            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "namespace_declaration"



    // $ANTLR start "qualified_identifier"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1096:1: qualified_identifier : IDENTIFIER ( DOT IDENTIFIER )* ;
    public final void qualified_identifier() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1097:2: ( IDENTIFIER ( DOT IDENTIFIER )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1097:4: IDENTIFIER ( DOT IDENTIFIER )*
            {
            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_qualified_identifier4783); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1097:15: ( DOT IDENTIFIER )*
            loop133:
            do {
                int alt133=2;
                int LA133_0 = input.LA(1);

                if ( (LA133_0==DOT) ) {
                    alt133=1;
                }


                switch (alt133) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1097:17: DOT IDENTIFIER
            	    {
            	    match(input,DOT,FOLLOW_DOT_in_qualified_identifier4787); if (state.failed) return ;

            	    match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_qualified_identifier4790); if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop133;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "qualified_identifier"



    // $ANTLR start "namespace_body"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1099:1: namespace_body : OPEN_BRACE ( extern_alias_directives )? ( using_directives )? ( namespace_member_declarations )? CLOSE_BRACE ;
    public final void namespace_body() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1100:2: ( OPEN_BRACE ( extern_alias_directives )? ( using_directives )? ( namespace_member_declarations )? CLOSE_BRACE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1100:4: OPEN_BRACE ( extern_alias_directives )? ( using_directives )? ( namespace_member_declarations )? CLOSE_BRACE
            {
            match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_namespace_body4804); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1100:15: ( extern_alias_directives )?
            int alt134=2;
            int LA134_0 = input.LA(1);

            if ( (LA134_0==EXTERN) ) {
                int LA134_1 = input.LA(2);

                if ( (LA134_1==IDENTIFIER) ) {
                    int LA134_3 = input.LA(3);

                    if ( (LA134_3==IDENTIFIER) ) {
                        int LA134_4 = input.LA(4);

                        if ( (LA134_4==SEMICOLON) ) {
                            alt134=1;
                        }
                    }
                }
            }
            switch (alt134) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1100:15: extern_alias_directives
                    {
                    pushFollow(FOLLOW_extern_alias_directives_in_namespace_body4806);
                    extern_alias_directives();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1100:40: ( using_directives )?
            int alt135=2;
            int LA135_0 = input.LA(1);

            if ( (LA135_0==USING) ) {
                alt135=1;
            }
            switch (alt135) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1100:40: using_directives
                    {
                    pushFollow(FOLLOW_using_directives_in_namespace_body4809);
                    using_directives();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1100:58: ( namespace_member_declarations )?
            int alt136=2;
            int LA136_0 = input.LA(1);

            if ( (LA136_0==ABSTRACT||LA136_0==CLASS||LA136_0==DELEGATE||LA136_0==ENUM||LA136_0==EXTERN||LA136_0==IDENTIFIER||(LA136_0 >= INTERFACE && LA136_0 <= INTERNAL)||(LA136_0 >= NAMESPACE && LA136_0 <= NEW)||LA136_0==OPEN_BRACKET||LA136_0==OVERRIDE||(LA136_0 >= PRIVATE && LA136_0 <= PUBLIC)||LA136_0==READONLY||LA136_0==SEALED||LA136_0==STATIC||LA136_0==STRUCT||LA136_0==UNSAFE||LA136_0==VIRTUAL||LA136_0==VOLATILE) ) {
                alt136=1;
            }
            switch (alt136) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1100:58: namespace_member_declarations
                    {
                    pushFollow(FOLLOW_namespace_member_declarations_in_namespace_body4812);
                    namespace_member_declarations();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_namespace_body4815); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "namespace_body"



    // $ANTLR start "extern_alias_directives"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1102:1: extern_alias_directives : ( extern_alias_directive )+ ;
    public final void extern_alias_directives() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1103:2: ( ( extern_alias_directive )+ )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1103:4: ( extern_alias_directive )+
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1103:4: ( extern_alias_directive )+
            int cnt137=0;
            loop137:
            do {
                int alt137=2;
                int LA137_0 = input.LA(1);

                if ( (LA137_0==EXTERN) ) {
                    int LA137_2 = input.LA(2);

                    if ( (LA137_2==IDENTIFIER) ) {
                        int LA137_3 = input.LA(3);

                        if ( (LA137_3==IDENTIFIER) ) {
                            int LA137_4 = input.LA(4);

                            if ( (LA137_4==SEMICOLON) ) {
                                alt137=1;
                            }


                        }


                    }


                }


                switch (alt137) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1103:4: extern_alias_directive
            	    {
            	    pushFollow(FOLLOW_extern_alias_directive_in_extern_alias_directives4826);
            	    extern_alias_directive();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    if ( cnt137 >= 1 ) break loop137;
            	    if (state.backtracking>0) {state.failed=true; return ;}
                        EarlyExitException eee =
                            new EarlyExitException(137, input);
                        throw eee;
                }
                cnt137++;
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "extern_alias_directives"



    // $ANTLR start "extern_alias_directive"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1105:1: extern_alias_directive : EXTERN alias_contextual_keyword IDENTIFIER SEMICOLON ;
    public final void extern_alias_directive() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1106:2: ( EXTERN alias_contextual_keyword IDENTIFIER SEMICOLON )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1106:4: EXTERN alias_contextual_keyword IDENTIFIER SEMICOLON
            {
            match(input,EXTERN,FOLLOW_EXTERN_in_extern_alias_directive4838); if (state.failed) return ;

            pushFollow(FOLLOW_alias_contextual_keyword_in_extern_alias_directive4840);
            alias_contextual_keyword();

            state._fsp--;
            if (state.failed) return ;

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_extern_alias_directive4842); if (state.failed) return ;

            match(input,SEMICOLON,FOLLOW_SEMICOLON_in_extern_alias_directive4844); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "extern_alias_directive"



    // $ANTLR start "using_directives"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1108:1: using_directives : ( using_directive )+ ;
    public final void using_directives() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1109:2: ( ( using_directive )+ )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1109:4: ( using_directive )+
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1109:4: ( using_directive )+
            int cnt138=0;
            loop138:
            do {
                int alt138=2;
                int LA138_0 = input.LA(1);

                if ( (LA138_0==USING) ) {
                    alt138=1;
                }


                switch (alt138) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1109:4: using_directive
            	    {
            	    pushFollow(FOLLOW_using_directive_in_using_directives4855);
            	    using_directive();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    if ( cnt138 >= 1 ) break loop138;
            	    if (state.backtracking>0) {state.failed=true; return ;}
                        EarlyExitException eee =
                            new EarlyExitException(138, input);
                        throw eee;
                }
                cnt138++;
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "using_directives"



    // $ANTLR start "using_directive"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1111:1: using_directive : ( using_alias_directive | using_namespace_directive );
    public final void using_directive() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1112:2: ( using_alias_directive | using_namespace_directive )
            int alt139=2;
            int LA139_0 = input.LA(1);

            if ( (LA139_0==USING) ) {
                int LA139_1 = input.LA(2);

                if ( (LA139_1==IDENTIFIER) ) {
                    int LA139_2 = input.LA(3);

                    if ( (LA139_2==ASSIGNMENT) ) {
                        alt139=1;
                    }
                    else if ( (LA139_2==DOT||LA139_2==DOUBLE_COLON||LA139_2==LT||LA139_2==SEMICOLON) ) {
                        alt139=2;
                    }
                    else {
                        if (state.backtracking>0) {state.failed=true; return ;}
                        NoViableAltException nvae =
                            new NoViableAltException("", 139, 2, input);

                        throw nvae;

                    }
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 139, 1, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 139, 0, input);

                throw nvae;

            }
            switch (alt139) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1112:4: using_alias_directive
                    {
                    pushFollow(FOLLOW_using_alias_directive_in_using_directive4867);
                    using_alias_directive();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1113:4: using_namespace_directive
                    {
                    pushFollow(FOLLOW_using_namespace_directive_in_using_directive4872);
                    using_namespace_directive();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "using_directive"



    // $ANTLR start "using_alias_directive"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1115:1: using_alias_directive : USING IDENTIFIER ASSIGNMENT namespace_or_type_name SEMICOLON ;
    public final void using_alias_directive() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1116:2: ( USING IDENTIFIER ASSIGNMENT namespace_or_type_name SEMICOLON )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1116:4: USING IDENTIFIER ASSIGNMENT namespace_or_type_name SEMICOLON
            {
            match(input,USING,FOLLOW_USING_in_using_alias_directive4883); if (state.failed) return ;

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_using_alias_directive4885); if (state.failed) return ;

            match(input,ASSIGNMENT,FOLLOW_ASSIGNMENT_in_using_alias_directive4887); if (state.failed) return ;

            pushFollow(FOLLOW_namespace_or_type_name_in_using_alias_directive4889);
            namespace_or_type_name();

            state._fsp--;
            if (state.failed) return ;

            match(input,SEMICOLON,FOLLOW_SEMICOLON_in_using_alias_directive4891); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "using_alias_directive"



    // $ANTLR start "using_namespace_directive"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1118:1: using_namespace_directive : USING namespace_name SEMICOLON ;
    public final void using_namespace_directive() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1119:2: ( USING namespace_name SEMICOLON )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1119:4: USING namespace_name SEMICOLON
            {
            match(input,USING,FOLLOW_USING_in_using_namespace_directive4902); if (state.failed) return ;

            pushFollow(FOLLOW_namespace_name_in_using_namespace_directive4904);
            namespace_name();

            state._fsp--;
            if (state.failed) return ;

            match(input,SEMICOLON,FOLLOW_SEMICOLON_in_using_namespace_directive4906); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "using_namespace_directive"



    // $ANTLR start "namespace_member_declarations"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1121:1: namespace_member_declarations : ( namespace_member_declaration )+ ;
    public final void namespace_member_declarations() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1122:2: ( ( namespace_member_declaration )+ )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1122:4: ( namespace_member_declaration )+
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1122:4: ( namespace_member_declaration )+
            int cnt140=0;
            loop140:
            do {
                int alt140=2;
                int LA140_0 = input.LA(1);

                if ( (LA140_0==ABSTRACT||LA140_0==CLASS||LA140_0==DELEGATE||LA140_0==ENUM||LA140_0==EXTERN||LA140_0==IDENTIFIER||(LA140_0 >= INTERFACE && LA140_0 <= INTERNAL)||(LA140_0 >= NAMESPACE && LA140_0 <= NEW)||LA140_0==OPEN_BRACKET||LA140_0==OVERRIDE||(LA140_0 >= PRIVATE && LA140_0 <= PUBLIC)||LA140_0==READONLY||LA140_0==SEALED||LA140_0==STATIC||LA140_0==STRUCT||LA140_0==UNSAFE||LA140_0==VIRTUAL||LA140_0==VOLATILE) ) {
                    alt140=1;
                }


                switch (alt140) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1122:4: namespace_member_declaration
            	    {
            	    pushFollow(FOLLOW_namespace_member_declaration_in_namespace_member_declarations4917);
            	    namespace_member_declaration();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    if ( cnt140 >= 1 ) break loop140;
            	    if (state.backtracking>0) {state.failed=true; return ;}
                        EarlyExitException eee =
                            new EarlyExitException(140, input);
                        throw eee;
                }
                cnt140++;
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "namespace_member_declarations"



    // $ANTLR start "namespace_member_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1124:1: namespace_member_declaration : ( namespace_declaration | type_declaration );
    public final void namespace_member_declaration() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1125:2: ( namespace_declaration | type_declaration )
            int alt141=2;
            int LA141_0 = input.LA(1);

            if ( (LA141_0==NAMESPACE) ) {
                alt141=1;
            }
            else if ( (LA141_0==ABSTRACT||LA141_0==CLASS||LA141_0==DELEGATE||LA141_0==ENUM||LA141_0==EXTERN||LA141_0==IDENTIFIER||(LA141_0 >= INTERFACE && LA141_0 <= INTERNAL)||LA141_0==NEW||LA141_0==OPEN_BRACKET||LA141_0==OVERRIDE||(LA141_0 >= PRIVATE && LA141_0 <= PUBLIC)||LA141_0==READONLY||LA141_0==SEALED||LA141_0==STATIC||LA141_0==STRUCT||LA141_0==UNSAFE||LA141_0==VIRTUAL||LA141_0==VOLATILE) ) {
                alt141=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 141, 0, input);

                throw nvae;

            }
            switch (alt141) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1125:4: namespace_declaration
                    {
                    pushFollow(FOLLOW_namespace_declaration_in_namespace_member_declaration4929);
                    namespace_declaration();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1126:4: type_declaration
                    {
                    pushFollow(FOLLOW_type_declaration_in_namespace_member_declaration4934);
                    type_declaration();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "namespace_member_declaration"



    // $ANTLR start "type_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1137:1: type_declaration : ( attributes )? ( all_member_modifiers )? ( class_definition | struct_definition | interface_definition | enum_definition | delegate_definition ) ;
    public final void type_declaration() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1138:3: ( ( attributes )? ( all_member_modifiers )? ( class_definition | struct_definition | interface_definition | enum_definition | delegate_definition ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1138:5: ( attributes )? ( all_member_modifiers )? ( class_definition | struct_definition | interface_definition | enum_definition | delegate_definition )
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1138:5: ( attributes )?
            int alt142=2;
            int LA142_0 = input.LA(1);

            if ( (LA142_0==OPEN_BRACKET) ) {
                alt142=1;
            }
            switch (alt142) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1138:5: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_type_declaration4948);
                    attributes();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1138:17: ( all_member_modifiers )?
            int alt143=2;
            int LA143_0 = input.LA(1);

            if ( (LA143_0==ABSTRACT||LA143_0==EXTERN||LA143_0==IDENTIFIER||LA143_0==INTERNAL||LA143_0==NEW||LA143_0==OVERRIDE||(LA143_0 >= PRIVATE && LA143_0 <= PUBLIC)||LA143_0==READONLY||LA143_0==SEALED||LA143_0==STATIC||LA143_0==UNSAFE||LA143_0==VIRTUAL||LA143_0==VOLATILE) ) {
                alt143=1;
            }
            switch (alt143) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1138:17: all_member_modifiers
                    {
                    pushFollow(FOLLOW_all_member_modifiers_in_type_declaration4951);
                    all_member_modifiers();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1139:5: ( class_definition | struct_definition | interface_definition | enum_definition | delegate_definition )
            int alt144=5;
            switch ( input.LA(1) ) {
            case CLASS:
                {
                alt144=1;
                }
                break;
            case STRUCT:
                {
                alt144=2;
                }
                break;
            case INTERFACE:
                {
                alt144=3;
                }
                break;
            case ENUM:
                {
                alt144=4;
                }
                break;
            case DELEGATE:
                {
                alt144=5;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 144, 0, input);

                throw nvae;

            }

            switch (alt144) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1139:7: class_definition
                    {
                    pushFollow(FOLLOW_class_definition_in_type_declaration4960);
                    class_definition();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1140:7: struct_definition
                    {
                    pushFollow(FOLLOW_struct_definition_in_type_declaration4968);
                    struct_definition();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1141:7: interface_definition
                    {
                    pushFollow(FOLLOW_interface_definition_in_type_declaration4976);
                    interface_definition();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1142:7: enum_definition
                    {
                    pushFollow(FOLLOW_enum_definition_in_type_declaration4984);
                    enum_definition();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1143:7: delegate_definition
                    {
                    pushFollow(FOLLOW_delegate_definition_in_type_declaration4992);
                    delegate_definition();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "type_declaration"



    // $ANTLR start "qualified_alias_member"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1147:1: qualified_alias_member : IDENTIFIER DOUBLE_COLON IDENTIFIER type_argument_list_opt ;
    public final void qualified_alias_member() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1148:2: ( IDENTIFIER DOUBLE_COLON IDENTIFIER type_argument_list_opt )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1148:4: IDENTIFIER DOUBLE_COLON IDENTIFIER type_argument_list_opt
            {
            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_qualified_alias_member5012); if (state.failed) return ;

            match(input,DOUBLE_COLON,FOLLOW_DOUBLE_COLON_in_qualified_alias_member5014); if (state.failed) return ;

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_qualified_alias_member5016); if (state.failed) return ;

            pushFollow(FOLLOW_type_argument_list_opt_in_qualified_alias_member5018);
            type_argument_list_opt();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "qualified_alias_member"



    // $ANTLR start "class_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1153:1: class_declaration : ( attributes )? ( class_modifiers )? ( partial_contextual_keyword )? CLASS IDENTIFIER ( type_parameter_list )? ( class_base )? ( type_parameter_constraints_clauses )? class_body ( SEMICOLON )? ;
    public final void class_declaration() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1154:2: ( ( attributes )? ( class_modifiers )? ( partial_contextual_keyword )? CLASS IDENTIFIER ( type_parameter_list )? ( class_base )? ( type_parameter_constraints_clauses )? class_body ( SEMICOLON )? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1154:4: ( attributes )? ( class_modifiers )? ( partial_contextual_keyword )? CLASS IDENTIFIER ( type_parameter_list )? ( class_base )? ( type_parameter_constraints_clauses )? class_body ( SEMICOLON )?
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1154:4: ( attributes )?
            int alt145=2;
            int LA145_0 = input.LA(1);

            if ( (LA145_0==OPEN_BRACKET) ) {
                alt145=1;
            }
            switch (alt145) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1154:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_class_declaration5032);
                    attributes();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1154:16: ( class_modifiers )?
            int alt146=2;
            int LA146_0 = input.LA(1);

            if ( (LA146_0==ABSTRACT||LA146_0==INTERNAL||LA146_0==NEW||(LA146_0 >= PRIVATE && LA146_0 <= PUBLIC)||LA146_0==SEALED||LA146_0==STATIC||LA146_0==UNSAFE) ) {
                alt146=1;
            }
            switch (alt146) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1154:16: class_modifiers
                    {
                    pushFollow(FOLLOW_class_modifiers_in_class_declaration5035);
                    class_modifiers();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1154:33: ( partial_contextual_keyword )?
            int alt147=2;
            int LA147_0 = input.LA(1);

            if ( (LA147_0==IDENTIFIER) ) {
                alt147=1;
            }
            switch (alt147) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1154:33: partial_contextual_keyword
                    {
                    pushFollow(FOLLOW_partial_contextual_keyword_in_class_declaration5038);
                    partial_contextual_keyword();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,CLASS,FOLLOW_CLASS_in_class_declaration5041); if (state.failed) return ;

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_class_declaration5043); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1154:78: ( type_parameter_list )?
            int alt148=2;
            int LA148_0 = input.LA(1);

            if ( (LA148_0==LT) ) {
                alt148=1;
            }
            switch (alt148) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1154:78: type_parameter_list
                    {
                    pushFollow(FOLLOW_type_parameter_list_in_class_declaration5045);
                    type_parameter_list();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1155:6: ( class_base )?
            int alt149=2;
            int LA149_0 = input.LA(1);

            if ( (LA149_0==COLON) ) {
                alt149=1;
            }
            switch (alt149) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1155:6: class_base
                    {
                    pushFollow(FOLLOW_class_base_in_class_declaration5053);
                    class_base();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1155:18: ( type_parameter_constraints_clauses )?
            int alt150=2;
            int LA150_0 = input.LA(1);

            if ( (LA150_0==IDENTIFIER) ) {
                alt150=1;
            }
            switch (alt150) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1155:18: type_parameter_constraints_clauses
                    {
                    pushFollow(FOLLOW_type_parameter_constraints_clauses_in_class_declaration5056);
                    type_parameter_constraints_clauses();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            pushFollow(FOLLOW_class_body_in_class_declaration5059);
            class_body();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1155:65: ( SEMICOLON )?
            int alt151=2;
            int LA151_0 = input.LA(1);

            if ( (LA151_0==SEMICOLON) ) {
                alt151=1;
            }
            switch (alt151) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1155:65: SEMICOLON
                    {
                    match(input,SEMICOLON,FOLLOW_SEMICOLON_in_class_declaration5061); if (state.failed) return ;

                    }
                    break;

            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "class_declaration"



    // $ANTLR start "class_modifiers"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1157:1: class_modifiers : class_modifier ( class_modifier )* ;
    public final void class_modifiers() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1158:2: ( class_modifier ( class_modifier )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1158:4: class_modifier ( class_modifier )*
            {
            pushFollow(FOLLOW_class_modifier_in_class_modifiers5073);
            class_modifier();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1158:19: ( class_modifier )*
            loop152:
            do {
                int alt152=2;
                int LA152_0 = input.LA(1);

                if ( (LA152_0==ABSTRACT||LA152_0==INTERNAL||LA152_0==NEW||(LA152_0 >= PRIVATE && LA152_0 <= PUBLIC)||LA152_0==SEALED||LA152_0==STATIC||LA152_0==UNSAFE) ) {
                    alt152=1;
                }


                switch (alt152) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1158:21: class_modifier
            	    {
            	    pushFollow(FOLLOW_class_modifier_in_class_modifiers5077);
            	    class_modifier();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop152;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "class_modifiers"



    // $ANTLR start "class_modifier"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1160:1: class_modifier : ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | ABSTRACT | SEALED | STATIC | class_modifier_unsafe );
    public final void class_modifier() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1161:2: ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | ABSTRACT | SEALED | STATIC | class_modifier_unsafe )
            int alt153=9;
            switch ( input.LA(1) ) {
            case NEW:
                {
                alt153=1;
                }
                break;
            case PUBLIC:
                {
                alt153=2;
                }
                break;
            case PROTECTED:
                {
                alt153=3;
                }
                break;
            case INTERNAL:
                {
                alt153=4;
                }
                break;
            case PRIVATE:
                {
                alt153=5;
                }
                break;
            case ABSTRACT:
                {
                alt153=6;
                }
                break;
            case SEALED:
                {
                alt153=7;
                }
                break;
            case STATIC:
                {
                alt153=8;
                }
                break;
            case UNSAFE:
                {
                alt153=9;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 153, 0, input);

                throw nvae;

            }

            switch (alt153) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1161:4: NEW
                    {
                    match(input,NEW,FOLLOW_NEW_in_class_modifier5091); if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1162:4: PUBLIC
                    {
                    match(input,PUBLIC,FOLLOW_PUBLIC_in_class_modifier5096); if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1163:4: PROTECTED
                    {
                    match(input,PROTECTED,FOLLOW_PROTECTED_in_class_modifier5101); if (state.failed) return ;

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1164:4: INTERNAL
                    {
                    match(input,INTERNAL,FOLLOW_INTERNAL_in_class_modifier5106); if (state.failed) return ;

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1165:4: PRIVATE
                    {
                    match(input,PRIVATE,FOLLOW_PRIVATE_in_class_modifier5111); if (state.failed) return ;

                    }
                    break;
                case 6 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1166:4: ABSTRACT
                    {
                    match(input,ABSTRACT,FOLLOW_ABSTRACT_in_class_modifier5116); if (state.failed) return ;

                    }
                    break;
                case 7 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1167:4: SEALED
                    {
                    match(input,SEALED,FOLLOW_SEALED_in_class_modifier5121); if (state.failed) return ;

                    }
                    break;
                case 8 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1168:4: STATIC
                    {
                    match(input,STATIC,FOLLOW_STATIC_in_class_modifier5126); if (state.failed) return ;

                    }
                    break;
                case 9 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1169:4: class_modifier_unsafe
                    {
                    pushFollow(FOLLOW_class_modifier_unsafe_in_class_modifier5131);
                    class_modifier_unsafe();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "class_modifier"



    // $ANTLR start "type_parameter_list"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1171:1: type_parameter_list : LT type_parameters GT ;
    public final void type_parameter_list() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1172:2: ( LT type_parameters GT )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1172:4: LT type_parameters GT
            {
            match(input,LT,FOLLOW_LT_in_type_parameter_list5142); if (state.failed) return ;

            pushFollow(FOLLOW_type_parameters_in_type_parameter_list5144);
            type_parameters();

            state._fsp--;
            if (state.failed) return ;

            match(input,GT,FOLLOW_GT_in_type_parameter_list5146); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "type_parameter_list"



    // $ANTLR start "type_parameters"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1174:1: type_parameters : ( attributes )? type_parameter ( COMMA ( attributes )? type_parameter )* ;
    public final void type_parameters() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1175:2: ( ( attributes )? type_parameter ( COMMA ( attributes )? type_parameter )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1175:4: ( attributes )? type_parameter ( COMMA ( attributes )? type_parameter )*
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1175:4: ( attributes )?
            int alt154=2;
            int LA154_0 = input.LA(1);

            if ( (LA154_0==OPEN_BRACKET) ) {
                alt154=1;
            }
            switch (alt154) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1175:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_type_parameters5157);
                    attributes();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            pushFollow(FOLLOW_type_parameter_in_type_parameters5160);
            type_parameter();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1175:31: ( COMMA ( attributes )? type_parameter )*
            loop156:
            do {
                int alt156=2;
                int LA156_0 = input.LA(1);

                if ( (LA156_0==COMMA) ) {
                    alt156=1;
                }


                switch (alt156) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1175:33: COMMA ( attributes )? type_parameter
            	    {
            	    match(input,COMMA,FOLLOW_COMMA_in_type_parameters5164); if (state.failed) return ;

            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1175:40: ( attributes )?
            	    int alt155=2;
            	    int LA155_0 = input.LA(1);

            	    if ( (LA155_0==OPEN_BRACKET) ) {
            	        alt155=1;
            	    }
            	    switch (alt155) {
            	        case 1 :
            	            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1175:40: attributes
            	            {
            	            pushFollow(FOLLOW_attributes_in_type_parameters5167);
            	            attributes();

            	            state._fsp--;
            	            if (state.failed) return ;

            	            }
            	            break;

            	    }


            	    pushFollow(FOLLOW_type_parameter_in_type_parameters5171);
            	    type_parameter();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop156;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "type_parameters"



    // $ANTLR start "type_parameter"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1178:1: type_parameter : IDENTIFIER ;
    public final void type_parameter() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1179:2: ( IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1179:4: IDENTIFIER
            {
            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_type_parameter5187); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "type_parameter"



    // $ANTLR start "class_base"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1189:1: class_base : COLON class_type ( COMMA interface_type )* ;
    public final void class_base() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1190:3: ( COLON class_type ( COMMA interface_type )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1190:5: COLON class_type ( COMMA interface_type )*
            {
            match(input,COLON,FOLLOW_COLON_in_class_base5202); if (state.failed) return ;

            pushFollow(FOLLOW_class_type_in_class_base5204);
            class_type();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1190:22: ( COMMA interface_type )*
            loop157:
            do {
                int alt157=2;
                int LA157_0 = input.LA(1);

                if ( (LA157_0==COMMA) ) {
                    alt157=1;
                }


                switch (alt157) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1190:24: COMMA interface_type
            	    {
            	    match(input,COMMA,FOLLOW_COMMA_in_class_base5208); if (state.failed) return ;

            	    pushFollow(FOLLOW_interface_type_in_class_base5211);
            	    interface_type();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop157;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "class_base"



    // $ANTLR start "interface_type_list"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1192:1: interface_type_list : interface_type ( COMMA interface_type )* ;
    public final void interface_type_list() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1193:2: ( interface_type ( COMMA interface_type )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1193:4: interface_type ( COMMA interface_type )*
            {
            pushFollow(FOLLOW_interface_type_in_interface_type_list5226);
            interface_type();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1193:19: ( COMMA interface_type )*
            loop158:
            do {
                int alt158=2;
                int LA158_0 = input.LA(1);

                if ( (LA158_0==COMMA) ) {
                    alt158=1;
                }


                switch (alt158) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1193:21: COMMA interface_type
            	    {
            	    match(input,COMMA,FOLLOW_COMMA_in_interface_type_list5230); if (state.failed) return ;

            	    pushFollow(FOLLOW_interface_type_in_interface_type_list5233);
            	    interface_type();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop158;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "interface_type_list"



    // $ANTLR start "type_parameter_constraints_clauses"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1195:1: type_parameter_constraints_clauses : type_parameter_constraints_clause ( type_parameter_constraints_clause )* ;
    public final void type_parameter_constraints_clauses() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1196:2: ( type_parameter_constraints_clause ( type_parameter_constraints_clause )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1196:4: type_parameter_constraints_clause ( type_parameter_constraints_clause )*
            {
            pushFollow(FOLLOW_type_parameter_constraints_clause_in_type_parameter_constraints_clauses5247);
            type_parameter_constraints_clause();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1196:38: ( type_parameter_constraints_clause )*
            loop159:
            do {
                int alt159=2;
                int LA159_0 = input.LA(1);

                if ( (LA159_0==IDENTIFIER) ) {
                    alt159=1;
                }


                switch (alt159) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1196:40: type_parameter_constraints_clause
            	    {
            	    pushFollow(FOLLOW_type_parameter_constraints_clause_in_type_parameter_constraints_clauses5251);
            	    type_parameter_constraints_clause();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop159;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "type_parameter_constraints_clauses"



    // $ANTLR start "type_parameter_constraints_clause"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1198:1: type_parameter_constraints_clause : where_contextual_keyword type_parameter COLON type_parameter_constraints ;
    public final void type_parameter_constraints_clause() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1199:2: ( where_contextual_keyword type_parameter COLON type_parameter_constraints )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1199:4: where_contextual_keyword type_parameter COLON type_parameter_constraints
            {
            pushFollow(FOLLOW_where_contextual_keyword_in_type_parameter_constraints_clause5265);
            where_contextual_keyword();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_type_parameter_in_type_parameter_constraints_clause5267);
            type_parameter();

            state._fsp--;
            if (state.failed) return ;

            match(input,COLON,FOLLOW_COLON_in_type_parameter_constraints_clause5269); if (state.failed) return ;

            pushFollow(FOLLOW_type_parameter_constraints_in_type_parameter_constraints_clause5271);
            type_parameter_constraints();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "type_parameter_constraints_clause"



    // $ANTLR start "type_parameter_constraints"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1212:1: type_parameter_constraints : ( constructor_constraint | primary_constraint ( COMMA secondary_constraints )? ( COMMA constructor_constraint )? );
    public final void type_parameter_constraints() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1213:3: ( constructor_constraint | primary_constraint ( COMMA secondary_constraints )? ( COMMA constructor_constraint )? )
            int alt162=2;
            int LA162_0 = input.LA(1);

            if ( (LA162_0==NEW) ) {
                alt162=1;
            }
            else if ( (LA162_0==CLASS||LA162_0==IDENTIFIER||LA162_0==OBJECT||LA162_0==STRING||LA162_0==STRUCT) ) {
                alt162=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 162, 0, input);

                throw nvae;

            }
            switch (alt162) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1213:5: constructor_constraint
                    {
                    pushFollow(FOLLOW_constructor_constraint_in_type_parameter_constraints5285);
                    constructor_constraint();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1214:5: primary_constraint ( COMMA secondary_constraints )? ( COMMA constructor_constraint )?
                    {
                    pushFollow(FOLLOW_primary_constraint_in_type_parameter_constraints5291);
                    primary_constraint();

                    state._fsp--;
                    if (state.failed) return ;

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1214:24: ( COMMA secondary_constraints )?
                    int alt160=2;
                    int LA160_0 = input.LA(1);

                    if ( (LA160_0==COMMA) ) {
                        int LA160_1 = input.LA(2);

                        if ( (LA160_1==IDENTIFIER) ) {
                            alt160=1;
                        }
                    }
                    switch (alt160) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1214:25: COMMA secondary_constraints
                            {
                            match(input,COMMA,FOLLOW_COMMA_in_type_parameter_constraints5294); if (state.failed) return ;

                            pushFollow(FOLLOW_secondary_constraints_in_type_parameter_constraints5296);
                            secondary_constraints();

                            state._fsp--;
                            if (state.failed) return ;

                            }
                            break;

                    }


                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1214:55: ( COMMA constructor_constraint )?
                    int alt161=2;
                    int LA161_0 = input.LA(1);

                    if ( (LA161_0==COMMA) ) {
                        alt161=1;
                    }
                    switch (alt161) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1214:56: COMMA constructor_constraint
                            {
                            match(input,COMMA,FOLLOW_COMMA_in_type_parameter_constraints5301); if (state.failed) return ;

                            pushFollow(FOLLOW_constructor_constraint_in_type_parameter_constraints5303);
                            constructor_constraint();

                            state._fsp--;
                            if (state.failed) return ;

                            }
                            break;

                    }


                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "type_parameter_constraints"



    // $ANTLR start "primary_constraint"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1216:1: primary_constraint : ( class_type | CLASS | STRUCT );
    public final void primary_constraint() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1217:2: ( class_type | CLASS | STRUCT )
            int alt163=3;
            switch ( input.LA(1) ) {
            case IDENTIFIER:
            case OBJECT:
            case STRING:
                {
                alt163=1;
                }
                break;
            case CLASS:
                {
                alt163=2;
                }
                break;
            case STRUCT:
                {
                alt163=3;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 163, 0, input);

                throw nvae;

            }

            switch (alt163) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1217:4: class_type
                    {
                    pushFollow(FOLLOW_class_type_in_primary_constraint5317);
                    class_type();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1218:4: CLASS
                    {
                    match(input,CLASS,FOLLOW_CLASS_in_primary_constraint5322); if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1219:4: STRUCT
                    {
                    match(input,STRUCT,FOLLOW_STRUCT_in_primary_constraint5327); if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "primary_constraint"



    // $ANTLR start "secondary_constraints"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1230:1: secondary_constraints : interface_type ( COMMA interface_type )* ;
    public final void secondary_constraints() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1231:3: ( interface_type ( COMMA interface_type )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1231:5: interface_type ( COMMA interface_type )*
            {
            pushFollow(FOLLOW_interface_type_in_secondary_constraints5341);
            interface_type();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1231:20: ( COMMA interface_type )*
            loop164:
            do {
                int alt164=2;
                int LA164_0 = input.LA(1);

                if ( (LA164_0==COMMA) ) {
                    int LA164_1 = input.LA(2);

                    if ( (LA164_1==IDENTIFIER) ) {
                        alt164=1;
                    }


                }


                switch (alt164) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1231:21: COMMA interface_type
            	    {
            	    match(input,COMMA,FOLLOW_COMMA_in_secondary_constraints5344); if (state.failed) return ;

            	    pushFollow(FOLLOW_interface_type_in_secondary_constraints5346);
            	    interface_type();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop164;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "secondary_constraints"



    // $ANTLR start "constructor_constraint"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1233:1: constructor_constraint : NEW OPEN_PARENS CLOSE_PARENS ;
    public final void constructor_constraint() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1234:2: ( NEW OPEN_PARENS CLOSE_PARENS )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1234:4: NEW OPEN_PARENS CLOSE_PARENS
            {
            match(input,NEW,FOLLOW_NEW_in_constructor_constraint5360); if (state.failed) return ;

            match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_constructor_constraint5362); if (state.failed) return ;

            match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_constructor_constraint5364); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "constructor_constraint"



    // $ANTLR start "class_body"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1236:1: class_body : OPEN_BRACE ( class_member_declarations )? CLOSE_BRACE ;
    public final void class_body() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1237:2: ( OPEN_BRACE ( class_member_declarations )? CLOSE_BRACE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1237:4: OPEN_BRACE ( class_member_declarations )? CLOSE_BRACE
            {
            match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_class_body5375); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1237:15: ( class_member_declarations )?
            int alt165=2;
            int LA165_0 = input.LA(1);

            if ( (LA165_0==ABSTRACT||LA165_0==BOOL||LA165_0==BYTE||LA165_0==CHAR||LA165_0==CLASS||LA165_0==CONST||LA165_0==DECIMAL||LA165_0==DELEGATE||LA165_0==DOUBLE||(LA165_0 >= ENUM && LA165_0 <= EXTERN)||LA165_0==FLOAT||LA165_0==IDENTIFIER||LA165_0==IMPLICIT||LA165_0==INT||(LA165_0 >= INTERFACE && LA165_0 <= INTERNAL)||LA165_0==LONG||LA165_0==NEW||LA165_0==OBJECT||LA165_0==OPEN_BRACKET||LA165_0==OVERRIDE||(LA165_0 >= PRIVATE && LA165_0 <= PUBLIC)||LA165_0==READONLY||(LA165_0 >= SBYTE && LA165_0 <= SEALED)||LA165_0==SHORT||(LA165_0 >= STATIC && LA165_0 <= STRING)||LA165_0==STRUCT||LA165_0==TILDE||(LA165_0 >= UINT && LA165_0 <= ULONG)||(LA165_0 >= UNSAFE && LA165_0 <= USHORT)||(LA165_0 >= VIRTUAL && LA165_0 <= VOLATILE)) ) {
                alt165=1;
            }
            switch (alt165) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1237:15: class_member_declarations
                    {
                    pushFollow(FOLLOW_class_member_declarations_in_class_body5377);
                    class_member_declarations();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_class_body5380); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "class_body"



    // $ANTLR start "class_member_declarations"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1239:1: class_member_declarations : ( class_member_declaration )+ ;
    public final void class_member_declarations() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1240:2: ( ( class_member_declaration )+ )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1240:4: ( class_member_declaration )+
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1240:4: ( class_member_declaration )+
            int cnt166=0;
            loop166:
            do {
                int alt166=2;
                int LA166_0 = input.LA(1);

                if ( (LA166_0==ABSTRACT||LA166_0==BOOL||LA166_0==BYTE||LA166_0==CHAR||LA166_0==CLASS||LA166_0==CONST||LA166_0==DECIMAL||LA166_0==DELEGATE||LA166_0==DOUBLE||(LA166_0 >= ENUM && LA166_0 <= EXTERN)||LA166_0==FLOAT||LA166_0==IDENTIFIER||LA166_0==IMPLICIT||LA166_0==INT||(LA166_0 >= INTERFACE && LA166_0 <= INTERNAL)||LA166_0==LONG||LA166_0==NEW||LA166_0==OBJECT||LA166_0==OPEN_BRACKET||LA166_0==OVERRIDE||(LA166_0 >= PRIVATE && LA166_0 <= PUBLIC)||LA166_0==READONLY||(LA166_0 >= SBYTE && LA166_0 <= SEALED)||LA166_0==SHORT||(LA166_0 >= STATIC && LA166_0 <= STRING)||LA166_0==STRUCT||LA166_0==TILDE||(LA166_0 >= UINT && LA166_0 <= ULONG)||(LA166_0 >= UNSAFE && LA166_0 <= USHORT)||(LA166_0 >= VIRTUAL && LA166_0 <= VOLATILE)) ) {
                    alt166=1;
                }


                switch (alt166) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1240:4: class_member_declaration
            	    {
            	    pushFollow(FOLLOW_class_member_declaration_in_class_member_declarations5391);
            	    class_member_declaration();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    if ( cnt166 >= 1 ) break loop166;
            	    if (state.backtracking>0) {state.failed=true; return ;}
                        EarlyExitException eee =
                            new EarlyExitException(166, input);
                        throw eee;
                }
                cnt166++;
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "class_member_declarations"



    // $ANTLR start "class_member_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1257:1: class_member_declaration : ( attributes )? ( all_member_modifiers )? ( common_member_declaration | TILDE IDENTIFIER OPEN_PARENS CLOSE_PARENS destructor_body ) ;
    public final void class_member_declaration() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1258:3: ( ( attributes )? ( all_member_modifiers )? ( common_member_declaration | TILDE IDENTIFIER OPEN_PARENS CLOSE_PARENS destructor_body ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1258:5: ( attributes )? ( all_member_modifiers )? ( common_member_declaration | TILDE IDENTIFIER OPEN_PARENS CLOSE_PARENS destructor_body )
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1258:5: ( attributes )?
            int alt167=2;
            int LA167_0 = input.LA(1);

            if ( (LA167_0==OPEN_BRACKET) ) {
                alt167=1;
            }
            switch (alt167) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1258:5: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_class_member_declaration5406);
                    attributes();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1258:17: ( all_member_modifiers )?
            int alt168=2;
            int LA168_0 = input.LA(1);

            if ( (LA168_0==ABSTRACT||LA168_0==EXTERN||LA168_0==INTERNAL||LA168_0==NEW||LA168_0==OVERRIDE||(LA168_0 >= PRIVATE && LA168_0 <= PUBLIC)||LA168_0==READONLY||LA168_0==SEALED||LA168_0==STATIC||LA168_0==UNSAFE||LA168_0==VIRTUAL||LA168_0==VOLATILE) ) {
                alt168=1;
            }
            else if ( (LA168_0==IDENTIFIER) ) {
                int LA168_15 = input.LA(2);

                if ( ((input.LT(1).getText().equals("partial"))) ) {
                    alt168=1;
                }
            }
            switch (alt168) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1258:17: all_member_modifiers
                    {
                    pushFollow(FOLLOW_all_member_modifiers_in_class_member_declaration5409);
                    all_member_modifiers();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1259:4: ( common_member_declaration | TILDE IDENTIFIER OPEN_PARENS CLOSE_PARENS destructor_body )
            int alt169=2;
            int LA169_0 = input.LA(1);

            if ( (LA169_0==BOOL||LA169_0==BYTE||LA169_0==CHAR||LA169_0==CLASS||LA169_0==CONST||LA169_0==DECIMAL||LA169_0==DELEGATE||LA169_0==DOUBLE||(LA169_0 >= ENUM && LA169_0 <= EXPLICIT)||LA169_0==FLOAT||LA169_0==IDENTIFIER||LA169_0==IMPLICIT||LA169_0==INT||LA169_0==INTERFACE||LA169_0==LONG||LA169_0==OBJECT||LA169_0==SBYTE||LA169_0==SHORT||LA169_0==STRING||LA169_0==STRUCT||(LA169_0 >= UINT && LA169_0 <= ULONG)||LA169_0==USHORT||LA169_0==VOID) ) {
                alt169=1;
            }
            else if ( (LA169_0==TILDE) ) {
                alt169=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 169, 0, input);

                throw nvae;

            }
            switch (alt169) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1259:6: common_member_declaration
                    {
                    pushFollow(FOLLOW_common_member_declaration_in_class_member_declaration5417);
                    common_member_declaration();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1260:6: TILDE IDENTIFIER OPEN_PARENS CLOSE_PARENS destructor_body
                    {
                    match(input,TILDE,FOLLOW_TILDE_in_class_member_declaration5424); if (state.failed) return ;

                    match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_class_member_declaration5426); if (state.failed) return ;

                    match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_class_member_declaration5428); if (state.failed) return ;

                    match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_class_member_declaration5430); if (state.failed) return ;

                    pushFollow(FOLLOW_destructor_body_in_class_member_declaration5432);
                    destructor_body();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "class_member_declaration"



    // $ANTLR start "all_member_modifiers"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1265:1: all_member_modifiers : (m= all_member_modifier )+ ;
    public final void all_member_modifiers() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1266:3: ( (m= all_member_modifier )+ )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1266:5: (m= all_member_modifier )+
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1266:5: (m= all_member_modifier )+
            int cnt170=0;
            loop170:
            do {
                int alt170=2;
                int LA170_0 = input.LA(1);

                if ( (LA170_0==IDENTIFIER) ) {
                    int LA170_11 = input.LA(2);

                    if ( ((input.LT(1).getText().equals("partial"))) ) {
                        alt170=1;
                    }


                }
                else if ( (LA170_0==ABSTRACT||LA170_0==EXTERN||LA170_0==INTERNAL||LA170_0==NEW||LA170_0==OVERRIDE||(LA170_0 >= PRIVATE && LA170_0 <= PUBLIC)||LA170_0==READONLY||LA170_0==SEALED||LA170_0==STATIC||LA170_0==UNSAFE||LA170_0==VIRTUAL||LA170_0==VOLATILE) ) {
                    alt170=1;
                }


                switch (alt170) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1266:6: m= all_member_modifier
            	    {
            	    pushFollow(FOLLOW_all_member_modifier_in_all_member_modifiers5454);
            	    all_member_modifier();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    if ( cnt170 >= 1 ) break loop170;
            	    if (state.backtracking>0) {state.failed=true; return ;}
                        EarlyExitException eee =
                            new EarlyExitException(170, input);
                        throw eee;
                }
                cnt170++;
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "all_member_modifiers"



    // $ANTLR start "all_member_modifier"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1268:1: all_member_modifier : ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | READONLY | VOLATILE | VIRTUAL | SEALED | OVERRIDE | ABSTRACT | STATIC | UNSAFE | EXTERN | partial_contextual_keyword );
    public final void all_member_modifier() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1269:3: ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | READONLY | VOLATILE | VIRTUAL | SEALED | OVERRIDE | ABSTRACT | STATIC | UNSAFE | EXTERN | partial_contextual_keyword )
            int alt171=15;
            switch ( input.LA(1) ) {
            case NEW:
                {
                alt171=1;
                }
                break;
            case PUBLIC:
                {
                alt171=2;
                }
                break;
            case PROTECTED:
                {
                alt171=3;
                }
                break;
            case INTERNAL:
                {
                alt171=4;
                }
                break;
            case PRIVATE:
                {
                alt171=5;
                }
                break;
            case READONLY:
                {
                alt171=6;
                }
                break;
            case VOLATILE:
                {
                alt171=7;
                }
                break;
            case VIRTUAL:
                {
                alt171=8;
                }
                break;
            case SEALED:
                {
                alt171=9;
                }
                break;
            case OVERRIDE:
                {
                alt171=10;
                }
                break;
            case ABSTRACT:
                {
                alt171=11;
                }
                break;
            case STATIC:
                {
                alt171=12;
                }
                break;
            case UNSAFE:
                {
                alt171=13;
                }
                break;
            case EXTERN:
                {
                alt171=14;
                }
                break;
            case IDENTIFIER:
                {
                alt171=15;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 171, 0, input);

                throw nvae;

            }

            switch (alt171) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1269:5: NEW
                    {
                    match(input,NEW,FOLLOW_NEW_in_all_member_modifier5468); if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1270:5: PUBLIC
                    {
                    match(input,PUBLIC,FOLLOW_PUBLIC_in_all_member_modifier5474); if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1271:5: PROTECTED
                    {
                    match(input,PROTECTED,FOLLOW_PROTECTED_in_all_member_modifier5480); if (state.failed) return ;

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1272:5: INTERNAL
                    {
                    match(input,INTERNAL,FOLLOW_INTERNAL_in_all_member_modifier5486); if (state.failed) return ;

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1273:5: PRIVATE
                    {
                    match(input,PRIVATE,FOLLOW_PRIVATE_in_all_member_modifier5492); if (state.failed) return ;

                    }
                    break;
                case 6 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1274:5: READONLY
                    {
                    match(input,READONLY,FOLLOW_READONLY_in_all_member_modifier5498); if (state.failed) return ;

                    }
                    break;
                case 7 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1275:5: VOLATILE
                    {
                    match(input,VOLATILE,FOLLOW_VOLATILE_in_all_member_modifier5504); if (state.failed) return ;

                    }
                    break;
                case 8 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1276:5: VIRTUAL
                    {
                    match(input,VIRTUAL,FOLLOW_VIRTUAL_in_all_member_modifier5510); if (state.failed) return ;

                    }
                    break;
                case 9 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1277:5: SEALED
                    {
                    match(input,SEALED,FOLLOW_SEALED_in_all_member_modifier5516); if (state.failed) return ;

                    }
                    break;
                case 10 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1278:5: OVERRIDE
                    {
                    match(input,OVERRIDE,FOLLOW_OVERRIDE_in_all_member_modifier5522); if (state.failed) return ;

                    }
                    break;
                case 11 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1279:5: ABSTRACT
                    {
                    match(input,ABSTRACT,FOLLOW_ABSTRACT_in_all_member_modifier5528); if (state.failed) return ;

                    }
                    break;
                case 12 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1280:5: STATIC
                    {
                    match(input,STATIC,FOLLOW_STATIC_in_all_member_modifier5534); if (state.failed) return ;

                    }
                    break;
                case 13 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1281:5: UNSAFE
                    {
                    match(input,UNSAFE,FOLLOW_UNSAFE_in_all_member_modifier5540); if (state.failed) return ;

                    }
                    break;
                case 14 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1282:5: EXTERN
                    {
                    match(input,EXTERN,FOLLOW_EXTERN_in_all_member_modifier5546); if (state.failed) return ;

                    }
                    break;
                case 15 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1283:5: partial_contextual_keyword
                    {
                    pushFollow(FOLLOW_partial_contextual_keyword_in_all_member_modifier5552);
                    partial_contextual_keyword();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "all_member_modifier"



    // $ANTLR start "common_member_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1300:1: common_member_declaration : ( constant_declaration2 | typed_member_declaration | EVENT type ( variable_declarators SEMICOLON | member_name OPEN_BRACE event_accessor_declarations CLOSE_BRACE ) | conversion_operator_declarator operator_body |cons= IDENTIFIER OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( constructor_initializer )? body | VOID method_definition | CLASS id= IDENTIFIER ( type_parameter_list )? ( class_base )? ( type_parameter_constraints_clauses )? class_body ( SEMICOLON )? | STRUCT IDENTIFIER ( type_parameter_list )? ( struct_interfaces )? ( type_parameter_constraints_clauses )? struct_body ( SEMICOLON )? | INTERFACE IDENTIFIER ( variant_type_parameter_list )? ( interface_base )? ( type_parameter_constraints_clauses )? interface_body ( SEMICOLON )? | ENUM IDENTIFIER ( enum_base )? enum_body ( SEMICOLON )? | DELEGATE return_type IDENTIFIER ( type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? SEMICOLON );
    public final void common_member_declaration() throws RecognitionException {
        Token cons=null;
        Token id=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1301:3: ( constant_declaration2 | typed_member_declaration | EVENT type ( variable_declarators SEMICOLON | member_name OPEN_BRACE event_accessor_declarations CLOSE_BRACE ) | conversion_operator_declarator operator_body |cons= IDENTIFIER OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( constructor_initializer )? body | VOID method_definition | CLASS id= IDENTIFIER ( type_parameter_list )? ( class_base )? ( type_parameter_constraints_clauses )? class_body ( SEMICOLON )? | STRUCT IDENTIFIER ( type_parameter_list )? ( struct_interfaces )? ( type_parameter_constraints_clauses )? struct_body ( SEMICOLON )? | INTERFACE IDENTIFIER ( variant_type_parameter_list )? ( interface_base )? ( type_parameter_constraints_clauses )? interface_body ( SEMICOLON )? | ENUM IDENTIFIER ( enum_base )? enum_body ( SEMICOLON )? | DELEGATE return_type IDENTIFIER ( type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? SEMICOLON )
            int alt192=11;
            switch ( input.LA(1) ) {
            case CONST:
                {
                alt192=1;
                }
                break;
            case BOOL:
            case BYTE:
            case CHAR:
            case DECIMAL:
            case DOUBLE:
            case FLOAT:
            case INT:
            case LONG:
            case OBJECT:
            case SBYTE:
            case SHORT:
            case STRING:
            case UINT:
            case ULONG:
            case USHORT:
                {
                alt192=2;
                }
                break;
            case IDENTIFIER:
                {
                int LA192_3 = input.LA(2);

                if ( (LA192_3==DOT||LA192_3==DOUBLE_COLON||LA192_3==IDENTIFIER||LA192_3==INTERR||LA192_3==LT||LA192_3==OPEN_BRACKET||LA192_3==OPERATOR||LA192_3==STAR||LA192_3==THIS) ) {
                    alt192=2;
                }
                else if ( (LA192_3==OPEN_PARENS) ) {
                    alt192=5;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 192, 3, input);

                    throw nvae;

                }
                }
                break;
            case VOID:
                {
                int LA192_4 = input.LA(2);

                if ( (LA192_4==STAR) ) {
                    alt192=2;
                }
                else if ( (LA192_4==IDENTIFIER) ) {
                    alt192=6;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 192, 4, input);

                    throw nvae;

                }
                }
                break;
            case EVENT:
                {
                alt192=3;
                }
                break;
            case EXPLICIT:
            case IMPLICIT:
                {
                alt192=4;
                }
                break;
            case CLASS:
                {
                alt192=7;
                }
                break;
            case STRUCT:
                {
                alt192=8;
                }
                break;
            case INTERFACE:
                {
                alt192=9;
                }
                break;
            case ENUM:
                {
                alt192=10;
                }
                break;
            case DELEGATE:
                {
                alt192=11;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 192, 0, input);

                throw nvae;

            }

            switch (alt192) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1301:5: constant_declaration2
                    {
                    pushFollow(FOLLOW_constant_declaration2_in_common_member_declaration5569);
                    constant_declaration2();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1302:5: typed_member_declaration
                    {
                    pushFollow(FOLLOW_typed_member_declaration_in_common_member_declaration5575);
                    typed_member_declaration();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1303:5: EVENT type ( variable_declarators SEMICOLON | member_name OPEN_BRACE event_accessor_declarations CLOSE_BRACE )
                    {
                    match(input,EVENT,FOLLOW_EVENT_in_common_member_declaration5581); if (state.failed) return ;

                    pushFollow(FOLLOW_type_in_common_member_declaration5583);
                    type();

                    state._fsp--;
                    if (state.failed) return ;

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1303:16: ( variable_declarators SEMICOLON | member_name OPEN_BRACE event_accessor_declarations CLOSE_BRACE )
                    int alt172=2;
                    int LA172_0 = input.LA(1);

                    if ( (LA172_0==IDENTIFIER) ) {
                        int LA172_1 = input.LA(2);

                        if ( (LA172_1==ASSIGNMENT||LA172_1==COMMA||LA172_1==SEMICOLON) ) {
                            alt172=1;
                        }
                        else if ( (LA172_1==DOT||LA172_1==DOUBLE_COLON||LA172_1==LT||LA172_1==OPEN_BRACE) ) {
                            alt172=2;
                        }
                        else {
                            if (state.backtracking>0) {state.failed=true; return ;}
                            NoViableAltException nvae =
                                new NoViableAltException("", 172, 1, input);

                            throw nvae;

                        }
                    }
                    else {
                        if (state.backtracking>0) {state.failed=true; return ;}
                        NoViableAltException nvae =
                            new NoViableAltException("", 172, 0, input);

                        throw nvae;

                    }
                    switch (alt172) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1303:18: variable_declarators SEMICOLON
                            {
                            pushFollow(FOLLOW_variable_declarators_in_common_member_declaration5587);
                            variable_declarators();

                            state._fsp--;
                            if (state.failed) return ;

                            match(input,SEMICOLON,FOLLOW_SEMICOLON_in_common_member_declaration5589); if (state.failed) return ;

                            }
                            break;
                        case 2 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1304:20: member_name OPEN_BRACE event_accessor_declarations CLOSE_BRACE
                            {
                            pushFollow(FOLLOW_member_name_in_common_member_declaration5610);
                            member_name();

                            state._fsp--;
                            if (state.failed) return ;

                            match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_common_member_declaration5612); if (state.failed) return ;

                            pushFollow(FOLLOW_event_accessor_declarations_in_common_member_declaration5614);
                            event_accessor_declarations();

                            state._fsp--;
                            if (state.failed) return ;

                            match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_common_member_declaration5616); if (state.failed) return ;

                            }
                            break;

                    }


                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1306:5: conversion_operator_declarator operator_body
                    {
                    pushFollow(FOLLOW_conversion_operator_declarator_in_common_member_declaration5641);
                    conversion_operator_declarator();

                    state._fsp--;
                    if (state.failed) return ;

                    pushFollow(FOLLOW_operator_body_in_common_member_declaration5643);
                    operator_body();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1308:5: cons= IDENTIFIER OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( constructor_initializer )? body
                    {
                    cons=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_common_member_declaration5654); if (state.failed) return ;

                    match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_common_member_declaration5656); if (state.failed) return ;

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1308:33: ( formal_parameter_list )?
                    int alt173=2;
                    int LA173_0 = input.LA(1);

                    if ( (LA173_0==BOOL||LA173_0==BYTE||LA173_0==CHAR||LA173_0==DECIMAL||LA173_0==DOUBLE||LA173_0==FLOAT||LA173_0==IDENTIFIER||LA173_0==INT||LA173_0==LONG||LA173_0==OBJECT||LA173_0==OPEN_BRACKET||LA173_0==OUT||LA173_0==PARAMS||LA173_0==REF||LA173_0==SBYTE||LA173_0==SHORT||LA173_0==STRING||LA173_0==THIS||(LA173_0 >= UINT && LA173_0 <= ULONG)||LA173_0==USHORT||LA173_0==VOID) ) {
                        alt173=1;
                    }
                    switch (alt173) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1308:33: formal_parameter_list
                            {
                            pushFollow(FOLLOW_formal_parameter_list_in_common_member_declaration5658);
                            formal_parameter_list();

                            state._fsp--;
                            if (state.failed) return ;

                            }
                            break;

                    }


                    match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_common_member_declaration5661); if (state.failed) return ;

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1308:69: ( constructor_initializer )?
                    int alt174=2;
                    int LA174_0 = input.LA(1);

                    if ( (LA174_0==COLON) ) {
                        alt174=1;
                    }
                    switch (alt174) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1308:69: constructor_initializer
                            {
                            pushFollow(FOLLOW_constructor_initializer_in_common_member_declaration5663);
                            constructor_initializer();

                            state._fsp--;
                            if (state.failed) return ;

                            }
                            break;

                    }


                    pushFollow(FOLLOW_body_in_common_member_declaration5666);
                    body();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 6 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1309:5: VOID method_definition
                    {
                    match(input,VOID,FOLLOW_VOID_in_common_member_declaration5672); if (state.failed) return ;

                    pushFollow(FOLLOW_method_definition_in_common_member_declaration5674);
                    method_definition();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 7 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1310:5: CLASS id= IDENTIFIER ( type_parameter_list )? ( class_base )? ( type_parameter_constraints_clauses )? class_body ( SEMICOLON )?
                    {
                    match(input,CLASS,FOLLOW_CLASS_in_common_member_declaration5680); if (state.failed) return ;

                    id=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_common_member_declaration5684); if (state.failed) return ;

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1310:25: ( type_parameter_list )?
                    int alt175=2;
                    int LA175_0 = input.LA(1);

                    if ( (LA175_0==LT) ) {
                        alt175=1;
                    }
                    switch (alt175) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1310:25: type_parameter_list
                            {
                            pushFollow(FOLLOW_type_parameter_list_in_common_member_declaration5686);
                            type_parameter_list();

                            state._fsp--;
                            if (state.failed) return ;

                            }
                            break;

                    }


                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1310:46: ( class_base )?
                    int alt176=2;
                    int LA176_0 = input.LA(1);

                    if ( (LA176_0==COLON) ) {
                        alt176=1;
                    }
                    switch (alt176) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1310:46: class_base
                            {
                            pushFollow(FOLLOW_class_base_in_common_member_declaration5689);
                            class_base();

                            state._fsp--;
                            if (state.failed) return ;

                            }
                            break;

                    }


                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1310:58: ( type_parameter_constraints_clauses )?
                    int alt177=2;
                    int LA177_0 = input.LA(1);

                    if ( (LA177_0==IDENTIFIER) ) {
                        alt177=1;
                    }
                    switch (alt177) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1310:58: type_parameter_constraints_clauses
                            {
                            pushFollow(FOLLOW_type_parameter_constraints_clauses_in_common_member_declaration5692);
                            type_parameter_constraints_clauses();

                            state._fsp--;
                            if (state.failed) return ;

                            }
                            break;

                    }


                    pushFollow(FOLLOW_class_body_in_common_member_declaration5695);
                    class_body();

                    state._fsp--;
                    if (state.failed) return ;

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1310:105: ( SEMICOLON )?
                    int alt178=2;
                    int LA178_0 = input.LA(1);

                    if ( (LA178_0==SEMICOLON) ) {
                        alt178=1;
                    }
                    switch (alt178) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1310:105: SEMICOLON
                            {
                            match(input,SEMICOLON,FOLLOW_SEMICOLON_in_common_member_declaration5697); if (state.failed) return ;

                            }
                            break;

                    }


                    }
                    break;
                case 8 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1311:5: STRUCT IDENTIFIER ( type_parameter_list )? ( struct_interfaces )? ( type_parameter_constraints_clauses )? struct_body ( SEMICOLON )?
                    {
                    match(input,STRUCT,FOLLOW_STRUCT_in_common_member_declaration5704); if (state.failed) return ;

                    match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_common_member_declaration5706); if (state.failed) return ;

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1311:23: ( type_parameter_list )?
                    int alt179=2;
                    int LA179_0 = input.LA(1);

                    if ( (LA179_0==LT) ) {
                        alt179=1;
                    }
                    switch (alt179) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1311:23: type_parameter_list
                            {
                            pushFollow(FOLLOW_type_parameter_list_in_common_member_declaration5708);
                            type_parameter_list();

                            state._fsp--;
                            if (state.failed) return ;

                            }
                            break;

                    }


                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1311:44: ( struct_interfaces )?
                    int alt180=2;
                    int LA180_0 = input.LA(1);

                    if ( (LA180_0==COLON) ) {
                        alt180=1;
                    }
                    switch (alt180) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1311:44: struct_interfaces
                            {
                            pushFollow(FOLLOW_struct_interfaces_in_common_member_declaration5711);
                            struct_interfaces();

                            state._fsp--;
                            if (state.failed) return ;

                            }
                            break;

                    }


                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1311:63: ( type_parameter_constraints_clauses )?
                    int alt181=2;
                    int LA181_0 = input.LA(1);

                    if ( (LA181_0==IDENTIFIER) ) {
                        alt181=1;
                    }
                    switch (alt181) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1311:63: type_parameter_constraints_clauses
                            {
                            pushFollow(FOLLOW_type_parameter_constraints_clauses_in_common_member_declaration5714);
                            type_parameter_constraints_clauses();

                            state._fsp--;
                            if (state.failed) return ;

                            }
                            break;

                    }


                    pushFollow(FOLLOW_struct_body_in_common_member_declaration5717);
                    struct_body();

                    state._fsp--;
                    if (state.failed) return ;

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1311:111: ( SEMICOLON )?
                    int alt182=2;
                    int LA182_0 = input.LA(1);

                    if ( (LA182_0==SEMICOLON) ) {
                        alt182=1;
                    }
                    switch (alt182) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1311:111: SEMICOLON
                            {
                            match(input,SEMICOLON,FOLLOW_SEMICOLON_in_common_member_declaration5719); if (state.failed) return ;

                            }
                            break;

                    }


                    }
                    break;
                case 9 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1312:5: INTERFACE IDENTIFIER ( variant_type_parameter_list )? ( interface_base )? ( type_parameter_constraints_clauses )? interface_body ( SEMICOLON )?
                    {
                    match(input,INTERFACE,FOLLOW_INTERFACE_in_common_member_declaration5726); if (state.failed) return ;

                    match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_common_member_declaration5728); if (state.failed) return ;

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1312:26: ( variant_type_parameter_list )?
                    int alt183=2;
                    int LA183_0 = input.LA(1);

                    if ( (LA183_0==LT) ) {
                        alt183=1;
                    }
                    switch (alt183) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1312:26: variant_type_parameter_list
                            {
                            pushFollow(FOLLOW_variant_type_parameter_list_in_common_member_declaration5730);
                            variant_type_parameter_list();

                            state._fsp--;
                            if (state.failed) return ;

                            }
                            break;

                    }


                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1312:55: ( interface_base )?
                    int alt184=2;
                    int LA184_0 = input.LA(1);

                    if ( (LA184_0==COLON) ) {
                        alt184=1;
                    }
                    switch (alt184) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1312:55: interface_base
                            {
                            pushFollow(FOLLOW_interface_base_in_common_member_declaration5733);
                            interface_base();

                            state._fsp--;
                            if (state.failed) return ;

                            }
                            break;

                    }


                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1312:71: ( type_parameter_constraints_clauses )?
                    int alt185=2;
                    int LA185_0 = input.LA(1);

                    if ( (LA185_0==IDENTIFIER) ) {
                        alt185=1;
                    }
                    switch (alt185) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1312:71: type_parameter_constraints_clauses
                            {
                            pushFollow(FOLLOW_type_parameter_constraints_clauses_in_common_member_declaration5736);
                            type_parameter_constraints_clauses();

                            state._fsp--;
                            if (state.failed) return ;

                            }
                            break;

                    }


                    pushFollow(FOLLOW_interface_body_in_common_member_declaration5739);
                    interface_body();

                    state._fsp--;
                    if (state.failed) return ;

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1312:122: ( SEMICOLON )?
                    int alt186=2;
                    int LA186_0 = input.LA(1);

                    if ( (LA186_0==SEMICOLON) ) {
                        alt186=1;
                    }
                    switch (alt186) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1312:122: SEMICOLON
                            {
                            match(input,SEMICOLON,FOLLOW_SEMICOLON_in_common_member_declaration5741); if (state.failed) return ;

                            }
                            break;

                    }


                    }
                    break;
                case 10 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1313:5: ENUM IDENTIFIER ( enum_base )? enum_body ( SEMICOLON )?
                    {
                    match(input,ENUM,FOLLOW_ENUM_in_common_member_declaration5748); if (state.failed) return ;

                    match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_common_member_declaration5750); if (state.failed) return ;

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1313:21: ( enum_base )?
                    int alt187=2;
                    int LA187_0 = input.LA(1);

                    if ( (LA187_0==COLON) ) {
                        alt187=1;
                    }
                    switch (alt187) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1313:21: enum_base
                            {
                            pushFollow(FOLLOW_enum_base_in_common_member_declaration5752);
                            enum_base();

                            state._fsp--;
                            if (state.failed) return ;

                            }
                            break;

                    }


                    pushFollow(FOLLOW_enum_body_in_common_member_declaration5755);
                    enum_body();

                    state._fsp--;
                    if (state.failed) return ;

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1313:42: ( SEMICOLON )?
                    int alt188=2;
                    int LA188_0 = input.LA(1);

                    if ( (LA188_0==SEMICOLON) ) {
                        alt188=1;
                    }
                    switch (alt188) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1313:42: SEMICOLON
                            {
                            match(input,SEMICOLON,FOLLOW_SEMICOLON_in_common_member_declaration5757); if (state.failed) return ;

                            }
                            break;

                    }


                    }
                    break;
                case 11 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1314:5: DELEGATE return_type IDENTIFIER ( type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? SEMICOLON
                    {
                    match(input,DELEGATE,FOLLOW_DELEGATE_in_common_member_declaration5764); if (state.failed) return ;

                    pushFollow(FOLLOW_return_type_in_common_member_declaration5766);
                    return_type();

                    state._fsp--;
                    if (state.failed) return ;

                    match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_common_member_declaration5768); if (state.failed) return ;

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1314:37: ( type_parameter_list )?
                    int alt189=2;
                    int LA189_0 = input.LA(1);

                    if ( (LA189_0==LT) ) {
                        alt189=1;
                    }
                    switch (alt189) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1314:37: type_parameter_list
                            {
                            pushFollow(FOLLOW_type_parameter_list_in_common_member_declaration5770);
                            type_parameter_list();

                            state._fsp--;
                            if (state.failed) return ;

                            }
                            break;

                    }


                    match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_common_member_declaration5773); if (state.failed) return ;

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1314:70: ( formal_parameter_list )?
                    int alt190=2;
                    int LA190_0 = input.LA(1);

                    if ( (LA190_0==BOOL||LA190_0==BYTE||LA190_0==CHAR||LA190_0==DECIMAL||LA190_0==DOUBLE||LA190_0==FLOAT||LA190_0==IDENTIFIER||LA190_0==INT||LA190_0==LONG||LA190_0==OBJECT||LA190_0==OPEN_BRACKET||LA190_0==OUT||LA190_0==PARAMS||LA190_0==REF||LA190_0==SBYTE||LA190_0==SHORT||LA190_0==STRING||LA190_0==THIS||(LA190_0 >= UINT && LA190_0 <= ULONG)||LA190_0==USHORT||LA190_0==VOID) ) {
                        alt190=1;
                    }
                    switch (alt190) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1314:70: formal_parameter_list
                            {
                            pushFollow(FOLLOW_formal_parameter_list_in_common_member_declaration5775);
                            formal_parameter_list();

                            state._fsp--;
                            if (state.failed) return ;

                            }
                            break;

                    }


                    match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_common_member_declaration5778); if (state.failed) return ;

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1314:106: ( type_parameter_constraints_clauses )?
                    int alt191=2;
                    int LA191_0 = input.LA(1);

                    if ( (LA191_0==IDENTIFIER) ) {
                        alt191=1;
                    }
                    switch (alt191) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1314:106: type_parameter_constraints_clauses
                            {
                            pushFollow(FOLLOW_type_parameter_constraints_clauses_in_common_member_declaration5780);
                            type_parameter_constraints_clauses();

                            state._fsp--;
                            if (state.failed) return ;

                            }
                            break;

                    }


                    match(input,SEMICOLON,FOLLOW_SEMICOLON_in_common_member_declaration5783); if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "common_member_declaration"



    // $ANTLR start "typed_member_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1317:1: typed_member_declaration : t= type ( ( interface_type DOT THIS )=> interface_type DOT THIS OPEN_BRACKET formal_parameter_list CLOSE_BRACKET OPEN_BRACE accessor_declarations CLOSE_BRACE | ( member_name ( type_parameter_list )? OPEN_PARENS )=> method_definition | ( member_name OPEN_BRACE )=> property_declaration2 | THIS OPEN_BRACKET formal_parameter_list CLOSE_BRACKET OPEN_BRACE accessor_declarations CLOSE_BRACE | operator_declaration2 | field_declaration2 ) ;
    public final void typed_member_declaration() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1318:3: (t= type ( ( interface_type DOT THIS )=> interface_type DOT THIS OPEN_BRACKET formal_parameter_list CLOSE_BRACKET OPEN_BRACE accessor_declarations CLOSE_BRACE | ( member_name ( type_parameter_list )? OPEN_PARENS )=> method_definition | ( member_name OPEN_BRACE )=> property_declaration2 | THIS OPEN_BRACKET formal_parameter_list CLOSE_BRACKET OPEN_BRACE accessor_declarations CLOSE_BRACE | operator_declaration2 | field_declaration2 ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1318:5: t= type ( ( interface_type DOT THIS )=> interface_type DOT THIS OPEN_BRACKET formal_parameter_list CLOSE_BRACKET OPEN_BRACE accessor_declarations CLOSE_BRACE | ( member_name ( type_parameter_list )? OPEN_PARENS )=> method_definition | ( member_name OPEN_BRACE )=> property_declaration2 | THIS OPEN_BRACKET formal_parameter_list CLOSE_BRACKET OPEN_BRACE accessor_declarations CLOSE_BRACE | operator_declaration2 | field_declaration2 )
            {
            pushFollow(FOLLOW_type_in_typed_member_declaration5798);
            type();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1319:5: ( ( interface_type DOT THIS )=> interface_type DOT THIS OPEN_BRACKET formal_parameter_list CLOSE_BRACKET OPEN_BRACE accessor_declarations CLOSE_BRACE | ( member_name ( type_parameter_list )? OPEN_PARENS )=> method_definition | ( member_name OPEN_BRACE )=> property_declaration2 | THIS OPEN_BRACKET formal_parameter_list CLOSE_BRACKET OPEN_BRACE accessor_declarations CLOSE_BRACE | operator_declaration2 | field_declaration2 )
            int alt193=6;
            switch ( input.LA(1) ) {
            case IDENTIFIER:
                {
                int LA193_1 = input.LA(2);

                if ( (synpred20_CSharp4()) ) {
                    alt193=1;
                }
                else if ( (synpred21_CSharp4()) ) {
                    alt193=2;
                }
                else if ( (synpred22_CSharp4()) ) {
                    alt193=3;
                }
                else if ( (true) ) {
                    alt193=6;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 193, 1, input);

                    throw nvae;

                }
                }
                break;
            case THIS:
                {
                alt193=4;
                }
                break;
            case OPERATOR:
                {
                alt193=5;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 193, 0, input);

                throw nvae;

            }

            switch (alt193) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1319:7: ( interface_type DOT THIS )=> interface_type DOT THIS OPEN_BRACKET formal_parameter_list CLOSE_BRACKET OPEN_BRACE accessor_declarations CLOSE_BRACE
                    {
                    pushFollow(FOLLOW_interface_type_in_typed_member_declaration5824);
                    interface_type();

                    state._fsp--;
                    if (state.failed) return ;

                    match(input,DOT,FOLLOW_DOT_in_typed_member_declaration5826); if (state.failed) return ;

                    match(input,THIS,FOLLOW_THIS_in_typed_member_declaration5828); if (state.failed) return ;

                    match(input,OPEN_BRACKET,FOLLOW_OPEN_BRACKET_in_typed_member_declaration5830); if (state.failed) return ;

                    pushFollow(FOLLOW_formal_parameter_list_in_typed_member_declaration5832);
                    formal_parameter_list();

                    state._fsp--;
                    if (state.failed) return ;

                    match(input,CLOSE_BRACKET,FOLLOW_CLOSE_BRACKET_in_typed_member_declaration5834); if (state.failed) return ;

                    match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_typed_member_declaration5836); if (state.failed) return ;

                    pushFollow(FOLLOW_accessor_declarations_in_typed_member_declaration5838);
                    accessor_declarations();

                    state._fsp--;
                    if (state.failed) return ;

                    match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_typed_member_declaration5840); if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1321:7: ( member_name ( type_parameter_list )? OPEN_PARENS )=> method_definition
                    {
                    pushFollow(FOLLOW_method_definition_in_typed_member_declaration5859);
                    method_definition();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1322:7: ( member_name OPEN_BRACE )=> property_declaration2
                    {
                    pushFollow(FOLLOW_property_declaration2_in_typed_member_declaration5875);
                    property_declaration2();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1323:7: THIS OPEN_BRACKET formal_parameter_list CLOSE_BRACKET OPEN_BRACE accessor_declarations CLOSE_BRACE
                    {
                    match(input,THIS,FOLLOW_THIS_in_typed_member_declaration5883); if (state.failed) return ;

                    match(input,OPEN_BRACKET,FOLLOW_OPEN_BRACKET_in_typed_member_declaration5885); if (state.failed) return ;

                    pushFollow(FOLLOW_formal_parameter_list_in_typed_member_declaration5887);
                    formal_parameter_list();

                    state._fsp--;
                    if (state.failed) return ;

                    match(input,CLOSE_BRACKET,FOLLOW_CLOSE_BRACKET_in_typed_member_declaration5889); if (state.failed) return ;

                    match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_typed_member_declaration5891); if (state.failed) return ;

                    pushFollow(FOLLOW_accessor_declarations_in_typed_member_declaration5893);
                    accessor_declarations();

                    state._fsp--;
                    if (state.failed) return ;

                    match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_typed_member_declaration5895); if (state.failed) return ;

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1324:7: operator_declaration2
                    {
                    pushFollow(FOLLOW_operator_declaration2_in_typed_member_declaration5903);
                    operator_declaration2();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 6 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1325:7: field_declaration2
                    {
                    pushFollow(FOLLOW_field_declaration2_in_typed_member_declaration5911);
                    field_declaration2();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "typed_member_declaration"



    // $ANTLR start "constant_declarators"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1343:1: constant_declarators : constant_declarator ( COMMA constant_declarator )* ;
    public final void constant_declarators() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1344:2: ( constant_declarator ( COMMA constant_declarator )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1344:4: constant_declarator ( COMMA constant_declarator )*
            {
            pushFollow(FOLLOW_constant_declarator_in_constant_declarators5931);
            constant_declarator();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1344:24: ( COMMA constant_declarator )*
            loop194:
            do {
                int alt194=2;
                int LA194_0 = input.LA(1);

                if ( (LA194_0==COMMA) ) {
                    alt194=1;
                }


                switch (alt194) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1344:26: COMMA constant_declarator
            	    {
            	    match(input,COMMA,FOLLOW_COMMA_in_constant_declarators5935); if (state.failed) return ;

            	    pushFollow(FOLLOW_constant_declarator_in_constant_declarators5938);
            	    constant_declarator();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop194;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "constant_declarators"



    // $ANTLR start "constant_declarator"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1346:1: constant_declarator : IDENTIFIER ASSIGNMENT constant_expression ;
    public final void constant_declarator() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1347:2: ( IDENTIFIER ASSIGNMENT constant_expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1347:4: IDENTIFIER ASSIGNMENT constant_expression
            {
            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_constant_declarator5952); if (state.failed) return ;

            match(input,ASSIGNMENT,FOLLOW_ASSIGNMENT_in_constant_declarator5954); if (state.failed) return ;

            pushFollow(FOLLOW_constant_expression_in_constant_declarator5956);
            constant_expression();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "constant_declarator"



    // $ANTLR start "variable_declarators"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1369:1: variable_declarators : variable_declarator ( COMMA variable_declarator )* ;
    public final void variable_declarators() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1370:2: ( variable_declarator ( COMMA variable_declarator )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1370:4: variable_declarator ( COMMA variable_declarator )*
            {
            pushFollow(FOLLOW_variable_declarator_in_variable_declarators5970);
            variable_declarator();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1370:24: ( COMMA variable_declarator )*
            loop195:
            do {
                int alt195=2;
                int LA195_0 = input.LA(1);

                if ( (LA195_0==COMMA) ) {
                    alt195=1;
                }


                switch (alt195) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1370:26: COMMA variable_declarator
            	    {
            	    match(input,COMMA,FOLLOW_COMMA_in_variable_declarators5974); if (state.failed) return ;

            	    pushFollow(FOLLOW_variable_declarator_in_variable_declarators5977);
            	    variable_declarator();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop195;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "variable_declarators"



    // $ANTLR start "variable_declarator"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1372:1: variable_declarator : ( IDENTIFIER | IDENTIFIER ASSIGNMENT variable_initializer );
    public final void variable_declarator() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1373:2: ( IDENTIFIER | IDENTIFIER ASSIGNMENT variable_initializer )
            int alt196=2;
            int LA196_0 = input.LA(1);

            if ( (LA196_0==IDENTIFIER) ) {
                int LA196_1 = input.LA(2);

                if ( (LA196_1==ASSIGNMENT) ) {
                    alt196=2;
                }
                else if ( (LA196_1==COMMA||LA196_1==SEMICOLON) ) {
                    alt196=1;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 196, 1, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 196, 0, input);

                throw nvae;

            }
            switch (alt196) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1373:4: IDENTIFIER
                    {
                    match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_variable_declarator5991); if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1374:4: IDENTIFIER ASSIGNMENT variable_initializer
                    {
                    match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_variable_declarator5996); if (state.failed) return ;

                    match(input,ASSIGNMENT,FOLLOW_ASSIGNMENT_in_variable_declarator5998); if (state.failed) return ;

                    pushFollow(FOLLOW_variable_initializer_in_variable_declarator6000);
                    variable_initializer();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "variable_declarator"



    // $ANTLR start "variable_initializer"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1376:1: variable_initializer : ( expression | array_initializer );
    public final void variable_initializer() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1377:2: ( expression | array_initializer )
            int alt197=2;
            int LA197_0 = input.LA(1);

            if ( (LA197_0==AMP||(LA197_0 >= BANG && LA197_0 <= BASE)||LA197_0==BOOL||LA197_0==BYTE||(LA197_0 >= CHAR && LA197_0 <= CHECKED)||LA197_0==DECIMAL||(LA197_0 >= DEFAULT && LA197_0 <= DELEGATE)||LA197_0==DOUBLE||LA197_0==FALSE||LA197_0==FLOAT||LA197_0==IDENTIFIER||(LA197_0 >= INT && LA197_0 <= INTEGER_LITERAL)||LA197_0==LONG||LA197_0==MINUS||LA197_0==NEW||LA197_0==NULL||LA197_0==OBJECT||LA197_0==OPEN_PARENS||LA197_0==OP_DEC||LA197_0==OP_INC||LA197_0==PLUS||LA197_0==REAL_LITERAL||LA197_0==SBYTE||LA197_0==SHORT||LA197_0==SIZEOF||LA197_0==STAR||(LA197_0 >= STRING && LA197_0 <= STRING_LITERAL)||LA197_0==THIS||(LA197_0 >= TILDE && LA197_0 <= TRUE)||(LA197_0 >= TYPEOF && LA197_0 <= UNCHECKED)||LA197_0==USHORT) ) {
                alt197=1;
            }
            else if ( (LA197_0==OPEN_BRACE) ) {
                alt197=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 197, 0, input);

                throw nvae;

            }
            switch (alt197) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1377:4: expression
                    {
                    pushFollow(FOLLOW_expression_in_variable_initializer6011);
                    expression();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1378:4: array_initializer
                    {
                    pushFollow(FOLLOW_array_initializer_in_variable_initializer6016);
                    array_initializer();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "variable_initializer"



    // $ANTLR start "method_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1380:1: method_declaration : method_header method_body ;
    public final void method_declaration() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1381:2: ( method_header method_body )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1381:4: method_header method_body
            {
            pushFollow(FOLLOW_method_header_in_method_declaration6027);
            method_header();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_method_body_in_method_declaration6029);
            method_body();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "method_declaration"



    // $ANTLR start "method_header"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1383:1: method_header : ( attributes )? ( method_modifiers )? ( partial_contextual_keyword )? return_type member_name ( type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? ;
    public final void method_header() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1384:2: ( ( attributes )? ( method_modifiers )? ( partial_contextual_keyword )? return_type member_name ( type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1384:4: ( attributes )? ( method_modifiers )? ( partial_contextual_keyword )? return_type member_name ( type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )?
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1384:4: ( attributes )?
            int alt198=2;
            int LA198_0 = input.LA(1);

            if ( (LA198_0==OPEN_BRACKET) ) {
                alt198=1;
            }
            switch (alt198) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1384:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_method_header6040);
                    attributes();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1384:16: ( method_modifiers )?
            int alt199=2;
            int LA199_0 = input.LA(1);

            if ( (LA199_0==ABSTRACT||LA199_0==EXTERN||LA199_0==INTERNAL||LA199_0==NEW||LA199_0==OVERRIDE||(LA199_0 >= PRIVATE && LA199_0 <= PUBLIC)||LA199_0==SEALED||LA199_0==STATIC||LA199_0==UNSAFE||LA199_0==VIRTUAL) ) {
                alt199=1;
            }
            switch (alt199) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1384:16: method_modifiers
                    {
                    pushFollow(FOLLOW_method_modifiers_in_method_header6043);
                    method_modifiers();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1384:34: ( partial_contextual_keyword )?
            int alt200=2;
            int LA200_0 = input.LA(1);

            if ( (LA200_0==IDENTIFIER) ) {
                int LA200_1 = input.LA(2);

                if ( ((input.LT(1).getText().equals("partial"))) ) {
                    alt200=1;
                }
            }
            switch (alt200) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1384:34: partial_contextual_keyword
                    {
                    pushFollow(FOLLOW_partial_contextual_keyword_in_method_header6046);
                    partial_contextual_keyword();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            pushFollow(FOLLOW_return_type_in_method_header6049);
            return_type();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_member_name_in_method_header6051);
            member_name();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1384:86: ( type_parameter_list )?
            int alt201=2;
            int LA201_0 = input.LA(1);

            if ( (LA201_0==LT) ) {
                alt201=1;
            }
            switch (alt201) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1384:86: type_parameter_list
                    {
                    pushFollow(FOLLOW_type_parameter_list_in_method_header6053);
                    type_parameter_list();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_method_header6056); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1384:119: ( formal_parameter_list )?
            int alt202=2;
            int LA202_0 = input.LA(1);

            if ( (LA202_0==BOOL||LA202_0==BYTE||LA202_0==CHAR||LA202_0==DECIMAL||LA202_0==DOUBLE||LA202_0==FLOAT||LA202_0==IDENTIFIER||LA202_0==INT||LA202_0==LONG||LA202_0==OBJECT||LA202_0==OPEN_BRACKET||LA202_0==OUT||LA202_0==PARAMS||LA202_0==REF||LA202_0==SBYTE||LA202_0==SHORT||LA202_0==STRING||LA202_0==THIS||(LA202_0 >= UINT && LA202_0 <= ULONG)||LA202_0==USHORT||LA202_0==VOID) ) {
                alt202=1;
            }
            switch (alt202) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1384:119: formal_parameter_list
                    {
                    pushFollow(FOLLOW_formal_parameter_list_in_method_header6058);
                    formal_parameter_list();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_method_header6061); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1384:155: ( type_parameter_constraints_clauses )?
            int alt203=2;
            int LA203_0 = input.LA(1);

            if ( (LA203_0==IDENTIFIER) ) {
                alt203=1;
            }
            switch (alt203) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1384:155: type_parameter_constraints_clauses
                    {
                    pushFollow(FOLLOW_type_parameter_constraints_clauses_in_method_header6063);
                    type_parameter_constraints_clauses();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "method_header"



    // $ANTLR start "method_modifiers"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1386:1: method_modifiers : ( method_modifier )+ ;
    public final void method_modifiers() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1387:2: ( ( method_modifier )+ )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1387:4: ( method_modifier )+
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1387:4: ( method_modifier )+
            int cnt204=0;
            loop204:
            do {
                int alt204=2;
                int LA204_0 = input.LA(1);

                if ( (LA204_0==ABSTRACT||LA204_0==EXTERN||LA204_0==INTERNAL||LA204_0==NEW||LA204_0==OVERRIDE||(LA204_0 >= PRIVATE && LA204_0 <= PUBLIC)||LA204_0==SEALED||LA204_0==STATIC||LA204_0==UNSAFE||LA204_0==VIRTUAL) ) {
                    alt204=1;
                }


                switch (alt204) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1387:4: method_modifier
            	    {
            	    pushFollow(FOLLOW_method_modifier_in_method_modifiers6075);
            	    method_modifier();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    if ( cnt204 >= 1 ) break loop204;
            	    if (state.backtracking>0) {state.failed=true; return ;}
                        EarlyExitException eee =
                            new EarlyExitException(204, input);
                        throw eee;
                }
                cnt204++;
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "method_modifiers"



    // $ANTLR start "method_modifier"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1389:1: method_modifier : ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | STATIC | VIRTUAL | SEALED | OVERRIDE | ABSTRACT | EXTERN | method_modifier_unsafe );
    public final void method_modifier() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1390:2: ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | STATIC | VIRTUAL | SEALED | OVERRIDE | ABSTRACT | EXTERN | method_modifier_unsafe )
            int alt205=12;
            switch ( input.LA(1) ) {
            case NEW:
                {
                alt205=1;
                }
                break;
            case PUBLIC:
                {
                alt205=2;
                }
                break;
            case PROTECTED:
                {
                alt205=3;
                }
                break;
            case INTERNAL:
                {
                alt205=4;
                }
                break;
            case PRIVATE:
                {
                alt205=5;
                }
                break;
            case STATIC:
                {
                alt205=6;
                }
                break;
            case VIRTUAL:
                {
                alt205=7;
                }
                break;
            case SEALED:
                {
                alt205=8;
                }
                break;
            case OVERRIDE:
                {
                alt205=9;
                }
                break;
            case ABSTRACT:
                {
                alt205=10;
                }
                break;
            case EXTERN:
                {
                alt205=11;
                }
                break;
            case UNSAFE:
                {
                alt205=12;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 205, 0, input);

                throw nvae;

            }

            switch (alt205) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1390:4: NEW
                    {
                    match(input,NEW,FOLLOW_NEW_in_method_modifier6087); if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1391:4: PUBLIC
                    {
                    match(input,PUBLIC,FOLLOW_PUBLIC_in_method_modifier6092); if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1392:4: PROTECTED
                    {
                    match(input,PROTECTED,FOLLOW_PROTECTED_in_method_modifier6097); if (state.failed) return ;

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1393:4: INTERNAL
                    {
                    match(input,INTERNAL,FOLLOW_INTERNAL_in_method_modifier6102); if (state.failed) return ;

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1394:4: PRIVATE
                    {
                    match(input,PRIVATE,FOLLOW_PRIVATE_in_method_modifier6107); if (state.failed) return ;

                    }
                    break;
                case 6 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1395:4: STATIC
                    {
                    match(input,STATIC,FOLLOW_STATIC_in_method_modifier6112); if (state.failed) return ;

                    }
                    break;
                case 7 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1396:4: VIRTUAL
                    {
                    match(input,VIRTUAL,FOLLOW_VIRTUAL_in_method_modifier6117); if (state.failed) return ;

                    }
                    break;
                case 8 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1397:4: SEALED
                    {
                    match(input,SEALED,FOLLOW_SEALED_in_method_modifier6122); if (state.failed) return ;

                    }
                    break;
                case 9 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1398:4: OVERRIDE
                    {
                    match(input,OVERRIDE,FOLLOW_OVERRIDE_in_method_modifier6127); if (state.failed) return ;

                    }
                    break;
                case 10 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1399:4: ABSTRACT
                    {
                    match(input,ABSTRACT,FOLLOW_ABSTRACT_in_method_modifier6132); if (state.failed) return ;

                    }
                    break;
                case 11 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1400:4: EXTERN
                    {
                    match(input,EXTERN,FOLLOW_EXTERN_in_method_modifier6137); if (state.failed) return ;

                    }
                    break;
                case 12 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1401:4: method_modifier_unsafe
                    {
                    pushFollow(FOLLOW_method_modifier_unsafe_in_method_modifier6142);
                    method_modifier_unsafe();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "method_modifier"



    // $ANTLR start "return_type"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1404:1: return_type : ( type | VOID );
    public final void return_type() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1405:2: ( type | VOID )
            int alt206=2;
            int LA206_0 = input.LA(1);

            if ( (LA206_0==BOOL||LA206_0==BYTE||LA206_0==CHAR||LA206_0==DECIMAL||LA206_0==DOUBLE||LA206_0==FLOAT||LA206_0==IDENTIFIER||LA206_0==INT||LA206_0==LONG||LA206_0==OBJECT||LA206_0==SBYTE||LA206_0==SHORT||LA206_0==STRING||(LA206_0 >= UINT && LA206_0 <= ULONG)||LA206_0==USHORT) ) {
                alt206=1;
            }
            else if ( (LA206_0==VOID) ) {
                int LA206_2 = input.LA(2);

                if ( (LA206_2==STAR) ) {
                    alt206=1;
                }
                else if ( (LA206_2==IDENTIFIER) ) {
                    alt206=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 206, 2, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 206, 0, input);

                throw nvae;

            }
            switch (alt206) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1405:4: type
                    {
                    pushFollow(FOLLOW_type_in_return_type6155);
                    type();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1406:4: VOID
                    {
                    match(input,VOID,FOLLOW_VOID_in_return_type6160); if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "return_type"



    // $ANTLR start "member_name"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1415:1: member_name : interface_type ;
    public final void member_name() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1416:3: ( interface_type )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1416:5: interface_type
            {
            pushFollow(FOLLOW_interface_type_in_member_name6176);
            interface_type();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "member_name"



    // $ANTLR start "method_body"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1418:1: method_body : ( block | SEMICOLON );
    public final void method_body() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1419:2: ( block | SEMICOLON )
            int alt207=2;
            int LA207_0 = input.LA(1);

            if ( (LA207_0==OPEN_BRACE) ) {
                alt207=1;
            }
            else if ( (LA207_0==SEMICOLON) ) {
                alt207=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 207, 0, input);

                throw nvae;

            }
            switch (alt207) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1419:4: block
                    {
                    pushFollow(FOLLOW_block_in_method_body6188);
                    block();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1420:4: SEMICOLON
                    {
                    match(input,SEMICOLON,FOLLOW_SEMICOLON_in_method_body6193); if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "method_body"



    // $ANTLR start "formal_parameter_list"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1429:1: formal_parameter_list : ( ( ( attributes )? PARAMS )=> parameter_array | fixed_parameters ( ( COMMA parameter_array )=> COMMA parameter_array )? );
    public final void formal_parameter_list() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1430:3: ( ( ( attributes )? PARAMS )=> parameter_array | fixed_parameters ( ( COMMA parameter_array )=> COMMA parameter_array )? )
            int alt209=2;
            int LA209_0 = input.LA(1);

            if ( (LA209_0==OPEN_BRACKET) ) {
                int LA209_1 = input.LA(2);

                if ( (synpred23_CSharp4()) ) {
                    alt209=1;
                }
                else if ( (true) ) {
                    alt209=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 209, 1, input);

                    throw nvae;

                }
            }
            else if ( (LA209_0==PARAMS) && (synpred23_CSharp4())) {
                alt209=1;
            }
            else if ( (LA209_0==BOOL||LA209_0==BYTE||LA209_0==CHAR||LA209_0==DECIMAL||LA209_0==DOUBLE||LA209_0==FLOAT||LA209_0==IDENTIFIER||LA209_0==INT||LA209_0==LONG||LA209_0==OBJECT||LA209_0==OUT||LA209_0==REF||LA209_0==SBYTE||LA209_0==SHORT||LA209_0==STRING||LA209_0==THIS||(LA209_0 >= UINT && LA209_0 <= ULONG)||LA209_0==USHORT||LA209_0==VOID) ) {
                alt209=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 209, 0, input);

                throw nvae;

            }
            switch (alt209) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1430:5: ( ( attributes )? PARAMS )=> parameter_array
                    {
                    pushFollow(FOLLOW_parameter_array_in_formal_parameter_list6216);
                    parameter_array();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1431:5: fixed_parameters ( ( COMMA parameter_array )=> COMMA parameter_array )?
                    {
                    pushFollow(FOLLOW_fixed_parameters_in_formal_parameter_list6222);
                    fixed_parameters();

                    state._fsp--;
                    if (state.failed) return ;

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1431:22: ( ( COMMA parameter_array )=> COMMA parameter_array )?
                    int alt208=2;
                    int LA208_0 = input.LA(1);

                    if ( (LA208_0==COMMA) && (synpred24_CSharp4())) {
                        alt208=1;
                    }
                    switch (alt208) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1431:24: ( COMMA parameter_array )=> COMMA parameter_array
                            {
                            match(input,COMMA,FOLLOW_COMMA_in_formal_parameter_list6234); if (state.failed) return ;

                            pushFollow(FOLLOW_parameter_array_in_formal_parameter_list6236);
                            parameter_array();

                            state._fsp--;
                            if (state.failed) return ;

                            }
                            break;

                    }


                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "formal_parameter_list"



    // $ANTLR start "fixed_parameters"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1433:1: fixed_parameters : fixed_parameter ( ( COMMA fixed_parameter )=> COMMA fixed_parameter )* ;
    public final void fixed_parameters() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1434:2: ( fixed_parameter ( ( COMMA fixed_parameter )=> COMMA fixed_parameter )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1434:4: fixed_parameter ( ( COMMA fixed_parameter )=> COMMA fixed_parameter )*
            {
            pushFollow(FOLLOW_fixed_parameter_in_fixed_parameters6250);
            fixed_parameter();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1434:20: ( ( COMMA fixed_parameter )=> COMMA fixed_parameter )*
            loop210:
            do {
                int alt210=2;
                int LA210_0 = input.LA(1);

                if ( (LA210_0==COMMA) ) {
                    int LA210_1 = input.LA(2);

                    if ( (synpred25_CSharp4()) ) {
                        alt210=1;
                    }


                }


                switch (alt210) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1434:22: ( COMMA fixed_parameter )=> COMMA fixed_parameter
            	    {
            	    match(input,COMMA,FOLLOW_COMMA_in_fixed_parameters6262); if (state.failed) return ;

            	    pushFollow(FOLLOW_fixed_parameter_in_fixed_parameters6264);
            	    fixed_parameter();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop210;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "fixed_parameters"



    // $ANTLR start "fixed_parameter"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1442:1: fixed_parameter : ( ( attributes )? ( parameter_modifier )? type IDENTIFIER ( default_argument )? | arglist );
    public final void fixed_parameter() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1443:3: ( ( attributes )? ( parameter_modifier )? type IDENTIFIER ( default_argument )? | arglist )
            int alt214=2;
            int LA214_0 = input.LA(1);

            if ( (LA214_0==BOOL||LA214_0==BYTE||LA214_0==CHAR||LA214_0==DECIMAL||LA214_0==DOUBLE||LA214_0==FLOAT||LA214_0==INT||LA214_0==LONG||LA214_0==OBJECT||LA214_0==OPEN_BRACKET||LA214_0==OUT||LA214_0==REF||LA214_0==SBYTE||LA214_0==SHORT||LA214_0==STRING||LA214_0==THIS||(LA214_0 >= UINT && LA214_0 <= ULONG)||LA214_0==USHORT||LA214_0==VOID) ) {
                alt214=1;
            }
            else if ( (LA214_0==IDENTIFIER) ) {
                int LA214_2 = input.LA(2);

                if ( (LA214_2==DOT||LA214_2==DOUBLE_COLON||LA214_2==IDENTIFIER||LA214_2==INTERR||LA214_2==LT||LA214_2==OPEN_BRACKET||LA214_2==STAR) ) {
                    alt214=1;
                }
                else if ( (LA214_2==EOF||(LA214_2 >= CLOSE_BRACKET && LA214_2 <= CLOSE_PARENS)||LA214_2==COMMA) ) {
                    alt214=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 214, 2, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 214, 0, input);

                throw nvae;

            }
            switch (alt214) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1443:5: ( attributes )? ( parameter_modifier )? type IDENTIFIER ( default_argument )?
                    {
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1443:5: ( attributes )?
                    int alt211=2;
                    int LA211_0 = input.LA(1);

                    if ( (LA211_0==OPEN_BRACKET) ) {
                        alt211=1;
                    }
                    switch (alt211) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1443:5: attributes
                            {
                            pushFollow(FOLLOW_attributes_in_fixed_parameter6281);
                            attributes();

                            state._fsp--;
                            if (state.failed) return ;

                            }
                            break;

                    }


                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1443:17: ( parameter_modifier )?
                    int alt212=2;
                    int LA212_0 = input.LA(1);

                    if ( (LA212_0==OUT||LA212_0==REF||LA212_0==THIS) ) {
                        alt212=1;
                    }
                    switch (alt212) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1443:17: parameter_modifier
                            {
                            pushFollow(FOLLOW_parameter_modifier_in_fixed_parameter6284);
                            parameter_modifier();

                            state._fsp--;
                            if (state.failed) return ;

                            }
                            break;

                    }


                    pushFollow(FOLLOW_type_in_fixed_parameter6287);
                    type();

                    state._fsp--;
                    if (state.failed) return ;

                    match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_fixed_parameter6289); if (state.failed) return ;

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1443:53: ( default_argument )?
                    int alt213=2;
                    int LA213_0 = input.LA(1);

                    if ( (LA213_0==ASSIGNMENT) ) {
                        alt213=1;
                    }
                    switch (alt213) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1443:53: default_argument
                            {
                            pushFollow(FOLLOW_default_argument_in_fixed_parameter6291);
                            default_argument();

                            state._fsp--;
                            if (state.failed) return ;

                            }
                            break;

                    }


                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1444:5: arglist
                    {
                    pushFollow(FOLLOW_arglist_in_fixed_parameter6298);
                    arglist();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "fixed_parameter"



    // $ANTLR start "default_argument"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1446:1: default_argument : ASSIGNMENT expression ;
    public final void default_argument() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1447:2: ( ASSIGNMENT expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1447:4: ASSIGNMENT expression
            {
            match(input,ASSIGNMENT,FOLLOW_ASSIGNMENT_in_default_argument6310); if (state.failed) return ;

            pushFollow(FOLLOW_expression_in_default_argument6312);
            expression();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "default_argument"



    // $ANTLR start "parameter_modifier"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1449:1: parameter_modifier : ( REF | OUT | THIS );
    public final void parameter_modifier() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1450:2: ( REF | OUT | THIS )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:
            {
            if ( input.LA(1)==OUT||input.LA(1)==REF||input.LA(1)==THIS ) {
                input.consume();
                state.errorRecovery=false;
                state.failed=false;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                MismatchedSetException mse = new MismatchedSetException(null,input);
                throw mse;
            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "parameter_modifier"



    // $ANTLR start "parameter_array"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1454:1: parameter_array : ( attributes )? PARAMS array_type IDENTIFIER ;
    public final void parameter_array() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1455:2: ( ( attributes )? PARAMS array_type IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1455:4: ( attributes )? PARAMS array_type IDENTIFIER
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1455:4: ( attributes )?
            int alt215=2;
            int LA215_0 = input.LA(1);

            if ( (LA215_0==OPEN_BRACKET) ) {
                alt215=1;
            }
            switch (alt215) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1455:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_parameter_array6344);
                    attributes();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,PARAMS,FOLLOW_PARAMS_in_parameter_array6347); if (state.failed) return ;

            pushFollow(FOLLOW_array_type_in_parameter_array6349);
            array_type();

            state._fsp--;
            if (state.failed) return ;

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_parameter_array6351); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "parameter_array"



    // $ANTLR start "property_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1457:1: property_declaration : ( attributes )? ( property_modifiers )? type member_name OPEN_BRACE accessor_declarations CLOSE_BRACE ;
    public final void property_declaration() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1458:2: ( ( attributes )? ( property_modifiers )? type member_name OPEN_BRACE accessor_declarations CLOSE_BRACE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1458:4: ( attributes )? ( property_modifiers )? type member_name OPEN_BRACE accessor_declarations CLOSE_BRACE
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1458:4: ( attributes )?
            int alt216=2;
            int LA216_0 = input.LA(1);

            if ( (LA216_0==OPEN_BRACKET) ) {
                alt216=1;
            }
            switch (alt216) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1458:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_property_declaration6362);
                    attributes();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1458:16: ( property_modifiers )?
            int alt217=2;
            int LA217_0 = input.LA(1);

            if ( (LA217_0==ABSTRACT||LA217_0==EXTERN||LA217_0==INTERNAL||LA217_0==NEW||LA217_0==OVERRIDE||(LA217_0 >= PRIVATE && LA217_0 <= PUBLIC)||LA217_0==SEALED||LA217_0==STATIC||LA217_0==UNSAFE||LA217_0==VIRTUAL) ) {
                alt217=1;
            }
            switch (alt217) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1458:16: property_modifiers
                    {
                    pushFollow(FOLLOW_property_modifiers_in_property_declaration6365);
                    property_modifiers();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            pushFollow(FOLLOW_type_in_property_declaration6368);
            type();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_member_name_in_property_declaration6370);
            member_name();

            state._fsp--;
            if (state.failed) return ;

            match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_property_declaration6372); if (state.failed) return ;

            pushFollow(FOLLOW_accessor_declarations_in_property_declaration6374);
            accessor_declarations();

            state._fsp--;
            if (state.failed) return ;

            match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_property_declaration6376); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "property_declaration"



    // $ANTLR start "property_modifiers"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1460:1: property_modifiers : ( property_modifier )+ ;
    public final void property_modifiers() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1461:2: ( ( property_modifier )+ )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1461:4: ( property_modifier )+
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1461:4: ( property_modifier )+
            int cnt218=0;
            loop218:
            do {
                int alt218=2;
                int LA218_0 = input.LA(1);

                if ( (LA218_0==ABSTRACT||LA218_0==EXTERN||LA218_0==INTERNAL||LA218_0==NEW||LA218_0==OVERRIDE||(LA218_0 >= PRIVATE && LA218_0 <= PUBLIC)||LA218_0==SEALED||LA218_0==STATIC||LA218_0==UNSAFE||LA218_0==VIRTUAL) ) {
                    alt218=1;
                }


                switch (alt218) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1461:4: property_modifier
            	    {
            	    pushFollow(FOLLOW_property_modifier_in_property_modifiers6387);
            	    property_modifier();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    if ( cnt218 >= 1 ) break loop218;
            	    if (state.backtracking>0) {state.failed=true; return ;}
                        EarlyExitException eee =
                            new EarlyExitException(218, input);
                        throw eee;
                }
                cnt218++;
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "property_modifiers"



    // $ANTLR start "property_modifier"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1463:1: property_modifier : ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | STATIC | VIRTUAL | SEALED | OVERRIDE | ABSTRACT | EXTERN | property_modifier_unsafe );
    public final void property_modifier() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1464:2: ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | STATIC | VIRTUAL | SEALED | OVERRIDE | ABSTRACT | EXTERN | property_modifier_unsafe )
            int alt219=12;
            switch ( input.LA(1) ) {
            case NEW:
                {
                alt219=1;
                }
                break;
            case PUBLIC:
                {
                alt219=2;
                }
                break;
            case PROTECTED:
                {
                alt219=3;
                }
                break;
            case INTERNAL:
                {
                alt219=4;
                }
                break;
            case PRIVATE:
                {
                alt219=5;
                }
                break;
            case STATIC:
                {
                alt219=6;
                }
                break;
            case VIRTUAL:
                {
                alt219=7;
                }
                break;
            case SEALED:
                {
                alt219=8;
                }
                break;
            case OVERRIDE:
                {
                alt219=9;
                }
                break;
            case ABSTRACT:
                {
                alt219=10;
                }
                break;
            case EXTERN:
                {
                alt219=11;
                }
                break;
            case UNSAFE:
                {
                alt219=12;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 219, 0, input);

                throw nvae;

            }

            switch (alt219) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1464:4: NEW
                    {
                    match(input,NEW,FOLLOW_NEW_in_property_modifier6399); if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1465:4: PUBLIC
                    {
                    match(input,PUBLIC,FOLLOW_PUBLIC_in_property_modifier6404); if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1466:4: PROTECTED
                    {
                    match(input,PROTECTED,FOLLOW_PROTECTED_in_property_modifier6409); if (state.failed) return ;

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1467:4: INTERNAL
                    {
                    match(input,INTERNAL,FOLLOW_INTERNAL_in_property_modifier6414); if (state.failed) return ;

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1468:4: PRIVATE
                    {
                    match(input,PRIVATE,FOLLOW_PRIVATE_in_property_modifier6419); if (state.failed) return ;

                    }
                    break;
                case 6 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1469:4: STATIC
                    {
                    match(input,STATIC,FOLLOW_STATIC_in_property_modifier6424); if (state.failed) return ;

                    }
                    break;
                case 7 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1470:4: VIRTUAL
                    {
                    match(input,VIRTUAL,FOLLOW_VIRTUAL_in_property_modifier6429); if (state.failed) return ;

                    }
                    break;
                case 8 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1471:4: SEALED
                    {
                    match(input,SEALED,FOLLOW_SEALED_in_property_modifier6434); if (state.failed) return ;

                    }
                    break;
                case 9 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1472:4: OVERRIDE
                    {
                    match(input,OVERRIDE,FOLLOW_OVERRIDE_in_property_modifier6439); if (state.failed) return ;

                    }
                    break;
                case 10 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1473:4: ABSTRACT
                    {
                    match(input,ABSTRACT,FOLLOW_ABSTRACT_in_property_modifier6444); if (state.failed) return ;

                    }
                    break;
                case 11 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1474:4: EXTERN
                    {
                    match(input,EXTERN,FOLLOW_EXTERN_in_property_modifier6449); if (state.failed) return ;

                    }
                    break;
                case 12 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1475:4: property_modifier_unsafe
                    {
                    pushFollow(FOLLOW_property_modifier_unsafe_in_property_modifier6454);
                    property_modifier_unsafe();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "property_modifier"



    // $ANTLR start "accessor_declarations"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1483:1: accessor_declarations : (attrs= attributes )? (mods= accessor_modifier )? ( get_contextual_keyword accessor_body ( set_accessor_declaration )? | set_contextual_keyword accessor_body ( get_accessor_declaration )? ) ;
    public final void accessor_declarations() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1484:3: ( (attrs= attributes )? (mods= accessor_modifier )? ( get_contextual_keyword accessor_body ( set_accessor_declaration )? | set_contextual_keyword accessor_body ( get_accessor_declaration )? ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1484:5: (attrs= attributes )? (mods= accessor_modifier )? ( get_contextual_keyword accessor_body ( set_accessor_declaration )? | set_contextual_keyword accessor_body ( get_accessor_declaration )? )
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1484:10: (attrs= attributes )?
            int alt220=2;
            int LA220_0 = input.LA(1);

            if ( (LA220_0==OPEN_BRACKET) ) {
                alt220=1;
            }
            switch (alt220) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1484:10: attrs= attributes
                    {
                    pushFollow(FOLLOW_attributes_in_accessor_declarations6470);
                    attributes();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1485:9: (mods= accessor_modifier )?
            int alt221=2;
            int LA221_0 = input.LA(1);

            if ( (LA221_0==INTERNAL||(LA221_0 >= PRIVATE && LA221_0 <= PROTECTED)) ) {
                alt221=1;
            }
            switch (alt221) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1485:9: mods= accessor_modifier
                    {
                    pushFollow(FOLLOW_accessor_modifier_in_accessor_declarations6479);
                    accessor_modifier();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1486:5: ( get_contextual_keyword accessor_body ( set_accessor_declaration )? | set_contextual_keyword accessor_body ( get_accessor_declaration )? )
            int alt224=2;
            int LA224_0 = input.LA(1);

            if ( (LA224_0==IDENTIFIER) ) {
                int LA224_1 = input.LA(2);

                if ( ((input.LT(1).getText().equals("get"))) ) {
                    alt224=1;
                }
                else if ( ((input.LT(1).getText().equals("set"))) ) {
                    alt224=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 224, 1, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 224, 0, input);

                throw nvae;

            }
            switch (alt224) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1486:7: get_contextual_keyword accessor_body ( set_accessor_declaration )?
                    {
                    pushFollow(FOLLOW_get_contextual_keyword_in_accessor_declarations6489);
                    get_contextual_keyword();

                    state._fsp--;
                    if (state.failed) return ;

                    pushFollow(FOLLOW_accessor_body_in_accessor_declarations6491);
                    accessor_body();

                    state._fsp--;
                    if (state.failed) return ;

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1486:44: ( set_accessor_declaration )?
                    int alt222=2;
                    int LA222_0 = input.LA(1);

                    if ( (LA222_0==IDENTIFIER||LA222_0==INTERNAL||LA222_0==OPEN_BRACKET||(LA222_0 >= PRIVATE && LA222_0 <= PROTECTED)) ) {
                        alt222=1;
                    }
                    switch (alt222) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1486:44: set_accessor_declaration
                            {
                            pushFollow(FOLLOW_set_accessor_declaration_in_accessor_declarations6493);
                            set_accessor_declaration();

                            state._fsp--;
                            if (state.failed) return ;

                            }
                            break;

                    }


                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1487:7: set_contextual_keyword accessor_body ( get_accessor_declaration )?
                    {
                    pushFollow(FOLLOW_set_contextual_keyword_in_accessor_declarations6502);
                    set_contextual_keyword();

                    state._fsp--;
                    if (state.failed) return ;

                    pushFollow(FOLLOW_accessor_body_in_accessor_declarations6504);
                    accessor_body();

                    state._fsp--;
                    if (state.failed) return ;

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1487:44: ( get_accessor_declaration )?
                    int alt223=2;
                    int LA223_0 = input.LA(1);

                    if ( (LA223_0==IDENTIFIER||LA223_0==INTERNAL||LA223_0==OPEN_BRACKET||(LA223_0 >= PRIVATE && LA223_0 <= PROTECTED)) ) {
                        alt223=1;
                    }
                    switch (alt223) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1487:44: get_accessor_declaration
                            {
                            pushFollow(FOLLOW_get_accessor_declaration_in_accessor_declarations6506);
                            get_accessor_declaration();

                            state._fsp--;
                            if (state.failed) return ;

                            }
                            break;

                    }


                    }
                    break;

            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "accessor_declarations"



    // $ANTLR start "get_accessor_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1490:1: get_accessor_declaration : ( attributes )? ( accessor_modifier )? get_contextual_keyword accessor_body ;
    public final void get_accessor_declaration() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1491:2: ( ( attributes )? ( accessor_modifier )? get_contextual_keyword accessor_body )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1491:4: ( attributes )? ( accessor_modifier )? get_contextual_keyword accessor_body
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1491:4: ( attributes )?
            int alt225=2;
            int LA225_0 = input.LA(1);

            if ( (LA225_0==OPEN_BRACKET) ) {
                alt225=1;
            }
            switch (alt225) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1491:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_get_accessor_declaration6525);
                    attributes();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1491:16: ( accessor_modifier )?
            int alt226=2;
            int LA226_0 = input.LA(1);

            if ( (LA226_0==INTERNAL||(LA226_0 >= PRIVATE && LA226_0 <= PROTECTED)) ) {
                alt226=1;
            }
            switch (alt226) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1491:16: accessor_modifier
                    {
                    pushFollow(FOLLOW_accessor_modifier_in_get_accessor_declaration6528);
                    accessor_modifier();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            pushFollow(FOLLOW_get_contextual_keyword_in_get_accessor_declaration6531);
            get_contextual_keyword();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_accessor_body_in_get_accessor_declaration6533);
            accessor_body();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "get_accessor_declaration"



    // $ANTLR start "set_accessor_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1493:1: set_accessor_declaration : ( attributes )? ( accessor_modifier )? set_contextual_keyword accessor_body ;
    public final void set_accessor_declaration() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1494:2: ( ( attributes )? ( accessor_modifier )? set_contextual_keyword accessor_body )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1494:4: ( attributes )? ( accessor_modifier )? set_contextual_keyword accessor_body
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1494:4: ( attributes )?
            int alt227=2;
            int LA227_0 = input.LA(1);

            if ( (LA227_0==OPEN_BRACKET) ) {
                alt227=1;
            }
            switch (alt227) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1494:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_set_accessor_declaration6544);
                    attributes();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1494:16: ( accessor_modifier )?
            int alt228=2;
            int LA228_0 = input.LA(1);

            if ( (LA228_0==INTERNAL||(LA228_0 >= PRIVATE && LA228_0 <= PROTECTED)) ) {
                alt228=1;
            }
            switch (alt228) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1494:16: accessor_modifier
                    {
                    pushFollow(FOLLOW_accessor_modifier_in_set_accessor_declaration6547);
                    accessor_modifier();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            pushFollow(FOLLOW_set_contextual_keyword_in_set_accessor_declaration6550);
            set_contextual_keyword();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_accessor_body_in_set_accessor_declaration6552);
            accessor_body();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "set_accessor_declaration"



    // $ANTLR start "accessor_modifier"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1496:1: accessor_modifier : ( PROTECTED | INTERNAL | PRIVATE | PROTECTED INTERNAL | INTERNAL PROTECTED );
    public final void accessor_modifier() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1497:2: ( PROTECTED | INTERNAL | PRIVATE | PROTECTED INTERNAL | INTERNAL PROTECTED )
            int alt229=5;
            switch ( input.LA(1) ) {
            case PROTECTED:
                {
                int LA229_1 = input.LA(2);

                if ( (LA229_1==INTERNAL) ) {
                    alt229=4;
                }
                else if ( (LA229_1==IDENTIFIER) ) {
                    alt229=1;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 229, 1, input);

                    throw nvae;

                }
                }
                break;
            case INTERNAL:
                {
                int LA229_2 = input.LA(2);

                if ( (LA229_2==PROTECTED) ) {
                    alt229=5;
                }
                else if ( (LA229_2==IDENTIFIER) ) {
                    alt229=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 229, 2, input);

                    throw nvae;

                }
                }
                break;
            case PRIVATE:
                {
                alt229=3;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 229, 0, input);

                throw nvae;

            }

            switch (alt229) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1497:4: PROTECTED
                    {
                    match(input,PROTECTED,FOLLOW_PROTECTED_in_accessor_modifier6563); if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1498:4: INTERNAL
                    {
                    match(input,INTERNAL,FOLLOW_INTERNAL_in_accessor_modifier6568); if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1499:4: PRIVATE
                    {
                    match(input,PRIVATE,FOLLOW_PRIVATE_in_accessor_modifier6573); if (state.failed) return ;

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1500:4: PROTECTED INTERNAL
                    {
                    match(input,PROTECTED,FOLLOW_PROTECTED_in_accessor_modifier6578); if (state.failed) return ;

                    match(input,INTERNAL,FOLLOW_INTERNAL_in_accessor_modifier6580); if (state.failed) return ;

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1501:4: INTERNAL PROTECTED
                    {
                    match(input,INTERNAL,FOLLOW_INTERNAL_in_accessor_modifier6585); if (state.failed) return ;

                    match(input,PROTECTED,FOLLOW_PROTECTED_in_accessor_modifier6587); if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "accessor_modifier"



    // $ANTLR start "accessor_body"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1503:1: accessor_body : ( block | SEMICOLON );
    public final void accessor_body() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1504:2: ( block | SEMICOLON )
            int alt230=2;
            int LA230_0 = input.LA(1);

            if ( (LA230_0==OPEN_BRACE) ) {
                alt230=1;
            }
            else if ( (LA230_0==SEMICOLON) ) {
                alt230=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 230, 0, input);

                throw nvae;

            }
            switch (alt230) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1504:4: block
                    {
                    pushFollow(FOLLOW_block_in_accessor_body6598);
                    block();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1505:4: SEMICOLON
                    {
                    match(input,SEMICOLON,FOLLOW_SEMICOLON_in_accessor_body6603); if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "accessor_body"



    // $ANTLR start "event_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1513:1: event_declaration : ( attributes )? ( event_modifiers )? EVENT type ( variable_declarators SEMICOLON | member_name OPEN_BRACE event_accessor_declarations CLOSE_BRACE ) ;
    public final void event_declaration() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1514:3: ( ( attributes )? ( event_modifiers )? EVENT type ( variable_declarators SEMICOLON | member_name OPEN_BRACE event_accessor_declarations CLOSE_BRACE ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1514:5: ( attributes )? ( event_modifiers )? EVENT type ( variable_declarators SEMICOLON | member_name OPEN_BRACE event_accessor_declarations CLOSE_BRACE )
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1514:5: ( attributes )?
            int alt231=2;
            int LA231_0 = input.LA(1);

            if ( (LA231_0==OPEN_BRACKET) ) {
                alt231=1;
            }
            switch (alt231) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1514:5: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_event_declaration6617);
                    attributes();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1514:17: ( event_modifiers )?
            int alt232=2;
            int LA232_0 = input.LA(1);

            if ( (LA232_0==ABSTRACT||LA232_0==EXTERN||LA232_0==INTERNAL||LA232_0==NEW||LA232_0==OVERRIDE||(LA232_0 >= PRIVATE && LA232_0 <= PUBLIC)||LA232_0==SEALED||LA232_0==STATIC||LA232_0==UNSAFE||LA232_0==VIRTUAL) ) {
                alt232=1;
            }
            switch (alt232) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1514:17: event_modifiers
                    {
                    pushFollow(FOLLOW_event_modifiers_in_event_declaration6620);
                    event_modifiers();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,EVENT,FOLLOW_EVENT_in_event_declaration6623); if (state.failed) return ;

            pushFollow(FOLLOW_type_in_event_declaration6625);
            type();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1515:5: ( variable_declarators SEMICOLON | member_name OPEN_BRACE event_accessor_declarations CLOSE_BRACE )
            int alt233=2;
            int LA233_0 = input.LA(1);

            if ( (LA233_0==IDENTIFIER) ) {
                int LA233_1 = input.LA(2);

                if ( (LA233_1==ASSIGNMENT||LA233_1==COMMA||LA233_1==SEMICOLON) ) {
                    alt233=1;
                }
                else if ( (LA233_1==DOT||LA233_1==DOUBLE_COLON||LA233_1==LT||LA233_1==OPEN_BRACE) ) {
                    alt233=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 233, 1, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 233, 0, input);

                throw nvae;

            }
            switch (alt233) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1515:7: variable_declarators SEMICOLON
                    {
                    pushFollow(FOLLOW_variable_declarators_in_event_declaration6633);
                    variable_declarators();

                    state._fsp--;
                    if (state.failed) return ;

                    match(input,SEMICOLON,FOLLOW_SEMICOLON_in_event_declaration6635); if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1516:7: member_name OPEN_BRACE event_accessor_declarations CLOSE_BRACE
                    {
                    pushFollow(FOLLOW_member_name_in_event_declaration6643);
                    member_name();

                    state._fsp--;
                    if (state.failed) return ;

                    match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_event_declaration6645); if (state.failed) return ;

                    pushFollow(FOLLOW_event_accessor_declarations_in_event_declaration6647);
                    event_accessor_declarations();

                    state._fsp--;
                    if (state.failed) return ;

                    match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_event_declaration6649); if (state.failed) return ;

                    }
                    break;

            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "event_declaration"



    // $ANTLR start "event_modifiers"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1519:1: event_modifiers : event_modifier ( event_modifier )* ;
    public final void event_modifiers() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1520:2: ( event_modifier ( event_modifier )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1520:4: event_modifier ( event_modifier )*
            {
            pushFollow(FOLLOW_event_modifier_in_event_modifiers6667);
            event_modifier();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1520:19: ( event_modifier )*
            loop234:
            do {
                int alt234=2;
                int LA234_0 = input.LA(1);

                if ( (LA234_0==ABSTRACT||LA234_0==EXTERN||LA234_0==INTERNAL||LA234_0==NEW||LA234_0==OVERRIDE||(LA234_0 >= PRIVATE && LA234_0 <= PUBLIC)||LA234_0==SEALED||LA234_0==STATIC||LA234_0==UNSAFE||LA234_0==VIRTUAL) ) {
                    alt234=1;
                }


                switch (alt234) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1520:21: event_modifier
            	    {
            	    pushFollow(FOLLOW_event_modifier_in_event_modifiers6671);
            	    event_modifier();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop234;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "event_modifiers"



    // $ANTLR start "event_modifier"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1522:1: event_modifier : ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | STATIC | VIRTUAL | SEALED | OVERRIDE | ABSTRACT | EXTERN | event_modifier_unsafe );
    public final void event_modifier() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1523:2: ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | STATIC | VIRTUAL | SEALED | OVERRIDE | ABSTRACT | EXTERN | event_modifier_unsafe )
            int alt235=12;
            switch ( input.LA(1) ) {
            case NEW:
                {
                alt235=1;
                }
                break;
            case PUBLIC:
                {
                alt235=2;
                }
                break;
            case PROTECTED:
                {
                alt235=3;
                }
                break;
            case INTERNAL:
                {
                alt235=4;
                }
                break;
            case PRIVATE:
                {
                alt235=5;
                }
                break;
            case STATIC:
                {
                alt235=6;
                }
                break;
            case VIRTUAL:
                {
                alt235=7;
                }
                break;
            case SEALED:
                {
                alt235=8;
                }
                break;
            case OVERRIDE:
                {
                alt235=9;
                }
                break;
            case ABSTRACT:
                {
                alt235=10;
                }
                break;
            case EXTERN:
                {
                alt235=11;
                }
                break;
            case UNSAFE:
                {
                alt235=12;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 235, 0, input);

                throw nvae;

            }

            switch (alt235) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1523:4: NEW
                    {
                    match(input,NEW,FOLLOW_NEW_in_event_modifier6685); if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1524:4: PUBLIC
                    {
                    match(input,PUBLIC,FOLLOW_PUBLIC_in_event_modifier6690); if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1525:4: PROTECTED
                    {
                    match(input,PROTECTED,FOLLOW_PROTECTED_in_event_modifier6695); if (state.failed) return ;

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1526:4: INTERNAL
                    {
                    match(input,INTERNAL,FOLLOW_INTERNAL_in_event_modifier6700); if (state.failed) return ;

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1527:4: PRIVATE
                    {
                    match(input,PRIVATE,FOLLOW_PRIVATE_in_event_modifier6705); if (state.failed) return ;

                    }
                    break;
                case 6 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1528:4: STATIC
                    {
                    match(input,STATIC,FOLLOW_STATIC_in_event_modifier6710); if (state.failed) return ;

                    }
                    break;
                case 7 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1529:4: VIRTUAL
                    {
                    match(input,VIRTUAL,FOLLOW_VIRTUAL_in_event_modifier6715); if (state.failed) return ;

                    }
                    break;
                case 8 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1530:4: SEALED
                    {
                    match(input,SEALED,FOLLOW_SEALED_in_event_modifier6720); if (state.failed) return ;

                    }
                    break;
                case 9 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1531:4: OVERRIDE
                    {
                    match(input,OVERRIDE,FOLLOW_OVERRIDE_in_event_modifier6725); if (state.failed) return ;

                    }
                    break;
                case 10 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1532:4: ABSTRACT
                    {
                    match(input,ABSTRACT,FOLLOW_ABSTRACT_in_event_modifier6730); if (state.failed) return ;

                    }
                    break;
                case 11 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1533:4: EXTERN
                    {
                    match(input,EXTERN,FOLLOW_EXTERN_in_event_modifier6735); if (state.failed) return ;

                    }
                    break;
                case 12 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1534:4: event_modifier_unsafe
                    {
                    pushFollow(FOLLOW_event_modifier_unsafe_in_event_modifier6740);
                    event_modifier_unsafe();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "event_modifier"



    // $ANTLR start "event_accessor_declarations"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1536:1: event_accessor_declarations : ( attributes )? ( add_contextual_keyword block remove_accessor_declaration | remove_contextual_keyword block add_accessor_declaration ) ;
    public final void event_accessor_declarations() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1537:2: ( ( attributes )? ( add_contextual_keyword block remove_accessor_declaration | remove_contextual_keyword block add_accessor_declaration ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1537:4: ( attributes )? ( add_contextual_keyword block remove_accessor_declaration | remove_contextual_keyword block add_accessor_declaration )
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1537:4: ( attributes )?
            int alt236=2;
            int LA236_0 = input.LA(1);

            if ( (LA236_0==OPEN_BRACKET) ) {
                alt236=1;
            }
            switch (alt236) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1537:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_event_accessor_declarations6751);
                    attributes();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1538:4: ( add_contextual_keyword block remove_accessor_declaration | remove_contextual_keyword block add_accessor_declaration )
            int alt237=2;
            int LA237_0 = input.LA(1);

            if ( (LA237_0==IDENTIFIER) ) {
                int LA237_1 = input.LA(2);

                if ( ((input.LT(1).getText().equals("add"))) ) {
                    alt237=1;
                }
                else if ( ((input.LT(1).getText().equals("remove"))) ) {
                    alt237=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 237, 1, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 237, 0, input);

                throw nvae;

            }
            switch (alt237) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1538:6: add_contextual_keyword block remove_accessor_declaration
                    {
                    pushFollow(FOLLOW_add_contextual_keyword_in_event_accessor_declarations6759);
                    add_contextual_keyword();

                    state._fsp--;
                    if (state.failed) return ;

                    pushFollow(FOLLOW_block_in_event_accessor_declarations6761);
                    block();

                    state._fsp--;
                    if (state.failed) return ;

                    pushFollow(FOLLOW_remove_accessor_declaration_in_event_accessor_declarations6763);
                    remove_accessor_declaration();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1539:6: remove_contextual_keyword block add_accessor_declaration
                    {
                    pushFollow(FOLLOW_remove_contextual_keyword_in_event_accessor_declarations6770);
                    remove_contextual_keyword();

                    state._fsp--;
                    if (state.failed) return ;

                    pushFollow(FOLLOW_block_in_event_accessor_declarations6772);
                    block();

                    state._fsp--;
                    if (state.failed) return ;

                    pushFollow(FOLLOW_add_accessor_declaration_in_event_accessor_declarations6774);
                    add_accessor_declaration();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "event_accessor_declarations"



    // $ANTLR start "add_accessor_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1542:1: add_accessor_declaration : ( attributes )? add_contextual_keyword block ;
    public final void add_accessor_declaration() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1543:2: ( ( attributes )? add_contextual_keyword block )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1543:4: ( attributes )? add_contextual_keyword block
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1543:4: ( attributes )?
            int alt238=2;
            int LA238_0 = input.LA(1);

            if ( (LA238_0==OPEN_BRACKET) ) {
                alt238=1;
            }
            switch (alt238) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1543:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_add_accessor_declaration6790);
                    attributes();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            pushFollow(FOLLOW_add_contextual_keyword_in_add_accessor_declaration6793);
            add_contextual_keyword();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_block_in_add_accessor_declaration6795);
            block();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "add_accessor_declaration"



    // $ANTLR start "remove_accessor_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1545:1: remove_accessor_declaration : ( attributes )? remove_contextual_keyword block ;
    public final void remove_accessor_declaration() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1546:2: ( ( attributes )? remove_contextual_keyword block )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1546:4: ( attributes )? remove_contextual_keyword block
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1546:4: ( attributes )?
            int alt239=2;
            int LA239_0 = input.LA(1);

            if ( (LA239_0==OPEN_BRACKET) ) {
                alt239=1;
            }
            switch (alt239) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1546:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_remove_accessor_declaration6806);
                    attributes();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            pushFollow(FOLLOW_remove_contextual_keyword_in_remove_accessor_declaration6809);
            remove_contextual_keyword();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_block_in_remove_accessor_declaration6811);
            block();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "remove_accessor_declaration"



    // $ANTLR start "indexer_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1548:1: indexer_declaration : ( attributes )? ( indexer_modifiers )? indexer_declarator OPEN_BRACE accessor_declarations CLOSE_BRACE ;
    public final void indexer_declaration() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1549:2: ( ( attributes )? ( indexer_modifiers )? indexer_declarator OPEN_BRACE accessor_declarations CLOSE_BRACE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1549:4: ( attributes )? ( indexer_modifiers )? indexer_declarator OPEN_BRACE accessor_declarations CLOSE_BRACE
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1549:4: ( attributes )?
            int alt240=2;
            int LA240_0 = input.LA(1);

            if ( (LA240_0==OPEN_BRACKET) ) {
                alt240=1;
            }
            switch (alt240) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1549:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_indexer_declaration6822);
                    attributes();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1549:16: ( indexer_modifiers )?
            int alt241=2;
            int LA241_0 = input.LA(1);

            if ( (LA241_0==ABSTRACT||LA241_0==EXTERN||LA241_0==INTERNAL||LA241_0==NEW||LA241_0==OVERRIDE||(LA241_0 >= PRIVATE && LA241_0 <= PUBLIC)||LA241_0==SEALED||LA241_0==UNSAFE||LA241_0==VIRTUAL) ) {
                alt241=1;
            }
            switch (alt241) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1549:16: indexer_modifiers
                    {
                    pushFollow(FOLLOW_indexer_modifiers_in_indexer_declaration6825);
                    indexer_modifiers();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            pushFollow(FOLLOW_indexer_declarator_in_indexer_declaration6828);
            indexer_declarator();

            state._fsp--;
            if (state.failed) return ;

            match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_indexer_declaration6830); if (state.failed) return ;

            pushFollow(FOLLOW_accessor_declarations_in_indexer_declaration6832);
            accessor_declarations();

            state._fsp--;
            if (state.failed) return ;

            match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_indexer_declaration6834); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "indexer_declaration"



    // $ANTLR start "indexer_modifiers"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1551:1: indexer_modifiers : indexer_modifier ( indexer_modifier )* ;
    public final void indexer_modifiers() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1552:2: ( indexer_modifier ( indexer_modifier )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1552:4: indexer_modifier ( indexer_modifier )*
            {
            pushFollow(FOLLOW_indexer_modifier_in_indexer_modifiers6845);
            indexer_modifier();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1552:21: ( indexer_modifier )*
            loop242:
            do {
                int alt242=2;
                int LA242_0 = input.LA(1);

                if ( (LA242_0==ABSTRACT||LA242_0==EXTERN||LA242_0==INTERNAL||LA242_0==NEW||LA242_0==OVERRIDE||(LA242_0 >= PRIVATE && LA242_0 <= PUBLIC)||LA242_0==SEALED||LA242_0==UNSAFE||LA242_0==VIRTUAL) ) {
                    alt242=1;
                }


                switch (alt242) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1552:23: indexer_modifier
            	    {
            	    pushFollow(FOLLOW_indexer_modifier_in_indexer_modifiers6849);
            	    indexer_modifier();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop242;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "indexer_modifiers"



    // $ANTLR start "indexer_modifier"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1554:1: indexer_modifier : ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | VIRTUAL | SEALED | OVERRIDE | ABSTRACT | EXTERN | indexer_modifier_unsafe );
    public final void indexer_modifier() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1555:2: ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | VIRTUAL | SEALED | OVERRIDE | ABSTRACT | EXTERN | indexer_modifier_unsafe )
            int alt243=11;
            switch ( input.LA(1) ) {
            case NEW:
                {
                alt243=1;
                }
                break;
            case PUBLIC:
                {
                alt243=2;
                }
                break;
            case PROTECTED:
                {
                alt243=3;
                }
                break;
            case INTERNAL:
                {
                alt243=4;
                }
                break;
            case PRIVATE:
                {
                alt243=5;
                }
                break;
            case VIRTUAL:
                {
                alt243=6;
                }
                break;
            case SEALED:
                {
                alt243=7;
                }
                break;
            case OVERRIDE:
                {
                alt243=8;
                }
                break;
            case ABSTRACT:
                {
                alt243=9;
                }
                break;
            case EXTERN:
                {
                alt243=10;
                }
                break;
            case UNSAFE:
                {
                alt243=11;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 243, 0, input);

                throw nvae;

            }

            switch (alt243) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1555:4: NEW
                    {
                    match(input,NEW,FOLLOW_NEW_in_indexer_modifier6863); if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1556:4: PUBLIC
                    {
                    match(input,PUBLIC,FOLLOW_PUBLIC_in_indexer_modifier6868); if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1557:4: PROTECTED
                    {
                    match(input,PROTECTED,FOLLOW_PROTECTED_in_indexer_modifier6873); if (state.failed) return ;

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1558:4: INTERNAL
                    {
                    match(input,INTERNAL,FOLLOW_INTERNAL_in_indexer_modifier6878); if (state.failed) return ;

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1559:4: PRIVATE
                    {
                    match(input,PRIVATE,FOLLOW_PRIVATE_in_indexer_modifier6883); if (state.failed) return ;

                    }
                    break;
                case 6 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1560:4: VIRTUAL
                    {
                    match(input,VIRTUAL,FOLLOW_VIRTUAL_in_indexer_modifier6888); if (state.failed) return ;

                    }
                    break;
                case 7 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1561:4: SEALED
                    {
                    match(input,SEALED,FOLLOW_SEALED_in_indexer_modifier6893); if (state.failed) return ;

                    }
                    break;
                case 8 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1562:4: OVERRIDE
                    {
                    match(input,OVERRIDE,FOLLOW_OVERRIDE_in_indexer_modifier6898); if (state.failed) return ;

                    }
                    break;
                case 9 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1563:4: ABSTRACT
                    {
                    match(input,ABSTRACT,FOLLOW_ABSTRACT_in_indexer_modifier6903); if (state.failed) return ;

                    }
                    break;
                case 10 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1564:4: EXTERN
                    {
                    match(input,EXTERN,FOLLOW_EXTERN_in_indexer_modifier6908); if (state.failed) return ;

                    }
                    break;
                case 11 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1565:4: indexer_modifier_unsafe
                    {
                    pushFollow(FOLLOW_indexer_modifier_unsafe_in_indexer_modifier6913);
                    indexer_modifier_unsafe();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "indexer_modifier"



    // $ANTLR start "indexer_declarator"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1573:1: indexer_declarator : type ( interface_type DOT )? THIS OPEN_BRACKET formal_parameter_list CLOSE_BRACKET ;
    public final void indexer_declarator() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1574:3: ( type ( interface_type DOT )? THIS OPEN_BRACKET formal_parameter_list CLOSE_BRACKET )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1574:5: type ( interface_type DOT )? THIS OPEN_BRACKET formal_parameter_list CLOSE_BRACKET
            {
            pushFollow(FOLLOW_type_in_indexer_declarator6927);
            type();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1574:10: ( interface_type DOT )?
            int alt244=2;
            int LA244_0 = input.LA(1);

            if ( (LA244_0==IDENTIFIER) ) {
                alt244=1;
            }
            switch (alt244) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1574:11: interface_type DOT
                    {
                    pushFollow(FOLLOW_interface_type_in_indexer_declarator6930);
                    interface_type();

                    state._fsp--;
                    if (state.failed) return ;

                    match(input,DOT,FOLLOW_DOT_in_indexer_declarator6932); if (state.failed) return ;

                    }
                    break;

            }


            match(input,THIS,FOLLOW_THIS_in_indexer_declarator6936); if (state.failed) return ;

            match(input,OPEN_BRACKET,FOLLOW_OPEN_BRACKET_in_indexer_declarator6938); if (state.failed) return ;

            pushFollow(FOLLOW_formal_parameter_list_in_indexer_declarator6940);
            formal_parameter_list();

            state._fsp--;
            if (state.failed) return ;

            match(input,CLOSE_BRACKET,FOLLOW_CLOSE_BRACKET_in_indexer_declarator6942); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "indexer_declarator"



    // $ANTLR start "operator_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1576:1: operator_declaration : ( attributes )? operator_modifiers operator_declarator operator_body ;
    public final void operator_declaration() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1577:2: ( ( attributes )? operator_modifiers operator_declarator operator_body )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1577:4: ( attributes )? operator_modifiers operator_declarator operator_body
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1577:4: ( attributes )?
            int alt245=2;
            int LA245_0 = input.LA(1);

            if ( (LA245_0==OPEN_BRACKET) ) {
                alt245=1;
            }
            switch (alt245) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1577:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_operator_declaration6954);
                    attributes();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            pushFollow(FOLLOW_operator_modifiers_in_operator_declaration6957);
            operator_modifiers();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_operator_declarator_in_operator_declaration6959);
            operator_declarator();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_operator_body_in_operator_declaration6961);
            operator_body();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "operator_declaration"



    // $ANTLR start "operator_modifiers"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1579:1: operator_modifiers : operator_modifier ( operator_modifier )* ;
    public final void operator_modifiers() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1580:2: ( operator_modifier ( operator_modifier )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1580:4: operator_modifier ( operator_modifier )*
            {
            pushFollow(FOLLOW_operator_modifier_in_operator_modifiers6972);
            operator_modifier();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1580:22: ( operator_modifier )*
            loop246:
            do {
                int alt246=2;
                int LA246_0 = input.LA(1);

                if ( (LA246_0==EXTERN||LA246_0==PUBLIC||LA246_0==STATIC||LA246_0==UNSAFE) ) {
                    alt246=1;
                }


                switch (alt246) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1580:24: operator_modifier
            	    {
            	    pushFollow(FOLLOW_operator_modifier_in_operator_modifiers6976);
            	    operator_modifier();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop246;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "operator_modifiers"



    // $ANTLR start "operator_modifier"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1582:1: operator_modifier : ( PUBLIC | STATIC | EXTERN | operator_modifier_unsafe );
    public final void operator_modifier() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1583:2: ( PUBLIC | STATIC | EXTERN | operator_modifier_unsafe )
            int alt247=4;
            switch ( input.LA(1) ) {
            case PUBLIC:
                {
                alt247=1;
                }
                break;
            case STATIC:
                {
                alt247=2;
                }
                break;
            case EXTERN:
                {
                alt247=3;
                }
                break;
            case UNSAFE:
                {
                alt247=4;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 247, 0, input);

                throw nvae;

            }

            switch (alt247) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1583:4: PUBLIC
                    {
                    match(input,PUBLIC,FOLLOW_PUBLIC_in_operator_modifier6990); if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1584:4: STATIC
                    {
                    match(input,STATIC,FOLLOW_STATIC_in_operator_modifier6995); if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1585:4: EXTERN
                    {
                    match(input,EXTERN,FOLLOW_EXTERN_in_operator_modifier7000); if (state.failed) return ;

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1586:4: operator_modifier_unsafe
                    {
                    pushFollow(FOLLOW_operator_modifier_unsafe_in_operator_modifier7005);
                    operator_modifier_unsafe();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "operator_modifier"



    // $ANTLR start "operator_declarator"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1595:1: operator_declarator : ( ( unary_operator_declarator )=> unary_operator_declarator | binary_operator_declarator | conversion_operator_declarator );
    public final void operator_declarator() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1596:3: ( ( unary_operator_declarator )=> unary_operator_declarator | binary_operator_declarator | conversion_operator_declarator )
            int alt248=3;
            switch ( input.LA(1) ) {
            case BYTE:
            case CHAR:
            case INT:
            case LONG:
            case SBYTE:
            case SHORT:
            case UINT:
            case ULONG:
            case USHORT:
                {
                int LA248_1 = input.LA(2);

                if ( (synpred26_CSharp4()) ) {
                    alt248=1;
                }
                else if ( (true) ) {
                    alt248=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 248, 1, input);

                    throw nvae;

                }
                }
                break;
            case DOUBLE:
            case FLOAT:
                {
                int LA248_2 = input.LA(2);

                if ( (synpred26_CSharp4()) ) {
                    alt248=1;
                }
                else if ( (true) ) {
                    alt248=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 248, 2, input);

                    throw nvae;

                }
                }
                break;
            case DECIMAL:
                {
                int LA248_3 = input.LA(2);

                if ( (synpred26_CSharp4()) ) {
                    alt248=1;
                }
                else if ( (true) ) {
                    alt248=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 248, 3, input);

                    throw nvae;

                }
                }
                break;
            case BOOL:
                {
                int LA248_4 = input.LA(2);

                if ( (synpred26_CSharp4()) ) {
                    alt248=1;
                }
                else if ( (true) ) {
                    alt248=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 248, 4, input);

                    throw nvae;

                }
                }
                break;
            case IDENTIFIER:
                {
                int LA248_5 = input.LA(2);

                if ( (synpred26_CSharp4()) ) {
                    alt248=1;
                }
                else if ( (true) ) {
                    alt248=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 248, 5, input);

                    throw nvae;

                }
                }
                break;
            case OBJECT:
                {
                int LA248_6 = input.LA(2);

                if ( (synpred26_CSharp4()) ) {
                    alt248=1;
                }
                else if ( (true) ) {
                    alt248=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 248, 6, input);

                    throw nvae;

                }
                }
                break;
            case STRING:
                {
                int LA248_7 = input.LA(2);

                if ( (synpred26_CSharp4()) ) {
                    alt248=1;
                }
                else if ( (true) ) {
                    alt248=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 248, 7, input);

                    throw nvae;

                }
                }
                break;
            case VOID:
                {
                int LA248_8 = input.LA(2);

                if ( (synpred26_CSharp4()) ) {
                    alt248=1;
                }
                else if ( (true) ) {
                    alt248=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 248, 8, input);

                    throw nvae;

                }
                }
                break;
            case EXPLICIT:
            case IMPLICIT:
                {
                alt248=3;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 248, 0, input);

                throw nvae;

            }

            switch (alt248) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1596:5: ( unary_operator_declarator )=> unary_operator_declarator
                    {
                    pushFollow(FOLLOW_unary_operator_declarator_in_operator_declarator7025);
                    unary_operator_declarator();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1597:5: binary_operator_declarator
                    {
                    pushFollow(FOLLOW_binary_operator_declarator_in_operator_declarator7031);
                    binary_operator_declarator();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1598:5: conversion_operator_declarator
                    {
                    pushFollow(FOLLOW_conversion_operator_declarator_in_operator_declarator7037);
                    conversion_operator_declarator();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "operator_declarator"



    // $ANTLR start "unary_operator_declarator"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1600:1: unary_operator_declarator : type OPERATOR overloadable_unary_operator OPEN_PARENS type IDENTIFIER CLOSE_PARENS ;
    public final void unary_operator_declarator() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1601:2: ( type OPERATOR overloadable_unary_operator OPEN_PARENS type IDENTIFIER CLOSE_PARENS )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1601:4: type OPERATOR overloadable_unary_operator OPEN_PARENS type IDENTIFIER CLOSE_PARENS
            {
            pushFollow(FOLLOW_type_in_unary_operator_declarator7049);
            type();

            state._fsp--;
            if (state.failed) return ;

            match(input,OPERATOR,FOLLOW_OPERATOR_in_unary_operator_declarator7051); if (state.failed) return ;

            pushFollow(FOLLOW_overloadable_unary_operator_in_unary_operator_declarator7053);
            overloadable_unary_operator();

            state._fsp--;
            if (state.failed) return ;

            match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_unary_operator_declarator7055); if (state.failed) return ;

            pushFollow(FOLLOW_type_in_unary_operator_declarator7057);
            type();

            state._fsp--;
            if (state.failed) return ;

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_unary_operator_declarator7059); if (state.failed) return ;

            match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_unary_operator_declarator7061); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "unary_operator_declarator"



    // $ANTLR start "overloadable_unary_operator"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1603:1: overloadable_unary_operator : ( PLUS | MINUS | BANG | TILDE | OP_INC | OP_DEC | TRUE | FALSE );
    public final void overloadable_unary_operator() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1604:2: ( PLUS | MINUS | BANG | TILDE | OP_INC | OP_DEC | TRUE | FALSE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:
            {
            if ( input.LA(1)==BANG||input.LA(1)==FALSE||input.LA(1)==MINUS||input.LA(1)==OP_DEC||input.LA(1)==OP_INC||input.LA(1)==PLUS||(input.LA(1) >= TILDE && input.LA(1) <= TRUE) ) {
                input.consume();
                state.errorRecovery=false;
                state.failed=false;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                MismatchedSetException mse = new MismatchedSetException(null,input);
                throw mse;
            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "overloadable_unary_operator"



    // $ANTLR start "binary_operator_declarator"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1613:1: binary_operator_declarator : type OPERATOR overloadable_binary_operator OPEN_PARENS type IDENTIFIER COMMA type IDENTIFIER CLOSE_PARENS ;
    public final void binary_operator_declarator() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1614:2: ( type OPERATOR overloadable_binary_operator OPEN_PARENS type IDENTIFIER COMMA type IDENTIFIER CLOSE_PARENS )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1614:4: type OPERATOR overloadable_binary_operator OPEN_PARENS type IDENTIFIER COMMA type IDENTIFIER CLOSE_PARENS
            {
            pushFollow(FOLLOW_type_in_binary_operator_declarator7118);
            type();

            state._fsp--;
            if (state.failed) return ;

            match(input,OPERATOR,FOLLOW_OPERATOR_in_binary_operator_declarator7120); if (state.failed) return ;

            pushFollow(FOLLOW_overloadable_binary_operator_in_binary_operator_declarator7122);
            overloadable_binary_operator();

            state._fsp--;
            if (state.failed) return ;

            match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_binary_operator_declarator7124); if (state.failed) return ;

            pushFollow(FOLLOW_type_in_binary_operator_declarator7126);
            type();

            state._fsp--;
            if (state.failed) return ;

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_binary_operator_declarator7128); if (state.failed) return ;

            match(input,COMMA,FOLLOW_COMMA_in_binary_operator_declarator7130); if (state.failed) return ;

            pushFollow(FOLLOW_type_in_binary_operator_declarator7132);
            type();

            state._fsp--;
            if (state.failed) return ;

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_binary_operator_declarator7134); if (state.failed) return ;

            match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_binary_operator_declarator7136); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "binary_operator_declarator"



    // $ANTLR start "overloadable_binary_operator"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1616:1: overloadable_binary_operator : ( PLUS | MINUS | STAR | DIV | PERCENT | AMP | BITWISE_OR | CARET | OP_LEFT_SHIFT | right_shift | OP_EQ | OP_NE | GT | LT | OP_GE | OP_LE );
    public final void overloadable_binary_operator() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1617:2: ( PLUS | MINUS | STAR | DIV | PERCENT | AMP | BITWISE_OR | CARET | OP_LEFT_SHIFT | right_shift | OP_EQ | OP_NE | GT | LT | OP_GE | OP_LE )
            int alt249=16;
            switch ( input.LA(1) ) {
            case PLUS:
                {
                alt249=1;
                }
                break;
            case MINUS:
                {
                alt249=2;
                }
                break;
            case STAR:
                {
                alt249=3;
                }
                break;
            case DIV:
                {
                alt249=4;
                }
                break;
            case PERCENT:
                {
                alt249=5;
                }
                break;
            case AMP:
                {
                alt249=6;
                }
                break;
            case BITWISE_OR:
                {
                alt249=7;
                }
                break;
            case CARET:
                {
                alt249=8;
                }
                break;
            case OP_LEFT_SHIFT:
                {
                alt249=9;
                }
                break;
            case GT:
                {
                int LA249_10 = input.LA(2);

                if ( (LA249_10==GT) ) {
                    alt249=10;
                }
                else if ( (LA249_10==OPEN_PARENS) ) {
                    alt249=13;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 249, 10, input);

                    throw nvae;

                }
                }
                break;
            case OP_EQ:
                {
                alt249=11;
                }
                break;
            case OP_NE:
                {
                alt249=12;
                }
                break;
            case LT:
                {
                alt249=14;
                }
                break;
            case OP_GE:
                {
                alt249=15;
                }
                break;
            case OP_LE:
                {
                alt249=16;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 249, 0, input);

                throw nvae;

            }

            switch (alt249) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1617:4: PLUS
                    {
                    match(input,PLUS,FOLLOW_PLUS_in_overloadable_binary_operator7147); if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1618:4: MINUS
                    {
                    match(input,MINUS,FOLLOW_MINUS_in_overloadable_binary_operator7152); if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1619:4: STAR
                    {
                    match(input,STAR,FOLLOW_STAR_in_overloadable_binary_operator7157); if (state.failed) return ;

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1620:4: DIV
                    {
                    match(input,DIV,FOLLOW_DIV_in_overloadable_binary_operator7162); if (state.failed) return ;

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1621:4: PERCENT
                    {
                    match(input,PERCENT,FOLLOW_PERCENT_in_overloadable_binary_operator7167); if (state.failed) return ;

                    }
                    break;
                case 6 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1622:4: AMP
                    {
                    match(input,AMP,FOLLOW_AMP_in_overloadable_binary_operator7172); if (state.failed) return ;

                    }
                    break;
                case 7 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1623:4: BITWISE_OR
                    {
                    match(input,BITWISE_OR,FOLLOW_BITWISE_OR_in_overloadable_binary_operator7177); if (state.failed) return ;

                    }
                    break;
                case 8 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1624:4: CARET
                    {
                    match(input,CARET,FOLLOW_CARET_in_overloadable_binary_operator7182); if (state.failed) return ;

                    }
                    break;
                case 9 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1625:4: OP_LEFT_SHIFT
                    {
                    match(input,OP_LEFT_SHIFT,FOLLOW_OP_LEFT_SHIFT_in_overloadable_binary_operator7187); if (state.failed) return ;

                    }
                    break;
                case 10 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1626:4: right_shift
                    {
                    pushFollow(FOLLOW_right_shift_in_overloadable_binary_operator7192);
                    right_shift();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 11 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1627:4: OP_EQ
                    {
                    match(input,OP_EQ,FOLLOW_OP_EQ_in_overloadable_binary_operator7197); if (state.failed) return ;

                    }
                    break;
                case 12 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1628:4: OP_NE
                    {
                    match(input,OP_NE,FOLLOW_OP_NE_in_overloadable_binary_operator7202); if (state.failed) return ;

                    }
                    break;
                case 13 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1629:4: GT
                    {
                    match(input,GT,FOLLOW_GT_in_overloadable_binary_operator7207); if (state.failed) return ;

                    }
                    break;
                case 14 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1630:4: LT
                    {
                    match(input,LT,FOLLOW_LT_in_overloadable_binary_operator7212); if (state.failed) return ;

                    }
                    break;
                case 15 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1631:4: OP_GE
                    {
                    match(input,OP_GE,FOLLOW_OP_GE_in_overloadable_binary_operator7217); if (state.failed) return ;

                    }
                    break;
                case 16 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1632:4: OP_LE
                    {
                    match(input,OP_LE,FOLLOW_OP_LE_in_overloadable_binary_operator7222); if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "overloadable_binary_operator"



    // $ANTLR start "overloadable_operator"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1636:1: overloadable_operator : ( PLUS | MINUS | BANG | TILDE | OP_INC | OP_DEC | TRUE | FALSE | STAR | DIV | PERCENT | AMP | BITWISE_OR | CARET | OP_LEFT_SHIFT | right_shift | OP_EQ | OP_NE | GT | LT | OP_GE | OP_LE );
    public final void overloadable_operator() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1637:3: ( PLUS | MINUS | BANG | TILDE | OP_INC | OP_DEC | TRUE | FALSE | STAR | DIV | PERCENT | AMP | BITWISE_OR | CARET | OP_LEFT_SHIFT | right_shift | OP_EQ | OP_NE | GT | LT | OP_GE | OP_LE )
            int alt250=22;
            switch ( input.LA(1) ) {
            case PLUS:
                {
                alt250=1;
                }
                break;
            case MINUS:
                {
                alt250=2;
                }
                break;
            case BANG:
                {
                alt250=3;
                }
                break;
            case TILDE:
                {
                alt250=4;
                }
                break;
            case OP_INC:
                {
                alt250=5;
                }
                break;
            case OP_DEC:
                {
                alt250=6;
                }
                break;
            case TRUE:
                {
                alt250=7;
                }
                break;
            case FALSE:
                {
                alt250=8;
                }
                break;
            case STAR:
                {
                alt250=9;
                }
                break;
            case DIV:
                {
                alt250=10;
                }
                break;
            case PERCENT:
                {
                alt250=11;
                }
                break;
            case AMP:
                {
                alt250=12;
                }
                break;
            case BITWISE_OR:
                {
                alt250=13;
                }
                break;
            case CARET:
                {
                alt250=14;
                }
                break;
            case OP_LEFT_SHIFT:
                {
                alt250=15;
                }
                break;
            case GT:
                {
                int LA250_16 = input.LA(2);

                if ( (LA250_16==GT) ) {
                    alt250=16;
                }
                else if ( (LA250_16==OPEN_PARENS) ) {
                    alt250=19;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 250, 16, input);

                    throw nvae;

                }
                }
                break;
            case OP_EQ:
                {
                alt250=17;
                }
                break;
            case OP_NE:
                {
                alt250=18;
                }
                break;
            case LT:
                {
                alt250=20;
                }
                break;
            case OP_GE:
                {
                alt250=21;
                }
                break;
            case OP_LE:
                {
                alt250=22;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 250, 0, input);

                throw nvae;

            }

            switch (alt250) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1637:5: PLUS
                    {
                    match(input,PLUS,FOLLOW_PLUS_in_overloadable_operator7236); if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1638:5: MINUS
                    {
                    match(input,MINUS,FOLLOW_MINUS_in_overloadable_operator7242); if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1639:5: BANG
                    {
                    match(input,BANG,FOLLOW_BANG_in_overloadable_operator7248); if (state.failed) return ;

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1640:5: TILDE
                    {
                    match(input,TILDE,FOLLOW_TILDE_in_overloadable_operator7254); if (state.failed) return ;

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1641:5: OP_INC
                    {
                    match(input,OP_INC,FOLLOW_OP_INC_in_overloadable_operator7260); if (state.failed) return ;

                    }
                    break;
                case 6 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1642:5: OP_DEC
                    {
                    match(input,OP_DEC,FOLLOW_OP_DEC_in_overloadable_operator7266); if (state.failed) return ;

                    }
                    break;
                case 7 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1643:5: TRUE
                    {
                    match(input,TRUE,FOLLOW_TRUE_in_overloadable_operator7272); if (state.failed) return ;

                    }
                    break;
                case 8 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1644:5: FALSE
                    {
                    match(input,FALSE,FOLLOW_FALSE_in_overloadable_operator7278); if (state.failed) return ;

                    }
                    break;
                case 9 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1645:5: STAR
                    {
                    match(input,STAR,FOLLOW_STAR_in_overloadable_operator7284); if (state.failed) return ;

                    }
                    break;
                case 10 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1646:5: DIV
                    {
                    match(input,DIV,FOLLOW_DIV_in_overloadable_operator7290); if (state.failed) return ;

                    }
                    break;
                case 11 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1647:5: PERCENT
                    {
                    match(input,PERCENT,FOLLOW_PERCENT_in_overloadable_operator7296); if (state.failed) return ;

                    }
                    break;
                case 12 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1648:5: AMP
                    {
                    match(input,AMP,FOLLOW_AMP_in_overloadable_operator7302); if (state.failed) return ;

                    }
                    break;
                case 13 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1649:5: BITWISE_OR
                    {
                    match(input,BITWISE_OR,FOLLOW_BITWISE_OR_in_overloadable_operator7308); if (state.failed) return ;

                    }
                    break;
                case 14 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1650:5: CARET
                    {
                    match(input,CARET,FOLLOW_CARET_in_overloadable_operator7314); if (state.failed) return ;

                    }
                    break;
                case 15 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1651:5: OP_LEFT_SHIFT
                    {
                    match(input,OP_LEFT_SHIFT,FOLLOW_OP_LEFT_SHIFT_in_overloadable_operator7320); if (state.failed) return ;

                    }
                    break;
                case 16 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1652:5: right_shift
                    {
                    pushFollow(FOLLOW_right_shift_in_overloadable_operator7326);
                    right_shift();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 17 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1653:5: OP_EQ
                    {
                    match(input,OP_EQ,FOLLOW_OP_EQ_in_overloadable_operator7332); if (state.failed) return ;

                    }
                    break;
                case 18 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1654:5: OP_NE
                    {
                    match(input,OP_NE,FOLLOW_OP_NE_in_overloadable_operator7338); if (state.failed) return ;

                    }
                    break;
                case 19 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1655:5: GT
                    {
                    match(input,GT,FOLLOW_GT_in_overloadable_operator7344); if (state.failed) return ;

                    }
                    break;
                case 20 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1656:5: LT
                    {
                    match(input,LT,FOLLOW_LT_in_overloadable_operator7350); if (state.failed) return ;

                    }
                    break;
                case 21 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1657:5: OP_GE
                    {
                    match(input,OP_GE,FOLLOW_OP_GE_in_overloadable_operator7356); if (state.failed) return ;

                    }
                    break;
                case 22 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1658:5: OP_LE
                    {
                    match(input,OP_LE,FOLLOW_OP_LE_in_overloadable_operator7362); if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "overloadable_operator"



    // $ANTLR start "conversion_operator_declarator"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1661:1: conversion_operator_declarator : ( IMPLICIT OPERATOR type OPEN_PARENS type IDENTIFIER CLOSE_PARENS | EXPLICIT OPERATOR type OPEN_PARENS type IDENTIFIER CLOSE_PARENS );
    public final void conversion_operator_declarator() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1662:2: ( IMPLICIT OPERATOR type OPEN_PARENS type IDENTIFIER CLOSE_PARENS | EXPLICIT OPERATOR type OPEN_PARENS type IDENTIFIER CLOSE_PARENS )
            int alt251=2;
            int LA251_0 = input.LA(1);

            if ( (LA251_0==IMPLICIT) ) {
                alt251=1;
            }
            else if ( (LA251_0==EXPLICIT) ) {
                alt251=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 251, 0, input);

                throw nvae;

            }
            switch (alt251) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1662:4: IMPLICIT OPERATOR type OPEN_PARENS type IDENTIFIER CLOSE_PARENS
                    {
                    match(input,IMPLICIT,FOLLOW_IMPLICIT_in_conversion_operator_declarator7375); if (state.failed) return ;

                    match(input,OPERATOR,FOLLOW_OPERATOR_in_conversion_operator_declarator7377); if (state.failed) return ;

                    pushFollow(FOLLOW_type_in_conversion_operator_declarator7379);
                    type();

                    state._fsp--;
                    if (state.failed) return ;

                    match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_conversion_operator_declarator7381); if (state.failed) return ;

                    pushFollow(FOLLOW_type_in_conversion_operator_declarator7383);
                    type();

                    state._fsp--;
                    if (state.failed) return ;

                    match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_conversion_operator_declarator7385); if (state.failed) return ;

                    match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_conversion_operator_declarator7387); if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1663:4: EXPLICIT OPERATOR type OPEN_PARENS type IDENTIFIER CLOSE_PARENS
                    {
                    match(input,EXPLICIT,FOLLOW_EXPLICIT_in_conversion_operator_declarator7392); if (state.failed) return ;

                    match(input,OPERATOR,FOLLOW_OPERATOR_in_conversion_operator_declarator7394); if (state.failed) return ;

                    pushFollow(FOLLOW_type_in_conversion_operator_declarator7396);
                    type();

                    state._fsp--;
                    if (state.failed) return ;

                    match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_conversion_operator_declarator7398); if (state.failed) return ;

                    pushFollow(FOLLOW_type_in_conversion_operator_declarator7400);
                    type();

                    state._fsp--;
                    if (state.failed) return ;

                    match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_conversion_operator_declarator7402); if (state.failed) return ;

                    match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_conversion_operator_declarator7404); if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "conversion_operator_declarator"



    // $ANTLR start "operator_body"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1665:1: operator_body : ( block | SEMICOLON );
    public final void operator_body() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1666:2: ( block | SEMICOLON )
            int alt252=2;
            int LA252_0 = input.LA(1);

            if ( (LA252_0==OPEN_BRACE) ) {
                alt252=1;
            }
            else if ( (LA252_0==SEMICOLON) ) {
                alt252=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 252, 0, input);

                throw nvae;

            }
            switch (alt252) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1666:4: block
                    {
                    pushFollow(FOLLOW_block_in_operator_body7415);
                    block();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1667:4: SEMICOLON
                    {
                    match(input,SEMICOLON,FOLLOW_SEMICOLON_in_operator_body7420); if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "operator_body"



    // $ANTLR start "constructor_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1669:1: constructor_declaration : ( attributes )? ( constructor_modifiers )? constructor_declarator constructor_body ;
    public final void constructor_declaration() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1670:2: ( ( attributes )? ( constructor_modifiers )? constructor_declarator constructor_body )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1670:4: ( attributes )? ( constructor_modifiers )? constructor_declarator constructor_body
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1670:4: ( attributes )?
            int alt253=2;
            int LA253_0 = input.LA(1);

            if ( (LA253_0==OPEN_BRACKET) ) {
                alt253=1;
            }
            switch (alt253) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1670:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_constructor_declaration7431);
                    attributes();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1670:16: ( constructor_modifiers )?
            int alt254=2;
            int LA254_0 = input.LA(1);

            if ( (LA254_0==EXTERN||LA254_0==INTERNAL||(LA254_0 >= PRIVATE && LA254_0 <= PUBLIC)||LA254_0==UNSAFE) ) {
                alt254=1;
            }
            switch (alt254) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1670:16: constructor_modifiers
                    {
                    pushFollow(FOLLOW_constructor_modifiers_in_constructor_declaration7434);
                    constructor_modifiers();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            pushFollow(FOLLOW_constructor_declarator_in_constructor_declaration7437);
            constructor_declarator();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_constructor_body_in_constructor_declaration7439);
            constructor_body();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "constructor_declaration"



    // $ANTLR start "constructor_modifiers"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1672:1: constructor_modifiers : ( constructor_modifier )+ ;
    public final void constructor_modifiers() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1673:2: ( ( constructor_modifier )+ )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1673:4: ( constructor_modifier )+
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1673:4: ( constructor_modifier )+
            int cnt255=0;
            loop255:
            do {
                int alt255=2;
                int LA255_0 = input.LA(1);

                if ( (LA255_0==EXTERN||LA255_0==INTERNAL||(LA255_0 >= PRIVATE && LA255_0 <= PUBLIC)||LA255_0==UNSAFE) ) {
                    alt255=1;
                }


                switch (alt255) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1673:4: constructor_modifier
            	    {
            	    pushFollow(FOLLOW_constructor_modifier_in_constructor_modifiers7450);
            	    constructor_modifier();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    if ( cnt255 >= 1 ) break loop255;
            	    if (state.backtracking>0) {state.failed=true; return ;}
                        EarlyExitException eee =
                            new EarlyExitException(255, input);
                        throw eee;
                }
                cnt255++;
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "constructor_modifiers"



    // $ANTLR start "constructor_modifier"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1675:1: constructor_modifier : ( PUBLIC | PROTECTED | INTERNAL | PRIVATE | EXTERN | constructor_modifier_unsafe );
    public final void constructor_modifier() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1676:2: ( PUBLIC | PROTECTED | INTERNAL | PRIVATE | EXTERN | constructor_modifier_unsafe )
            int alt256=6;
            switch ( input.LA(1) ) {
            case PUBLIC:
                {
                alt256=1;
                }
                break;
            case PROTECTED:
                {
                alt256=2;
                }
                break;
            case INTERNAL:
                {
                alt256=3;
                }
                break;
            case PRIVATE:
                {
                alt256=4;
                }
                break;
            case EXTERN:
                {
                alt256=5;
                }
                break;
            case UNSAFE:
                {
                alt256=6;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 256, 0, input);

                throw nvae;

            }

            switch (alt256) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1676:4: PUBLIC
                    {
                    match(input,PUBLIC,FOLLOW_PUBLIC_in_constructor_modifier7462); if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1677:4: PROTECTED
                    {
                    match(input,PROTECTED,FOLLOW_PROTECTED_in_constructor_modifier7467); if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1678:4: INTERNAL
                    {
                    match(input,INTERNAL,FOLLOW_INTERNAL_in_constructor_modifier7472); if (state.failed) return ;

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1679:4: PRIVATE
                    {
                    match(input,PRIVATE,FOLLOW_PRIVATE_in_constructor_modifier7477); if (state.failed) return ;

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1680:4: EXTERN
                    {
                    match(input,EXTERN,FOLLOW_EXTERN_in_constructor_modifier7482); if (state.failed) return ;

                    }
                    break;
                case 6 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1681:4: constructor_modifier_unsafe
                    {
                    pushFollow(FOLLOW_constructor_modifier_unsafe_in_constructor_modifier7487);
                    constructor_modifier_unsafe();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "constructor_modifier"



    // $ANTLR start "constructor_declarator"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1683:1: constructor_declarator : IDENTIFIER OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( constructor_initializer )? ;
    public final void constructor_declarator() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1684:2: ( IDENTIFIER OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( constructor_initializer )? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1684:4: IDENTIFIER OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( constructor_initializer )?
            {
            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_constructor_declarator7498); if (state.failed) return ;

            match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_constructor_declarator7500); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1684:27: ( formal_parameter_list )?
            int alt257=2;
            int LA257_0 = input.LA(1);

            if ( (LA257_0==BOOL||LA257_0==BYTE||LA257_0==CHAR||LA257_0==DECIMAL||LA257_0==DOUBLE||LA257_0==FLOAT||LA257_0==IDENTIFIER||LA257_0==INT||LA257_0==LONG||LA257_0==OBJECT||LA257_0==OPEN_BRACKET||LA257_0==OUT||LA257_0==PARAMS||LA257_0==REF||LA257_0==SBYTE||LA257_0==SHORT||LA257_0==STRING||LA257_0==THIS||(LA257_0 >= UINT && LA257_0 <= ULONG)||LA257_0==USHORT||LA257_0==VOID) ) {
                alt257=1;
            }
            switch (alt257) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1684:27: formal_parameter_list
                    {
                    pushFollow(FOLLOW_formal_parameter_list_in_constructor_declarator7502);
                    formal_parameter_list();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_constructor_declarator7505); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1684:63: ( constructor_initializer )?
            int alt258=2;
            int LA258_0 = input.LA(1);

            if ( (LA258_0==COLON) ) {
                alt258=1;
            }
            switch (alt258) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1684:63: constructor_initializer
                    {
                    pushFollow(FOLLOW_constructor_initializer_in_constructor_declarator7507);
                    constructor_initializer();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "constructor_declarator"



    // $ANTLR start "constructor_initializer"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1686:1: constructor_initializer : ( COLON BASE OPEN_PARENS ( argument_list )? CLOSE_PARENS | COLON THIS OPEN_PARENS ( argument_list )? CLOSE_PARENS );
    public final void constructor_initializer() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1687:2: ( COLON BASE OPEN_PARENS ( argument_list )? CLOSE_PARENS | COLON THIS OPEN_PARENS ( argument_list )? CLOSE_PARENS )
            int alt261=2;
            int LA261_0 = input.LA(1);

            if ( (LA261_0==COLON) ) {
                int LA261_1 = input.LA(2);

                if ( (LA261_1==BASE) ) {
                    alt261=1;
                }
                else if ( (LA261_1==THIS) ) {
                    alt261=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 261, 1, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 261, 0, input);

                throw nvae;

            }
            switch (alt261) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1687:4: COLON BASE OPEN_PARENS ( argument_list )? CLOSE_PARENS
                    {
                    match(input,COLON,FOLLOW_COLON_in_constructor_initializer7519); if (state.failed) return ;

                    match(input,BASE,FOLLOW_BASE_in_constructor_initializer7521); if (state.failed) return ;

                    match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_constructor_initializer7523); if (state.failed) return ;

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1687:27: ( argument_list )?
                    int alt259=2;
                    int LA259_0 = input.LA(1);

                    if ( (LA259_0==AMP||(LA259_0 >= BANG && LA259_0 <= BASE)||LA259_0==BOOL||LA259_0==BYTE||(LA259_0 >= CHAR && LA259_0 <= CHECKED)||LA259_0==DECIMAL||(LA259_0 >= DEFAULT && LA259_0 <= DELEGATE)||LA259_0==DOUBLE||LA259_0==FALSE||LA259_0==FLOAT||LA259_0==IDENTIFIER||(LA259_0 >= INT && LA259_0 <= INTEGER_LITERAL)||LA259_0==LONG||LA259_0==MINUS||LA259_0==NEW||LA259_0==NULL||LA259_0==OBJECT||LA259_0==OPEN_PARENS||LA259_0==OP_DEC||LA259_0==OP_INC||LA259_0==OUT||LA259_0==PLUS||(LA259_0 >= REAL_LITERAL && LA259_0 <= REF)||LA259_0==SBYTE||LA259_0==SHORT||LA259_0==SIZEOF||LA259_0==STAR||(LA259_0 >= STRING && LA259_0 <= STRING_LITERAL)||LA259_0==THIS||(LA259_0 >= TILDE && LA259_0 <= TRUE)||(LA259_0 >= TYPEOF && LA259_0 <= UNCHECKED)||LA259_0==USHORT) ) {
                        alt259=1;
                    }
                    switch (alt259) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1687:27: argument_list
                            {
                            pushFollow(FOLLOW_argument_list_in_constructor_initializer7525);
                            argument_list();

                            state._fsp--;
                            if (state.failed) return ;

                            }
                            break;

                    }


                    match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_constructor_initializer7528); if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1688:4: COLON THIS OPEN_PARENS ( argument_list )? CLOSE_PARENS
                    {
                    match(input,COLON,FOLLOW_COLON_in_constructor_initializer7533); if (state.failed) return ;

                    match(input,THIS,FOLLOW_THIS_in_constructor_initializer7535); if (state.failed) return ;

                    match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_constructor_initializer7537); if (state.failed) return ;

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1688:27: ( argument_list )?
                    int alt260=2;
                    int LA260_0 = input.LA(1);

                    if ( (LA260_0==AMP||(LA260_0 >= BANG && LA260_0 <= BASE)||LA260_0==BOOL||LA260_0==BYTE||(LA260_0 >= CHAR && LA260_0 <= CHECKED)||LA260_0==DECIMAL||(LA260_0 >= DEFAULT && LA260_0 <= DELEGATE)||LA260_0==DOUBLE||LA260_0==FALSE||LA260_0==FLOAT||LA260_0==IDENTIFIER||(LA260_0 >= INT && LA260_0 <= INTEGER_LITERAL)||LA260_0==LONG||LA260_0==MINUS||LA260_0==NEW||LA260_0==NULL||LA260_0==OBJECT||LA260_0==OPEN_PARENS||LA260_0==OP_DEC||LA260_0==OP_INC||LA260_0==OUT||LA260_0==PLUS||(LA260_0 >= REAL_LITERAL && LA260_0 <= REF)||LA260_0==SBYTE||LA260_0==SHORT||LA260_0==SIZEOF||LA260_0==STAR||(LA260_0 >= STRING && LA260_0 <= STRING_LITERAL)||LA260_0==THIS||(LA260_0 >= TILDE && LA260_0 <= TRUE)||(LA260_0 >= TYPEOF && LA260_0 <= UNCHECKED)||LA260_0==USHORT) ) {
                        alt260=1;
                    }
                    switch (alt260) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1688:27: argument_list
                            {
                            pushFollow(FOLLOW_argument_list_in_constructor_initializer7539);
                            argument_list();

                            state._fsp--;
                            if (state.failed) return ;

                            }
                            break;

                    }


                    match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_constructor_initializer7542); if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "constructor_initializer"



    // $ANTLR start "constructor_body"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1690:1: constructor_body : ( block | SEMICOLON );
    public final void constructor_body() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1691:2: ( block | SEMICOLON )
            int alt262=2;
            int LA262_0 = input.LA(1);

            if ( (LA262_0==OPEN_BRACE) ) {
                alt262=1;
            }
            else if ( (LA262_0==SEMICOLON) ) {
                alt262=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 262, 0, input);

                throw nvae;

            }
            switch (alt262) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1691:4: block
                    {
                    pushFollow(FOLLOW_block_in_constructor_body7553);
                    block();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1692:4: SEMICOLON
                    {
                    match(input,SEMICOLON,FOLLOW_SEMICOLON_in_constructor_body7558); if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "constructor_body"



    // $ANTLR start "static_constructor_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1694:1: static_constructor_declaration : ( attributes )? static_constructor_modifiers IDENTIFIER OPEN_PARENS CLOSE_PARENS static_constructor_body ;
    public final void static_constructor_declaration() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1695:2: ( ( attributes )? static_constructor_modifiers IDENTIFIER OPEN_PARENS CLOSE_PARENS static_constructor_body )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1695:4: ( attributes )? static_constructor_modifiers IDENTIFIER OPEN_PARENS CLOSE_PARENS static_constructor_body
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1695:4: ( attributes )?
            int alt263=2;
            int LA263_0 = input.LA(1);

            if ( (LA263_0==OPEN_BRACKET) ) {
                alt263=1;
            }
            switch (alt263) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1695:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_static_constructor_declaration7569);
                    attributes();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            pushFollow(FOLLOW_static_constructor_modifiers_in_static_constructor_declaration7572);
            static_constructor_modifiers();

            state._fsp--;
            if (state.failed) return ;

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_static_constructor_declaration7574); if (state.failed) return ;

            match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_static_constructor_declaration7576); if (state.failed) return ;

            match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_static_constructor_declaration7578); if (state.failed) return ;

            pushFollow(FOLLOW_static_constructor_body_in_static_constructor_declaration7580);
            static_constructor_body();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "static_constructor_declaration"



    // $ANTLR start "static_constructor_modifiers"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1704:1: static_constructor_modifiers : static_constructor_modifiers_unsafe ;
    public final void static_constructor_modifiers() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1705:3: ( static_constructor_modifiers_unsafe )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1705:5: static_constructor_modifiers_unsafe
            {
            pushFollow(FOLLOW_static_constructor_modifiers_unsafe_in_static_constructor_modifiers7594);
            static_constructor_modifiers_unsafe();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "static_constructor_modifiers"



    // $ANTLR start "static_constructor_body"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1707:1: static_constructor_body : ( block | SEMICOLON );
    public final void static_constructor_body() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1708:2: ( block | SEMICOLON )
            int alt264=2;
            int LA264_0 = input.LA(1);

            if ( (LA264_0==OPEN_BRACE) ) {
                alt264=1;
            }
            else if ( (LA264_0==SEMICOLON) ) {
                alt264=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 264, 0, input);

                throw nvae;

            }
            switch (alt264) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1708:4: block
                    {
                    pushFollow(FOLLOW_block_in_static_constructor_body7606);
                    block();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1709:4: SEMICOLON
                    {
                    match(input,SEMICOLON,FOLLOW_SEMICOLON_in_static_constructor_body7611); if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "static_constructor_body"



    // $ANTLR start "destructor_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1717:1: destructor_declaration : destructor_declaration_unsafe ;
    public final void destructor_declaration() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1718:2: ( destructor_declaration_unsafe )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1718:4: destructor_declaration_unsafe
            {
            pushFollow(FOLLOW_destructor_declaration_unsafe_in_destructor_declaration7624);
            destructor_declaration_unsafe();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "destructor_declaration"



    // $ANTLR start "destructor_body"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1720:1: destructor_body : ( block | SEMICOLON );
    public final void destructor_body() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1721:2: ( block | SEMICOLON )
            int alt265=2;
            int LA265_0 = input.LA(1);

            if ( (LA265_0==OPEN_BRACE) ) {
                alt265=1;
            }
            else if ( (LA265_0==SEMICOLON) ) {
                alt265=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 265, 0, input);

                throw nvae;

            }
            switch (alt265) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1721:4: block
                    {
                    pushFollow(FOLLOW_block_in_destructor_body7635);
                    block();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1722:4: SEMICOLON
                    {
                    match(input,SEMICOLON,FOLLOW_SEMICOLON_in_destructor_body7640); if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "destructor_body"



    // $ANTLR start "body"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1725:1: body : ( block | SEMICOLON );
    public final void body() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1726:3: ( block | SEMICOLON )
            int alt266=2;
            int LA266_0 = input.LA(1);

            if ( (LA266_0==OPEN_BRACE) ) {
                alt266=1;
            }
            else if ( (LA266_0==SEMICOLON) ) {
                alt266=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 266, 0, input);

                throw nvae;

            }
            switch (alt266) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1726:5: block
                    {
                    pushFollow(FOLLOW_block_in_body7652);
                    block();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1727:5: SEMICOLON
                    {
                    match(input,SEMICOLON,FOLLOW_SEMICOLON_in_body7658); if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "body"



    // $ANTLR start "struct_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1731:1: struct_declaration : ( attributes )? ( struct_modifiers )? ( partial_contextual_keyword )? STRUCT IDENTIFIER ( type_parameter_list )? ( struct_interfaces )? ( type_parameter_constraints_clauses )? struct_body ( SEMICOLON )? ;
    public final void struct_declaration() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1732:2: ( ( attributes )? ( struct_modifiers )? ( partial_contextual_keyword )? STRUCT IDENTIFIER ( type_parameter_list )? ( struct_interfaces )? ( type_parameter_constraints_clauses )? struct_body ( SEMICOLON )? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1732:4: ( attributes )? ( struct_modifiers )? ( partial_contextual_keyword )? STRUCT IDENTIFIER ( type_parameter_list )? ( struct_interfaces )? ( type_parameter_constraints_clauses )? struct_body ( SEMICOLON )?
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1732:4: ( attributes )?
            int alt267=2;
            int LA267_0 = input.LA(1);

            if ( (LA267_0==OPEN_BRACKET) ) {
                alt267=1;
            }
            switch (alt267) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1732:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_struct_declaration7672);
                    attributes();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1732:16: ( struct_modifiers )?
            int alt268=2;
            int LA268_0 = input.LA(1);

            if ( (LA268_0==INTERNAL||LA268_0==NEW||(LA268_0 >= PRIVATE && LA268_0 <= PUBLIC)||LA268_0==UNSAFE) ) {
                alt268=1;
            }
            switch (alt268) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1732:16: struct_modifiers
                    {
                    pushFollow(FOLLOW_struct_modifiers_in_struct_declaration7675);
                    struct_modifiers();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1732:34: ( partial_contextual_keyword )?
            int alt269=2;
            int LA269_0 = input.LA(1);

            if ( (LA269_0==IDENTIFIER) ) {
                alt269=1;
            }
            switch (alt269) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1732:34: partial_contextual_keyword
                    {
                    pushFollow(FOLLOW_partial_contextual_keyword_in_struct_declaration7678);
                    partial_contextual_keyword();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,STRUCT,FOLLOW_STRUCT_in_struct_declaration7681); if (state.failed) return ;

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_struct_declaration7683); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1732:80: ( type_parameter_list )?
            int alt270=2;
            int LA270_0 = input.LA(1);

            if ( (LA270_0==LT) ) {
                alt270=1;
            }
            switch (alt270) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1732:80: type_parameter_list
                    {
                    pushFollow(FOLLOW_type_parameter_list_in_struct_declaration7685);
                    type_parameter_list();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1732:101: ( struct_interfaces )?
            int alt271=2;
            int LA271_0 = input.LA(1);

            if ( (LA271_0==COLON) ) {
                alt271=1;
            }
            switch (alt271) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1732:101: struct_interfaces
                    {
                    pushFollow(FOLLOW_struct_interfaces_in_struct_declaration7688);
                    struct_interfaces();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1732:120: ( type_parameter_constraints_clauses )?
            int alt272=2;
            int LA272_0 = input.LA(1);

            if ( (LA272_0==IDENTIFIER) ) {
                alt272=1;
            }
            switch (alt272) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1732:120: type_parameter_constraints_clauses
                    {
                    pushFollow(FOLLOW_type_parameter_constraints_clauses_in_struct_declaration7691);
                    type_parameter_constraints_clauses();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            pushFollow(FOLLOW_struct_body_in_struct_declaration7694);
            struct_body();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1732:168: ( SEMICOLON )?
            int alt273=2;
            int LA273_0 = input.LA(1);

            if ( (LA273_0==SEMICOLON) ) {
                alt273=1;
            }
            switch (alt273) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1732:168: SEMICOLON
                    {
                    match(input,SEMICOLON,FOLLOW_SEMICOLON_in_struct_declaration7696); if (state.failed) return ;

                    }
                    break;

            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "struct_declaration"



    // $ANTLR start "struct_modifiers"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1734:1: struct_modifiers : struct_modifier ( struct_modifier )* ;
    public final void struct_modifiers() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1735:2: ( struct_modifier ( struct_modifier )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1735:4: struct_modifier ( struct_modifier )*
            {
            pushFollow(FOLLOW_struct_modifier_in_struct_modifiers7708);
            struct_modifier();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1735:20: ( struct_modifier )*
            loop274:
            do {
                int alt274=2;
                int LA274_0 = input.LA(1);

                if ( (LA274_0==INTERNAL||LA274_0==NEW||(LA274_0 >= PRIVATE && LA274_0 <= PUBLIC)||LA274_0==UNSAFE) ) {
                    alt274=1;
                }


                switch (alt274) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1735:22: struct_modifier
            	    {
            	    pushFollow(FOLLOW_struct_modifier_in_struct_modifiers7712);
            	    struct_modifier();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop274;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "struct_modifiers"



    // $ANTLR start "struct_modifier"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1737:1: struct_modifier : ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | struct_modifier_unsafe );
    public final void struct_modifier() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1738:2: ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | struct_modifier_unsafe )
            int alt275=6;
            switch ( input.LA(1) ) {
            case NEW:
                {
                alt275=1;
                }
                break;
            case PUBLIC:
                {
                alt275=2;
                }
                break;
            case PROTECTED:
                {
                alt275=3;
                }
                break;
            case INTERNAL:
                {
                alt275=4;
                }
                break;
            case PRIVATE:
                {
                alt275=5;
                }
                break;
            case UNSAFE:
                {
                alt275=6;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 275, 0, input);

                throw nvae;

            }

            switch (alt275) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1738:4: NEW
                    {
                    match(input,NEW,FOLLOW_NEW_in_struct_modifier7726); if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1739:4: PUBLIC
                    {
                    match(input,PUBLIC,FOLLOW_PUBLIC_in_struct_modifier7731); if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1740:4: PROTECTED
                    {
                    match(input,PROTECTED,FOLLOW_PROTECTED_in_struct_modifier7736); if (state.failed) return ;

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1741:4: INTERNAL
                    {
                    match(input,INTERNAL,FOLLOW_INTERNAL_in_struct_modifier7741); if (state.failed) return ;

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1742:4: PRIVATE
                    {
                    match(input,PRIVATE,FOLLOW_PRIVATE_in_struct_modifier7746); if (state.failed) return ;

                    }
                    break;
                case 6 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1743:4: struct_modifier_unsafe
                    {
                    pushFollow(FOLLOW_struct_modifier_unsafe_in_struct_modifier7751);
                    struct_modifier_unsafe();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "struct_modifier"



    // $ANTLR start "struct_interfaces"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1745:1: struct_interfaces : COLON interface_type_list ;
    public final void struct_interfaces() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1746:2: ( COLON interface_type_list )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1746:4: COLON interface_type_list
            {
            match(input,COLON,FOLLOW_COLON_in_struct_interfaces7762); if (state.failed) return ;

            pushFollow(FOLLOW_interface_type_list_in_struct_interfaces7764);
            interface_type_list();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "struct_interfaces"



    // $ANTLR start "struct_body"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1748:1: struct_body : OPEN_BRACE ( struct_member_declarations )? CLOSE_BRACE ;
    public final void struct_body() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1749:2: ( OPEN_BRACE ( struct_member_declarations )? CLOSE_BRACE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1749:4: OPEN_BRACE ( struct_member_declarations )? CLOSE_BRACE
            {
            match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_struct_body7775); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1749:15: ( struct_member_declarations )?
            int alt276=2;
            int LA276_0 = input.LA(1);

            if ( (LA276_0==ABSTRACT||LA276_0==BOOL||LA276_0==BYTE||LA276_0==CHAR||LA276_0==CLASS||LA276_0==CONST||LA276_0==DECIMAL||LA276_0==DELEGATE||LA276_0==DOUBLE||(LA276_0 >= ENUM && LA276_0 <= EXTERN)||(LA276_0 >= FIXED && LA276_0 <= FLOAT)||LA276_0==IDENTIFIER||LA276_0==IMPLICIT||LA276_0==INT||(LA276_0 >= INTERFACE && LA276_0 <= INTERNAL)||LA276_0==LONG||LA276_0==NEW||LA276_0==OBJECT||LA276_0==OPEN_BRACKET||LA276_0==OVERRIDE||(LA276_0 >= PRIVATE && LA276_0 <= PUBLIC)||LA276_0==READONLY||(LA276_0 >= SBYTE && LA276_0 <= SEALED)||LA276_0==SHORT||(LA276_0 >= STATIC && LA276_0 <= STRING)||LA276_0==STRUCT||(LA276_0 >= UINT && LA276_0 <= ULONG)||(LA276_0 >= UNSAFE && LA276_0 <= USHORT)||(LA276_0 >= VIRTUAL && LA276_0 <= VOLATILE)) ) {
                alt276=1;
            }
            switch (alt276) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1749:15: struct_member_declarations
                    {
                    pushFollow(FOLLOW_struct_member_declarations_in_struct_body7777);
                    struct_member_declarations();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_struct_body7780); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "struct_body"



    // $ANTLR start "struct_member_declarations"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1751:1: struct_member_declarations : struct_member_declaration ( struct_member_declaration )* ;
    public final void struct_member_declarations() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1752:2: ( struct_member_declaration ( struct_member_declaration )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1752:4: struct_member_declaration ( struct_member_declaration )*
            {
            pushFollow(FOLLOW_struct_member_declaration_in_struct_member_declarations7791);
            struct_member_declaration();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1752:30: ( struct_member_declaration )*
            loop277:
            do {
                int alt277=2;
                int LA277_0 = input.LA(1);

                if ( (LA277_0==ABSTRACT||LA277_0==BOOL||LA277_0==BYTE||LA277_0==CHAR||LA277_0==CLASS||LA277_0==CONST||LA277_0==DECIMAL||LA277_0==DELEGATE||LA277_0==DOUBLE||(LA277_0 >= ENUM && LA277_0 <= EXTERN)||(LA277_0 >= FIXED && LA277_0 <= FLOAT)||LA277_0==IDENTIFIER||LA277_0==IMPLICIT||LA277_0==INT||(LA277_0 >= INTERFACE && LA277_0 <= INTERNAL)||LA277_0==LONG||LA277_0==NEW||LA277_0==OBJECT||LA277_0==OPEN_BRACKET||LA277_0==OVERRIDE||(LA277_0 >= PRIVATE && LA277_0 <= PUBLIC)||LA277_0==READONLY||(LA277_0 >= SBYTE && LA277_0 <= SEALED)||LA277_0==SHORT||(LA277_0 >= STATIC && LA277_0 <= STRING)||LA277_0==STRUCT||(LA277_0 >= UINT && LA277_0 <= ULONG)||(LA277_0 >= UNSAFE && LA277_0 <= USHORT)||(LA277_0 >= VIRTUAL && LA277_0 <= VOLATILE)) ) {
                    alt277=1;
                }


                switch (alt277) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1752:32: struct_member_declaration
            	    {
            	    pushFollow(FOLLOW_struct_member_declaration_in_struct_member_declarations7795);
            	    struct_member_declaration();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop277;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "struct_member_declarations"



    // $ANTLR start "struct_member_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1769:1: struct_member_declaration : ( attributes )? ( all_member_modifiers )? ( common_member_declaration | FIXED buffer_element_type fixed_size_buffer_declarators SEMICOLON ) ;
    public final void struct_member_declaration() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1770:2: ( ( attributes )? ( all_member_modifiers )? ( common_member_declaration | FIXED buffer_element_type fixed_size_buffer_declarators SEMICOLON ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1770:4: ( attributes )? ( all_member_modifiers )? ( common_member_declaration | FIXED buffer_element_type fixed_size_buffer_declarators SEMICOLON )
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1770:4: ( attributes )?
            int alt278=2;
            int LA278_0 = input.LA(1);

            if ( (LA278_0==OPEN_BRACKET) ) {
                alt278=1;
            }
            switch (alt278) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1770:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_struct_member_declaration7811);
                    attributes();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1770:16: ( all_member_modifiers )?
            int alt279=2;
            int LA279_0 = input.LA(1);

            if ( (LA279_0==ABSTRACT||LA279_0==EXTERN||LA279_0==INTERNAL||LA279_0==NEW||LA279_0==OVERRIDE||(LA279_0 >= PRIVATE && LA279_0 <= PUBLIC)||LA279_0==READONLY||LA279_0==SEALED||LA279_0==STATIC||LA279_0==UNSAFE||LA279_0==VIRTUAL||LA279_0==VOLATILE) ) {
                alt279=1;
            }
            else if ( (LA279_0==IDENTIFIER) ) {
                int LA279_15 = input.LA(2);

                if ( ((input.LT(1).getText().equals("partial"))) ) {
                    alt279=1;
                }
            }
            switch (alt279) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1770:16: all_member_modifiers
                    {
                    pushFollow(FOLLOW_all_member_modifiers_in_struct_member_declaration7814);
                    all_member_modifiers();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1771:3: ( common_member_declaration | FIXED buffer_element_type fixed_size_buffer_declarators SEMICOLON )
            int alt280=2;
            int LA280_0 = input.LA(1);

            if ( (LA280_0==BOOL||LA280_0==BYTE||LA280_0==CHAR||LA280_0==CLASS||LA280_0==CONST||LA280_0==DECIMAL||LA280_0==DELEGATE||LA280_0==DOUBLE||(LA280_0 >= ENUM && LA280_0 <= EXPLICIT)||LA280_0==FLOAT||LA280_0==IDENTIFIER||LA280_0==IMPLICIT||LA280_0==INT||LA280_0==INTERFACE||LA280_0==LONG||LA280_0==OBJECT||LA280_0==SBYTE||LA280_0==SHORT||LA280_0==STRING||LA280_0==STRUCT||(LA280_0 >= UINT && LA280_0 <= ULONG)||LA280_0==USHORT||LA280_0==VOID) ) {
                alt280=1;
            }
            else if ( (LA280_0==FIXED) ) {
                alt280=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 280, 0, input);

                throw nvae;

            }
            switch (alt280) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1771:5: common_member_declaration
                    {
                    pushFollow(FOLLOW_common_member_declaration_in_struct_member_declaration7821);
                    common_member_declaration();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1772:5: FIXED buffer_element_type fixed_size_buffer_declarators SEMICOLON
                    {
                    match(input,FIXED,FOLLOW_FIXED_in_struct_member_declaration7827); if (state.failed) return ;

                    pushFollow(FOLLOW_buffer_element_type_in_struct_member_declaration7829);
                    buffer_element_type();

                    state._fsp--;
                    if (state.failed) return ;

                    pushFollow(FOLLOW_fixed_size_buffer_declarators_in_struct_member_declaration7831);
                    fixed_size_buffer_declarators();

                    state._fsp--;
                    if (state.failed) return ;

                    match(input,SEMICOLON,FOLLOW_SEMICOLON_in_struct_member_declaration7833); if (state.failed) return ;

                    }
                    break;

            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "struct_member_declaration"



    // $ANTLR start "array_type"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1782:1: array_type : base_type ( ( STAR | INTERR )* rank_specifier )+ ;
    public final void array_type() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1783:2: ( base_type ( ( STAR | INTERR )* rank_specifier )+ )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1783:4: base_type ( ( STAR | INTERR )* rank_specifier )+
            {
            pushFollow(FOLLOW_base_type_in_array_type7853);
            base_type();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1783:14: ( ( STAR | INTERR )* rank_specifier )+
            int cnt282=0;
            loop282:
            do {
                int alt282=2;
                int LA282_0 = input.LA(1);

                if ( (LA282_0==OPEN_BRACKET) ) {
                    int LA282_2 = input.LA(2);

                    if ( (LA282_2==CLOSE_BRACKET||LA282_2==COMMA) ) {
                        alt282=1;
                    }


                }
                else if ( (LA282_0==INTERR||LA282_0==STAR) ) {
                    alt282=1;
                }


                switch (alt282) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1783:15: ( STAR | INTERR )* rank_specifier
            	    {
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1783:15: ( STAR | INTERR )*
            	    loop281:
            	    do {
            	        int alt281=2;
            	        int LA281_0 = input.LA(1);

            	        if ( (LA281_0==INTERR||LA281_0==STAR) ) {
            	            alt281=1;
            	        }


            	        switch (alt281) {
            	    	case 1 :
            	    	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:
            	    	    {
            	    	    if ( input.LA(1)==INTERR||input.LA(1)==STAR ) {
            	    	        input.consume();
            	    	        state.errorRecovery=false;
            	    	        state.failed=false;
            	    	    }
            	    	    else {
            	    	        if (state.backtracking>0) {state.failed=true; return ;}
            	    	        MismatchedSetException mse = new MismatchedSetException(null,input);
            	    	        throw mse;
            	    	    }


            	    	    }
            	    	    break;

            	    	default :
            	    	    break loop281;
            	        }
            	    } while (true);


            	    pushFollow(FOLLOW_rank_specifier_in_array_type7865);
            	    rank_specifier();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    if ( cnt282 >= 1 ) break loop282;
            	    if (state.backtracking>0) {state.failed=true; return ;}
                        EarlyExitException eee =
                            new EarlyExitException(282, input);
                        throw eee;
                }
                cnt282++;
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "array_type"



    // $ANTLR start "non_array_type"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1791:1: non_array_type : base_type ( rank_specifier | INTERR | STAR )* ;
    public final void non_array_type() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1792:2: ( base_type ( rank_specifier | INTERR | STAR )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1792:4: base_type ( rank_specifier | INTERR | STAR )*
            {
            pushFollow(FOLLOW_base_type_in_non_array_type7882);
            base_type();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1792:14: ( rank_specifier | INTERR | STAR )*
            loop283:
            do {
                int alt283=4;
                switch ( input.LA(1) ) {
                case OPEN_BRACKET:
                    {
                    int LA283_1 = input.LA(2);

                    if ( (LA283_1==CLOSE_BRACKET||LA283_1==COMMA) ) {
                        alt283=1;
                    }


                    }
                    break;
                case INTERR:
                    {
                    alt283=2;
                    }
                    break;
                case STAR:
                    {
                    alt283=3;
                    }
                    break;

                }

                switch (alt283) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1792:15: rank_specifier
            	    {
            	    pushFollow(FOLLOW_rank_specifier_in_non_array_type7885);
            	    rank_specifier();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;
            	case 2 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1792:32: INTERR
            	    {
            	    match(input,INTERR,FOLLOW_INTERR_in_non_array_type7889); if (state.failed) return ;

            	    }
            	    break;
            	case 3 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1792:41: STAR
            	    {
            	    match(input,STAR,FOLLOW_STAR_in_non_array_type7893); if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop283;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "non_array_type"



    // $ANTLR start "rank_specifiers"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1800:1: rank_specifiers : ( rank_specifier )+ ;
    public final void rank_specifiers() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1801:3: ( ( rank_specifier )+ )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1801:5: ( rank_specifier )+
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1801:5: ( rank_specifier )+
            int cnt284=0;
            loop284:
            do {
                int alt284=2;
                int LA284_0 = input.LA(1);

                if ( (LA284_0==OPEN_BRACKET) ) {
                    int LA284_2 = input.LA(2);

                    if ( (LA284_2==CLOSE_BRACKET||LA284_2==COMMA) ) {
                        alt284=1;
                    }


                }


                switch (alt284) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1801:5: rank_specifier
            	    {
            	    pushFollow(FOLLOW_rank_specifier_in_rank_specifiers7911);
            	    rank_specifier();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    if ( cnt284 >= 1 ) break loop284;
            	    if (state.backtracking>0) {state.failed=true; return ;}
                        EarlyExitException eee =
                            new EarlyExitException(284, input);
                        throw eee;
                }
                cnt284++;
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "rank_specifiers"



    // $ANTLR start "rank_specifier"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1804:1: rank_specifier : OPEN_BRACKET ( dim_separators )? CLOSE_BRACKET ;
    public final void rank_specifier() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1805:2: ( OPEN_BRACKET ( dim_separators )? CLOSE_BRACKET )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1805:4: OPEN_BRACKET ( dim_separators )? CLOSE_BRACKET
            {
            match(input,OPEN_BRACKET,FOLLOW_OPEN_BRACKET_in_rank_specifier7926); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1805:17: ( dim_separators )?
            int alt285=2;
            int LA285_0 = input.LA(1);

            if ( (LA285_0==COMMA) ) {
                alt285=1;
            }
            switch (alt285) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1805:17: dim_separators
                    {
                    pushFollow(FOLLOW_dim_separators_in_rank_specifier7928);
                    dim_separators();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,CLOSE_BRACKET,FOLLOW_CLOSE_BRACKET_in_rank_specifier7931); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "rank_specifier"



    // $ANTLR start "dim_separators"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1807:1: dim_separators : COMMA ( COMMA )* ;
    public final void dim_separators() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1808:2: ( COMMA ( COMMA )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1808:4: COMMA ( COMMA )*
            {
            match(input,COMMA,FOLLOW_COMMA_in_dim_separators7942); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1808:10: ( COMMA )*
            loop286:
            do {
                int alt286=2;
                int LA286_0 = input.LA(1);

                if ( (LA286_0==COMMA) ) {
                    alt286=1;
                }


                switch (alt286) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1808:12: COMMA
            	    {
            	    match(input,COMMA,FOLLOW_COMMA_in_dim_separators7946); if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop286;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "dim_separators"



    // $ANTLR start "array_initializer"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1817:1: array_initializer : ( OPEN_BRACE CLOSE_BRACE | OPEN_BRACE variable_initializer_list ( COMMA )? CLOSE_BRACE );
    public final void array_initializer() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1818:3: ( OPEN_BRACE CLOSE_BRACE | OPEN_BRACE variable_initializer_list ( COMMA )? CLOSE_BRACE )
            int alt288=2;
            int LA288_0 = input.LA(1);

            if ( (LA288_0==OPEN_BRACE) ) {
                int LA288_1 = input.LA(2);

                if ( (LA288_1==CLOSE_BRACE) ) {
                    alt288=1;
                }
                else if ( (LA288_1==AMP||(LA288_1 >= BANG && LA288_1 <= BASE)||LA288_1==BOOL||LA288_1==BYTE||(LA288_1 >= CHAR && LA288_1 <= CHECKED)||LA288_1==DECIMAL||(LA288_1 >= DEFAULT && LA288_1 <= DELEGATE)||LA288_1==DOUBLE||LA288_1==FALSE||LA288_1==FLOAT||LA288_1==IDENTIFIER||(LA288_1 >= INT && LA288_1 <= INTEGER_LITERAL)||LA288_1==LONG||LA288_1==MINUS||LA288_1==NEW||LA288_1==NULL||(LA288_1 >= OBJECT && LA288_1 <= OPEN_BRACE)||LA288_1==OPEN_PARENS||LA288_1==OP_DEC||LA288_1==OP_INC||LA288_1==PLUS||LA288_1==REAL_LITERAL||LA288_1==SBYTE||LA288_1==SHORT||LA288_1==SIZEOF||LA288_1==STAR||(LA288_1 >= STRING && LA288_1 <= STRING_LITERAL)||LA288_1==THIS||(LA288_1 >= TILDE && LA288_1 <= TRUE)||(LA288_1 >= TYPEOF && LA288_1 <= UNCHECKED)||LA288_1==USHORT) ) {
                    alt288=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 288, 1, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 288, 0, input);

                throw nvae;

            }
            switch (alt288) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1818:5: OPEN_BRACE CLOSE_BRACE
                    {
                    match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_array_initializer7965); if (state.failed) return ;

                    match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_array_initializer7967); if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1819:5: OPEN_BRACE variable_initializer_list ( COMMA )? CLOSE_BRACE
                    {
                    match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_array_initializer7973); if (state.failed) return ;

                    pushFollow(FOLLOW_variable_initializer_list_in_array_initializer7975);
                    variable_initializer_list();

                    state._fsp--;
                    if (state.failed) return ;

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1819:42: ( COMMA )?
                    int alt287=2;
                    int LA287_0 = input.LA(1);

                    if ( (LA287_0==COMMA) ) {
                        alt287=1;
                    }
                    switch (alt287) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1819:42: COMMA
                            {
                            match(input,COMMA,FOLLOW_COMMA_in_array_initializer7977); if (state.failed) return ;

                            }
                            break;

                    }


                    match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_array_initializer7980); if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "array_initializer"



    // $ANTLR start "variable_initializer_list"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1821:1: variable_initializer_list : variable_initializer ( COMMA variable_initializer )* ;
    public final void variable_initializer_list() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1822:2: ( variable_initializer ( COMMA variable_initializer )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1822:4: variable_initializer ( COMMA variable_initializer )*
            {
            pushFollow(FOLLOW_variable_initializer_in_variable_initializer_list7992);
            variable_initializer();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1822:25: ( COMMA variable_initializer )*
            loop289:
            do {
                int alt289=2;
                int LA289_0 = input.LA(1);

                if ( (LA289_0==COMMA) ) {
                    int LA289_1 = input.LA(2);

                    if ( (LA289_1==AMP||(LA289_1 >= BANG && LA289_1 <= BASE)||LA289_1==BOOL||LA289_1==BYTE||(LA289_1 >= CHAR && LA289_1 <= CHECKED)||LA289_1==DECIMAL||(LA289_1 >= DEFAULT && LA289_1 <= DELEGATE)||LA289_1==DOUBLE||LA289_1==FALSE||LA289_1==FLOAT||LA289_1==IDENTIFIER||(LA289_1 >= INT && LA289_1 <= INTEGER_LITERAL)||LA289_1==LONG||LA289_1==MINUS||LA289_1==NEW||LA289_1==NULL||(LA289_1 >= OBJECT && LA289_1 <= OPEN_BRACE)||LA289_1==OPEN_PARENS||LA289_1==OP_DEC||LA289_1==OP_INC||LA289_1==PLUS||LA289_1==REAL_LITERAL||LA289_1==SBYTE||LA289_1==SHORT||LA289_1==SIZEOF||LA289_1==STAR||(LA289_1 >= STRING && LA289_1 <= STRING_LITERAL)||LA289_1==THIS||(LA289_1 >= TILDE && LA289_1 <= TRUE)||(LA289_1 >= TYPEOF && LA289_1 <= UNCHECKED)||LA289_1==USHORT) ) {
                        alt289=1;
                    }


                }


                switch (alt289) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1822:27: COMMA variable_initializer
            	    {
            	    match(input,COMMA,FOLLOW_COMMA_in_variable_initializer_list7996); if (state.failed) return ;

            	    pushFollow(FOLLOW_variable_initializer_in_variable_initializer_list7999);
            	    variable_initializer();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop289;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "variable_initializer_list"



    // $ANTLR start "interface_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1825:1: interface_declaration : ( attributes )? ( interface_modifiers )? ( partial_contextual_keyword )? INTERFACE IDENTIFIER ( variant_type_parameter_list )? ( interface_base )? ( type_parameter_constraints_clauses )? interface_body ( SEMICOLON )? ;
    public final void interface_declaration() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1826:2: ( ( attributes )? ( interface_modifiers )? ( partial_contextual_keyword )? INTERFACE IDENTIFIER ( variant_type_parameter_list )? ( interface_base )? ( type_parameter_constraints_clauses )? interface_body ( SEMICOLON )? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1826:4: ( attributes )? ( interface_modifiers )? ( partial_contextual_keyword )? INTERFACE IDENTIFIER ( variant_type_parameter_list )? ( interface_base )? ( type_parameter_constraints_clauses )? interface_body ( SEMICOLON )?
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1826:4: ( attributes )?
            int alt290=2;
            int LA290_0 = input.LA(1);

            if ( (LA290_0==OPEN_BRACKET) ) {
                alt290=1;
            }
            switch (alt290) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1826:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_interface_declaration8014);
                    attributes();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1826:16: ( interface_modifiers )?
            int alt291=2;
            int LA291_0 = input.LA(1);

            if ( (LA291_0==INTERNAL||LA291_0==NEW||(LA291_0 >= PRIVATE && LA291_0 <= PUBLIC)||LA291_0==UNSAFE) ) {
                alt291=1;
            }
            switch (alt291) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1826:16: interface_modifiers
                    {
                    pushFollow(FOLLOW_interface_modifiers_in_interface_declaration8017);
                    interface_modifiers();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1826:37: ( partial_contextual_keyword )?
            int alt292=2;
            int LA292_0 = input.LA(1);

            if ( (LA292_0==IDENTIFIER) ) {
                alt292=1;
            }
            switch (alt292) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1826:37: partial_contextual_keyword
                    {
                    pushFollow(FOLLOW_partial_contextual_keyword_in_interface_declaration8020);
                    partial_contextual_keyword();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,INTERFACE,FOLLOW_INTERFACE_in_interface_declaration8023); if (state.failed) return ;

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_interface_declaration8025); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1826:86: ( variant_type_parameter_list )?
            int alt293=2;
            int LA293_0 = input.LA(1);

            if ( (LA293_0==LT) ) {
                alt293=1;
            }
            switch (alt293) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1826:86: variant_type_parameter_list
                    {
                    pushFollow(FOLLOW_variant_type_parameter_list_in_interface_declaration8027);
                    variant_type_parameter_list();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1826:115: ( interface_base )?
            int alt294=2;
            int LA294_0 = input.LA(1);

            if ( (LA294_0==COLON) ) {
                alt294=1;
            }
            switch (alt294) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1826:115: interface_base
                    {
                    pushFollow(FOLLOW_interface_base_in_interface_declaration8030);
                    interface_base();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1826:131: ( type_parameter_constraints_clauses )?
            int alt295=2;
            int LA295_0 = input.LA(1);

            if ( (LA295_0==IDENTIFIER) ) {
                alt295=1;
            }
            switch (alt295) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1826:131: type_parameter_constraints_clauses
                    {
                    pushFollow(FOLLOW_type_parameter_constraints_clauses_in_interface_declaration8033);
                    type_parameter_constraints_clauses();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            pushFollow(FOLLOW_interface_body_in_interface_declaration8036);
            interface_body();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1826:182: ( SEMICOLON )?
            int alt296=2;
            int LA296_0 = input.LA(1);

            if ( (LA296_0==SEMICOLON) ) {
                alt296=1;
            }
            switch (alt296) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1826:182: SEMICOLON
                    {
                    match(input,SEMICOLON,FOLLOW_SEMICOLON_in_interface_declaration8038); if (state.failed) return ;

                    }
                    break;

            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "interface_declaration"



    // $ANTLR start "interface_modifiers"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1828:1: interface_modifiers : interface_modifier ( interface_modifier )* ;
    public final void interface_modifiers() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1829:2: ( interface_modifier ( interface_modifier )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1829:4: interface_modifier ( interface_modifier )*
            {
            pushFollow(FOLLOW_interface_modifier_in_interface_modifiers8050);
            interface_modifier();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1829:23: ( interface_modifier )*
            loop297:
            do {
                int alt297=2;
                int LA297_0 = input.LA(1);

                if ( (LA297_0==INTERNAL||LA297_0==NEW||(LA297_0 >= PRIVATE && LA297_0 <= PUBLIC)||LA297_0==UNSAFE) ) {
                    alt297=1;
                }


                switch (alt297) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1829:25: interface_modifier
            	    {
            	    pushFollow(FOLLOW_interface_modifier_in_interface_modifiers8054);
            	    interface_modifier();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop297;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "interface_modifiers"



    // $ANTLR start "interface_modifier"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1831:1: interface_modifier : ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | interface_modifier_unsafe );
    public final void interface_modifier() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1832:2: ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | interface_modifier_unsafe )
            int alt298=6;
            switch ( input.LA(1) ) {
            case NEW:
                {
                alt298=1;
                }
                break;
            case PUBLIC:
                {
                alt298=2;
                }
                break;
            case PROTECTED:
                {
                alt298=3;
                }
                break;
            case INTERNAL:
                {
                alt298=4;
                }
                break;
            case PRIVATE:
                {
                alt298=5;
                }
                break;
            case UNSAFE:
                {
                alt298=6;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 298, 0, input);

                throw nvae;

            }

            switch (alt298) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1832:4: NEW
                    {
                    match(input,NEW,FOLLOW_NEW_in_interface_modifier8068); if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1833:4: PUBLIC
                    {
                    match(input,PUBLIC,FOLLOW_PUBLIC_in_interface_modifier8073); if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1834:4: PROTECTED
                    {
                    match(input,PROTECTED,FOLLOW_PROTECTED_in_interface_modifier8078); if (state.failed) return ;

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1835:4: INTERNAL
                    {
                    match(input,INTERNAL,FOLLOW_INTERNAL_in_interface_modifier8083); if (state.failed) return ;

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1836:4: PRIVATE
                    {
                    match(input,PRIVATE,FOLLOW_PRIVATE_in_interface_modifier8088); if (state.failed) return ;

                    }
                    break;
                case 6 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1837:4: interface_modifier_unsafe
                    {
                    pushFollow(FOLLOW_interface_modifier_unsafe_in_interface_modifier8093);
                    interface_modifier_unsafe();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "interface_modifier"



    // $ANTLR start "variant_type_parameter_list"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1839:1: variant_type_parameter_list : LT variant_type_parameters GT ;
    public final void variant_type_parameter_list() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1840:2: ( LT variant_type_parameters GT )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1840:4: LT variant_type_parameters GT
            {
            match(input,LT,FOLLOW_LT_in_variant_type_parameter_list8104); if (state.failed) return ;

            pushFollow(FOLLOW_variant_type_parameters_in_variant_type_parameter_list8106);
            variant_type_parameters();

            state._fsp--;
            if (state.failed) return ;

            match(input,GT,FOLLOW_GT_in_variant_type_parameter_list8108); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "variant_type_parameter_list"



    // $ANTLR start "variant_type_parameters"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1842:1: variant_type_parameters : ( attributes )? ( variance_annotation )? type_parameter ( COMMA ( attributes )? ( variance_annotation )? type_parameter )* ;
    public final void variant_type_parameters() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1843:2: ( ( attributes )? ( variance_annotation )? type_parameter ( COMMA ( attributes )? ( variance_annotation )? type_parameter )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1843:4: ( attributes )? ( variance_annotation )? type_parameter ( COMMA ( attributes )? ( variance_annotation )? type_parameter )*
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1843:4: ( attributes )?
            int alt299=2;
            int LA299_0 = input.LA(1);

            if ( (LA299_0==OPEN_BRACKET) ) {
                alt299=1;
            }
            switch (alt299) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1843:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_variant_type_parameters8119);
                    attributes();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1843:16: ( variance_annotation )?
            int alt300=2;
            int LA300_0 = input.LA(1);

            if ( (LA300_0==IN||LA300_0==OUT) ) {
                alt300=1;
            }
            switch (alt300) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1843:16: variance_annotation
                    {
                    pushFollow(FOLLOW_variance_annotation_in_variant_type_parameters8122);
                    variance_annotation();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            pushFollow(FOLLOW_type_parameter_in_variant_type_parameters8125);
            type_parameter();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1843:52: ( COMMA ( attributes )? ( variance_annotation )? type_parameter )*
            loop303:
            do {
                int alt303=2;
                int LA303_0 = input.LA(1);

                if ( (LA303_0==COMMA) ) {
                    alt303=1;
                }


                switch (alt303) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1843:54: COMMA ( attributes )? ( variance_annotation )? type_parameter
            	    {
            	    match(input,COMMA,FOLLOW_COMMA_in_variant_type_parameters8129); if (state.failed) return ;

            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1843:61: ( attributes )?
            	    int alt301=2;
            	    int LA301_0 = input.LA(1);

            	    if ( (LA301_0==OPEN_BRACKET) ) {
            	        alt301=1;
            	    }
            	    switch (alt301) {
            	        case 1 :
            	            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1843:61: attributes
            	            {
            	            pushFollow(FOLLOW_attributes_in_variant_type_parameters8132);
            	            attributes();

            	            state._fsp--;
            	            if (state.failed) return ;

            	            }
            	            break;

            	    }


            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1843:74: ( variance_annotation )?
            	    int alt302=2;
            	    int LA302_0 = input.LA(1);

            	    if ( (LA302_0==IN||LA302_0==OUT) ) {
            	        alt302=1;
            	    }
            	    switch (alt302) {
            	        case 1 :
            	            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1843:74: variance_annotation
            	            {
            	            pushFollow(FOLLOW_variance_annotation_in_variant_type_parameters8136);
            	            variance_annotation();

            	            state._fsp--;
            	            if (state.failed) return ;

            	            }
            	            break;

            	    }


            	    pushFollow(FOLLOW_type_parameter_in_variant_type_parameters8140);
            	    type_parameter();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop303;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "variant_type_parameters"



    // $ANTLR start "variance_annotation"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1845:1: variance_annotation : ( IN | OUT );
    public final void variance_annotation() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1846:2: ( IN | OUT )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:
            {
            if ( input.LA(1)==IN||input.LA(1)==OUT ) {
                input.consume();
                state.errorRecovery=false;
                state.failed=false;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                MismatchedSetException mse = new MismatchedSetException(null,input);
                throw mse;
            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "variance_annotation"



    // $ANTLR start "interface_base"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1849:1: interface_base : COLON interface_type_list ;
    public final void interface_base() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1850:2: ( COLON interface_type_list )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1850:4: COLON interface_type_list
            {
            match(input,COLON,FOLLOW_COLON_in_interface_base8170); if (state.failed) return ;

            pushFollow(FOLLOW_interface_type_list_in_interface_base8172);
            interface_type_list();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "interface_base"



    // $ANTLR start "interface_body"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1852:1: interface_body : OPEN_BRACE ( interface_member_declarations )? CLOSE_BRACE ;
    public final void interface_body() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1853:2: ( OPEN_BRACE ( interface_member_declarations )? CLOSE_BRACE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1853:4: OPEN_BRACE ( interface_member_declarations )? CLOSE_BRACE
            {
            match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_interface_body8183); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1853:15: ( interface_member_declarations )?
            int alt304=2;
            int LA304_0 = input.LA(1);

            if ( (LA304_0==BOOL||LA304_0==BYTE||LA304_0==CHAR||LA304_0==DECIMAL||LA304_0==DOUBLE||LA304_0==EVENT||LA304_0==FLOAT||LA304_0==IDENTIFIER||LA304_0==INT||LA304_0==LONG||LA304_0==NEW||LA304_0==OBJECT||LA304_0==OPEN_BRACKET||LA304_0==SBYTE||LA304_0==SHORT||LA304_0==STRING||(LA304_0 >= UINT && LA304_0 <= ULONG)||LA304_0==USHORT||LA304_0==VOID) ) {
                alt304=1;
            }
            switch (alt304) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1853:15: interface_member_declarations
                    {
                    pushFollow(FOLLOW_interface_member_declarations_in_interface_body8185);
                    interface_member_declarations();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_interface_body8188); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "interface_body"



    // $ANTLR start "interface_member_declarations"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1855:1: interface_member_declarations : ( interface_member_declaration )+ ;
    public final void interface_member_declarations() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1856:2: ( ( interface_member_declaration )+ )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1856:4: ( interface_member_declaration )+
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1856:4: ( interface_member_declaration )+
            int cnt305=0;
            loop305:
            do {
                int alt305=2;
                int LA305_0 = input.LA(1);

                if ( (LA305_0==BOOL||LA305_0==BYTE||LA305_0==CHAR||LA305_0==DECIMAL||LA305_0==DOUBLE||LA305_0==EVENT||LA305_0==FLOAT||LA305_0==IDENTIFIER||LA305_0==INT||LA305_0==LONG||LA305_0==NEW||LA305_0==OBJECT||LA305_0==OPEN_BRACKET||LA305_0==SBYTE||LA305_0==SHORT||LA305_0==STRING||(LA305_0 >= UINT && LA305_0 <= ULONG)||LA305_0==USHORT||LA305_0==VOID) ) {
                    alt305=1;
                }


                switch (alt305) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1856:4: interface_member_declaration
            	    {
            	    pushFollow(FOLLOW_interface_member_declaration_in_interface_member_declarations8199);
            	    interface_member_declaration();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    if ( cnt305 >= 1 ) break loop305;
            	    if (state.backtracking>0) {state.failed=true; return ;}
                        EarlyExitException eee =
                            new EarlyExitException(305, input);
                        throw eee;
                }
                cnt305++;
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "interface_member_declarations"



    // $ANTLR start "interface_member_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1866:1: interface_member_declaration : ( attributes )? ( NEW )? ( type ( IDENTIFIER ( type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? SEMICOLON | IDENTIFIER OPEN_BRACE interface_accessors CLOSE_BRACE | THIS OPEN_BRACKET formal_parameter_list CLOSE_BRACKET OPEN_BRACE interface_accessors CLOSE_BRACE ) | VOID IDENTIFIER ( type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? SEMICOLON | EVENT type IDENTIFIER SEMICOLON ) ;
    public final void interface_member_declaration() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1867:3: ( ( attributes )? ( NEW )? ( type ( IDENTIFIER ( type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? SEMICOLON | IDENTIFIER OPEN_BRACE interface_accessors CLOSE_BRACE | THIS OPEN_BRACKET formal_parameter_list CLOSE_BRACKET OPEN_BRACE interface_accessors CLOSE_BRACE ) | VOID IDENTIFIER ( type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? SEMICOLON | EVENT type IDENTIFIER SEMICOLON ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1867:5: ( attributes )? ( NEW )? ( type ( IDENTIFIER ( type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? SEMICOLON | IDENTIFIER OPEN_BRACE interface_accessors CLOSE_BRACE | THIS OPEN_BRACKET formal_parameter_list CLOSE_BRACKET OPEN_BRACE interface_accessors CLOSE_BRACE ) | VOID IDENTIFIER ( type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? SEMICOLON | EVENT type IDENTIFIER SEMICOLON )
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1867:5: ( attributes )?
            int alt306=2;
            int LA306_0 = input.LA(1);

            if ( (LA306_0==OPEN_BRACKET) ) {
                alt306=1;
            }
            switch (alt306) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1867:5: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_interface_member_declaration8214);
                    attributes();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1867:17: ( NEW )?
            int alt307=2;
            int LA307_0 = input.LA(1);

            if ( (LA307_0==NEW) ) {
                alt307=1;
            }
            switch (alt307) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1867:17: NEW
                    {
                    match(input,NEW,FOLLOW_NEW_in_interface_member_declaration8217); if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1868:5: ( type ( IDENTIFIER ( type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? SEMICOLON | IDENTIFIER OPEN_BRACE interface_accessors CLOSE_BRACE | THIS OPEN_BRACKET formal_parameter_list CLOSE_BRACKET OPEN_BRACE interface_accessors CLOSE_BRACE ) | VOID IDENTIFIER ( type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? SEMICOLON | EVENT type IDENTIFIER SEMICOLON )
            int alt315=3;
            switch ( input.LA(1) ) {
            case BOOL:
            case BYTE:
            case CHAR:
            case DECIMAL:
            case DOUBLE:
            case FLOAT:
            case IDENTIFIER:
            case INT:
            case LONG:
            case OBJECT:
            case SBYTE:
            case SHORT:
            case STRING:
            case UINT:
            case ULONG:
            case USHORT:
                {
                alt315=1;
                }
                break;
            case VOID:
                {
                int LA315_2 = input.LA(2);

                if ( (LA315_2==STAR) ) {
                    alt315=1;
                }
                else if ( (LA315_2==IDENTIFIER) ) {
                    alt315=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 315, 2, input);

                    throw nvae;

                }
                }
                break;
            case EVENT:
                {
                alt315=3;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 315, 0, input);

                throw nvae;

            }

            switch (alt315) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1868:7: type ( IDENTIFIER ( type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? SEMICOLON | IDENTIFIER OPEN_BRACE interface_accessors CLOSE_BRACE | THIS OPEN_BRACKET formal_parameter_list CLOSE_BRACKET OPEN_BRACE interface_accessors CLOSE_BRACE )
                    {
                    pushFollow(FOLLOW_type_in_interface_member_declaration8226);
                    type();

                    state._fsp--;
                    if (state.failed) return ;

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1869:7: ( IDENTIFIER ( type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? SEMICOLON | IDENTIFIER OPEN_BRACE interface_accessors CLOSE_BRACE | THIS OPEN_BRACKET formal_parameter_list CLOSE_BRACKET OPEN_BRACE interface_accessors CLOSE_BRACE )
                    int alt311=3;
                    int LA311_0 = input.LA(1);

                    if ( (LA311_0==IDENTIFIER) ) {
                        int LA311_1 = input.LA(2);

                        if ( (LA311_1==OPEN_BRACE) ) {
                            alt311=2;
                        }
                        else if ( (LA311_1==LT||LA311_1==OPEN_PARENS) ) {
                            alt311=1;
                        }
                        else {
                            if (state.backtracking>0) {state.failed=true; return ;}
                            NoViableAltException nvae =
                                new NoViableAltException("", 311, 1, input);

                            throw nvae;

                        }
                    }
                    else if ( (LA311_0==THIS) ) {
                        alt311=3;
                    }
                    else {
                        if (state.backtracking>0) {state.failed=true; return ;}
                        NoViableAltException nvae =
                            new NoViableAltException("", 311, 0, input);

                        throw nvae;

                    }
                    switch (alt311) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1869:9: IDENTIFIER ( type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? SEMICOLON
                            {
                            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_interface_member_declaration8236); if (state.failed) return ;

                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1869:20: ( type_parameter_list )?
                            int alt308=2;
                            int LA308_0 = input.LA(1);

                            if ( (LA308_0==LT) ) {
                                alt308=1;
                            }
                            switch (alt308) {
                                case 1 :
                                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1869:20: type_parameter_list
                                    {
                                    pushFollow(FOLLOW_type_parameter_list_in_interface_member_declaration8238);
                                    type_parameter_list();

                                    state._fsp--;
                                    if (state.failed) return ;

                                    }
                                    break;

                            }


                            match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_interface_member_declaration8241); if (state.failed) return ;

                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1869:53: ( formal_parameter_list )?
                            int alt309=2;
                            int LA309_0 = input.LA(1);

                            if ( (LA309_0==BOOL||LA309_0==BYTE||LA309_0==CHAR||LA309_0==DECIMAL||LA309_0==DOUBLE||LA309_0==FLOAT||LA309_0==IDENTIFIER||LA309_0==INT||LA309_0==LONG||LA309_0==OBJECT||LA309_0==OPEN_BRACKET||LA309_0==OUT||LA309_0==PARAMS||LA309_0==REF||LA309_0==SBYTE||LA309_0==SHORT||LA309_0==STRING||LA309_0==THIS||(LA309_0 >= UINT && LA309_0 <= ULONG)||LA309_0==USHORT||LA309_0==VOID) ) {
                                alt309=1;
                            }
                            switch (alt309) {
                                case 1 :
                                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1869:53: formal_parameter_list
                                    {
                                    pushFollow(FOLLOW_formal_parameter_list_in_interface_member_declaration8243);
                                    formal_parameter_list();

                                    state._fsp--;
                                    if (state.failed) return ;

                                    }
                                    break;

                            }


                            match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_interface_member_declaration8246); if (state.failed) return ;

                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1869:89: ( type_parameter_constraints_clauses )?
                            int alt310=2;
                            int LA310_0 = input.LA(1);

                            if ( (LA310_0==IDENTIFIER) ) {
                                alt310=1;
                            }
                            switch (alt310) {
                                case 1 :
                                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1869:89: type_parameter_constraints_clauses
                                    {
                                    pushFollow(FOLLOW_type_parameter_constraints_clauses_in_interface_member_declaration8248);
                                    type_parameter_constraints_clauses();

                                    state._fsp--;
                                    if (state.failed) return ;

                                    }
                                    break;

                            }


                            match(input,SEMICOLON,FOLLOW_SEMICOLON_in_interface_member_declaration8251); if (state.failed) return ;

                            }
                            break;
                        case 2 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1870:9: IDENTIFIER OPEN_BRACE interface_accessors CLOSE_BRACE
                            {
                            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_interface_member_declaration8261); if (state.failed) return ;

                            match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_interface_member_declaration8263); if (state.failed) return ;

                            pushFollow(FOLLOW_interface_accessors_in_interface_member_declaration8265);
                            interface_accessors();

                            state._fsp--;
                            if (state.failed) return ;

                            match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_interface_member_declaration8267); if (state.failed) return ;

                            }
                            break;
                        case 3 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1871:9: THIS OPEN_BRACKET formal_parameter_list CLOSE_BRACKET OPEN_BRACE interface_accessors CLOSE_BRACE
                            {
                            match(input,THIS,FOLLOW_THIS_in_interface_member_declaration8277); if (state.failed) return ;

                            match(input,OPEN_BRACKET,FOLLOW_OPEN_BRACKET_in_interface_member_declaration8279); if (state.failed) return ;

                            pushFollow(FOLLOW_formal_parameter_list_in_interface_member_declaration8281);
                            formal_parameter_list();

                            state._fsp--;
                            if (state.failed) return ;

                            match(input,CLOSE_BRACKET,FOLLOW_CLOSE_BRACKET_in_interface_member_declaration8283); if (state.failed) return ;

                            match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_interface_member_declaration8285); if (state.failed) return ;

                            pushFollow(FOLLOW_interface_accessors_in_interface_member_declaration8287);
                            interface_accessors();

                            state._fsp--;
                            if (state.failed) return ;

                            match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_interface_member_declaration8289); if (state.failed) return ;

                            }
                            break;

                    }


                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1873:7: VOID IDENTIFIER ( type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? SEMICOLON
                    {
                    match(input,VOID,FOLLOW_VOID_in_interface_member_declaration8305); if (state.failed) return ;

                    match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_interface_member_declaration8307); if (state.failed) return ;

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1873:23: ( type_parameter_list )?
                    int alt312=2;
                    int LA312_0 = input.LA(1);

                    if ( (LA312_0==LT) ) {
                        alt312=1;
                    }
                    switch (alt312) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1873:23: type_parameter_list
                            {
                            pushFollow(FOLLOW_type_parameter_list_in_interface_member_declaration8309);
                            type_parameter_list();

                            state._fsp--;
                            if (state.failed) return ;

                            }
                            break;

                    }


                    match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_interface_member_declaration8312); if (state.failed) return ;

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1873:56: ( formal_parameter_list )?
                    int alt313=2;
                    int LA313_0 = input.LA(1);

                    if ( (LA313_0==BOOL||LA313_0==BYTE||LA313_0==CHAR||LA313_0==DECIMAL||LA313_0==DOUBLE||LA313_0==FLOAT||LA313_0==IDENTIFIER||LA313_0==INT||LA313_0==LONG||LA313_0==OBJECT||LA313_0==OPEN_BRACKET||LA313_0==OUT||LA313_0==PARAMS||LA313_0==REF||LA313_0==SBYTE||LA313_0==SHORT||LA313_0==STRING||LA313_0==THIS||(LA313_0 >= UINT && LA313_0 <= ULONG)||LA313_0==USHORT||LA313_0==VOID) ) {
                        alt313=1;
                    }
                    switch (alt313) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1873:56: formal_parameter_list
                            {
                            pushFollow(FOLLOW_formal_parameter_list_in_interface_member_declaration8314);
                            formal_parameter_list();

                            state._fsp--;
                            if (state.failed) return ;

                            }
                            break;

                    }


                    match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_interface_member_declaration8317); if (state.failed) return ;

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1873:92: ( type_parameter_constraints_clauses )?
                    int alt314=2;
                    int LA314_0 = input.LA(1);

                    if ( (LA314_0==IDENTIFIER) ) {
                        alt314=1;
                    }
                    switch (alt314) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1873:92: type_parameter_constraints_clauses
                            {
                            pushFollow(FOLLOW_type_parameter_constraints_clauses_in_interface_member_declaration8319);
                            type_parameter_constraints_clauses();

                            state._fsp--;
                            if (state.failed) return ;

                            }
                            break;

                    }


                    match(input,SEMICOLON,FOLLOW_SEMICOLON_in_interface_member_declaration8322); if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1874:7: EVENT type IDENTIFIER SEMICOLON
                    {
                    match(input,EVENT,FOLLOW_EVENT_in_interface_member_declaration8330); if (state.failed) return ;

                    pushFollow(FOLLOW_type_in_interface_member_declaration8332);
                    type();

                    state._fsp--;
                    if (state.failed) return ;

                    match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_interface_member_declaration8334); if (state.failed) return ;

                    match(input,SEMICOLON,FOLLOW_SEMICOLON_in_interface_member_declaration8336); if (state.failed) return ;

                    }
                    break;

            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "interface_member_declaration"



    // $ANTLR start "interface_method_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1877:1: interface_method_declaration : ( attributes )? ( NEW )? return_type IDENTIFIER ( type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? SEMICOLON ;
    public final void interface_method_declaration() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1878:2: ( ( attributes )? ( NEW )? return_type IDENTIFIER ( type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? SEMICOLON )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1878:4: ( attributes )? ( NEW )? return_type IDENTIFIER ( type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? SEMICOLON
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1878:4: ( attributes )?
            int alt316=2;
            int LA316_0 = input.LA(1);

            if ( (LA316_0==OPEN_BRACKET) ) {
                alt316=1;
            }
            switch (alt316) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1878:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_interface_method_declaration8354);
                    attributes();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1878:16: ( NEW )?
            int alt317=2;
            int LA317_0 = input.LA(1);

            if ( (LA317_0==NEW) ) {
                alt317=1;
            }
            switch (alt317) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1878:16: NEW
                    {
                    match(input,NEW,FOLLOW_NEW_in_interface_method_declaration8357); if (state.failed) return ;

                    }
                    break;

            }


            pushFollow(FOLLOW_return_type_in_interface_method_declaration8360);
            return_type();

            state._fsp--;
            if (state.failed) return ;

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_interface_method_declaration8362); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1878:44: ( type_parameter_list )?
            int alt318=2;
            int LA318_0 = input.LA(1);

            if ( (LA318_0==LT) ) {
                alt318=1;
            }
            switch (alt318) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1878:44: type_parameter_list
                    {
                    pushFollow(FOLLOW_type_parameter_list_in_interface_method_declaration8364);
                    type_parameter_list();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_interface_method_declaration8367); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1878:77: ( formal_parameter_list )?
            int alt319=2;
            int LA319_0 = input.LA(1);

            if ( (LA319_0==BOOL||LA319_0==BYTE||LA319_0==CHAR||LA319_0==DECIMAL||LA319_0==DOUBLE||LA319_0==FLOAT||LA319_0==IDENTIFIER||LA319_0==INT||LA319_0==LONG||LA319_0==OBJECT||LA319_0==OPEN_BRACKET||LA319_0==OUT||LA319_0==PARAMS||LA319_0==REF||LA319_0==SBYTE||LA319_0==SHORT||LA319_0==STRING||LA319_0==THIS||(LA319_0 >= UINT && LA319_0 <= ULONG)||LA319_0==USHORT||LA319_0==VOID) ) {
                alt319=1;
            }
            switch (alt319) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1878:77: formal_parameter_list
                    {
                    pushFollow(FOLLOW_formal_parameter_list_in_interface_method_declaration8369);
                    formal_parameter_list();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_interface_method_declaration8372); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1878:113: ( type_parameter_constraints_clauses )?
            int alt320=2;
            int LA320_0 = input.LA(1);

            if ( (LA320_0==IDENTIFIER) ) {
                alt320=1;
            }
            switch (alt320) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1878:113: type_parameter_constraints_clauses
                    {
                    pushFollow(FOLLOW_type_parameter_constraints_clauses_in_interface_method_declaration8374);
                    type_parameter_constraints_clauses();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,SEMICOLON,FOLLOW_SEMICOLON_in_interface_method_declaration8377); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "interface_method_declaration"



    // $ANTLR start "interface_property_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1880:1: interface_property_declaration : ( attributes )? ( NEW )? type IDENTIFIER OPEN_BRACE interface_accessors CLOSE_BRACE ;
    public final void interface_property_declaration() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1881:2: ( ( attributes )? ( NEW )? type IDENTIFIER OPEN_BRACE interface_accessors CLOSE_BRACE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1881:4: ( attributes )? ( NEW )? type IDENTIFIER OPEN_BRACE interface_accessors CLOSE_BRACE
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1881:4: ( attributes )?
            int alt321=2;
            int LA321_0 = input.LA(1);

            if ( (LA321_0==OPEN_BRACKET) ) {
                alt321=1;
            }
            switch (alt321) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1881:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_interface_property_declaration8388);
                    attributes();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1881:16: ( NEW )?
            int alt322=2;
            int LA322_0 = input.LA(1);

            if ( (LA322_0==NEW) ) {
                alt322=1;
            }
            switch (alt322) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1881:16: NEW
                    {
                    match(input,NEW,FOLLOW_NEW_in_interface_property_declaration8391); if (state.failed) return ;

                    }
                    break;

            }


            pushFollow(FOLLOW_type_in_interface_property_declaration8394);
            type();

            state._fsp--;
            if (state.failed) return ;

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_interface_property_declaration8396); if (state.failed) return ;

            match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_interface_property_declaration8398); if (state.failed) return ;

            pushFollow(FOLLOW_interface_accessors_in_interface_property_declaration8400);
            interface_accessors();

            state._fsp--;
            if (state.failed) return ;

            match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_interface_property_declaration8402); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "interface_property_declaration"



    // $ANTLR start "interface_accessors"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1891:1: interface_accessors : ( attributes )? ( get_contextual_keyword SEMICOLON ( ( attributes )? set_contextual_keyword SEMICOLON )? | set_contextual_keyword SEMICOLON ( ( attributes )? get_contextual_keyword SEMICOLON )? ) ;
    public final void interface_accessors() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1892:3: ( ( attributes )? ( get_contextual_keyword SEMICOLON ( ( attributes )? set_contextual_keyword SEMICOLON )? | set_contextual_keyword SEMICOLON ( ( attributes )? get_contextual_keyword SEMICOLON )? ) )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1892:5: ( attributes )? ( get_contextual_keyword SEMICOLON ( ( attributes )? set_contextual_keyword SEMICOLON )? | set_contextual_keyword SEMICOLON ( ( attributes )? get_contextual_keyword SEMICOLON )? )
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1892:5: ( attributes )?
            int alt323=2;
            int LA323_0 = input.LA(1);

            if ( (LA323_0==OPEN_BRACKET) ) {
                alt323=1;
            }
            switch (alt323) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1892:5: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_interface_accessors8416);
                    attributes();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1893:5: ( get_contextual_keyword SEMICOLON ( ( attributes )? set_contextual_keyword SEMICOLON )? | set_contextual_keyword SEMICOLON ( ( attributes )? get_contextual_keyword SEMICOLON )? )
            int alt328=2;
            int LA328_0 = input.LA(1);

            if ( (LA328_0==IDENTIFIER) ) {
                int LA328_1 = input.LA(2);

                if ( (LA328_1==SEMICOLON) ) {
                    int LA328_2 = input.LA(3);

                    if ( ((input.LT(1).getText().equals("get"))) ) {
                        alt328=1;
                    }
                    else if ( ((input.LT(1).getText().equals("set"))) ) {
                        alt328=2;
                    }
                    else {
                        if (state.backtracking>0) {state.failed=true; return ;}
                        NoViableAltException nvae =
                            new NoViableAltException("", 328, 2, input);

                        throw nvae;

                    }
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 328, 1, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 328, 0, input);

                throw nvae;

            }
            switch (alt328) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1893:7: get_contextual_keyword SEMICOLON ( ( attributes )? set_contextual_keyword SEMICOLON )?
                    {
                    pushFollow(FOLLOW_get_contextual_keyword_in_interface_accessors8425);
                    get_contextual_keyword();

                    state._fsp--;
                    if (state.failed) return ;

                    match(input,SEMICOLON,FOLLOW_SEMICOLON_in_interface_accessors8427); if (state.failed) return ;

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1893:40: ( ( attributes )? set_contextual_keyword SEMICOLON )?
                    int alt325=2;
                    int LA325_0 = input.LA(1);

                    if ( (LA325_0==IDENTIFIER||LA325_0==OPEN_BRACKET) ) {
                        alt325=1;
                    }
                    switch (alt325) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1893:41: ( attributes )? set_contextual_keyword SEMICOLON
                            {
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1893:41: ( attributes )?
                            int alt324=2;
                            int LA324_0 = input.LA(1);

                            if ( (LA324_0==OPEN_BRACKET) ) {
                                alt324=1;
                            }
                            switch (alt324) {
                                case 1 :
                                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1893:41: attributes
                                    {
                                    pushFollow(FOLLOW_attributes_in_interface_accessors8430);
                                    attributes();

                                    state._fsp--;
                                    if (state.failed) return ;

                                    }
                                    break;

                            }


                            pushFollow(FOLLOW_set_contextual_keyword_in_interface_accessors8433);
                            set_contextual_keyword();

                            state._fsp--;
                            if (state.failed) return ;

                            match(input,SEMICOLON,FOLLOW_SEMICOLON_in_interface_accessors8435); if (state.failed) return ;

                            }
                            break;

                    }


                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1894:7: set_contextual_keyword SEMICOLON ( ( attributes )? get_contextual_keyword SEMICOLON )?
                    {
                    pushFollow(FOLLOW_set_contextual_keyword_in_interface_accessors8445);
                    set_contextual_keyword();

                    state._fsp--;
                    if (state.failed) return ;

                    match(input,SEMICOLON,FOLLOW_SEMICOLON_in_interface_accessors8447); if (state.failed) return ;

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1894:40: ( ( attributes )? get_contextual_keyword SEMICOLON )?
                    int alt327=2;
                    int LA327_0 = input.LA(1);

                    if ( (LA327_0==IDENTIFIER||LA327_0==OPEN_BRACKET) ) {
                        alt327=1;
                    }
                    switch (alt327) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1894:41: ( attributes )? get_contextual_keyword SEMICOLON
                            {
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1894:41: ( attributes )?
                            int alt326=2;
                            int LA326_0 = input.LA(1);

                            if ( (LA326_0==OPEN_BRACKET) ) {
                                alt326=1;
                            }
                            switch (alt326) {
                                case 1 :
                                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1894:41: attributes
                                    {
                                    pushFollow(FOLLOW_attributes_in_interface_accessors8450);
                                    attributes();

                                    state._fsp--;
                                    if (state.failed) return ;

                                    }
                                    break;

                            }


                            pushFollow(FOLLOW_get_contextual_keyword_in_interface_accessors8453);
                            get_contextual_keyword();

                            state._fsp--;
                            if (state.failed) return ;

                            match(input,SEMICOLON,FOLLOW_SEMICOLON_in_interface_accessors8455); if (state.failed) return ;

                            }
                            break;

                    }


                    }
                    break;

            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "interface_accessors"



    // $ANTLR start "interface_event_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1897:1: interface_event_declaration : ( attributes )? ( NEW )? EVENT type IDENTIFIER SEMICOLON ;
    public final void interface_event_declaration() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1898:2: ( ( attributes )? ( NEW )? EVENT type IDENTIFIER SEMICOLON )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1898:4: ( attributes )? ( NEW )? EVENT type IDENTIFIER SEMICOLON
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1898:4: ( attributes )?
            int alt329=2;
            int LA329_0 = input.LA(1);

            if ( (LA329_0==OPEN_BRACKET) ) {
                alt329=1;
            }
            switch (alt329) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1898:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_interface_event_declaration8475);
                    attributes();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1898:16: ( NEW )?
            int alt330=2;
            int LA330_0 = input.LA(1);

            if ( (LA330_0==NEW) ) {
                alt330=1;
            }
            switch (alt330) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1898:16: NEW
                    {
                    match(input,NEW,FOLLOW_NEW_in_interface_event_declaration8478); if (state.failed) return ;

                    }
                    break;

            }


            match(input,EVENT,FOLLOW_EVENT_in_interface_event_declaration8481); if (state.failed) return ;

            pushFollow(FOLLOW_type_in_interface_event_declaration8483);
            type();

            state._fsp--;
            if (state.failed) return ;

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_interface_event_declaration8485); if (state.failed) return ;

            match(input,SEMICOLON,FOLLOW_SEMICOLON_in_interface_event_declaration8487); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "interface_event_declaration"



    // $ANTLR start "interface_indexer_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1900:1: interface_indexer_declaration : ( attributes )? ( NEW )? type THIS OPEN_BRACKET formal_parameter_list CLOSE_BRACKET OPEN_BRACE interface_accessors CLOSE_BRACE ;
    public final void interface_indexer_declaration() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1901:2: ( ( attributes )? ( NEW )? type THIS OPEN_BRACKET formal_parameter_list CLOSE_BRACKET OPEN_BRACE interface_accessors CLOSE_BRACE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1901:4: ( attributes )? ( NEW )? type THIS OPEN_BRACKET formal_parameter_list CLOSE_BRACKET OPEN_BRACE interface_accessors CLOSE_BRACE
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1901:4: ( attributes )?
            int alt331=2;
            int LA331_0 = input.LA(1);

            if ( (LA331_0==OPEN_BRACKET) ) {
                alt331=1;
            }
            switch (alt331) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1901:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_interface_indexer_declaration8498);
                    attributes();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1901:16: ( NEW )?
            int alt332=2;
            int LA332_0 = input.LA(1);

            if ( (LA332_0==NEW) ) {
                alt332=1;
            }
            switch (alt332) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1901:16: NEW
                    {
                    match(input,NEW,FOLLOW_NEW_in_interface_indexer_declaration8501); if (state.failed) return ;

                    }
                    break;

            }


            pushFollow(FOLLOW_type_in_interface_indexer_declaration8504);
            type();

            state._fsp--;
            if (state.failed) return ;

            match(input,THIS,FOLLOW_THIS_in_interface_indexer_declaration8506); if (state.failed) return ;

            match(input,OPEN_BRACKET,FOLLOW_OPEN_BRACKET_in_interface_indexer_declaration8508); if (state.failed) return ;

            pushFollow(FOLLOW_formal_parameter_list_in_interface_indexer_declaration8510);
            formal_parameter_list();

            state._fsp--;
            if (state.failed) return ;

            match(input,CLOSE_BRACKET,FOLLOW_CLOSE_BRACKET_in_interface_indexer_declaration8512); if (state.failed) return ;

            match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_interface_indexer_declaration8514); if (state.failed) return ;

            pushFollow(FOLLOW_interface_accessors_in_interface_indexer_declaration8516);
            interface_accessors();

            state._fsp--;
            if (state.failed) return ;

            match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_interface_indexer_declaration8518); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "interface_indexer_declaration"



    // $ANTLR start "enum_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1906:1: enum_declaration : ( attributes )? ( enum_modifiers )? ENUM IDENTIFIER ( enum_base )? enum_body ( SEMICOLON )? ;
    public final void enum_declaration() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1907:2: ( ( attributes )? ( enum_modifiers )? ENUM IDENTIFIER ( enum_base )? enum_body ( SEMICOLON )? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1907:4: ( attributes )? ( enum_modifiers )? ENUM IDENTIFIER ( enum_base )? enum_body ( SEMICOLON )?
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1907:4: ( attributes )?
            int alt333=2;
            int LA333_0 = input.LA(1);

            if ( (LA333_0==OPEN_BRACKET) ) {
                alt333=1;
            }
            switch (alt333) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1907:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_enum_declaration8532);
                    attributes();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1907:16: ( enum_modifiers )?
            int alt334=2;
            int LA334_0 = input.LA(1);

            if ( (LA334_0==INTERNAL||LA334_0==NEW||(LA334_0 >= PRIVATE && LA334_0 <= PUBLIC)) ) {
                alt334=1;
            }
            switch (alt334) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1907:16: enum_modifiers
                    {
                    pushFollow(FOLLOW_enum_modifiers_in_enum_declaration8535);
                    enum_modifiers();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,ENUM,FOLLOW_ENUM_in_enum_declaration8538); if (state.failed) return ;

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_enum_declaration8540); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1907:48: ( enum_base )?
            int alt335=2;
            int LA335_0 = input.LA(1);

            if ( (LA335_0==COLON) ) {
                alt335=1;
            }
            switch (alt335) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1907:48: enum_base
                    {
                    pushFollow(FOLLOW_enum_base_in_enum_declaration8542);
                    enum_base();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            pushFollow(FOLLOW_enum_body_in_enum_declaration8545);
            enum_body();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1907:69: ( SEMICOLON )?
            int alt336=2;
            int LA336_0 = input.LA(1);

            if ( (LA336_0==SEMICOLON) ) {
                alt336=1;
            }
            switch (alt336) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1907:69: SEMICOLON
                    {
                    match(input,SEMICOLON,FOLLOW_SEMICOLON_in_enum_declaration8547); if (state.failed) return ;

                    }
                    break;

            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "enum_declaration"



    // $ANTLR start "enum_base"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1909:1: enum_base : COLON integral_type ;
    public final void enum_base() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1910:2: ( COLON integral_type )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1910:4: COLON integral_type
            {
            match(input,COLON,FOLLOW_COLON_in_enum_base8559); if (state.failed) return ;

            pushFollow(FOLLOW_integral_type_in_enum_base8561);
            integral_type();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "enum_base"



    // $ANTLR start "enum_body"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1918:1: enum_body : ( OPEN_BRACE CLOSE_BRACE | OPEN_BRACE enum_member_declarations ( COMMA )? CLOSE_BRACE );
    public final void enum_body() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1919:3: ( OPEN_BRACE CLOSE_BRACE | OPEN_BRACE enum_member_declarations ( COMMA )? CLOSE_BRACE )
            int alt338=2;
            int LA338_0 = input.LA(1);

            if ( (LA338_0==OPEN_BRACE) ) {
                int LA338_1 = input.LA(2);

                if ( (LA338_1==CLOSE_BRACE) ) {
                    alt338=1;
                }
                else if ( (LA338_1==IDENTIFIER||LA338_1==OPEN_BRACKET) ) {
                    alt338=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 338, 1, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 338, 0, input);

                throw nvae;

            }
            switch (alt338) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1919:5: OPEN_BRACE CLOSE_BRACE
                    {
                    match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_enum_body8575); if (state.failed) return ;

                    match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_enum_body8577); if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1920:5: OPEN_BRACE enum_member_declarations ( COMMA )? CLOSE_BRACE
                    {
                    match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_enum_body8583); if (state.failed) return ;

                    pushFollow(FOLLOW_enum_member_declarations_in_enum_body8585);
                    enum_member_declarations();

                    state._fsp--;
                    if (state.failed) return ;

                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1920:41: ( COMMA )?
                    int alt337=2;
                    int LA337_0 = input.LA(1);

                    if ( (LA337_0==COMMA) ) {
                        alt337=1;
                    }
                    switch (alt337) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1920:41: COMMA
                            {
                            match(input,COMMA,FOLLOW_COMMA_in_enum_body8587); if (state.failed) return ;

                            }
                            break;

                    }


                    match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_enum_body8590); if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "enum_body"



    // $ANTLR start "enum_modifiers"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1922:1: enum_modifiers : ( enum_modifier )+ ;
    public final void enum_modifiers() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1923:2: ( ( enum_modifier )+ )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1923:4: ( enum_modifier )+
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1923:4: ( enum_modifier )+
            int cnt339=0;
            loop339:
            do {
                int alt339=2;
                int LA339_0 = input.LA(1);

                if ( (LA339_0==INTERNAL||LA339_0==NEW||(LA339_0 >= PRIVATE && LA339_0 <= PUBLIC)) ) {
                    alt339=1;
                }


                switch (alt339) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1923:4: enum_modifier
            	    {
            	    pushFollow(FOLLOW_enum_modifier_in_enum_modifiers8602);
            	    enum_modifier();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    if ( cnt339 >= 1 ) break loop339;
            	    if (state.backtracking>0) {state.failed=true; return ;}
                        EarlyExitException eee =
                            new EarlyExitException(339, input);
                        throw eee;
                }
                cnt339++;
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "enum_modifiers"



    // $ANTLR start "enum_modifier"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1925:1: enum_modifier : ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE );
    public final void enum_modifier() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1926:2: ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:
            {
            if ( input.LA(1)==INTERNAL||input.LA(1)==NEW||(input.LA(1) >= PRIVATE && input.LA(1) <= PUBLIC) ) {
                input.consume();
                state.errorRecovery=false;
                state.failed=false;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                MismatchedSetException mse = new MismatchedSetException(null,input);
                throw mse;
            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "enum_modifier"



    // $ANTLR start "enum_member_declarations"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1932:1: enum_member_declarations : enum_member_declaration ( COMMA enum_member_declaration )* ;
    public final void enum_member_declarations() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1933:2: ( enum_member_declaration ( COMMA enum_member_declaration )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1933:4: enum_member_declaration ( COMMA enum_member_declaration )*
            {
            pushFollow(FOLLOW_enum_member_declaration_in_enum_member_declarations8645);
            enum_member_declaration();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1933:28: ( COMMA enum_member_declaration )*
            loop340:
            do {
                int alt340=2;
                int LA340_0 = input.LA(1);

                if ( (LA340_0==COMMA) ) {
                    int LA340_1 = input.LA(2);

                    if ( (LA340_1==IDENTIFIER||LA340_1==OPEN_BRACKET) ) {
                        alt340=1;
                    }


                }


                switch (alt340) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1933:30: COMMA enum_member_declaration
            	    {
            	    match(input,COMMA,FOLLOW_COMMA_in_enum_member_declarations8649); if (state.failed) return ;

            	    pushFollow(FOLLOW_enum_member_declaration_in_enum_member_declarations8652);
            	    enum_member_declaration();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop340;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "enum_member_declarations"



    // $ANTLR start "enum_member_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1941:1: enum_member_declaration : ( attributes )? IDENTIFIER ( ASSIGNMENT constant_expression )? ;
    public final void enum_member_declaration() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1942:3: ( ( attributes )? IDENTIFIER ( ASSIGNMENT constant_expression )? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1942:5: ( attributes )? IDENTIFIER ( ASSIGNMENT constant_expression )?
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1942:5: ( attributes )?
            int alt341=2;
            int LA341_0 = input.LA(1);

            if ( (LA341_0==OPEN_BRACKET) ) {
                alt341=1;
            }
            switch (alt341) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1942:5: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_enum_member_declaration8669);
                    attributes();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_enum_member_declaration8672); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1942:28: ( ASSIGNMENT constant_expression )?
            int alt342=2;
            int LA342_0 = input.LA(1);

            if ( (LA342_0==ASSIGNMENT) ) {
                alt342=1;
            }
            switch (alt342) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1942:29: ASSIGNMENT constant_expression
                    {
                    match(input,ASSIGNMENT,FOLLOW_ASSIGNMENT_in_enum_member_declaration8675); if (state.failed) return ;

                    pushFollow(FOLLOW_constant_expression_in_enum_member_declaration8677);
                    constant_expression();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "enum_member_declaration"



    // $ANTLR start "delegate_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1946:1: delegate_declaration : ( attributes )? ( delegate_modifiers )? DELEGATE return_type IDENTIFIER ( variant_type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? SEMICOLON ;
    public final void delegate_declaration() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1947:2: ( ( attributes )? ( delegate_modifiers )? DELEGATE return_type IDENTIFIER ( variant_type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? SEMICOLON )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1947:4: ( attributes )? ( delegate_modifiers )? DELEGATE return_type IDENTIFIER ( variant_type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? SEMICOLON
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1947:4: ( attributes )?
            int alt343=2;
            int LA343_0 = input.LA(1);

            if ( (LA343_0==OPEN_BRACKET) ) {
                alt343=1;
            }
            switch (alt343) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1947:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_delegate_declaration8693);
                    attributes();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1947:16: ( delegate_modifiers )?
            int alt344=2;
            int LA344_0 = input.LA(1);

            if ( (LA344_0==INTERNAL||LA344_0==NEW||(LA344_0 >= PRIVATE && LA344_0 <= PUBLIC)||LA344_0==UNSAFE) ) {
                alt344=1;
            }
            switch (alt344) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1947:16: delegate_modifiers
                    {
                    pushFollow(FOLLOW_delegate_modifiers_in_delegate_declaration8696);
                    delegate_modifiers();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,DELEGATE,FOLLOW_DELEGATE_in_delegate_declaration8699); if (state.failed) return ;

            pushFollow(FOLLOW_return_type_in_delegate_declaration8701);
            return_type();

            state._fsp--;
            if (state.failed) return ;

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_delegate_declaration8703); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1947:68: ( variant_type_parameter_list )?
            int alt345=2;
            int LA345_0 = input.LA(1);

            if ( (LA345_0==LT) ) {
                alt345=1;
            }
            switch (alt345) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1947:68: variant_type_parameter_list
                    {
                    pushFollow(FOLLOW_variant_type_parameter_list_in_delegate_declaration8705);
                    variant_type_parameter_list();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_delegate_declaration8714); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1948:18: ( formal_parameter_list )?
            int alt346=2;
            int LA346_0 = input.LA(1);

            if ( (LA346_0==BOOL||LA346_0==BYTE||LA346_0==CHAR||LA346_0==DECIMAL||LA346_0==DOUBLE||LA346_0==FLOAT||LA346_0==IDENTIFIER||LA346_0==INT||LA346_0==LONG||LA346_0==OBJECT||LA346_0==OPEN_BRACKET||LA346_0==OUT||LA346_0==PARAMS||LA346_0==REF||LA346_0==SBYTE||LA346_0==SHORT||LA346_0==STRING||LA346_0==THIS||(LA346_0 >= UINT && LA346_0 <= ULONG)||LA346_0==USHORT||LA346_0==VOID) ) {
                alt346=1;
            }
            switch (alt346) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1948:18: formal_parameter_list
                    {
                    pushFollow(FOLLOW_formal_parameter_list_in_delegate_declaration8716);
                    formal_parameter_list();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_delegate_declaration8719); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1948:54: ( type_parameter_constraints_clauses )?
            int alt347=2;
            int LA347_0 = input.LA(1);

            if ( (LA347_0==IDENTIFIER) ) {
                alt347=1;
            }
            switch (alt347) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1948:54: type_parameter_constraints_clauses
                    {
                    pushFollow(FOLLOW_type_parameter_constraints_clauses_in_delegate_declaration8721);
                    type_parameter_constraints_clauses();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,SEMICOLON,FOLLOW_SEMICOLON_in_delegate_declaration8724); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "delegate_declaration"



    // $ANTLR start "delegate_modifiers"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1950:1: delegate_modifiers : delegate_modifier ( delegate_modifier )* ;
    public final void delegate_modifiers() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1951:2: ( delegate_modifier ( delegate_modifier )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1951:4: delegate_modifier ( delegate_modifier )*
            {
            pushFollow(FOLLOW_delegate_modifier_in_delegate_modifiers8735);
            delegate_modifier();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1951:22: ( delegate_modifier )*
            loop348:
            do {
                int alt348=2;
                int LA348_0 = input.LA(1);

                if ( (LA348_0==INTERNAL||LA348_0==NEW||(LA348_0 >= PRIVATE && LA348_0 <= PUBLIC)||LA348_0==UNSAFE) ) {
                    alt348=1;
                }


                switch (alt348) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1951:24: delegate_modifier
            	    {
            	    pushFollow(FOLLOW_delegate_modifier_in_delegate_modifiers8739);
            	    delegate_modifier();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop348;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "delegate_modifiers"



    // $ANTLR start "delegate_modifier"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1953:1: delegate_modifier : ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | delegate_modifier_unsafe );
    public final void delegate_modifier() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1954:2: ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | delegate_modifier_unsafe )
            int alt349=6;
            switch ( input.LA(1) ) {
            case NEW:
                {
                alt349=1;
                }
                break;
            case PUBLIC:
                {
                alt349=2;
                }
                break;
            case PROTECTED:
                {
                alt349=3;
                }
                break;
            case INTERNAL:
                {
                alt349=4;
                }
                break;
            case PRIVATE:
                {
                alt349=5;
                }
                break;
            case UNSAFE:
                {
                alt349=6;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 349, 0, input);

                throw nvae;

            }

            switch (alt349) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1954:4: NEW
                    {
                    match(input,NEW,FOLLOW_NEW_in_delegate_modifier8753); if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1955:4: PUBLIC
                    {
                    match(input,PUBLIC,FOLLOW_PUBLIC_in_delegate_modifier8758); if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1956:4: PROTECTED
                    {
                    match(input,PROTECTED,FOLLOW_PROTECTED_in_delegate_modifier8763); if (state.failed) return ;

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1957:4: INTERNAL
                    {
                    match(input,INTERNAL,FOLLOW_INTERNAL_in_delegate_modifier8768); if (state.failed) return ;

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1958:4: PRIVATE
                    {
                    match(input,PRIVATE,FOLLOW_PRIVATE_in_delegate_modifier8773); if (state.failed) return ;

                    }
                    break;
                case 6 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1959:4: delegate_modifier_unsafe
                    {
                    pushFollow(FOLLOW_delegate_modifier_unsafe_in_delegate_modifier8778);
                    delegate_modifier_unsafe();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "delegate_modifier"



    // $ANTLR start "global_attributes"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1965:1: global_attributes : global_attribute_sections ;
    public final void global_attributes() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1966:2: ( global_attribute_sections )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1966:4: global_attribute_sections
            {
            pushFollow(FOLLOW_global_attribute_sections_in_global_attributes8793);
            global_attribute_sections();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "global_attributes"



    // $ANTLR start "global_attribute_sections"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1968:1: global_attribute_sections : ( global_attribute_section )+ ;
    public final void global_attribute_sections() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1969:2: ( ( global_attribute_section )+ )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1969:4: ( global_attribute_section )+
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1969:4: ( global_attribute_section )+
            int cnt350=0;
            loop350:
            do {
                int alt350=2;
                int LA350_0 = input.LA(1);

                if ( (LA350_0==OPEN_BRACKET) ) {
                    alt350=1;
                }


                switch (alt350) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1969:4: global_attribute_section
            	    {
            	    pushFollow(FOLLOW_global_attribute_section_in_global_attribute_sections8804);
            	    global_attribute_section();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    if ( cnt350 >= 1 ) break loop350;
            	    if (state.backtracking>0) {state.failed=true; return ;}
                        EarlyExitException eee =
                            new EarlyExitException(350, input);
                        throw eee;
                }
                cnt350++;
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "global_attribute_sections"



    // $ANTLR start "global_attribute_section"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1977:1: global_attribute_section : OPEN_BRACKET global_attribute_target_specifier attribute_list ( COMMA )? CLOSE_BRACKET ;
    public final void global_attribute_section() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1978:3: ( OPEN_BRACKET global_attribute_target_specifier attribute_list ( COMMA )? CLOSE_BRACKET )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1978:5: OPEN_BRACKET global_attribute_target_specifier attribute_list ( COMMA )? CLOSE_BRACKET
            {
            match(input,OPEN_BRACKET,FOLLOW_OPEN_BRACKET_in_global_attribute_section8819); if (state.failed) return ;

            pushFollow(FOLLOW_global_attribute_target_specifier_in_global_attribute_section8821);
            global_attribute_target_specifier();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_attribute_list_in_global_attribute_section8823);
            attribute_list();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1978:67: ( COMMA )?
            int alt351=2;
            int LA351_0 = input.LA(1);

            if ( (LA351_0==COMMA) ) {
                alt351=1;
            }
            switch (alt351) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1978:67: COMMA
                    {
                    match(input,COMMA,FOLLOW_COMMA_in_global_attribute_section8825); if (state.failed) return ;

                    }
                    break;

            }


            match(input,CLOSE_BRACKET,FOLLOW_CLOSE_BRACKET_in_global_attribute_section8828); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "global_attribute_section"



    // $ANTLR start "global_attribute_target_specifier"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1980:1: global_attribute_target_specifier : global_attribute_target COLON ;
    public final void global_attribute_target_specifier() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1981:2: ( global_attribute_target COLON )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1981:4: global_attribute_target COLON
            {
            pushFollow(FOLLOW_global_attribute_target_in_global_attribute_target_specifier8840);
            global_attribute_target();

            state._fsp--;
            if (state.failed) return ;

            match(input,COLON,FOLLOW_COLON_in_global_attribute_target_specifier8842); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "global_attribute_target_specifier"



    // $ANTLR start "global_attribute_target"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1983:1: global_attribute_target : ( keyword | IDENTIFIER );
    public final void global_attribute_target() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1984:3: ( keyword | IDENTIFIER )
            int alt352=2;
            int LA352_0 = input.LA(1);

            if ( (LA352_0==ABSTRACT||LA352_0==AS||LA352_0==BASE||(LA352_0 >= BOOL && LA352_0 <= BYTE)||(LA352_0 >= CASE && LA352_0 <= CHAR)||(LA352_0 >= CHECKED && LA352_0 <= CLASS)||(LA352_0 >= CONST && LA352_0 <= CONTINUE)||LA352_0==DECIMAL||(LA352_0 >= DEFAULT && LA352_0 <= DELEGATE)||LA352_0==DO||LA352_0==DOUBLE||(LA352_0 >= ELSE && LA352_0 <= EXTERN)||(LA352_0 >= FALSE && LA352_0 <= FOREACH)||LA352_0==GOTO||(LA352_0 >= IF && LA352_0 <= INT)||(LA352_0 >= INTERFACE && LA352_0 <= INTERNAL)||LA352_0==IS||(LA352_0 >= LOCK && LA352_0 <= LONG)||(LA352_0 >= NAMESPACE && LA352_0 <= NEW)||LA352_0==NULL||LA352_0==OBJECT||LA352_0==OPERATOR||(LA352_0 >= OUT && LA352_0 <= PARAMS)||(LA352_0 >= PRIVATE && LA352_0 <= PUBLIC)||LA352_0==READONLY||(LA352_0 >= REF && LA352_0 <= RETURN)||(LA352_0 >= SBYTE && LA352_0 <= SEALED)||LA352_0==SHORT||(LA352_0 >= SIZEOF && LA352_0 <= STACKALLOC)||(LA352_0 >= STATIC && LA352_0 <= STRING)||(LA352_0 >= STRUCT && LA352_0 <= SWITCH)||(LA352_0 >= THIS && LA352_0 <= THROW)||(LA352_0 >= TRUE && LA352_0 <= UNCHECKED)||(LA352_0 >= UNSAFE && LA352_0 <= USING)||(LA352_0 >= VIRTUAL && LA352_0 <= VOLATILE)||LA352_0==WHILE) ) {
                alt352=1;
            }
            else if ( (LA352_0==IDENTIFIER) ) {
                alt352=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 352, 0, input);

                throw nvae;

            }
            switch (alt352) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1984:5: keyword
                    {
                    pushFollow(FOLLOW_keyword_in_global_attribute_target8854);
                    keyword();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1985:5: IDENTIFIER
                    {
                    match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_global_attribute_target8860); if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "global_attribute_target"



    // $ANTLR start "attributes"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1993:1: attributes : attribute_sections ;
    public final void attributes() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1994:2: ( attribute_sections )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1994:4: attribute_sections
            {
            pushFollow(FOLLOW_attribute_sections_in_attributes8874);
            attribute_sections();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "attributes"



    // $ANTLR start "attribute_sections"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1996:1: attribute_sections : ( attribute_section )+ ;
    public final void attribute_sections() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1997:2: ( ( attribute_section )+ )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1997:4: ( attribute_section )+
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1997:4: ( attribute_section )+
            int cnt353=0;
            loop353:
            do {
                int alt353=2;
                int LA353_0 = input.LA(1);

                if ( (LA353_0==OPEN_BRACKET) ) {
                    alt353=1;
                }


                switch (alt353) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1997:4: attribute_section
            	    {
            	    pushFollow(FOLLOW_attribute_section_in_attribute_sections8885);
            	    attribute_section();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    if ( cnt353 >= 1 ) break loop353;
            	    if (state.backtracking>0) {state.failed=true; return ;}
                        EarlyExitException eee =
                            new EarlyExitException(353, input);
                        throw eee;
                }
                cnt353++;
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "attribute_sections"



    // $ANTLR start "attribute_section"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2005:1: attribute_section : OPEN_BRACKET ( attribute_target_specifier )? attribute_list ( COMMA )? CLOSE_BRACKET ;
    public final void attribute_section() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2006:3: ( OPEN_BRACKET ( attribute_target_specifier )? attribute_list ( COMMA )? CLOSE_BRACKET )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2006:5: OPEN_BRACKET ( attribute_target_specifier )? attribute_list ( COMMA )? CLOSE_BRACKET
            {
            match(input,OPEN_BRACKET,FOLLOW_OPEN_BRACKET_in_attribute_section8900); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2006:18: ( attribute_target_specifier )?
            int alt354=2;
            int LA354_0 = input.LA(1);

            if ( (LA354_0==ABSTRACT||LA354_0==AS||LA354_0==BASE||(LA354_0 >= BOOL && LA354_0 <= BYTE)||(LA354_0 >= CASE && LA354_0 <= CHAR)||(LA354_0 >= CHECKED && LA354_0 <= CLASS)||(LA354_0 >= CONST && LA354_0 <= CONTINUE)||LA354_0==DECIMAL||(LA354_0 >= DEFAULT && LA354_0 <= DELEGATE)||LA354_0==DO||LA354_0==DOUBLE||(LA354_0 >= ELSE && LA354_0 <= EXTERN)||(LA354_0 >= FALSE && LA354_0 <= FOREACH)||LA354_0==GOTO||(LA354_0 >= IF && LA354_0 <= INT)||(LA354_0 >= INTERFACE && LA354_0 <= INTERNAL)||LA354_0==IS||(LA354_0 >= LOCK && LA354_0 <= LONG)||(LA354_0 >= NAMESPACE && LA354_0 <= NEW)||LA354_0==NULL||LA354_0==OBJECT||LA354_0==OPERATOR||(LA354_0 >= OUT && LA354_0 <= PARAMS)||(LA354_0 >= PRIVATE && LA354_0 <= PUBLIC)||LA354_0==READONLY||(LA354_0 >= REF && LA354_0 <= RETURN)||(LA354_0 >= SBYTE && LA354_0 <= SEALED)||LA354_0==SHORT||(LA354_0 >= SIZEOF && LA354_0 <= STACKALLOC)||(LA354_0 >= STATIC && LA354_0 <= STRING)||(LA354_0 >= STRUCT && LA354_0 <= SWITCH)||(LA354_0 >= THIS && LA354_0 <= THROW)||(LA354_0 >= TRUE && LA354_0 <= UNCHECKED)||(LA354_0 >= UNSAFE && LA354_0 <= USING)||(LA354_0 >= VIRTUAL && LA354_0 <= VOLATILE)||LA354_0==WHILE) ) {
                alt354=1;
            }
            else if ( (LA354_0==IDENTIFIER) ) {
                int LA354_2 = input.LA(2);

                if ( (LA354_2==COLON) ) {
                    alt354=1;
                }
            }
            switch (alt354) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2006:18: attribute_target_specifier
                    {
                    pushFollow(FOLLOW_attribute_target_specifier_in_attribute_section8902);
                    attribute_target_specifier();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            pushFollow(FOLLOW_attribute_list_in_attribute_section8905);
            attribute_list();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2006:61: ( COMMA )?
            int alt355=2;
            int LA355_0 = input.LA(1);

            if ( (LA355_0==COMMA) ) {
                alt355=1;
            }
            switch (alt355) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2006:61: COMMA
                    {
                    match(input,COMMA,FOLLOW_COMMA_in_attribute_section8907); if (state.failed) return ;

                    }
                    break;

            }


            match(input,CLOSE_BRACKET,FOLLOW_CLOSE_BRACKET_in_attribute_section8910); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "attribute_section"



    // $ANTLR start "attribute_target_specifier"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2008:1: attribute_target_specifier : attribute_target COLON ;
    public final void attribute_target_specifier() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2009:2: ( attribute_target COLON )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2009:4: attribute_target COLON
            {
            pushFollow(FOLLOW_attribute_target_in_attribute_target_specifier8922);
            attribute_target();

            state._fsp--;
            if (state.failed) return ;

            match(input,COLON,FOLLOW_COLON_in_attribute_target_specifier8924); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "attribute_target_specifier"



    // $ANTLR start "attribute_target"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2011:1: attribute_target : ( keyword | IDENTIFIER );
    public final void attribute_target() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2012:3: ( keyword | IDENTIFIER )
            int alt356=2;
            int LA356_0 = input.LA(1);

            if ( (LA356_0==ABSTRACT||LA356_0==AS||LA356_0==BASE||(LA356_0 >= BOOL && LA356_0 <= BYTE)||(LA356_0 >= CASE && LA356_0 <= CHAR)||(LA356_0 >= CHECKED && LA356_0 <= CLASS)||(LA356_0 >= CONST && LA356_0 <= CONTINUE)||LA356_0==DECIMAL||(LA356_0 >= DEFAULT && LA356_0 <= DELEGATE)||LA356_0==DO||LA356_0==DOUBLE||(LA356_0 >= ELSE && LA356_0 <= EXTERN)||(LA356_0 >= FALSE && LA356_0 <= FOREACH)||LA356_0==GOTO||(LA356_0 >= IF && LA356_0 <= INT)||(LA356_0 >= INTERFACE && LA356_0 <= INTERNAL)||LA356_0==IS||(LA356_0 >= LOCK && LA356_0 <= LONG)||(LA356_0 >= NAMESPACE && LA356_0 <= NEW)||LA356_0==NULL||LA356_0==OBJECT||LA356_0==OPERATOR||(LA356_0 >= OUT && LA356_0 <= PARAMS)||(LA356_0 >= PRIVATE && LA356_0 <= PUBLIC)||LA356_0==READONLY||(LA356_0 >= REF && LA356_0 <= RETURN)||(LA356_0 >= SBYTE && LA356_0 <= SEALED)||LA356_0==SHORT||(LA356_0 >= SIZEOF && LA356_0 <= STACKALLOC)||(LA356_0 >= STATIC && LA356_0 <= STRING)||(LA356_0 >= STRUCT && LA356_0 <= SWITCH)||(LA356_0 >= THIS && LA356_0 <= THROW)||(LA356_0 >= TRUE && LA356_0 <= UNCHECKED)||(LA356_0 >= UNSAFE && LA356_0 <= USING)||(LA356_0 >= VIRTUAL && LA356_0 <= VOLATILE)||LA356_0==WHILE) ) {
                alt356=1;
            }
            else if ( (LA356_0==IDENTIFIER) ) {
                alt356=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 356, 0, input);

                throw nvae;

            }
            switch (alt356) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2012:5: keyword
                    {
                    pushFollow(FOLLOW_keyword_in_attribute_target8936);
                    keyword();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2013:5: IDENTIFIER
                    {
                    match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_attribute_target8942); if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "attribute_target"



    // $ANTLR start "attribute_list"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2026:1: attribute_list : attribute ( COMMA attribute )* ;
    public final void attribute_list() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2027:2: ( attribute ( COMMA attribute )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2027:4: attribute ( COMMA attribute )*
            {
            pushFollow(FOLLOW_attribute_in_attribute_list8956);
            attribute();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2027:14: ( COMMA attribute )*
            loop357:
            do {
                int alt357=2;
                int LA357_0 = input.LA(1);

                if ( (LA357_0==COMMA) ) {
                    int LA357_1 = input.LA(2);

                    if ( (LA357_1==IDENTIFIER) ) {
                        alt357=1;
                    }


                }


                switch (alt357) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2027:16: COMMA attribute
            	    {
            	    match(input,COMMA,FOLLOW_COMMA_in_attribute_list8960); if (state.failed) return ;

            	    pushFollow(FOLLOW_attribute_in_attribute_list8963);
            	    attribute();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop357;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "attribute_list"



    // $ANTLR start "attribute"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2029:1: attribute : attribute_name ( attribute_arguments )? ;
    public final void attribute() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2030:2: ( attribute_name ( attribute_arguments )? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2030:4: attribute_name ( attribute_arguments )?
            {
            pushFollow(FOLLOW_attribute_name_in_attribute8977);
            attribute_name();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2030:19: ( attribute_arguments )?
            int alt358=2;
            int LA358_0 = input.LA(1);

            if ( (LA358_0==OPEN_PARENS) ) {
                alt358=1;
            }
            switch (alt358) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2030:19: attribute_arguments
                    {
                    pushFollow(FOLLOW_attribute_arguments_in_attribute8979);
                    attribute_arguments();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "attribute"



    // $ANTLR start "attribute_name"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2032:1: attribute_name : type_name ;
    public final void attribute_name() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2033:2: ( type_name )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2033:4: type_name
            {
            pushFollow(FOLLOW_type_name_in_attribute_name8991);
            type_name();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "attribute_name"



    // $ANTLR start "attribute_arguments"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2043:1: attribute_arguments : OPEN_PARENS ( positional_argument_list )? CLOSE_PARENS ;
    public final void attribute_arguments() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2044:3: ( OPEN_PARENS ( positional_argument_list )? CLOSE_PARENS )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2044:5: OPEN_PARENS ( positional_argument_list )? CLOSE_PARENS
            {
            match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_attribute_arguments9008); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2044:17: ( positional_argument_list )?
            int alt359=2;
            int LA359_0 = input.LA(1);

            if ( (LA359_0==AMP||(LA359_0 >= BANG && LA359_0 <= BASE)||LA359_0==BOOL||LA359_0==BYTE||(LA359_0 >= CHAR && LA359_0 <= CHECKED)||LA359_0==DECIMAL||(LA359_0 >= DEFAULT && LA359_0 <= DELEGATE)||LA359_0==DOUBLE||LA359_0==FALSE||LA359_0==FLOAT||LA359_0==IDENTIFIER||(LA359_0 >= INT && LA359_0 <= INTEGER_LITERAL)||LA359_0==LONG||LA359_0==MINUS||LA359_0==NEW||LA359_0==NULL||LA359_0==OBJECT||LA359_0==OPEN_PARENS||LA359_0==OP_DEC||LA359_0==OP_INC||LA359_0==PLUS||LA359_0==REAL_LITERAL||LA359_0==SBYTE||LA359_0==SHORT||LA359_0==SIZEOF||LA359_0==STAR||(LA359_0 >= STRING && LA359_0 <= STRING_LITERAL)||LA359_0==THIS||(LA359_0 >= TILDE && LA359_0 <= TRUE)||(LA359_0 >= TYPEOF && LA359_0 <= UNCHECKED)||LA359_0==USHORT) ) {
                alt359=1;
            }
            switch (alt359) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2044:17: positional_argument_list
                    {
                    pushFollow(FOLLOW_positional_argument_list_in_attribute_arguments9010);
                    positional_argument_list();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_attribute_arguments9013); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "attribute_arguments"



    // $ANTLR start "positional_argument_list"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2046:1: positional_argument_list : arg= positional_argument ( COMMA arg2= positional_argument )* ;
    public final void positional_argument_list() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2047:2: (arg= positional_argument ( COMMA arg2= positional_argument )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2047:4: arg= positional_argument ( COMMA arg2= positional_argument )*
            {
            pushFollow(FOLLOW_positional_argument_in_positional_argument_list9027);
            positional_argument();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2048:6: ( COMMA arg2= positional_argument )*
            loop360:
            do {
                int alt360=2;
                int LA360_0 = input.LA(1);

                if ( (LA360_0==COMMA) ) {
                    alt360=1;
                }


                switch (alt360) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2048:8: COMMA arg2= positional_argument
            	    {
            	    match(input,COMMA,FOLLOW_COMMA_in_positional_argument_list9036); if (state.failed) return ;

            	    pushFollow(FOLLOW_positional_argument_in_positional_argument_list9041);
            	    positional_argument();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop360;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "positional_argument_list"



    // $ANTLR start "positional_argument"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2051:1: positional_argument : attribute_argument_expression ;
    public final void positional_argument() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2052:2: ( attribute_argument_expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2052:4: attribute_argument_expression
            {
            pushFollow(FOLLOW_attribute_argument_expression_in_positional_argument9057);
            attribute_argument_expression();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "positional_argument"



    // $ANTLR start "named_argument_list"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2055:1: named_argument_list : named_argument ( COMMA named_argument )* ;
    public final void named_argument_list() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2056:2: ( named_argument ( COMMA named_argument )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2056:4: named_argument ( COMMA named_argument )*
            {
            pushFollow(FOLLOW_named_argument_in_named_argument_list9070);
            named_argument();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2056:19: ( COMMA named_argument )*
            loop361:
            do {
                int alt361=2;
                int LA361_0 = input.LA(1);

                if ( (LA361_0==COMMA) ) {
                    alt361=1;
                }


                switch (alt361) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2056:21: COMMA named_argument
            	    {
            	    match(input,COMMA,FOLLOW_COMMA_in_named_argument_list9074); if (state.failed) return ;

            	    pushFollow(FOLLOW_named_argument_in_named_argument_list9077);
            	    named_argument();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop361;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "named_argument_list"



    // $ANTLR start "named_argument"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2059:1: named_argument : IDENTIFIER ASSIGNMENT attribute_argument_expression ;
    public final void named_argument() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2060:2: ( IDENTIFIER ASSIGNMENT attribute_argument_expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2060:4: IDENTIFIER ASSIGNMENT attribute_argument_expression
            {
            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_named_argument9093); if (state.failed) return ;

            match(input,ASSIGNMENT,FOLLOW_ASSIGNMENT_in_named_argument9095); if (state.failed) return ;

            pushFollow(FOLLOW_attribute_argument_expression_in_named_argument9097);
            attribute_argument_expression();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "named_argument"



    // $ANTLR start "attribute_argument_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2062:1: attribute_argument_expression : expression ;
    public final void attribute_argument_expression() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2063:2: ( expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2063:4: expression
            {
            pushFollow(FOLLOW_expression_in_attribute_argument_expression9108);
            expression();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "attribute_argument_expression"



    // $ANTLR start "class_modifier_unsafe"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2068:1: class_modifier_unsafe : UNSAFE ;
    public final void class_modifier_unsafe() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2069:2: ( UNSAFE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2069:4: UNSAFE
            {
            match(input,UNSAFE,FOLLOW_UNSAFE_in_class_modifier_unsafe9122); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "class_modifier_unsafe"



    // $ANTLR start "struct_modifier_unsafe"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2071:1: struct_modifier_unsafe : UNSAFE ;
    public final void struct_modifier_unsafe() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2072:2: ( UNSAFE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2072:4: UNSAFE
            {
            match(input,UNSAFE,FOLLOW_UNSAFE_in_struct_modifier_unsafe9133); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "struct_modifier_unsafe"



    // $ANTLR start "interface_modifier_unsafe"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2074:1: interface_modifier_unsafe : UNSAFE ;
    public final void interface_modifier_unsafe() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2075:2: ( UNSAFE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2075:4: UNSAFE
            {
            match(input,UNSAFE,FOLLOW_UNSAFE_in_interface_modifier_unsafe9144); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "interface_modifier_unsafe"



    // $ANTLR start "delegate_modifier_unsafe"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2077:1: delegate_modifier_unsafe : UNSAFE ;
    public final void delegate_modifier_unsafe() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2078:2: ( UNSAFE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2078:4: UNSAFE
            {
            match(input,UNSAFE,FOLLOW_UNSAFE_in_delegate_modifier_unsafe9155); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "delegate_modifier_unsafe"



    // $ANTLR start "field_modifier_unsafe"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2080:1: field_modifier_unsafe : UNSAFE ;
    public final void field_modifier_unsafe() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2081:2: ( UNSAFE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2081:4: UNSAFE
            {
            match(input,UNSAFE,FOLLOW_UNSAFE_in_field_modifier_unsafe9166); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "field_modifier_unsafe"



    // $ANTLR start "method_modifier_unsafe"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2083:1: method_modifier_unsafe : UNSAFE ;
    public final void method_modifier_unsafe() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2084:2: ( UNSAFE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2084:4: UNSAFE
            {
            match(input,UNSAFE,FOLLOW_UNSAFE_in_method_modifier_unsafe9177); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "method_modifier_unsafe"



    // $ANTLR start "property_modifier_unsafe"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2086:1: property_modifier_unsafe : UNSAFE ;
    public final void property_modifier_unsafe() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2087:2: ( UNSAFE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2087:4: UNSAFE
            {
            match(input,UNSAFE,FOLLOW_UNSAFE_in_property_modifier_unsafe9188); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "property_modifier_unsafe"



    // $ANTLR start "event_modifier_unsafe"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2089:1: event_modifier_unsafe : UNSAFE ;
    public final void event_modifier_unsafe() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2090:2: ( UNSAFE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2090:4: UNSAFE
            {
            match(input,UNSAFE,FOLLOW_UNSAFE_in_event_modifier_unsafe9199); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "event_modifier_unsafe"



    // $ANTLR start "indexer_modifier_unsafe"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2092:1: indexer_modifier_unsafe : UNSAFE ;
    public final void indexer_modifier_unsafe() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2093:2: ( UNSAFE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2093:4: UNSAFE
            {
            match(input,UNSAFE,FOLLOW_UNSAFE_in_indexer_modifier_unsafe9210); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "indexer_modifier_unsafe"



    // $ANTLR start "operator_modifier_unsafe"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2095:1: operator_modifier_unsafe : UNSAFE ;
    public final void operator_modifier_unsafe() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2096:2: ( UNSAFE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2096:4: UNSAFE
            {
            match(input,UNSAFE,FOLLOW_UNSAFE_in_operator_modifier_unsafe9221); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "operator_modifier_unsafe"



    // $ANTLR start "constructor_modifier_unsafe"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2098:1: constructor_modifier_unsafe : UNSAFE ;
    public final void constructor_modifier_unsafe() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2099:2: ( UNSAFE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2099:4: UNSAFE
            {
            match(input,UNSAFE,FOLLOW_UNSAFE_in_constructor_modifier_unsafe9232); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "constructor_modifier_unsafe"



    // $ANTLR start "destructor_declaration_unsafe"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2107:1: destructor_declaration_unsafe : ( attributes )? ( ( EXTERN )? ( UNSAFE )? | UNSAFE EXTERN ) TILDE IDENTIFIER OPEN_PARENS CLOSE_PARENS destructor_body ;
    public final void destructor_declaration_unsafe() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2108:3: ( ( attributes )? ( ( EXTERN )? ( UNSAFE )? | UNSAFE EXTERN ) TILDE IDENTIFIER OPEN_PARENS CLOSE_PARENS destructor_body )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2108:5: ( attributes )? ( ( EXTERN )? ( UNSAFE )? | UNSAFE EXTERN ) TILDE IDENTIFIER OPEN_PARENS CLOSE_PARENS destructor_body
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2108:5: ( attributes )?
            int alt362=2;
            int LA362_0 = input.LA(1);

            if ( (LA362_0==OPEN_BRACKET) ) {
                alt362=1;
            }
            switch (alt362) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2108:5: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_destructor_declaration_unsafe9246);
                    attributes();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2109:5: ( ( EXTERN )? ( UNSAFE )? | UNSAFE EXTERN )
            int alt365=2;
            int LA365_0 = input.LA(1);

            if ( (LA365_0==EXTERN||LA365_0==TILDE) ) {
                alt365=1;
            }
            else if ( (LA365_0==UNSAFE) ) {
                int LA365_2 = input.LA(2);

                if ( (LA365_2==EXTERN) ) {
                    alt365=2;
                }
                else if ( (LA365_2==TILDE) ) {
                    alt365=1;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 365, 2, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 365, 0, input);

                throw nvae;

            }
            switch (alt365) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2109:7: ( EXTERN )? ( UNSAFE )?
                    {
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2109:7: ( EXTERN )?
                    int alt363=2;
                    int LA363_0 = input.LA(1);

                    if ( (LA363_0==EXTERN) ) {
                        alt363=1;
                    }
                    switch (alt363) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2109:7: EXTERN
                            {
                            match(input,EXTERN,FOLLOW_EXTERN_in_destructor_declaration_unsafe9255); if (state.failed) return ;

                            }
                            break;

                    }


                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2109:15: ( UNSAFE )?
                    int alt364=2;
                    int LA364_0 = input.LA(1);

                    if ( (LA364_0==UNSAFE) ) {
                        alt364=1;
                    }
                    switch (alt364) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2109:15: UNSAFE
                            {
                            match(input,UNSAFE,FOLLOW_UNSAFE_in_destructor_declaration_unsafe9258); if (state.failed) return ;

                            }
                            break;

                    }


                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2110:7: UNSAFE EXTERN
                    {
                    match(input,UNSAFE,FOLLOW_UNSAFE_in_destructor_declaration_unsafe9267); if (state.failed) return ;

                    match(input,EXTERN,FOLLOW_EXTERN_in_destructor_declaration_unsafe9269); if (state.failed) return ;

                    }
                    break;

            }


            match(input,TILDE,FOLLOW_TILDE_in_destructor_declaration_unsafe9283); if (state.failed) return ;

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_destructor_declaration_unsafe9285); if (state.failed) return ;

            match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_destructor_declaration_unsafe9287); if (state.failed) return ;

            match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_destructor_declaration_unsafe9289); if (state.failed) return ;

            pushFollow(FOLLOW_destructor_body_in_destructor_declaration_unsafe9291);
            destructor_body();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "destructor_declaration_unsafe"



    // $ANTLR start "static_constructor_modifiers_unsafe"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2124:1: static_constructor_modifiers_unsafe : ( ( EXTERN | UNSAFE )? STATIC | EXTERN UNSAFE STATIC | UNSAFE EXTERN STATIC | EXTERN STATIC UNSAFE | UNSAFE STATIC EXTERN | STATIC ( EXTERN | UNSAFE ) | STATIC EXTERN UNSAFE | STATIC UNSAFE EXTERN );
    public final void static_constructor_modifiers_unsafe() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2125:3: ( ( EXTERN | UNSAFE )? STATIC | EXTERN UNSAFE STATIC | UNSAFE EXTERN STATIC | EXTERN STATIC UNSAFE | UNSAFE STATIC EXTERN | STATIC ( EXTERN | UNSAFE ) | STATIC EXTERN UNSAFE | STATIC UNSAFE EXTERN )
            int alt367=8;
            switch ( input.LA(1) ) {
            case EXTERN:
                {
                int LA367_1 = input.LA(2);

                if ( (LA367_1==UNSAFE) ) {
                    alt367=2;
                }
                else if ( (LA367_1==STATIC) ) {
                    int LA367_5 = input.LA(3);

                    if ( (LA367_5==UNSAFE) ) {
                        alt367=4;
                    }
                    else if ( (LA367_5==IDENTIFIER) ) {
                        alt367=1;
                    }
                    else {
                        if (state.backtracking>0) {state.failed=true; return ;}
                        NoViableAltException nvae =
                            new NoViableAltException("", 367, 5, input);

                        throw nvae;

                    }
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 367, 1, input);

                    throw nvae;

                }
                }
                break;
            case STATIC:
                {
                switch ( input.LA(2) ) {
                case EXTERN:
                    {
                    int LA367_6 = input.LA(3);

                    if ( (LA367_6==UNSAFE) ) {
                        alt367=7;
                    }
                    else if ( (LA367_6==IDENTIFIER) ) {
                        alt367=6;
                    }
                    else {
                        if (state.backtracking>0) {state.failed=true; return ;}
                        NoViableAltException nvae =
                            new NoViableAltException("", 367, 6, input);

                        throw nvae;

                    }
                    }
                    break;
                case UNSAFE:
                    {
                    int LA367_7 = input.LA(3);

                    if ( (LA367_7==EXTERN) ) {
                        alt367=8;
                    }
                    else if ( (LA367_7==IDENTIFIER) ) {
                        alt367=6;
                    }
                    else {
                        if (state.backtracking>0) {state.failed=true; return ;}
                        NoViableAltException nvae =
                            new NoViableAltException("", 367, 7, input);

                        throw nvae;

                    }
                    }
                    break;
                case IDENTIFIER:
                    {
                    alt367=1;
                    }
                    break;
                default:
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 367, 2, input);

                    throw nvae;

                }

                }
                break;
            case UNSAFE:
                {
                int LA367_3 = input.LA(2);

                if ( (LA367_3==EXTERN) ) {
                    alt367=3;
                }
                else if ( (LA367_3==STATIC) ) {
                    int LA367_10 = input.LA(3);

                    if ( (LA367_10==EXTERN) ) {
                        alt367=5;
                    }
                    else if ( (LA367_10==IDENTIFIER) ) {
                        alt367=1;
                    }
                    else {
                        if (state.backtracking>0) {state.failed=true; return ;}
                        NoViableAltException nvae =
                            new NoViableAltException("", 367, 10, input);

                        throw nvae;

                    }
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 367, 3, input);

                    throw nvae;

                }
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 367, 0, input);

                throw nvae;

            }

            switch (alt367) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2125:5: ( EXTERN | UNSAFE )? STATIC
                    {
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2125:5: ( EXTERN | UNSAFE )?
                    int alt366=2;
                    int LA366_0 = input.LA(1);

                    if ( (LA366_0==EXTERN||LA366_0==UNSAFE) ) {
                        alt366=1;
                    }
                    switch (alt366) {
                        case 1 :
                            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:
                            {
                            if ( input.LA(1)==EXTERN||input.LA(1)==UNSAFE ) {
                                input.consume();
                                state.errorRecovery=false;
                                state.failed=false;
                            }
                            else {
                                if (state.backtracking>0) {state.failed=true; return ;}
                                MismatchedSetException mse = new MismatchedSetException(null,input);
                                throw mse;
                            }


                            }
                            break;

                    }


                    match(input,STATIC,FOLLOW_STATIC_in_static_constructor_modifiers_unsafe9315); if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2126:5: EXTERN UNSAFE STATIC
                    {
                    match(input,EXTERN,FOLLOW_EXTERN_in_static_constructor_modifiers_unsafe9321); if (state.failed) return ;

                    match(input,UNSAFE,FOLLOW_UNSAFE_in_static_constructor_modifiers_unsafe9323); if (state.failed) return ;

                    match(input,STATIC,FOLLOW_STATIC_in_static_constructor_modifiers_unsafe9325); if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2127:5: UNSAFE EXTERN STATIC
                    {
                    match(input,UNSAFE,FOLLOW_UNSAFE_in_static_constructor_modifiers_unsafe9331); if (state.failed) return ;

                    match(input,EXTERN,FOLLOW_EXTERN_in_static_constructor_modifiers_unsafe9333); if (state.failed) return ;

                    match(input,STATIC,FOLLOW_STATIC_in_static_constructor_modifiers_unsafe9335); if (state.failed) return ;

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2128:5: EXTERN STATIC UNSAFE
                    {
                    match(input,EXTERN,FOLLOW_EXTERN_in_static_constructor_modifiers_unsafe9341); if (state.failed) return ;

                    match(input,STATIC,FOLLOW_STATIC_in_static_constructor_modifiers_unsafe9343); if (state.failed) return ;

                    match(input,UNSAFE,FOLLOW_UNSAFE_in_static_constructor_modifiers_unsafe9345); if (state.failed) return ;

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2129:5: UNSAFE STATIC EXTERN
                    {
                    match(input,UNSAFE,FOLLOW_UNSAFE_in_static_constructor_modifiers_unsafe9351); if (state.failed) return ;

                    match(input,STATIC,FOLLOW_STATIC_in_static_constructor_modifiers_unsafe9353); if (state.failed) return ;

                    match(input,EXTERN,FOLLOW_EXTERN_in_static_constructor_modifiers_unsafe9355); if (state.failed) return ;

                    }
                    break;
                case 6 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2130:5: STATIC ( EXTERN | UNSAFE )
                    {
                    match(input,STATIC,FOLLOW_STATIC_in_static_constructor_modifiers_unsafe9361); if (state.failed) return ;

                    if ( input.LA(1)==EXTERN||input.LA(1)==UNSAFE ) {
                        input.consume();
                        state.errorRecovery=false;
                        state.failed=false;
                    }
                    else {
                        if (state.backtracking>0) {state.failed=true; return ;}
                        MismatchedSetException mse = new MismatchedSetException(null,input);
                        throw mse;
                    }


                    }
                    break;
                case 7 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2131:5: STATIC EXTERN UNSAFE
                    {
                    match(input,STATIC,FOLLOW_STATIC_in_static_constructor_modifiers_unsafe9375); if (state.failed) return ;

                    match(input,EXTERN,FOLLOW_EXTERN_in_static_constructor_modifiers_unsafe9377); if (state.failed) return ;

                    match(input,UNSAFE,FOLLOW_UNSAFE_in_static_constructor_modifiers_unsafe9379); if (state.failed) return ;

                    }
                    break;
                case 8 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2132:5: STATIC UNSAFE EXTERN
                    {
                    match(input,STATIC,FOLLOW_STATIC_in_static_constructor_modifiers_unsafe9385); if (state.failed) return ;

                    match(input,UNSAFE,FOLLOW_UNSAFE_in_static_constructor_modifiers_unsafe9387); if (state.failed) return ;

                    match(input,EXTERN,FOLLOW_EXTERN_in_static_constructor_modifiers_unsafe9389); if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "static_constructor_modifiers_unsafe"



    // $ANTLR start "embedded_statement_unsafe"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2135:1: embedded_statement_unsafe : ( unsafe_statement | fixed_statement );
    public final void embedded_statement_unsafe() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2136:2: ( unsafe_statement | fixed_statement )
            int alt368=2;
            int LA368_0 = input.LA(1);

            if ( (LA368_0==UNSAFE) ) {
                alt368=1;
            }
            else if ( (LA368_0==FIXED) ) {
                alt368=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 368, 0, input);

                throw nvae;

            }
            switch (alt368) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2136:4: unsafe_statement
                    {
                    pushFollow(FOLLOW_unsafe_statement_in_embedded_statement_unsafe9403);
                    unsafe_statement();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2137:4: fixed_statement
                    {
                    pushFollow(FOLLOW_fixed_statement_in_embedded_statement_unsafe9408);
                    fixed_statement();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "embedded_statement_unsafe"



    // $ANTLR start "unsafe_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2139:1: unsafe_statement : UNSAFE block ;
    public final void unsafe_statement() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2140:2: ( UNSAFE block )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2140:4: UNSAFE block
            {
            match(input,UNSAFE,FOLLOW_UNSAFE_in_unsafe_statement9419); if (state.failed) return ;

            pushFollow(FOLLOW_block_in_unsafe_statement9421);
            block();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "unsafe_statement"



    // $ANTLR start "type_unsafe"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2142:1: type_unsafe : pointer_type ;
    public final void type_unsafe() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2143:2: ( pointer_type )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2143:4: pointer_type
            {
            pushFollow(FOLLOW_pointer_type_in_type_unsafe9432);
            pointer_type();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "type_unsafe"



    // $ANTLR start "pointer_type"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2152:1: pointer_type : ( simple_type | class_type | VOID ) ({...}? => rank_specifier |{...}? => INTERR | STAR )* STAR ;
    public final void pointer_type() throws RecognitionException {

            boolean allowAll = true;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2156:3: ( ( simple_type | class_type | VOID ) ({...}? => rank_specifier |{...}? => INTERR | STAR )* STAR )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2156:5: ( simple_type | class_type | VOID ) ({...}? => rank_specifier |{...}? => INTERR | STAR )* STAR
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2156:5: ( simple_type | class_type | VOID )
            int alt369=3;
            switch ( input.LA(1) ) {
            case BOOL:
            case BYTE:
            case CHAR:
            case DECIMAL:
            case DOUBLE:
            case FLOAT:
            case INT:
            case LONG:
            case SBYTE:
            case SHORT:
            case UINT:
            case ULONG:
            case USHORT:
                {
                alt369=1;
                }
                break;
            case IDENTIFIER:
            case OBJECT:
            case STRING:
                {
                alt369=2;
                }
                break;
            case VOID:
                {
                alt369=3;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 369, 0, input);

                throw nvae;

            }

            switch (alt369) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2156:7: simple_type
                    {
                    pushFollow(FOLLOW_simple_type_in_pointer_type9454);
                    simple_type();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2157:6: class_type
                    {
                    pushFollow(FOLLOW_class_type_in_pointer_type9461);
                    class_type();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2158:6: VOID
                    {
                    match(input,VOID,FOLLOW_VOID_in_pointer_type9468); if (state.failed) return ;

                    if ( state.backtracking==0 ) {allowAll = false;}

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2159:5: ({...}? => rank_specifier |{...}? => INTERR | STAR )*
            loop370:
            do {
                int alt370=4;
                int LA370_0 = input.LA(1);

                if ( (LA370_0==STAR) ) {
                    int LA370_1 = input.LA(2);

                    if ( (LA370_1==INTERR||LA370_1==OPEN_BRACKET||LA370_1==STAR) ) {
                        alt370=3;
                    }


                }
                else if ( (LA370_0==OPEN_BRACKET) && ((allowAll))) {
                    alt370=1;
                }
                else if ( (LA370_0==INTERR) && ((allowAll))) {
                    alt370=2;
                }


                switch (alt370) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2159:7: {...}? => rank_specifier
            	    {
            	    if ( !((allowAll)) ) {
            	        if (state.backtracking>0) {state.failed=true; return ;}
            	        throw new FailedPredicateException(input, "pointer_type", "allowAll");
            	    }

            	    pushFollow(FOLLOW_rank_specifier_in_pointer_type9482);
            	    rank_specifier();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;
            	case 2 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2160:7: {...}? => INTERR
            	    {
            	    if ( !((allowAll)) ) {
            	        if (state.backtracking>0) {state.failed=true; return ;}
            	        throw new FailedPredicateException(input, "pointer_type", "allowAll");
            	    }

            	    match(input,INTERR,FOLLOW_INTERR_in_pointer_type9494); if (state.failed) return ;

            	    }
            	    break;
            	case 3 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2161:7: STAR
            	    {
            	    match(input,STAR,FOLLOW_STAR_in_pointer_type9502); if (state.failed) return ;

            	    if ( state.backtracking==0 ) {allowAll = true;}

            	    }
            	    break;

            	default :
            	    break loop370;
                }
            } while (true);


            match(input,STAR,FOLLOW_STAR_in_pointer_type9513); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "pointer_type"



    // $ANTLR start "unmanaged_type"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2175:1: unmanaged_type : type ;
    public final void unmanaged_type() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2176:2: ( type )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2176:4: type
            {
            pushFollow(FOLLOW_type_in_unmanaged_type9536);
            type();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "unmanaged_type"



    // $ANTLR start "primary_no_array_creation_expression_unsafe"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2185:1: primary_no_array_creation_expression_unsafe : primary_expression ;
    public final void primary_no_array_creation_expression_unsafe() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2186:2: ( primary_expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2186:4: primary_expression
            {
            pushFollow(FOLLOW_primary_expression_in_primary_no_array_creation_expression_unsafe9549);
            primary_expression();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "primary_no_array_creation_expression_unsafe"



    // $ANTLR start "unary_expression_unsafe"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2189:1: unary_expression_unsafe : ( pointer_indirection_expression | addressof_expression );
    public final void unary_expression_unsafe() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2190:2: ( pointer_indirection_expression | addressof_expression )
            int alt371=2;
            int LA371_0 = input.LA(1);

            if ( (LA371_0==STAR) ) {
                alt371=1;
            }
            else if ( (LA371_0==AMP) ) {
                alt371=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 371, 0, input);

                throw nvae;

            }
            switch (alt371) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2190:4: pointer_indirection_expression
                    {
                    pushFollow(FOLLOW_pointer_indirection_expression_in_unary_expression_unsafe9562);
                    pointer_indirection_expression();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2191:4: addressof_expression
                    {
                    pushFollow(FOLLOW_addressof_expression_in_unary_expression_unsafe9567);
                    addressof_expression();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "unary_expression_unsafe"



    // $ANTLR start "pointer_indirection_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2193:1: pointer_indirection_expression : STAR unary_expression ;
    public final void pointer_indirection_expression() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2194:2: ( STAR unary_expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2194:4: STAR unary_expression
            {
            match(input,STAR,FOLLOW_STAR_in_pointer_indirection_expression9578); if (state.failed) return ;

            pushFollow(FOLLOW_unary_expression_in_pointer_indirection_expression9580);
            unary_expression();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "pointer_indirection_expression"



    // $ANTLR start "addressof_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2207:1: addressof_expression : AMP unary_expression ;
    public final void addressof_expression() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2208:2: ( AMP unary_expression )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2208:4: AMP unary_expression
            {
            match(input,AMP,FOLLOW_AMP_in_addressof_expression9597); if (state.failed) return ;

            pushFollow(FOLLOW_unary_expression_in_addressof_expression9599);
            unary_expression();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "addressof_expression"



    // $ANTLR start "sizeof_expression"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2210:1: sizeof_expression : SIZEOF OPEN_PARENS unmanaged_type CLOSE_PARENS ;
    public final void sizeof_expression() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2211:2: ( SIZEOF OPEN_PARENS unmanaged_type CLOSE_PARENS )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2211:4: SIZEOF OPEN_PARENS unmanaged_type CLOSE_PARENS
            {
            match(input,SIZEOF,FOLLOW_SIZEOF_in_sizeof_expression9610); if (state.failed) return ;

            match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_sizeof_expression9612); if (state.failed) return ;

            pushFollow(FOLLOW_unmanaged_type_in_sizeof_expression9614);
            unmanaged_type();

            state._fsp--;
            if (state.failed) return ;

            match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_sizeof_expression9616); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "sizeof_expression"



    // $ANTLR start "fixed_statement"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2213:1: fixed_statement : FIXED OPEN_PARENS pointer_type fixed_pointer_declarators CLOSE_PARENS embedded_statement ;
    public final void fixed_statement() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2214:2: ( FIXED OPEN_PARENS pointer_type fixed_pointer_declarators CLOSE_PARENS embedded_statement )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2214:4: FIXED OPEN_PARENS pointer_type fixed_pointer_declarators CLOSE_PARENS embedded_statement
            {
            match(input,FIXED,FOLLOW_FIXED_in_fixed_statement9627); if (state.failed) return ;

            match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_fixed_statement9629); if (state.failed) return ;

            pushFollow(FOLLOW_pointer_type_in_fixed_statement9631);
            pointer_type();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_fixed_pointer_declarators_in_fixed_statement9633);
            fixed_pointer_declarators();

            state._fsp--;
            if (state.failed) return ;

            match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_fixed_statement9635); if (state.failed) return ;

            pushFollow(FOLLOW_embedded_statement_in_fixed_statement9637);
            embedded_statement();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "fixed_statement"



    // $ANTLR start "fixed_pointer_declarators"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2216:1: fixed_pointer_declarators : fixed_pointer_declarator ( COMMA fixed_pointer_declarator )* ;
    public final void fixed_pointer_declarators() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2217:2: ( fixed_pointer_declarator ( COMMA fixed_pointer_declarator )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2217:4: fixed_pointer_declarator ( COMMA fixed_pointer_declarator )*
            {
            pushFollow(FOLLOW_fixed_pointer_declarator_in_fixed_pointer_declarators9648);
            fixed_pointer_declarator();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2217:29: ( COMMA fixed_pointer_declarator )*
            loop372:
            do {
                int alt372=2;
                int LA372_0 = input.LA(1);

                if ( (LA372_0==COMMA) ) {
                    alt372=1;
                }


                switch (alt372) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2217:31: COMMA fixed_pointer_declarator
            	    {
            	    match(input,COMMA,FOLLOW_COMMA_in_fixed_pointer_declarators9652); if (state.failed) return ;

            	    pushFollow(FOLLOW_fixed_pointer_declarator_in_fixed_pointer_declarators9655);
            	    fixed_pointer_declarator();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop372;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "fixed_pointer_declarators"



    // $ANTLR start "fixed_pointer_declarator"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2219:1: fixed_pointer_declarator : IDENTIFIER ASSIGNMENT fixed_pointer_initializer ;
    public final void fixed_pointer_declarator() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2220:2: ( IDENTIFIER ASSIGNMENT fixed_pointer_initializer )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2220:4: IDENTIFIER ASSIGNMENT fixed_pointer_initializer
            {
            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_fixed_pointer_declarator9669); if (state.failed) return ;

            match(input,ASSIGNMENT,FOLLOW_ASSIGNMENT_in_fixed_pointer_declarator9671); if (state.failed) return ;

            pushFollow(FOLLOW_fixed_pointer_initializer_in_fixed_pointer_declarator9673);
            fixed_pointer_initializer();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "fixed_pointer_declarator"



    // $ANTLR start "fixed_pointer_initializer"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2228:1: fixed_pointer_initializer : ( ( AMP )=> AMP variable_reference | expression );
    public final void fixed_pointer_initializer() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2229:3: ( ( AMP )=> AMP variable_reference | expression )
            int alt373=2;
            int LA373_0 = input.LA(1);

            if ( (LA373_0==AMP) ) {
                int LA373_1 = input.LA(2);

                if ( (synpred27_CSharp4()) ) {
                    alt373=1;
                }
                else if ( (true) ) {
                    alt373=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 373, 1, input);

                    throw nvae;

                }
            }
            else if ( ((LA373_0 >= BANG && LA373_0 <= BASE)||LA373_0==BOOL||LA373_0==BYTE||(LA373_0 >= CHAR && LA373_0 <= CHECKED)||LA373_0==DECIMAL||(LA373_0 >= DEFAULT && LA373_0 <= DELEGATE)||LA373_0==DOUBLE||LA373_0==FALSE||LA373_0==FLOAT||LA373_0==IDENTIFIER||(LA373_0 >= INT && LA373_0 <= INTEGER_LITERAL)||LA373_0==LONG||LA373_0==MINUS||LA373_0==NEW||LA373_0==NULL||LA373_0==OBJECT||LA373_0==OPEN_PARENS||LA373_0==OP_DEC||LA373_0==OP_INC||LA373_0==PLUS||LA373_0==REAL_LITERAL||LA373_0==SBYTE||LA373_0==SHORT||LA373_0==SIZEOF||LA373_0==STAR||(LA373_0 >= STRING && LA373_0 <= STRING_LITERAL)||LA373_0==THIS||(LA373_0 >= TILDE && LA373_0 <= TRUE)||(LA373_0 >= TYPEOF && LA373_0 <= UNCHECKED)||LA373_0==USHORT) ) {
                alt373=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 373, 0, input);

                throw nvae;

            }
            switch (alt373) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2229:5: ( AMP )=> AMP variable_reference
                    {
                    match(input,AMP,FOLLOW_AMP_in_fixed_pointer_initializer9693); if (state.failed) return ;

                    pushFollow(FOLLOW_variable_reference_in_fixed_pointer_initializer9695);
                    variable_reference();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2230:5: expression
                    {
                    pushFollow(FOLLOW_expression_in_fixed_pointer_initializer9701);
                    expression();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "fixed_pointer_initializer"



    // $ANTLR start "struct_member_declaration_unsafe"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2232:1: struct_member_declaration_unsafe : fixed_size_buffer_declaration ;
    public final void struct_member_declaration_unsafe() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2233:2: ( fixed_size_buffer_declaration )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2233:4: fixed_size_buffer_declaration
            {
            pushFollow(FOLLOW_fixed_size_buffer_declaration_in_struct_member_declaration_unsafe9713);
            fixed_size_buffer_declaration();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "struct_member_declaration_unsafe"



    // $ANTLR start "fixed_size_buffer_declaration"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2235:1: fixed_size_buffer_declaration : ( attributes )? ( fixed_size_buffer_modifiers )? FIXED buffer_element_type fixed_size_buffer_declarators SEMICOLON ;
    public final void fixed_size_buffer_declaration() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2236:2: ( ( attributes )? ( fixed_size_buffer_modifiers )? FIXED buffer_element_type fixed_size_buffer_declarators SEMICOLON )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2236:4: ( attributes )? ( fixed_size_buffer_modifiers )? FIXED buffer_element_type fixed_size_buffer_declarators SEMICOLON
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2236:4: ( attributes )?
            int alt374=2;
            int LA374_0 = input.LA(1);

            if ( (LA374_0==OPEN_BRACKET) ) {
                alt374=1;
            }
            switch (alt374) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2236:4: attributes
                    {
                    pushFollow(FOLLOW_attributes_in_fixed_size_buffer_declaration9724);
                    attributes();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2236:16: ( fixed_size_buffer_modifiers )?
            int alt375=2;
            int LA375_0 = input.LA(1);

            if ( (LA375_0==INTERNAL||LA375_0==NEW||(LA375_0 >= PRIVATE && LA375_0 <= PUBLIC)||LA375_0==UNSAFE) ) {
                alt375=1;
            }
            switch (alt375) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2236:16: fixed_size_buffer_modifiers
                    {
                    pushFollow(FOLLOW_fixed_size_buffer_modifiers_in_fixed_size_buffer_declaration9727);
                    fixed_size_buffer_modifiers();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,FIXED,FOLLOW_FIXED_in_fixed_size_buffer_declaration9730); if (state.failed) return ;

            pushFollow(FOLLOW_buffer_element_type_in_fixed_size_buffer_declaration9732);
            buffer_element_type();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_fixed_size_buffer_declarators_in_fixed_size_buffer_declaration9734);
            fixed_size_buffer_declarators();

            state._fsp--;
            if (state.failed) return ;

            match(input,SEMICOLON,FOLLOW_SEMICOLON_in_fixed_size_buffer_declaration9736); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "fixed_size_buffer_declaration"



    // $ANTLR start "fixed_size_buffer_modifiers"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2238:1: fixed_size_buffer_modifiers : ( fixed_size_buffer_modifier )+ ;
    public final void fixed_size_buffer_modifiers() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2239:2: ( ( fixed_size_buffer_modifier )+ )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2239:4: ( fixed_size_buffer_modifier )+
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2239:4: ( fixed_size_buffer_modifier )+
            int cnt376=0;
            loop376:
            do {
                int alt376=2;
                int LA376_0 = input.LA(1);

                if ( (LA376_0==INTERNAL||LA376_0==NEW||(LA376_0 >= PRIVATE && LA376_0 <= PUBLIC)||LA376_0==UNSAFE) ) {
                    alt376=1;
                }


                switch (alt376) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2239:4: fixed_size_buffer_modifier
            	    {
            	    pushFollow(FOLLOW_fixed_size_buffer_modifier_in_fixed_size_buffer_modifiers9747);
            	    fixed_size_buffer_modifier();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    if ( cnt376 >= 1 ) break loop376;
            	    if (state.backtracking>0) {state.failed=true; return ;}
                        EarlyExitException eee =
                            new EarlyExitException(376, input);
                        throw eee;
                }
                cnt376++;
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "fixed_size_buffer_modifiers"



    // $ANTLR start "fixed_size_buffer_modifier"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2241:1: fixed_size_buffer_modifier : ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | UNSAFE );
    public final void fixed_size_buffer_modifier() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2242:2: ( NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | UNSAFE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:
            {
            if ( input.LA(1)==INTERNAL||input.LA(1)==NEW||(input.LA(1) >= PRIVATE && input.LA(1) <= PUBLIC)||input.LA(1)==UNSAFE ) {
                input.consume();
                state.errorRecovery=false;
                state.failed=false;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                MismatchedSetException mse = new MismatchedSetException(null,input);
                throw mse;
            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "fixed_size_buffer_modifier"



    // $ANTLR start "buffer_element_type"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2249:1: buffer_element_type : type ;
    public final void buffer_element_type() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2250:2: ( type )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2250:4: type
            {
            pushFollow(FOLLOW_type_in_buffer_element_type9795);
            type();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "buffer_element_type"



    // $ANTLR start "fixed_size_buffer_declarators"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2252:1: fixed_size_buffer_declarators : ( fixed_size_buffer_declarator )+ ;
    public final void fixed_size_buffer_declarators() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2253:2: ( ( fixed_size_buffer_declarator )+ )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2253:4: ( fixed_size_buffer_declarator )+
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2253:4: ( fixed_size_buffer_declarator )+
            int cnt377=0;
            loop377:
            do {
                int alt377=2;
                int LA377_0 = input.LA(1);

                if ( (LA377_0==IDENTIFIER) ) {
                    alt377=1;
                }


                switch (alt377) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2253:4: fixed_size_buffer_declarator
            	    {
            	    pushFollow(FOLLOW_fixed_size_buffer_declarator_in_fixed_size_buffer_declarators9806);
            	    fixed_size_buffer_declarator();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    if ( cnt377 >= 1 ) break loop377;
            	    if (state.backtracking>0) {state.failed=true; return ;}
                        EarlyExitException eee =
                            new EarlyExitException(377, input);
                        throw eee;
                }
                cnt377++;
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "fixed_size_buffer_declarators"



    // $ANTLR start "fixed_size_buffer_declarator"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2255:1: fixed_size_buffer_declarator : IDENTIFIER OPEN_BRACKET constant_expression CLOSE_BRACKET ;
    public final void fixed_size_buffer_declarator() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2256:2: ( IDENTIFIER OPEN_BRACKET constant_expression CLOSE_BRACKET )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2256:4: IDENTIFIER OPEN_BRACKET constant_expression CLOSE_BRACKET
            {
            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_fixed_size_buffer_declarator9818); if (state.failed) return ;

            match(input,OPEN_BRACKET,FOLLOW_OPEN_BRACKET_in_fixed_size_buffer_declarator9820); if (state.failed) return ;

            pushFollow(FOLLOW_constant_expression_in_fixed_size_buffer_declarator9822);
            constant_expression();

            state._fsp--;
            if (state.failed) return ;

            match(input,CLOSE_BRACKET,FOLLOW_CLOSE_BRACKET_in_fixed_size_buffer_declarator9824); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "fixed_size_buffer_declarator"



    // $ANTLR start "local_variable_initializer_unsafe"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2259:1: local_variable_initializer_unsafe : stackalloc_initializer ;
    public final void local_variable_initializer_unsafe() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2260:2: ( stackalloc_initializer )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2260:4: stackalloc_initializer
            {
            pushFollow(FOLLOW_stackalloc_initializer_in_local_variable_initializer_unsafe9837);
            stackalloc_initializer();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "local_variable_initializer_unsafe"



    // $ANTLR start "stackalloc_initializer"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2262:1: stackalloc_initializer : STACKALLOC unmanaged_type OPEN_BRACKET expression CLOSE_BRACKET ;
    public final void stackalloc_initializer() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2263:2: ( STACKALLOC unmanaged_type OPEN_BRACKET expression CLOSE_BRACKET )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2263:4: STACKALLOC unmanaged_type OPEN_BRACKET expression CLOSE_BRACKET
            {
            match(input,STACKALLOC,FOLLOW_STACKALLOC_in_stackalloc_initializer9848); if (state.failed) return ;

            pushFollow(FOLLOW_unmanaged_type_in_stackalloc_initializer9850);
            unmanaged_type();

            state._fsp--;
            if (state.failed) return ;

            match(input,OPEN_BRACKET,FOLLOW_OPEN_BRACKET_in_stackalloc_initializer9852); if (state.failed) return ;

            pushFollow(FOLLOW_expression_in_stackalloc_initializer9854);
            expression();

            state._fsp--;
            if (state.failed) return ;

            match(input,CLOSE_BRACKET,FOLLOW_CLOSE_BRACKET_in_stackalloc_initializer9856); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "stackalloc_initializer"



    // $ANTLR start "from_contextual_keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2273:1: from_contextual_keyword :{...}? IDENTIFIER ;
    public final void from_contextual_keyword() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2274:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2274:5: {...}? IDENTIFIER
            {
            if ( !((input.LT(1).getText().equals("from"))) ) {
                if (state.backtracking>0) {state.failed=true; return ;}
                throw new FailedPredicateException(input, "from_contextual_keyword", "input.LT(1).getText().equals(\"from\")");
            }

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_from_contextual_keyword9878); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "from_contextual_keyword"



    // $ANTLR start "let_contextual_keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2276:1: let_contextual_keyword :{...}? IDENTIFIER ;
    public final void let_contextual_keyword() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2277:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2277:5: {...}? IDENTIFIER
            {
            if ( !((input.LT(1).getText().equals("let"))) ) {
                if (state.backtracking>0) {state.failed=true; return ;}
                throw new FailedPredicateException(input, "let_contextual_keyword", "input.LT(1).getText().equals(\"let\")");
            }

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_let_contextual_keyword9892); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "let_contextual_keyword"



    // $ANTLR start "where_contextual_keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2279:1: where_contextual_keyword :{...}? IDENTIFIER ;
    public final void where_contextual_keyword() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2280:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2280:5: {...}? IDENTIFIER
            {
            if ( !((input.LT(1).getText().equals("where"))) ) {
                if (state.backtracking>0) {state.failed=true; return ;}
                throw new FailedPredicateException(input, "where_contextual_keyword", "input.LT(1).getText().equals(\"where\")");
            }

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_where_contextual_keyword9906); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "where_contextual_keyword"



    // $ANTLR start "join_contextual_keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2282:1: join_contextual_keyword :{...}? IDENTIFIER ;
    public final void join_contextual_keyword() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2283:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2283:5: {...}? IDENTIFIER
            {
            if ( !((input.LT(1).getText().equals("join"))) ) {
                if (state.backtracking>0) {state.failed=true; return ;}
                throw new FailedPredicateException(input, "join_contextual_keyword", "input.LT(1).getText().equals(\"join\")");
            }

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_join_contextual_keyword9920); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "join_contextual_keyword"



    // $ANTLR start "on_contextual_keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2285:1: on_contextual_keyword :{...}? IDENTIFIER ;
    public final void on_contextual_keyword() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2286:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2286:5: {...}? IDENTIFIER
            {
            if ( !((input.LT(1).getText().equals("on"))) ) {
                if (state.backtracking>0) {state.failed=true; return ;}
                throw new FailedPredicateException(input, "on_contextual_keyword", "input.LT(1).getText().equals(\"on\")");
            }

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_on_contextual_keyword9934); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "on_contextual_keyword"



    // $ANTLR start "equals_contextual_keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2288:1: equals_contextual_keyword :{...}? IDENTIFIER ;
    public final void equals_contextual_keyword() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2289:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2289:5: {...}? IDENTIFIER
            {
            if ( !((input.LT(1).getText().equals("equals"))) ) {
                if (state.backtracking>0) {state.failed=true; return ;}
                throw new FailedPredicateException(input, "equals_contextual_keyword", "input.LT(1).getText().equals(\"equals\")");
            }

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_equals_contextual_keyword9948); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "equals_contextual_keyword"



    // $ANTLR start "into_contextual_keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2291:1: into_contextual_keyword :{...}? IDENTIFIER ;
    public final void into_contextual_keyword() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2292:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2292:5: {...}? IDENTIFIER
            {
            if ( !((input.LT(1).getText().equals("into"))) ) {
                if (state.backtracking>0) {state.failed=true; return ;}
                throw new FailedPredicateException(input, "into_contextual_keyword", "input.LT(1).getText().equals(\"into\")");
            }

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_into_contextual_keyword9962); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "into_contextual_keyword"



    // $ANTLR start "orderby_contextual_keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2294:1: orderby_contextual_keyword :{...}? IDENTIFIER ;
    public final void orderby_contextual_keyword() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2295:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2295:5: {...}? IDENTIFIER
            {
            if ( !((input.LT(1).getText().equals("orderby"))) ) {
                if (state.backtracking>0) {state.failed=true; return ;}
                throw new FailedPredicateException(input, "orderby_contextual_keyword", "input.LT(1).getText().equals(\"orderby\")");
            }

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_orderby_contextual_keyword9976); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "orderby_contextual_keyword"



    // $ANTLR start "ascending_contextual_keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2297:1: ascending_contextual_keyword :{...}? IDENTIFIER ;
    public final void ascending_contextual_keyword() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2298:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2298:5: {...}? IDENTIFIER
            {
            if ( !((input.LT(1).getText().equals("ascending"))) ) {
                if (state.backtracking>0) {state.failed=true; return ;}
                throw new FailedPredicateException(input, "ascending_contextual_keyword", "input.LT(1).getText().equals(\"ascending\")");
            }

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_ascending_contextual_keyword9990); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "ascending_contextual_keyword"



    // $ANTLR start "descending_contextual_keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2300:1: descending_contextual_keyword :{...}? IDENTIFIER ;
    public final void descending_contextual_keyword() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2301:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2301:5: {...}? IDENTIFIER
            {
            if ( !((input.LT(1).getText().equals("descending"))) ) {
                if (state.backtracking>0) {state.failed=true; return ;}
                throw new FailedPredicateException(input, "descending_contextual_keyword", "input.LT(1).getText().equals(\"descending\")");
            }

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_descending_contextual_keyword10004); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "descending_contextual_keyword"



    // $ANTLR start "select_contextual_keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2303:1: select_contextual_keyword :{...}? IDENTIFIER ;
    public final void select_contextual_keyword() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2304:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2304:5: {...}? IDENTIFIER
            {
            if ( !((input.LT(1).getText().equals("select"))) ) {
                if (state.backtracking>0) {state.failed=true; return ;}
                throw new FailedPredicateException(input, "select_contextual_keyword", "input.LT(1).getText().equals(\"select\")");
            }

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_select_contextual_keyword10018); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "select_contextual_keyword"



    // $ANTLR start "group_contextual_keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2306:1: group_contextual_keyword :{...}? IDENTIFIER ;
    public final void group_contextual_keyword() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2307:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2307:5: {...}? IDENTIFIER
            {
            if ( !((input.LT(1).getText().equals("group"))) ) {
                if (state.backtracking>0) {state.failed=true; return ;}
                throw new FailedPredicateException(input, "group_contextual_keyword", "input.LT(1).getText().equals(\"group\")");
            }

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_group_contextual_keyword10032); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "group_contextual_keyword"



    // $ANTLR start "by_contextual_keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2309:1: by_contextual_keyword :{...}? IDENTIFIER ;
    public final void by_contextual_keyword() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2310:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2310:5: {...}? IDENTIFIER
            {
            if ( !((input.LT(1).getText().equals("by"))) ) {
                if (state.backtracking>0) {state.failed=true; return ;}
                throw new FailedPredicateException(input, "by_contextual_keyword", "input.LT(1).getText().equals(\"by\")");
            }

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_by_contextual_keyword10046); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "by_contextual_keyword"



    // $ANTLR start "partial_contextual_keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2312:1: partial_contextual_keyword :{...}? IDENTIFIER ;
    public final void partial_contextual_keyword() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2313:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2313:5: {...}? IDENTIFIER
            {
            if ( !((input.LT(1).getText().equals("partial"))) ) {
                if (state.backtracking>0) {state.failed=true; return ;}
                throw new FailedPredicateException(input, "partial_contextual_keyword", "input.LT(1).getText().equals(\"partial\")");
            }

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_partial_contextual_keyword10060); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "partial_contextual_keyword"



    // $ANTLR start "alias_contextual_keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2315:1: alias_contextual_keyword :{...}? IDENTIFIER ;
    public final void alias_contextual_keyword() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2316:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2316:5: {...}? IDENTIFIER
            {
            if ( !((input.LT(1).getText().equals("alias"))) ) {
                if (state.backtracking>0) {state.failed=true; return ;}
                throw new FailedPredicateException(input, "alias_contextual_keyword", "input.LT(1).getText().equals(\"alias\")");
            }

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_alias_contextual_keyword10074); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "alias_contextual_keyword"



    // $ANTLR start "yield_contextual_keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2318:1: yield_contextual_keyword :{...}? IDENTIFIER ;
    public final void yield_contextual_keyword() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2319:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2319:5: {...}? IDENTIFIER
            {
            if ( !((input.LT(1).getText().equals("yield"))) ) {
                if (state.backtracking>0) {state.failed=true; return ;}
                throw new FailedPredicateException(input, "yield_contextual_keyword", "input.LT(1).getText().equals(\"yield\")");
            }

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_yield_contextual_keyword10088); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "yield_contextual_keyword"



    // $ANTLR start "get_contextual_keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2321:1: get_contextual_keyword :{...}? IDENTIFIER ;
    public final void get_contextual_keyword() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2322:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2322:5: {...}? IDENTIFIER
            {
            if ( !((input.LT(1).getText().equals("get"))) ) {
                if (state.backtracking>0) {state.failed=true; return ;}
                throw new FailedPredicateException(input, "get_contextual_keyword", "input.LT(1).getText().equals(\"get\")");
            }

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_get_contextual_keyword10102); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "get_contextual_keyword"



    // $ANTLR start "set_contextual_keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2324:1: set_contextual_keyword :{...}? IDENTIFIER ;
    public final void set_contextual_keyword() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2325:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2325:5: {...}? IDENTIFIER
            {
            if ( !((input.LT(1).getText().equals("set"))) ) {
                if (state.backtracking>0) {state.failed=true; return ;}
                throw new FailedPredicateException(input, "set_contextual_keyword", "input.LT(1).getText().equals(\"set\")");
            }

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_set_contextual_keyword10116); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "set_contextual_keyword"



    // $ANTLR start "add_contextual_keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2327:1: add_contextual_keyword :{...}? IDENTIFIER ;
    public final void add_contextual_keyword() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2328:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2328:5: {...}? IDENTIFIER
            {
            if ( !((input.LT(1).getText().equals("add"))) ) {
                if (state.backtracking>0) {state.failed=true; return ;}
                throw new FailedPredicateException(input, "add_contextual_keyword", "input.LT(1).getText().equals(\"add\")");
            }

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_add_contextual_keyword10130); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "add_contextual_keyword"



    // $ANTLR start "remove_contextual_keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2330:1: remove_contextual_keyword :{...}? IDENTIFIER ;
    public final void remove_contextual_keyword() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2331:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2331:5: {...}? IDENTIFIER
            {
            if ( !((input.LT(1).getText().equals("remove"))) ) {
                if (state.backtracking>0) {state.failed=true; return ;}
                throw new FailedPredicateException(input, "remove_contextual_keyword", "input.LT(1).getText().equals(\"remove\")");
            }

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_remove_contextual_keyword10144); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "remove_contextual_keyword"



    // $ANTLR start "dynamic_contextual_keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2333:1: dynamic_contextual_keyword :{...}? IDENTIFIER ;
    public final void dynamic_contextual_keyword() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2334:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2334:5: {...}? IDENTIFIER
            {
            if ( !((input.LT(1).getText().equals("dynamic"))) ) {
                if (state.backtracking>0) {state.failed=true; return ;}
                throw new FailedPredicateException(input, "dynamic_contextual_keyword", "input.LT(1).getText().equals(\"dynamic\")");
            }

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_dynamic_contextual_keyword10158); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "dynamic_contextual_keyword"



    // $ANTLR start "arglist"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2336:1: arglist :{...}? IDENTIFIER ;
    public final void arglist() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2337:3: ({...}? IDENTIFIER )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2337:5: {...}? IDENTIFIER
            {
            if ( !((input.LT(1).getText().equals("__arglist"))) ) {
                if (state.backtracking>0) {state.failed=true; return ;}
                throw new FailedPredicateException(input, "arglist", "input.LT(1).getText().equals(\"__arglist\")");
            }

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_arglist10172); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "arglist"



    // $ANTLR start "right_arrow"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2339:1: right_arrow : first= ASSIGNMENT second= GT {...}?;
    public final void right_arrow() throws RecognitionException {
        Token first=null;
        Token second=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2340:3: (first= ASSIGNMENT second= GT {...}?)
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2340:5: first= ASSIGNMENT second= GT {...}?
            {
            first=(Token)match(input,ASSIGNMENT,FOLLOW_ASSIGNMENT_in_right_arrow10186); if (state.failed) return ;

            second=(Token)match(input,GT,FOLLOW_GT_in_right_arrow10190); if (state.failed) return ;

            if ( !(((first!=null?first.getTokenIndex():0) + 1 == (second!=null?second.getTokenIndex():0))) ) {
                if (state.backtracking>0) {state.failed=true; return ;}
                throw new FailedPredicateException(input, "right_arrow", "$first.index + 1 == $second.index");
            }

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "right_arrow"



    // $ANTLR start "right_shift"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2342:1: right_shift : first= GT second= GT {...}?;
    public final void right_shift() throws RecognitionException {
        Token first=null;
        Token second=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2343:3: (first= GT second= GT {...}?)
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2343:5: first= GT second= GT {...}?
            {
            first=(Token)match(input,GT,FOLLOW_GT_in_right_shift10207); if (state.failed) return ;

            second=(Token)match(input,GT,FOLLOW_GT_in_right_shift10211); if (state.failed) return ;

            if ( !(((first!=null?first.getTokenIndex():0) + 1 == (second!=null?second.getTokenIndex():0))) ) {
                if (state.backtracking>0) {state.failed=true; return ;}
                throw new FailedPredicateException(input, "right_shift", "$first.index + 1 == $second.index");
            }

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "right_shift"



    // $ANTLR start "right_shift_assignment"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2345:1: right_shift_assignment : first= GT second= OP_GE {...}?;
    public final void right_shift_assignment() throws RecognitionException {
        Token first=null;
        Token second=null;

        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2346:3: (first= GT second= OP_GE {...}?)
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2346:5: first= GT second= OP_GE {...}?
            {
            first=(Token)match(input,GT,FOLLOW_GT_in_right_shift_assignment10228); if (state.failed) return ;

            second=(Token)match(input,OP_GE,FOLLOW_OP_GE_in_right_shift_assignment10232); if (state.failed) return ;

            if ( !(((first!=null?first.getTokenIndex():0) + 1 == (second!=null?second.getTokenIndex():0))) ) {
                if (state.backtracking>0) {state.failed=true; return ;}
                throw new FailedPredicateException(input, "right_shift_assignment", "$first.index + 1 == $second.index");
            }

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "right_shift_assignment"



    // $ANTLR start "literal"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2348:1: literal : ( boolean_literal | INTEGER_LITERAL | REAL_LITERAL | CHARACTER_LITERAL | STRING_LITERAL | NULL );
    public final void literal() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2349:3: ( boolean_literal | INTEGER_LITERAL | REAL_LITERAL | CHARACTER_LITERAL | STRING_LITERAL | NULL )
            int alt378=6;
            switch ( input.LA(1) ) {
            case FALSE:
            case TRUE:
                {
                alt378=1;
                }
                break;
            case INTEGER_LITERAL:
                {
                alt378=2;
                }
                break;
            case REAL_LITERAL:
                {
                alt378=3;
                }
                break;
            case CHARACTER_LITERAL:
                {
                alt378=4;
                }
                break;
            case STRING_LITERAL:
                {
                alt378=5;
                }
                break;
            case NULL:
                {
                alt378=6;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 378, 0, input);

                throw nvae;

            }

            switch (alt378) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2349:5: boolean_literal
                    {
                    pushFollow(FOLLOW_boolean_literal_in_literal10247);
                    boolean_literal();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2350:5: INTEGER_LITERAL
                    {
                    match(input,INTEGER_LITERAL,FOLLOW_INTEGER_LITERAL_in_literal10253); if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2351:5: REAL_LITERAL
                    {
                    match(input,REAL_LITERAL,FOLLOW_REAL_LITERAL_in_literal10259); if (state.failed) return ;

                    }
                    break;
                case 4 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2352:5: CHARACTER_LITERAL
                    {
                    match(input,CHARACTER_LITERAL,FOLLOW_CHARACTER_LITERAL_in_literal10265); if (state.failed) return ;

                    }
                    break;
                case 5 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2353:5: STRING_LITERAL
                    {
                    match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_literal10271); if (state.failed) return ;

                    }
                    break;
                case 6 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2354:5: NULL
                    {
                    match(input,NULL,FOLLOW_NULL_in_literal10277); if (state.failed) return ;

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "literal"



    // $ANTLR start "boolean_literal"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2356:1: boolean_literal : ( TRUE | FALSE );
    public final void boolean_literal() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2357:3: ( TRUE | FALSE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:
            {
            if ( input.LA(1)==FALSE||input.LA(1)==TRUE ) {
                input.consume();
                state.errorRecovery=false;
                state.failed=false;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                MismatchedSetException mse = new MismatchedSetException(null,input);
                throw mse;
            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "boolean_literal"



    // $ANTLR start "keyword"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2361:1: keyword : ( ABSTRACT | AS | BASE | BOOL | BREAK | BYTE | CASE | CATCH | CHAR | CHECKED | CLASS | CONST | CONTINUE | DECIMAL | DEFAULT | DELEGATE | DO | DOUBLE | ELSE | ENUM | EVENT | EXPLICIT | EXTERN | FALSE | FINALLY | FIXED | FLOAT | FOR | FOREACH | GOTO | IF | IMPLICIT | IN | INT | INTERFACE | INTERNAL | IS | LOCK | LONG | NAMESPACE | NEW | NULL | OBJECT | OPERATOR | OUT | OVERRIDE | PARAMS | PRIVATE | PROTECTED | PUBLIC | READONLY | REF | RETURN | SBYTE | SEALED | SHORT | SIZEOF | STACKALLOC | STATIC | STRING | STRUCT | SWITCH | THIS | THROW | TRUE | TRY | TYPEOF | UINT | ULONG | UNCHECKED | UNSAFE | USHORT | USING | VIRTUAL | VOID | VOLATILE | WHILE );
    public final void keyword() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2362:3: ( ABSTRACT | AS | BASE | BOOL | BREAK | BYTE | CASE | CATCH | CHAR | CHECKED | CLASS | CONST | CONTINUE | DECIMAL | DEFAULT | DELEGATE | DO | DOUBLE | ELSE | ENUM | EVENT | EXPLICIT | EXTERN | FALSE | FINALLY | FIXED | FLOAT | FOR | FOREACH | GOTO | IF | IMPLICIT | IN | INT | INTERFACE | INTERNAL | IS | LOCK | LONG | NAMESPACE | NEW | NULL | OBJECT | OPERATOR | OUT | OVERRIDE | PARAMS | PRIVATE | PROTECTED | PUBLIC | READONLY | REF | RETURN | SBYTE | SEALED | SHORT | SIZEOF | STACKALLOC | STATIC | STRING | STRUCT | SWITCH | THIS | THROW | TRUE | TRY | TYPEOF | UINT | ULONG | UNCHECKED | UNSAFE | USHORT | USING | VIRTUAL | VOID | VOLATILE | WHILE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:
            {
            if ( input.LA(1)==ABSTRACT||input.LA(1)==AS||input.LA(1)==BASE||(input.LA(1) >= BOOL && input.LA(1) <= BYTE)||(input.LA(1) >= CASE && input.LA(1) <= CHAR)||(input.LA(1) >= CHECKED && input.LA(1) <= CLASS)||(input.LA(1) >= CONST && input.LA(1) <= CONTINUE)||input.LA(1)==DECIMAL||(input.LA(1) >= DEFAULT && input.LA(1) <= DELEGATE)||input.LA(1)==DO||input.LA(1)==DOUBLE||(input.LA(1) >= ELSE && input.LA(1) <= EXTERN)||(input.LA(1) >= FALSE && input.LA(1) <= FOREACH)||input.LA(1)==GOTO||(input.LA(1) >= IF && input.LA(1) <= INT)||(input.LA(1) >= INTERFACE && input.LA(1) <= INTERNAL)||input.LA(1)==IS||(input.LA(1) >= LOCK && input.LA(1) <= LONG)||(input.LA(1) >= NAMESPACE && input.LA(1) <= NEW)||input.LA(1)==NULL||input.LA(1)==OBJECT||input.LA(1)==OPERATOR||(input.LA(1) >= OUT && input.LA(1) <= PARAMS)||(input.LA(1) >= PRIVATE && input.LA(1) <= PUBLIC)||input.LA(1)==READONLY||(input.LA(1) >= REF && input.LA(1) <= RETURN)||(input.LA(1) >= SBYTE && input.LA(1) <= SEALED)||input.LA(1)==SHORT||(input.LA(1) >= SIZEOF && input.LA(1) <= STACKALLOC)||(input.LA(1) >= STATIC && input.LA(1) <= STRING)||(input.LA(1) >= STRUCT && input.LA(1) <= SWITCH)||(input.LA(1) >= THIS && input.LA(1) <= THROW)||(input.LA(1) >= TRUE && input.LA(1) <= UNCHECKED)||(input.LA(1) >= UNSAFE && input.LA(1) <= USING)||(input.LA(1) >= VIRTUAL && input.LA(1) <= VOLATILE)||input.LA(1)==WHILE ) {
                input.consume();
                state.errorRecovery=false;
                state.failed=false;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                MismatchedSetException mse = new MismatchedSetException(null,input);
                throw mse;
            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "keyword"



    // $ANTLR start "class_definition"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2443:1: class_definition : CLASS IDENTIFIER ( type_parameter_list )? ( class_base )? ( type_parameter_constraints_clauses )? class_body ( SEMICOLON )? ;
    public final void class_definition() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2444:3: ( CLASS IDENTIFIER ( type_parameter_list )? ( class_base )? ( type_parameter_constraints_clauses )? class_body ( SEMICOLON )? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2444:5: CLASS IDENTIFIER ( type_parameter_list )? ( class_base )? ( type_parameter_constraints_clauses )? class_body ( SEMICOLON )?
            {
            match(input,CLASS,FOLLOW_CLASS_in_class_definition10779); if (state.failed) return ;

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_class_definition10781); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2444:22: ( type_parameter_list )?
            int alt379=2;
            int LA379_0 = input.LA(1);

            if ( (LA379_0==LT) ) {
                alt379=1;
            }
            switch (alt379) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2444:22: type_parameter_list
                    {
                    pushFollow(FOLLOW_type_parameter_list_in_class_definition10783);
                    type_parameter_list();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2444:43: ( class_base )?
            int alt380=2;
            int LA380_0 = input.LA(1);

            if ( (LA380_0==COLON) ) {
                alt380=1;
            }
            switch (alt380) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2444:43: class_base
                    {
                    pushFollow(FOLLOW_class_base_in_class_definition10786);
                    class_base();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2444:55: ( type_parameter_constraints_clauses )?
            int alt381=2;
            int LA381_0 = input.LA(1);

            if ( (LA381_0==IDENTIFIER) ) {
                alt381=1;
            }
            switch (alt381) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2444:55: type_parameter_constraints_clauses
                    {
                    pushFollow(FOLLOW_type_parameter_constraints_clauses_in_class_definition10789);
                    type_parameter_constraints_clauses();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            pushFollow(FOLLOW_class_body_in_class_definition10798);
            class_body();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2445:18: ( SEMICOLON )?
            int alt382=2;
            int LA382_0 = input.LA(1);

            if ( (LA382_0==SEMICOLON) ) {
                alt382=1;
            }
            switch (alt382) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2445:18: SEMICOLON
                    {
                    match(input,SEMICOLON,FOLLOW_SEMICOLON_in_class_definition10800); if (state.failed) return ;

                    }
                    break;

            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "class_definition"



    // $ANTLR start "struct_definition"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2447:1: struct_definition : STRUCT IDENTIFIER ( type_parameter_list )? ( struct_interfaces )? ( type_parameter_constraints_clauses )? struct_body ( SEMICOLON )? ;
    public final void struct_definition() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2448:3: ( STRUCT IDENTIFIER ( type_parameter_list )? ( struct_interfaces )? ( type_parameter_constraints_clauses )? struct_body ( SEMICOLON )? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2448:5: STRUCT IDENTIFIER ( type_parameter_list )? ( struct_interfaces )? ( type_parameter_constraints_clauses )? struct_body ( SEMICOLON )?
            {
            match(input,STRUCT,FOLLOW_STRUCT_in_struct_definition10813); if (state.failed) return ;

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_struct_definition10815); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2448:23: ( type_parameter_list )?
            int alt383=2;
            int LA383_0 = input.LA(1);

            if ( (LA383_0==LT) ) {
                alt383=1;
            }
            switch (alt383) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2448:23: type_parameter_list
                    {
                    pushFollow(FOLLOW_type_parameter_list_in_struct_definition10817);
                    type_parameter_list();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2448:44: ( struct_interfaces )?
            int alt384=2;
            int LA384_0 = input.LA(1);

            if ( (LA384_0==COLON) ) {
                alt384=1;
            }
            switch (alt384) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2448:44: struct_interfaces
                    {
                    pushFollow(FOLLOW_struct_interfaces_in_struct_definition10820);
                    struct_interfaces();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2448:63: ( type_parameter_constraints_clauses )?
            int alt385=2;
            int LA385_0 = input.LA(1);

            if ( (LA385_0==IDENTIFIER) ) {
                alt385=1;
            }
            switch (alt385) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2448:63: type_parameter_constraints_clauses
                    {
                    pushFollow(FOLLOW_type_parameter_constraints_clauses_in_struct_definition10823);
                    type_parameter_constraints_clauses();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            pushFollow(FOLLOW_struct_body_in_struct_definition10832);
            struct_body();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2449:19: ( SEMICOLON )?
            int alt386=2;
            int LA386_0 = input.LA(1);

            if ( (LA386_0==SEMICOLON) ) {
                alt386=1;
            }
            switch (alt386) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2449:19: SEMICOLON
                    {
                    match(input,SEMICOLON,FOLLOW_SEMICOLON_in_struct_definition10834); if (state.failed) return ;

                    }
                    break;

            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "struct_definition"



    // $ANTLR start "interface_definition"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2451:1: interface_definition : INTERFACE IDENTIFIER ( variant_type_parameter_list )? ( interface_base )? ( type_parameter_constraints_clauses )? interface_body ( SEMICOLON )? ;
    public final void interface_definition() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2452:3: ( INTERFACE IDENTIFIER ( variant_type_parameter_list )? ( interface_base )? ( type_parameter_constraints_clauses )? interface_body ( SEMICOLON )? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2452:5: INTERFACE IDENTIFIER ( variant_type_parameter_list )? ( interface_base )? ( type_parameter_constraints_clauses )? interface_body ( SEMICOLON )?
            {
            match(input,INTERFACE,FOLLOW_INTERFACE_in_interface_definition10847); if (state.failed) return ;

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_interface_definition10849); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2452:26: ( variant_type_parameter_list )?
            int alt387=2;
            int LA387_0 = input.LA(1);

            if ( (LA387_0==LT) ) {
                alt387=1;
            }
            switch (alt387) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2452:26: variant_type_parameter_list
                    {
                    pushFollow(FOLLOW_variant_type_parameter_list_in_interface_definition10851);
                    variant_type_parameter_list();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2452:55: ( interface_base )?
            int alt388=2;
            int LA388_0 = input.LA(1);

            if ( (LA388_0==COLON) ) {
                alt388=1;
            }
            switch (alt388) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2452:55: interface_base
                    {
                    pushFollow(FOLLOW_interface_base_in_interface_definition10854);
                    interface_base();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2453:7: ( type_parameter_constraints_clauses )?
            int alt389=2;
            int LA389_0 = input.LA(1);

            if ( (LA389_0==IDENTIFIER) ) {
                alt389=1;
            }
            switch (alt389) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2453:7: type_parameter_constraints_clauses
                    {
                    pushFollow(FOLLOW_type_parameter_constraints_clauses_in_interface_definition10863);
                    type_parameter_constraints_clauses();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            pushFollow(FOLLOW_interface_body_in_interface_definition10866);
            interface_body();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2453:58: ( SEMICOLON )?
            int alt390=2;
            int LA390_0 = input.LA(1);

            if ( (LA390_0==SEMICOLON) ) {
                alt390=1;
            }
            switch (alt390) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2453:58: SEMICOLON
                    {
                    match(input,SEMICOLON,FOLLOW_SEMICOLON_in_interface_definition10868); if (state.failed) return ;

                    }
                    break;

            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "interface_definition"



    // $ANTLR start "enum_definition"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2455:1: enum_definition : ENUM IDENTIFIER ( enum_base )? enum_body ( SEMICOLON )? ;
    public final void enum_definition() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2456:3: ( ENUM IDENTIFIER ( enum_base )? enum_body ( SEMICOLON )? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2456:5: ENUM IDENTIFIER ( enum_base )? enum_body ( SEMICOLON )?
            {
            match(input,ENUM,FOLLOW_ENUM_in_enum_definition10881); if (state.failed) return ;

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_enum_definition10883); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2456:21: ( enum_base )?
            int alt391=2;
            int LA391_0 = input.LA(1);

            if ( (LA391_0==COLON) ) {
                alt391=1;
            }
            switch (alt391) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2456:21: enum_base
                    {
                    pushFollow(FOLLOW_enum_base_in_enum_definition10885);
                    enum_base();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            pushFollow(FOLLOW_enum_body_in_enum_definition10888);
            enum_body();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2456:42: ( SEMICOLON )?
            int alt392=2;
            int LA392_0 = input.LA(1);

            if ( (LA392_0==SEMICOLON) ) {
                alt392=1;
            }
            switch (alt392) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2456:42: SEMICOLON
                    {
                    match(input,SEMICOLON,FOLLOW_SEMICOLON_in_enum_definition10890); if (state.failed) return ;

                    }
                    break;

            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "enum_definition"



    // $ANTLR start "delegate_definition"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2458:1: delegate_definition : DELEGATE return_type IDENTIFIER ( variant_type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? SEMICOLON ;
    public final void delegate_definition() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2459:3: ( DELEGATE return_type IDENTIFIER ( variant_type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? SEMICOLON )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2459:5: DELEGATE return_type IDENTIFIER ( variant_type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? SEMICOLON
            {
            match(input,DELEGATE,FOLLOW_DELEGATE_in_delegate_definition10903); if (state.failed) return ;

            pushFollow(FOLLOW_return_type_in_delegate_definition10905);
            return_type();

            state._fsp--;
            if (state.failed) return ;

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_delegate_definition10907); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2459:37: ( variant_type_parameter_list )?
            int alt393=2;
            int LA393_0 = input.LA(1);

            if ( (LA393_0==LT) ) {
                alt393=1;
            }
            switch (alt393) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2459:37: variant_type_parameter_list
                    {
                    pushFollow(FOLLOW_variant_type_parameter_list_in_delegate_definition10909);
                    variant_type_parameter_list();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_delegate_definition10912); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2460:7: ( formal_parameter_list )?
            int alt394=2;
            int LA394_0 = input.LA(1);

            if ( (LA394_0==BOOL||LA394_0==BYTE||LA394_0==CHAR||LA394_0==DECIMAL||LA394_0==DOUBLE||LA394_0==FLOAT||LA394_0==IDENTIFIER||LA394_0==INT||LA394_0==LONG||LA394_0==OBJECT||LA394_0==OPEN_BRACKET||LA394_0==OUT||LA394_0==PARAMS||LA394_0==REF||LA394_0==SBYTE||LA394_0==SHORT||LA394_0==STRING||LA394_0==THIS||(LA394_0 >= UINT && LA394_0 <= ULONG)||LA394_0==USHORT||LA394_0==VOID) ) {
                alt394=1;
            }
            switch (alt394) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2460:7: formal_parameter_list
                    {
                    pushFollow(FOLLOW_formal_parameter_list_in_delegate_definition10920);
                    formal_parameter_list();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_delegate_definition10923); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2460:43: ( type_parameter_constraints_clauses )?
            int alt395=2;
            int LA395_0 = input.LA(1);

            if ( (LA395_0==IDENTIFIER) ) {
                alt395=1;
            }
            switch (alt395) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2460:43: type_parameter_constraints_clauses
                    {
                    pushFollow(FOLLOW_type_parameter_constraints_clauses_in_delegate_definition10925);
                    type_parameter_constraints_clauses();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,SEMICOLON,FOLLOW_SEMICOLON_in_delegate_definition10928); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "delegate_definition"



    // $ANTLR start "method_definition"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2462:1: method_definition : method_member_name ( type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? method_body ;
    public final void method_definition() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2463:3: ( method_member_name ( type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? method_body )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2463:5: method_member_name ( type_parameter_list )? OPEN_PARENS ( formal_parameter_list )? CLOSE_PARENS ( type_parameter_constraints_clauses )? method_body
            {
            pushFollow(FOLLOW_method_member_name_in_method_definition10940);
            method_member_name();

            state._fsp--;
            if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2463:24: ( type_parameter_list )?
            int alt396=2;
            int LA396_0 = input.LA(1);

            if ( (LA396_0==LT) ) {
                alt396=1;
            }
            switch (alt396) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2463:24: type_parameter_list
                    {
                    pushFollow(FOLLOW_type_parameter_list_in_method_definition10942);
                    type_parameter_list();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_method_definition10945); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2463:57: ( formal_parameter_list )?
            int alt397=2;
            int LA397_0 = input.LA(1);

            if ( (LA397_0==BOOL||LA397_0==BYTE||LA397_0==CHAR||LA397_0==DECIMAL||LA397_0==DOUBLE||LA397_0==FLOAT||LA397_0==IDENTIFIER||LA397_0==INT||LA397_0==LONG||LA397_0==OBJECT||LA397_0==OPEN_BRACKET||LA397_0==OUT||LA397_0==PARAMS||LA397_0==REF||LA397_0==SBYTE||LA397_0==SHORT||LA397_0==STRING||LA397_0==THIS||(LA397_0 >= UINT && LA397_0 <= ULONG)||LA397_0==USHORT||LA397_0==VOID) ) {
                alt397=1;
            }
            switch (alt397) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2463:57: formal_parameter_list
                    {
                    pushFollow(FOLLOW_formal_parameter_list_in_method_definition10947);
                    formal_parameter_list();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_method_definition10950); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2464:7: ( type_parameter_constraints_clauses )?
            int alt398=2;
            int LA398_0 = input.LA(1);

            if ( (LA398_0==IDENTIFIER) ) {
                alt398=1;
            }
            switch (alt398) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2464:7: type_parameter_constraints_clauses
                    {
                    pushFollow(FOLLOW_type_parameter_constraints_clauses_in_method_definition10959);
                    type_parameter_constraints_clauses();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            pushFollow(FOLLOW_method_body_in_method_definition10962);
            method_body();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "method_definition"



    // $ANTLR start "method_member_name"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2467:1: method_member_name : ( IDENTIFIER | IDENTIFIER DOUBLE_COLON IDENTIFIER ) ( type_argument_list_opt DOT IDENTIFIER )* ;
    public final void method_member_name() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2468:3: ( ( IDENTIFIER | IDENTIFIER DOUBLE_COLON IDENTIFIER ) ( type_argument_list_opt DOT IDENTIFIER )* )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2468:5: ( IDENTIFIER | IDENTIFIER DOUBLE_COLON IDENTIFIER ) ( type_argument_list_opt DOT IDENTIFIER )*
            {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2468:5: ( IDENTIFIER | IDENTIFIER DOUBLE_COLON IDENTIFIER )
            int alt399=2;
            int LA399_0 = input.LA(1);

            if ( (LA399_0==IDENTIFIER) ) {
                int LA399_1 = input.LA(2);

                if ( (LA399_1==DOUBLE_COLON) ) {
                    alt399=2;
                }
                else if ( (LA399_1==DOT||LA399_1==LT||LA399_1==OPEN_PARENS) ) {
                    alt399=1;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 399, 1, input);

                    throw nvae;

                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 399, 0, input);

                throw nvae;

            }
            switch (alt399) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2468:7: IDENTIFIER
                    {
                    match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_method_member_name10977); if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2469:7: IDENTIFIER DOUBLE_COLON IDENTIFIER
                    {
                    match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_method_member_name10985); if (state.failed) return ;

                    match(input,DOUBLE_COLON,FOLLOW_DOUBLE_COLON_in_method_member_name10987); if (state.failed) return ;

                    match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_method_member_name10989); if (state.failed) return ;

                    }
                    break;

            }


            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2470:7: ( type_argument_list_opt DOT IDENTIFIER )*
            loop400:
            do {
                int alt400=2;
                alt400 = dfa400.predict(input);
                switch (alt400) {
            	case 1 :
            	    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2470:8: type_argument_list_opt DOT IDENTIFIER
            	    {
            	    pushFollow(FOLLOW_type_argument_list_opt_in_method_member_name10998);
            	    type_argument_list_opt();

            	    state._fsp--;
            	    if (state.failed) return ;

            	    match(input,DOT,FOLLOW_DOT_in_method_member_name11000); if (state.failed) return ;

            	    match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_method_member_name11002); if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop400;
                }
            } while (true);


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "method_member_name"



    // $ANTLR start "field_declaration2"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2473:1: field_declaration2 : variable_declarators SEMICOLON ;
    public final void field_declaration2() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2474:3: ( variable_declarators SEMICOLON )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2474:5: variable_declarators SEMICOLON
            {
            pushFollow(FOLLOW_variable_declarators_in_field_declaration211017);
            variable_declarators();

            state._fsp--;
            if (state.failed) return ;

            match(input,SEMICOLON,FOLLOW_SEMICOLON_in_field_declaration211019); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "field_declaration2"



    // $ANTLR start "property_declaration2"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2476:1: property_declaration2 : member_name OPEN_BRACE accessor_declarations CLOSE_BRACE ;
    public final void property_declaration2() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2477:3: ( member_name OPEN_BRACE accessor_declarations CLOSE_BRACE )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2477:5: member_name OPEN_BRACE accessor_declarations CLOSE_BRACE
            {
            pushFollow(FOLLOW_member_name_in_property_declaration211031);
            member_name();

            state._fsp--;
            if (state.failed) return ;

            match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_property_declaration211033); if (state.failed) return ;

            pushFollow(FOLLOW_accessor_declarations_in_property_declaration211035);
            accessor_declarations();

            state._fsp--;
            if (state.failed) return ;

            match(input,CLOSE_BRACE,FOLLOW_CLOSE_BRACE_in_property_declaration211037); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "property_declaration2"



    // $ANTLR start "constant_declaration2"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2479:1: constant_declaration2 : CONST type constant_declarators SEMICOLON ;
    public final void constant_declaration2() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2480:3: ( CONST type constant_declarators SEMICOLON )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2480:5: CONST type constant_declarators SEMICOLON
            {
            match(input,CONST,FOLLOW_CONST_in_constant_declaration211049); if (state.failed) return ;

            pushFollow(FOLLOW_type_in_constant_declaration211051);
            type();

            state._fsp--;
            if (state.failed) return ;

            pushFollow(FOLLOW_constant_declarators_in_constant_declaration211053);
            constant_declarators();

            state._fsp--;
            if (state.failed) return ;

            match(input,SEMICOLON,FOLLOW_SEMICOLON_in_constant_declaration211055); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "constant_declaration2"



    // $ANTLR start "operator_declaration2"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2483:1: operator_declaration2 : OPERATOR overloadable_operator OPEN_PARENS type IDENTIFIER ( COMMA type IDENTIFIER )? CLOSE_PARENS operator_body ;
    public final void operator_declaration2() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2484:3: ( OPERATOR overloadable_operator OPEN_PARENS type IDENTIFIER ( COMMA type IDENTIFIER )? CLOSE_PARENS operator_body )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2484:5: OPERATOR overloadable_operator OPEN_PARENS type IDENTIFIER ( COMMA type IDENTIFIER )? CLOSE_PARENS operator_body
            {
            match(input,OPERATOR,FOLLOW_OPERATOR_in_operator_declaration211068); if (state.failed) return ;

            pushFollow(FOLLOW_overloadable_operator_in_operator_declaration211070);
            overloadable_operator();

            state._fsp--;
            if (state.failed) return ;

            match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_operator_declaration211072); if (state.failed) return ;

            pushFollow(FOLLOW_type_in_operator_declaration211074);
            type();

            state._fsp--;
            if (state.failed) return ;

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_operator_declaration211076); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2485:10: ( COMMA type IDENTIFIER )?
            int alt401=2;
            int LA401_0 = input.LA(1);

            if ( (LA401_0==COMMA) ) {
                alt401=1;
            }
            switch (alt401) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2485:11: COMMA type IDENTIFIER
                    {
                    match(input,COMMA,FOLLOW_COMMA_in_operator_declaration211088); if (state.failed) return ;

                    pushFollow(FOLLOW_type_in_operator_declaration211090);
                    type();

                    state._fsp--;
                    if (state.failed) return ;

                    match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_operator_declaration211092); if (state.failed) return ;

                    }
                    break;

            }


            match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_operator_declaration211096); if (state.failed) return ;

            pushFollow(FOLLOW_operator_body_in_operator_declaration211098);
            operator_body();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "operator_declaration2"



    // $ANTLR start "member_access2"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2488:1: member_access2 : DOT IDENTIFIER type_argument_list_opt ;
    public final void member_access2() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2489:3: ( DOT IDENTIFIER type_argument_list_opt )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2489:5: DOT IDENTIFIER type_argument_list_opt
            {
            match(input,DOT,FOLLOW_DOT_in_member_access211111); if (state.failed) return ;

            match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_member_access211113); if (state.failed) return ;

            pushFollow(FOLLOW_type_argument_list_opt_in_member_access211115);
            type_argument_list_opt();

            state._fsp--;
            if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "member_access2"



    // $ANTLR start "method_invocation2"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2491:1: method_invocation2 : OPEN_PARENS ( argument_list )? CLOSE_PARENS ;
    public final void method_invocation2() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2492:3: ( OPEN_PARENS ( argument_list )? CLOSE_PARENS )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2492:5: OPEN_PARENS ( argument_list )? CLOSE_PARENS
            {
            match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_method_invocation211127); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2492:17: ( argument_list )?
            int alt402=2;
            int LA402_0 = input.LA(1);

            if ( (LA402_0==AMP||(LA402_0 >= BANG && LA402_0 <= BASE)||LA402_0==BOOL||LA402_0==BYTE||(LA402_0 >= CHAR && LA402_0 <= CHECKED)||LA402_0==DECIMAL||(LA402_0 >= DEFAULT && LA402_0 <= DELEGATE)||LA402_0==DOUBLE||LA402_0==FALSE||LA402_0==FLOAT||LA402_0==IDENTIFIER||(LA402_0 >= INT && LA402_0 <= INTEGER_LITERAL)||LA402_0==LONG||LA402_0==MINUS||LA402_0==NEW||LA402_0==NULL||LA402_0==OBJECT||LA402_0==OPEN_PARENS||LA402_0==OP_DEC||LA402_0==OP_INC||LA402_0==OUT||LA402_0==PLUS||(LA402_0 >= REAL_LITERAL && LA402_0 <= REF)||LA402_0==SBYTE||LA402_0==SHORT||LA402_0==SIZEOF||LA402_0==STAR||(LA402_0 >= STRING && LA402_0 <= STRING_LITERAL)||LA402_0==THIS||(LA402_0 >= TILDE && LA402_0 <= TRUE)||(LA402_0 >= TYPEOF && LA402_0 <= UNCHECKED)||LA402_0==USHORT) ) {
                alt402=1;
            }
            switch (alt402) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2492:17: argument_list
                    {
                    pushFollow(FOLLOW_argument_list_in_method_invocation211129);
                    argument_list();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_method_invocation211132); if (state.failed) return ;

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "method_invocation2"



    // $ANTLR start "object_creation_expression2"
    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2494:1: object_creation_expression2 : OPEN_PARENS ( argument_list )? CLOSE_PARENS ( object_or_collection_initializer )? ;
    public final void object_creation_expression2() throws RecognitionException {
        try {
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2495:3: ( OPEN_PARENS ( argument_list )? CLOSE_PARENS ( object_or_collection_initializer )? )
            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2495:5: OPEN_PARENS ( argument_list )? CLOSE_PARENS ( object_or_collection_initializer )?
            {
            match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_object_creation_expression211144); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2495:17: ( argument_list )?
            int alt403=2;
            int LA403_0 = input.LA(1);

            if ( (LA403_0==AMP||(LA403_0 >= BANG && LA403_0 <= BASE)||LA403_0==BOOL||LA403_0==BYTE||(LA403_0 >= CHAR && LA403_0 <= CHECKED)||LA403_0==DECIMAL||(LA403_0 >= DEFAULT && LA403_0 <= DELEGATE)||LA403_0==DOUBLE||LA403_0==FALSE||LA403_0==FLOAT||LA403_0==IDENTIFIER||(LA403_0 >= INT && LA403_0 <= INTEGER_LITERAL)||LA403_0==LONG||LA403_0==MINUS||LA403_0==NEW||LA403_0==NULL||LA403_0==OBJECT||LA403_0==OPEN_PARENS||LA403_0==OP_DEC||LA403_0==OP_INC||LA403_0==OUT||LA403_0==PLUS||(LA403_0 >= REAL_LITERAL && LA403_0 <= REF)||LA403_0==SBYTE||LA403_0==SHORT||LA403_0==SIZEOF||LA403_0==STAR||(LA403_0 >= STRING && LA403_0 <= STRING_LITERAL)||LA403_0==THIS||(LA403_0 >= TILDE && LA403_0 <= TRUE)||(LA403_0 >= TYPEOF && LA403_0 <= UNCHECKED)||LA403_0==USHORT) ) {
                alt403=1;
            }
            switch (alt403) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2495:17: argument_list
                    {
                    pushFollow(FOLLOW_argument_list_in_object_creation_expression211146);
                    argument_list();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            match(input,CLOSE_PARENS,FOLLOW_CLOSE_PARENS_in_object_creation_expression211149); if (state.failed) return ;

            // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2495:45: ( object_or_collection_initializer )?
            int alt404=2;
            int LA404_0 = input.LA(1);

            if ( (LA404_0==OPEN_BRACE) ) {
                alt404=1;
            }
            switch (alt404) {
                case 1 :
                    // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2495:45: object_or_collection_initializer
                    {
                    pushFollow(FOLLOW_object_or_collection_initializer_in_object_creation_expression211151);
                    object_or_collection_initializer();

                    state._fsp--;
                    if (state.failed) return ;

                    }
                    break;

            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }

        finally {
        	// do for sure before leaving
        }
        return ;
    }
    // $ANTLR end "object_creation_expression2"

    // $ANTLR start synpred1_CSharp4
    public final void synpred1_CSharp4_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:89:5: ( type_argument_list )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:89:6: type_argument_list
        {
        pushFollow(FOLLOW_type_argument_list_in_synpred1_CSharp4125);
        type_argument_list();

        state._fsp--;
        if (state.failed) return ;

        }

    }
    // $ANTLR end synpred1_CSharp4

    // $ANTLR start synpred2_CSharp4
    public final void synpred2_CSharp4_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:103:7: ( INTERR )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:103:8: INTERR
        {
        match(input,INTERR,FOLLOW_INTERR_in_synpred2_CSharp4161); if (state.failed) return ;

        }

    }
    // $ANTLR end synpred2_CSharp4

    // $ANTLR start synpred3_CSharp4
    public final void synpred3_CSharp4_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:104:7: ( rank_specifier )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:104:8: rank_specifier
        {
        pushFollow(FOLLOW_rank_specifier_in_synpred3_CSharp4175);
        rank_specifier();

        state._fsp--;
        if (state.failed) return ;

        }

    }
    // $ANTLR end synpred3_CSharp4

    // $ANTLR start synpred4_CSharp4
    public final void synpred4_CSharp4_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:161:7: ( rank_specifier )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:161:8: rank_specifier
        {
        pushFollow(FOLLOW_rank_specifier_in_synpred4_CSharp4369);
        rank_specifier();

        state._fsp--;
        if (state.failed) return ;

        }

    }
    // $ANTLR end synpred4_CSharp4

    // $ANTLR start synpred5_CSharp4
    public final void synpred5_CSharp4_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:482:11: ( array_type OPEN_BRACKET )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:482:12: array_type OPEN_BRACKET
        {
        pushFollow(FOLLOW_array_type_in_synpred5_CSharp41445);
        array_type();

        state._fsp--;
        if (state.failed) return ;

        match(input,OPEN_BRACKET,FOLLOW_OPEN_BRACKET_in_synpred5_CSharp41447); if (state.failed) return ;

        }

    }
    // $ANTLR end synpred5_CSharp4

    // $ANTLR start synpred6_CSharp4
    public final void synpred6_CSharp4_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:523:6: ( unbound_type_name )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:523:7: unbound_type_name
        {
        pushFollow(FOLLOW_unbound_type_name_in_synpred6_CSharp41636);
        unbound_type_name();

        state._fsp--;
        if (state.failed) return ;

        }

    }
    // $ANTLR end synpred6_CSharp4

    // $ANTLR start synpred7_CSharp4
    public final void synpred7_CSharp4_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:570:4: ( scan_for_cast_generic_precedence | OPEN_PARENS predefined_type )
        int alt405=2;
        int LA405_0 = input.LA(1);

        if ( (LA405_0==OPEN_PARENS) ) {
            switch ( input.LA(2) ) {
            case BYTE:
            case CHAR:
            case INT:
            case LONG:
            case SBYTE:
            case SHORT:
            case UINT:
            case ULONG:
            case USHORT:
                {
                int LA405_2 = input.LA(3);

                if ( (LA405_2==CLOSE_PARENS||LA405_2==INTERR||LA405_2==OPEN_BRACKET||LA405_2==STAR) ) {
                    alt405=1;
                }
                else if ( (LA405_2==EOF) ) {
                    alt405=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 405, 2, input);

                    throw nvae;

                }
                }
                break;
            case DOUBLE:
            case FLOAT:
                {
                int LA405_3 = input.LA(3);

                if ( (LA405_3==CLOSE_PARENS||LA405_3==INTERR||LA405_3==OPEN_BRACKET||LA405_3==STAR) ) {
                    alt405=1;
                }
                else if ( (LA405_3==EOF) ) {
                    alt405=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 405, 3, input);

                    throw nvae;

                }
                }
                break;
            case DECIMAL:
                {
                int LA405_4 = input.LA(3);

                if ( (LA405_4==CLOSE_PARENS||LA405_4==INTERR||LA405_4==OPEN_BRACKET||LA405_4==STAR) ) {
                    alt405=1;
                }
                else if ( (LA405_4==EOF) ) {
                    alt405=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 405, 4, input);

                    throw nvae;

                }
                }
                break;
            case BOOL:
                {
                int LA405_5 = input.LA(3);

                if ( (LA405_5==CLOSE_PARENS||LA405_5==INTERR||LA405_5==OPEN_BRACKET||LA405_5==STAR) ) {
                    alt405=1;
                }
                else if ( (LA405_5==EOF) ) {
                    alt405=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 405, 5, input);

                    throw nvae;

                }
                }
                break;
            case IDENTIFIER:
            case VOID:
                {
                alt405=1;
                }
                break;
            case OBJECT:
                {
                int LA405_7 = input.LA(3);

                if ( (LA405_7==CLOSE_PARENS||LA405_7==INTERR||LA405_7==OPEN_BRACKET||LA405_7==STAR) ) {
                    alt405=1;
                }
                else if ( (LA405_7==EOF) ) {
                    alt405=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 405, 7, input);

                    throw nvae;

                }
                }
                break;
            case STRING:
                {
                int LA405_8 = input.LA(3);

                if ( (LA405_8==CLOSE_PARENS||LA405_8==INTERR||LA405_8==OPEN_BRACKET||LA405_8==STAR) ) {
                    alt405=1;
                }
                else if ( (LA405_8==EOF) ) {
                    alt405=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 405, 8, input);

                    throw nvae;

                }
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 405, 1, input);

                throw nvae;

            }

        }
        else {
            if (state.backtracking>0) {state.failed=true; return ;}
            NoViableAltException nvae =
                new NoViableAltException("", 405, 0, input);

            throw nvae;

        }
        switch (alt405) {
            case 1 :
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:570:5: scan_for_cast_generic_precedence
                {
                pushFollow(FOLLOW_scan_for_cast_generic_precedence_in_synpred7_CSharp41840);
                scan_for_cast_generic_precedence();

                state._fsp--;
                if (state.failed) return ;

                }
                break;
            case 2 :
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:570:40: OPEN_PARENS predefined_type
                {
                match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_synpred7_CSharp41844); if (state.failed) return ;

                pushFollow(FOLLOW_predefined_type_in_synpred7_CSharp41846);
                predefined_type();

                state._fsp--;
                if (state.failed) return ;

                }
                break;

        }
    }
    // $ANTLR end synpred7_CSharp4

    // $ANTLR start synpred8_CSharp4
    public final void synpred8_CSharp4_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:640:31: ( INTERR is_disambiguation_token )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:640:32: INTERR is_disambiguation_token
        {
        match(input,INTERR,FOLLOW_INTERR_in_synpred8_CSharp42710); if (state.failed) return ;

        pushFollow(FOLLOW_is_disambiguation_token_in_synpred8_CSharp42712);
        is_disambiguation_token();

        state._fsp--;
        if (state.failed) return ;

        }

    }
    // $ANTLR end synpred8_CSharp4

    // $ANTLR start synpred9_CSharp4
    public final void synpred9_CSharp4_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:736:29: ( type IDENTIFIER IN )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:736:30: type IDENTIFIER IN
        {
        pushFollow(FOLLOW_type_in_synpred9_CSharp43170);
        type();

        state._fsp--;
        if (state.failed) return ;

        match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_synpred9_CSharp43172); if (state.failed) return ;

        match(input,IN,FOLLOW_IN_in_synpred9_CSharp43174); if (state.failed) return ;

        }

    }
    // $ANTLR end synpred9_CSharp4

    // $ANTLR start synpred10_CSharp4
    public final void synpred10_CSharp4_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:744:49: ( into_contextual_keyword )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:744:50: into_contextual_keyword
        {
        pushFollow(FOLLOW_into_contextual_keyword_in_synpred10_CSharp43208);
        into_contextual_keyword();

        state._fsp--;
        if (state.failed) return ;

        }

    }
    // $ANTLR end synpred10_CSharp4

    // $ANTLR start synpred11_CSharp4
    public final void synpred11_CSharp4_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:827:4: ( assignment )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:827:5: assignment
        {
        pushFollow(FOLLOW_assignment_in_synpred11_CSharp43617);
        assignment();

        state._fsp--;
        if (state.failed) return ;

        }

    }
    // $ANTLR end synpred11_CSharp4

    // $ANTLR start synpred12_CSharp4
    public final void synpred12_CSharp4_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:831:4: ( lambda_expression )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:831:5: lambda_expression
        {
        pushFollow(FOLLOW_lambda_expression_in_synpred12_CSharp43638);
        lambda_expression();

        state._fsp--;
        if (state.failed) return ;

        }

    }
    // $ANTLR end synpred12_CSharp4

    // $ANTLR start synpred13_CSharp4
    public final void synpred13_CSharp4_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:832:4: ( query_expression )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:832:5: query_expression
        {
        pushFollow(FOLLOW_query_expression_in_synpred13_CSharp43649);
        query_expression();

        state._fsp--;
        if (state.failed) return ;

        }

    }
    // $ANTLR end synpred13_CSharp4

    // $ANTLR start synpred14_CSharp4
    public final void synpred14_CSharp4_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:844:4: ( labeled_statement )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:844:5: labeled_statement
        {
        pushFollow(FOLLOW_labeled_statement_in_synpred14_CSharp43695);
        labeled_statement();

        state._fsp--;
        if (state.failed) return ;

        }

    }
    // $ANTLR end synpred14_CSharp4

    // $ANTLR start synpred15_CSharp4
    public final void synpred15_CSharp4_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:845:4: ( declaration_statement )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:845:5: declaration_statement
        {
        pushFollow(FOLLOW_declaration_statement_in_synpred15_CSharp43706);
        declaration_statement();

        state._fsp--;
        if (state.failed) return ;

        }

    }
    // $ANTLR end synpred15_CSharp4

    // $ANTLR start synpred16_CSharp4
    public final void synpred16_CSharp4_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:944:73: ( ELSE )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:944:74: ELSE
        {
        match(input,ELSE,FOLLOW_ELSE_in_synpred16_CSharp44046); if (state.failed) return ;

        }

    }
    // $ANTLR end synpred16_CSharp4

    // $ANTLR start synpred17_CSharp4
    public final void synpred17_CSharp4_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:981:4: ( local_variable_declaration )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:981:5: local_variable_declaration
        {
        pushFollow(FOLLOW_local_variable_declaration_in_synpred17_CSharp44273);
        local_variable_declaration();

        state._fsp--;
        if (state.failed) return ;

        }

    }
    // $ANTLR end synpred17_CSharp4

    // $ANTLR start synpred18_CSharp4
    public final void synpred18_CSharp4_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1071:4: ( local_variable_declaration )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1071:5: local_variable_declaration
        {
        pushFollow(FOLLOW_local_variable_declaration_in_synpred18_CSharp44666);
        local_variable_declaration();

        state._fsp--;
        if (state.failed) return ;

        }

    }
    // $ANTLR end synpred18_CSharp4

    // $ANTLR start synpred19_CSharp4
    public final void synpred19_CSharp4_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1090:7: ( global_attribute_section )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1090:8: global_attribute_section
        {
        pushFollow(FOLLOW_global_attribute_section_in_synpred19_CSharp44734);
        global_attribute_section();

        state._fsp--;
        if (state.failed) return ;

        }

    }
    // $ANTLR end synpred19_CSharp4

    // $ANTLR start synpred20_CSharp4
    public final void synpred20_CSharp4_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1319:7: ( interface_type DOT THIS )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1319:8: interface_type DOT THIS
        {
        pushFollow(FOLLOW_interface_type_in_synpred20_CSharp45807);
        interface_type();

        state._fsp--;
        if (state.failed) return ;

        match(input,DOT,FOLLOW_DOT_in_synpred20_CSharp45809); if (state.failed) return ;

        match(input,THIS,FOLLOW_THIS_in_synpred20_CSharp45811); if (state.failed) return ;

        }

    }
    // $ANTLR end synpred20_CSharp4

    // $ANTLR start synpred21_CSharp4
    public final void synpred21_CSharp4_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1321:7: ( member_name ( type_parameter_list )? OPEN_PARENS )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1321:8: member_name ( type_parameter_list )? OPEN_PARENS
        {
        pushFollow(FOLLOW_member_name_in_synpred21_CSharp45849);
        member_name();

        state._fsp--;
        if (state.failed) return ;

        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1321:20: ( type_parameter_list )?
        int alt406=2;
        int LA406_0 = input.LA(1);

        if ( (LA406_0==LT) ) {
            alt406=1;
        }
        switch (alt406) {
            case 1 :
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1321:20: type_parameter_list
                {
                pushFollow(FOLLOW_type_parameter_list_in_synpred21_CSharp45851);
                type_parameter_list();

                state._fsp--;
                if (state.failed) return ;

                }
                break;

        }


        match(input,OPEN_PARENS,FOLLOW_OPEN_PARENS_in_synpred21_CSharp45854); if (state.failed) return ;

        }

    }
    // $ANTLR end synpred21_CSharp4

    // $ANTLR start synpred22_CSharp4
    public final void synpred22_CSharp4_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1322:7: ( member_name OPEN_BRACE )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1322:8: member_name OPEN_BRACE
        {
        pushFollow(FOLLOW_member_name_in_synpred22_CSharp45868);
        member_name();

        state._fsp--;
        if (state.failed) return ;

        match(input,OPEN_BRACE,FOLLOW_OPEN_BRACE_in_synpred22_CSharp45870); if (state.failed) return ;

        }

    }
    // $ANTLR end synpred22_CSharp4

    // $ANTLR start synpred23_CSharp4
    public final void synpred23_CSharp4_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1430:5: ( ( attributes )? PARAMS )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1430:6: ( attributes )? PARAMS
        {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1430:6: ( attributes )?
        int alt407=2;
        int LA407_0 = input.LA(1);

        if ( (LA407_0==OPEN_BRACKET) ) {
            alt407=1;
        }
        switch (alt407) {
            case 1 :
                // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1430:6: attributes
                {
                pushFollow(FOLLOW_attributes_in_synpred23_CSharp46208);
                attributes();

                state._fsp--;
                if (state.failed) return ;

                }
                break;

        }


        match(input,PARAMS,FOLLOW_PARAMS_in_synpred23_CSharp46211); if (state.failed) return ;

        }

    }
    // $ANTLR end synpred23_CSharp4

    // $ANTLR start synpred24_CSharp4
    public final void synpred24_CSharp4_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1431:24: ( COMMA parameter_array )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1431:25: COMMA parameter_array
        {
        match(input,COMMA,FOLLOW_COMMA_in_synpred24_CSharp46227); if (state.failed) return ;

        pushFollow(FOLLOW_parameter_array_in_synpred24_CSharp46229);
        parameter_array();

        state._fsp--;
        if (state.failed) return ;

        }

    }
    // $ANTLR end synpred24_CSharp4

    // $ANTLR start synpred25_CSharp4
    public final void synpred25_CSharp4_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1434:22: ( COMMA fixed_parameter )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1434:23: COMMA fixed_parameter
        {
        match(input,COMMA,FOLLOW_COMMA_in_synpred25_CSharp46255); if (state.failed) return ;

        pushFollow(FOLLOW_fixed_parameter_in_synpred25_CSharp46257);
        fixed_parameter();

        state._fsp--;
        if (state.failed) return ;

        }

    }
    // $ANTLR end synpred25_CSharp4

    // $ANTLR start synpred26_CSharp4
    public final void synpred26_CSharp4_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1596:5: ( unary_operator_declarator )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:1596:6: unary_operator_declarator
        {
        pushFollow(FOLLOW_unary_operator_declarator_in_synpred26_CSharp47020);
        unary_operator_declarator();

        state._fsp--;
        if (state.failed) return ;

        }

    }
    // $ANTLR end synpred26_CSharp4

    // $ANTLR start synpred27_CSharp4
    public final void synpred27_CSharp4_fragment() throws RecognitionException {
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2229:5: ( AMP )
        // E:\\GitHub\\CesTa\\src\\org\\cesta\\grammars\\csharp\\CSharp4.g:2229:6: AMP
        {
        match(input,AMP,FOLLOW_AMP_in_synpred27_CSharp49688); if (state.failed) return ;

        }

    }
    // $ANTLR end synpred27_CSharp4

    // Delegated rules

    public final boolean synpred19_CSharp4() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred19_CSharp4_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred15_CSharp4() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred15_CSharp4_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred20_CSharp4() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred20_CSharp4_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred25_CSharp4() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred25_CSharp4_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred21_CSharp4() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred21_CSharp4_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred24_CSharp4() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred24_CSharp4_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred5_CSharp4() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred5_CSharp4_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred10_CSharp4() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred10_CSharp4_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred18_CSharp4() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred18_CSharp4_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred12_CSharp4() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred12_CSharp4_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred13_CSharp4() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred13_CSharp4_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred1_CSharp4() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred1_CSharp4_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred26_CSharp4() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred26_CSharp4_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred4_CSharp4() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred4_CSharp4_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred23_CSharp4() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred23_CSharp4_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred2_CSharp4() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred2_CSharp4_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred27_CSharp4() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred27_CSharp4_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred6_CSharp4() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred6_CSharp4_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred22_CSharp4() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred22_CSharp4_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred7_CSharp4() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred7_CSharp4_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred3_CSharp4() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred3_CSharp4_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred17_CSharp4() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred17_CSharp4_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred11_CSharp4() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred11_CSharp4_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred16_CSharp4() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred16_CSharp4_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred9_CSharp4() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred9_CSharp4_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred14_CSharp4() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred14_CSharp4_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred8_CSharp4() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred8_CSharp4_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }


    protected DFA11 dfa11 = new DFA11(this);
    protected DFA47 dfa47 = new DFA47(this);
    protected DFA56 dfa56 = new DFA56(this);
    protected DFA400 dfa400 = new DFA400(this);
    static final String DFA11_eotS =
        "\10\uffff";
    static final String DFA11_eofS =
        "\4\uffff\1\6\3\uffff";
    static final String DFA11_minS =
        "\2\122\2\31\1\122\1\31\2\uffff";
    static final String DFA11_maxS =
        "\2\u00b1\2\34\1\u00b1\1\34\2\uffff";
    static final String DFA11_acceptS =
        "\6\uffff\1\2\1\1";
    static final String DFA11_specialS =
        "\10\uffff}>";
    static final String[] DFA11_transitionS = {
            "\1\1\27\uffff\1\2\106\uffff\1\1",
            "\1\1\27\uffff\1\2\106\uffff\1\1",
            "\1\4\2\uffff\1\3",
            "\1\4\2\uffff\1\5",
            "\1\7\27\uffff\1\7\106\uffff\1\7",
            "\1\4\2\uffff\1\5",
            "",
            ""
    };

    static final short[] DFA11_eot = DFA.unpackEncodedString(DFA11_eotS);
    static final short[] DFA11_eof = DFA.unpackEncodedString(DFA11_eofS);
    static final char[] DFA11_min = DFA.unpackEncodedStringToUnsignedChars(DFA11_minS);
    static final char[] DFA11_max = DFA.unpackEncodedStringToUnsignedChars(DFA11_maxS);
    static final short[] DFA11_accept = DFA.unpackEncodedString(DFA11_acceptS);
    static final short[] DFA11_special = DFA.unpackEncodedString(DFA11_specialS);
    static final short[][] DFA11_transition;

    static {
        int numStates = DFA11_transitionS.length;
        DFA11_transition = new short[numStates][];
        for (int i=0; i<numStates; i++) {
            DFA11_transition[i] = DFA.unpackEncodedString(DFA11_transitionS[i]);
        }
    }

    class DFA11 extends DFA {

        public DFA11(BaseRecognizer recognizer) {
            this.recognizer = recognizer;
            this.decisionNumber = 11;
            this.eot = DFA11_eot;
            this.eof = DFA11_eof;
            this.min = DFA11_min;
            this.max = DFA11_max;
            this.accept = DFA11_accept;
            this.special = DFA11_special;
            this.transition = DFA11_transition;
        }
        public String getDescription() {
            return "()* loopback of 183:5: ( ( STAR | INTERR )* rank_specifier )*";
        }
    }
    static final String DFA47_eotS =
        "\25\uffff";
    static final String DFA47_eofS =
        "\25\uffff";
    static final String DFA47_minS =
        "\1\16\1\32\1\uffff\1\32\1\112\1\16\1\112\1\0\1\uffff\1\32\2\uffff"+
        "\1\32\1\16\1\0\1\16\1\0\4\uffff";
    static final String DFA47_maxS =
        "\1\u00d8\1\u00b1\1\uffff\1\u00b1\1\112\1\u00d8\1\112\1\0\1\uffff"+
        "\1\u00b1\2\uffff\1\u00b1\1\u00d8\1\0\1\u00d8\1\0\4\uffff";
    static final String DFA47_acceptS =
        "\2\uffff\1\2\5\uffff\1\3\1\uffff\2\1\5\uffff\4\1";
    static final String DFA47_specialS =
        "\5\uffff\1\5\1\uffff\1\0\5\uffff\1\4\1\2\1\3\1\1\4\uffff}>";
    static final String[] DFA47_transitionS = {
            "\1\2\1\uffff\1\2\3\uffff\1\2\16\uffff\1\2\10\uffff\1\2\20\uffff"+
            "\1\2\14\uffff\1\1\3\uffff\1\2\14\uffff\1\2\14\uffff\1\2\77\uffff"+
            "\1\2\3\uffff\1\2\6\uffff\1\2\20\uffff\2\2\16\uffff\1\2\3\uffff"+
            "\1\3",
            "\1\7\20\uffff\1\6\2\uffff\1\4\43\uffff\1\2\11\uffff\1\5\15"+
            "\uffff\1\2\106\uffff\1\2",
            "",
            "\1\10\u0096\uffff\1\2",
            "\1\11",
            "\1\2\1\uffff\1\2\3\uffff\1\2\7\uffff\1\12\6\uffff\1\2\10\uffff"+
            "\1\2\20\uffff\1\2\7\uffff\1\13\4\uffff\1\2\3\uffff\1\2\14\uffff"+
            "\1\2\14\uffff\1\2\77\uffff\1\2\3\uffff\1\2\6\uffff\1\2\20\uffff"+
            "\2\2\16\uffff\1\2\3\uffff\1\2",
            "\1\14",
            "\1\uffff",
            "",
            "\1\16\20\uffff\1\6\46\uffff\1\2\11\uffff\1\15\15\uffff\1\2"+
            "\106\uffff\1\2",
            "",
            "",
            "\1\20\20\uffff\1\6\46\uffff\1\2\11\uffff\1\17\15\uffff\1\2"+
            "\106\uffff\1\2",
            "\1\2\1\uffff\1\2\3\uffff\1\2\7\uffff\1\21\6\uffff\1\2\10\uffff"+
            "\1\2\20\uffff\1\2\7\uffff\1\22\4\uffff\1\2\3\uffff\1\2\14\uffff"+
            "\1\2\14\uffff\1\2\77\uffff\1\2\3\uffff\1\2\6\uffff\1\2\20\uffff"+
            "\2\2\16\uffff\1\2\3\uffff\1\2",
            "\1\uffff",
            "\1\2\1\uffff\1\2\3\uffff\1\2\7\uffff\1\23\6\uffff\1\2\10\uffff"+
            "\1\2\20\uffff\1\2\7\uffff\1\24\4\uffff\1\2\3\uffff\1\2\14\uffff"+
            "\1\2\14\uffff\1\2\77\uffff\1\2\3\uffff\1\2\6\uffff\1\2\20\uffff"+
            "\2\2\16\uffff\1\2\3\uffff\1\2",
            "\1\uffff",
            "",
            "",
            "",
            ""
    };

    static final short[] DFA47_eot = DFA.unpackEncodedString(DFA47_eotS);
    static final short[] DFA47_eof = DFA.unpackEncodedString(DFA47_eofS);
    static final char[] DFA47_min = DFA.unpackEncodedStringToUnsignedChars(DFA47_minS);
    static final char[] DFA47_max = DFA.unpackEncodedStringToUnsignedChars(DFA47_maxS);
    static final short[] DFA47_accept = DFA.unpackEncodedString(DFA47_acceptS);
    static final short[] DFA47_special = DFA.unpackEncodedString(DFA47_specialS);
    static final short[][] DFA47_transition;

    static {
        int numStates = DFA47_transitionS.length;
        DFA47_transition = new short[numStates][];
        for (int i=0; i<numStates; i++) {
            DFA47_transition[i] = DFA.unpackEncodedString(DFA47_transitionS[i]);
        }
    }

    class DFA47 extends DFA {

        public DFA47(BaseRecognizer recognizer) {
            this.recognizer = recognizer;
            this.decisionNumber = 47;
            this.eot = DFA47_eot;
            this.eof = DFA47_eof;
            this.min = DFA47_min;
            this.max = DFA47_max;
            this.accept = DFA47_accept;
            this.special = DFA47_special;
            this.transition = DFA47_transition;
        }
        public String getDescription() {
            return "523:4: ( ( unbound_type_name )=> unbound_type_name CLOSE_PARENS | type CLOSE_PARENS | VOID CLOSE_PARENS )";
        }
        public int specialStateTransition(int s, IntStream _input) throws NoViableAltException {
            TokenStream input = (TokenStream)_input;
        	int _s = s;
            switch ( s ) {
                    case 0 : 
                        int LA47_7 = input.LA(1);

                         
                        int index47_7 = input.index();
                        input.rewind();

                        s = -1;
                        if ( (synpred6_CSharp4()) ) {s = 11;}

                        else if ( (true) ) {s = 2;}

                         
                        input.seek(index47_7);

                        if ( s>=0 ) return s;
                        break;

                    case 1 : 
                        int LA47_16 = input.LA(1);

                         
                        int index47_16 = input.index();
                        input.rewind();

                        s = -1;
                        if ( (synpred6_CSharp4()) ) {s = 20;}

                        else if ( (true) ) {s = 2;}

                         
                        input.seek(index47_16);

                        if ( s>=0 ) return s;
                        break;

                    case 2 : 
                        int LA47_14 = input.LA(1);

                         
                        int index47_14 = input.index();
                        input.rewind();

                        s = -1;
                        if ( (synpred6_CSharp4()) ) {s = 18;}

                        else if ( (true) ) {s = 2;}

                         
                        input.seek(index47_14);

                        if ( s>=0 ) return s;
                        break;

                    case 3 : 
                        int LA47_15 = input.LA(1);

                         
                        int index47_15 = input.index();
                        input.rewind();

                        s = -1;
                        if ( (LA47_15==COMMA) && (synpred6_CSharp4())) {s = 19;}

                        else if ( (LA47_15==GT) && (synpred6_CSharp4())) {s = 20;}

                        else if ( (LA47_15==BOOL||LA47_15==BYTE||LA47_15==CHAR||LA47_15==DECIMAL||LA47_15==DOUBLE||LA47_15==FLOAT||LA47_15==IDENTIFIER||LA47_15==INT||LA47_15==LONG||LA47_15==OBJECT||LA47_15==SBYTE||LA47_15==SHORT||LA47_15==STRING||(LA47_15 >= UINT && LA47_15 <= ULONG)||LA47_15==USHORT||LA47_15==VOID) ) {s = 2;}

                         
                        input.seek(index47_15);

                        if ( s>=0 ) return s;
                        break;

                    case 4 : 
                        int LA47_13 = input.LA(1);

                         
                        int index47_13 = input.index();
                        input.rewind();

                        s = -1;
                        if ( (LA47_13==BOOL||LA47_13==BYTE||LA47_13==CHAR||LA47_13==DECIMAL||LA47_13==DOUBLE||LA47_13==FLOAT||LA47_13==IDENTIFIER||LA47_13==INT||LA47_13==LONG||LA47_13==OBJECT||LA47_13==SBYTE||LA47_13==SHORT||LA47_13==STRING||(LA47_13 >= UINT && LA47_13 <= ULONG)||LA47_13==USHORT||LA47_13==VOID) ) {s = 2;}

                        else if ( (LA47_13==COMMA) && (synpred6_CSharp4())) {s = 17;}

                        else if ( (LA47_13==GT) && (synpred6_CSharp4())) {s = 18;}

                         
                        input.seek(index47_13);

                        if ( s>=0 ) return s;
                        break;

                    case 5 : 
                        int LA47_5 = input.LA(1);

                         
                        int index47_5 = input.index();
                        input.rewind();

                        s = -1;
                        if ( (LA47_5==COMMA) && (synpred6_CSharp4())) {s = 10;}

                        else if ( (LA47_5==GT) && (synpred6_CSharp4())) {s = 11;}

                        else if ( (LA47_5==BOOL||LA47_5==BYTE||LA47_5==CHAR||LA47_5==DECIMAL||LA47_5==DOUBLE||LA47_5==FLOAT||LA47_5==IDENTIFIER||LA47_5==INT||LA47_5==LONG||LA47_5==OBJECT||LA47_5==SBYTE||LA47_5==SHORT||LA47_5==STRING||(LA47_5 >= UINT && LA47_5 <= ULONG)||LA47_5==USHORT||LA47_5==VOID) ) {s = 2;}

                         
                        input.seek(index47_5);

                        if ( s>=0 ) return s;
                        break;
            }
            if (state.backtracking>0) {state.failed=true; return -1;}

            NoViableAltException nvae =
                new NoViableAltException(getDescription(), 47, _s, input);
            error(nvae);
            throw nvae;
        }

    }
    static final String DFA56_eotS =
        "\116\uffff";
    static final String DFA56_eofS =
        "\116\uffff";
    static final String DFA56_minS =
        "\1\4\115\uffff";
    static final String DFA56_maxS =
        "\1\u00dc\115\uffff";
    static final String DFA56_acceptS =
        "\1\uffff\1\1\1\2\1\3\1\4\1\5\1\6\1\7\1\10\1\11\1\12\1\13\1\14\1"+
        "\15\1\16\1\17\1\20\1\21\1\22\1\23\1\24\1\25\1\26\1\27\1\30\1\31"+
        "\1\32\1\33\1\34\1\35\1\36\1\37\1\40\1\41\1\42\1\43\1\44\1\45\1\46"+
        "\1\47\1\50\1\51\1\52\1\53\1\54\1\55\1\56\1\57\1\60\1\61\1\62\1\63"+
        "\1\64\1\65\1\66\1\67\1\70\1\71\1\72\1\73\1\74\1\75\1\76\1\77\1\100"+
        "\1\101\1\102\1\103\1\104\1\105\1\106\1\107\1\110\1\111\1\112\1\113"+
        "\1\114\1\115";
    static final String DFA56_specialS =
        "\116\uffff}>";
    static final String[] DFA56_transitionS = {
            "\1\6\6\uffff\1\2\1\7\1\uffff\1\10\1\11\1\12\1\uffff\1\13\1\14"+
            "\1\15\1\5\1\16\1\17\5\uffff\1\20\1\21\4\uffff\1\22\1\uffff\1"+
            "\23\1\24\3\uffff\1\25\1\uffff\1\26\7\uffff\1\27\1\30\1\31\1"+
            "\32\1\33\1\uffff\1\5\1\34\1\35\1\36\1\37\1\40\4\uffff\1\41\5"+
            "\uffff\1\4\1\42\1\43\1\44\1\45\1\5\1\46\1\47\10\uffff\1\50\1"+
            "\51\5\uffff\1\52\1\53\2\uffff\1\5\2\uffff\1\54\2\uffff\1\3\1"+
            "\55\24\uffff\1\56\1\57\1\60\2\uffff\1\61\1\62\1\63\30\uffff"+
            "\1\64\1\5\1\65\1\66\3\uffff\1\67\1\70\2\uffff\1\71\2\uffff\1"+
            "\72\1\73\1\uffff\1\74\1\75\1\5\1\76\1\77\7\uffff\1\100\1\101"+
            "\1\1\1\5\1\102\1\103\1\104\1\105\1\106\14\uffff\1\107\1\110"+
            "\1\111\1\uffff\1\112\1\113\1\114\2\uffff\1\115",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
    };

    static final short[] DFA56_eot = DFA.unpackEncodedString(DFA56_eotS);
    static final short[] DFA56_eof = DFA.unpackEncodedString(DFA56_eofS);
    static final char[] DFA56_min = DFA.unpackEncodedStringToUnsignedChars(DFA56_minS);
    static final char[] DFA56_max = DFA.unpackEncodedStringToUnsignedChars(DFA56_maxS);
    static final short[] DFA56_accept = DFA.unpackEncodedString(DFA56_acceptS);
    static final short[] DFA56_special = DFA.unpackEncodedString(DFA56_specialS);
    static final short[][] DFA56_transition;

    static {
        int numStates = DFA56_transitionS.length;
        DFA56_transition = new short[numStates][];
        for (int i=0; i<numStates; i++) {
            DFA56_transition[i] = DFA.unpackEncodedString(DFA56_transitionS[i]);
        }
    }

    class DFA56 extends DFA {

        public DFA56(BaseRecognizer recognizer) {
            this.recognizer = recognizer;
            this.decisionNumber = 56;
            this.eot = DFA56_eot;
            this.eof = DFA56_eof;
            this.min = DFA56_min;
            this.max = DFA56_max;
            this.accept = DFA56_accept;
            this.special = DFA56_special;
            this.transition = DFA56_transition;
        }
        public String getDescription() {
            return "590:5: ( TILDE | BANG | OPEN_PARENS | IDENTIFIER | literal | ABSTRACT | BASE | BOOL | BREAK | BYTE | CASE | CATCH | CHAR | CHECKED | CLASS | CONST | CONTINUE | DECIMAL | DEFAULT | DELEGATE | DO | DOUBLE | ELSE | ENUM | EVENT | EXPLICIT | EXTERN | FINALLY | FIXED | FLOAT | FOR | FOREACH | GOTO | IF | IMPLICIT | IN | INT | INTERFACE | INTERNAL | LOCK | LONG | NAMESPACE | NEW | OBJECT | OPERATOR | OUT | OVERRIDE | PARAMS | PRIVATE | PROTECTED | PUBLIC | READONLY | REF | RETURN | SBYTE | SEALED | SHORT | SIZEOF | STACKALLOC | STATIC | STRING | STRUCT | SWITCH | THIS | THROW | TRY | TYPEOF | UINT | ULONG | UNCHECKED | UNSAFE | USHORT | USING | VIRTUAL | VOID | VOLATILE | WHILE )";
        }
    }
    static final String DFA400_eotS =
        "\10\uffff";
    static final String DFA400_eofS =
        "\10\uffff";
    static final String DFA400_minS =
        "\1\53\1\16\2\uffff\1\34\1\16\1\53\1\34";
    static final String DFA400_maxS =
        "\1\153\1\u00d8\2\uffff\1\u00b1\1\u00d8\1\153\1\u00b1";
    static final String DFA400_acceptS =
        "\2\uffff\1\2\1\1\4\uffff";
    static final String DFA400_specialS =
        "\10\uffff}>";
    static final String[] DFA400_transitionS = {
            "\1\3\60\uffff\1\1\16\uffff\1\2",
            "\1\3\1\uffff\1\3\3\uffff\1\3\16\uffff\1\3\10\uffff\1\3\20\uffff"+
            "\1\3\14\uffff\1\4\3\uffff\1\3\14\uffff\1\3\14\uffff\1\3\1\uffff"+
            "\1\2\75\uffff\1\3\3\uffff\1\3\6\uffff\1\3\20\uffff\2\3\16\uffff"+
            "\1\3\3\uffff\1\3",
            "",
            "",
            "\1\5\16\uffff\1\3\2\uffff\1\3\26\uffff\1\6\14\uffff\1\3\11"+
            "\uffff\1\3\15\uffff\1\3\106\uffff\1\3",
            "\1\3\1\uffff\1\3\3\uffff\1\3\16\uffff\1\3\10\uffff\1\3\20\uffff"+
            "\1\3\14\uffff\1\7\3\uffff\1\3\14\uffff\1\3\14\uffff\1\3\1\uffff"+
            "\1\2\75\uffff\1\3\3\uffff\1\3\6\uffff\1\3\20\uffff\2\3\16\uffff"+
            "\1\3\3\uffff\1\3",
            "\1\3\77\uffff\1\2",
            "\1\5\16\uffff\1\3\2\uffff\1\3\26\uffff\1\6\14\uffff\1\3\11"+
            "\uffff\1\3\15\uffff\1\3\106\uffff\1\3"
    };

    static final short[] DFA400_eot = DFA.unpackEncodedString(DFA400_eotS);
    static final short[] DFA400_eof = DFA.unpackEncodedString(DFA400_eofS);
    static final char[] DFA400_min = DFA.unpackEncodedStringToUnsignedChars(DFA400_minS);
    static final char[] DFA400_max = DFA.unpackEncodedStringToUnsignedChars(DFA400_maxS);
    static final short[] DFA400_accept = DFA.unpackEncodedString(DFA400_acceptS);
    static final short[] DFA400_special = DFA.unpackEncodedString(DFA400_specialS);
    static final short[][] DFA400_transition;

    static {
        int numStates = DFA400_transitionS.length;
        DFA400_transition = new short[numStates][];
        for (int i=0; i<numStates; i++) {
            DFA400_transition[i] = DFA.unpackEncodedString(DFA400_transitionS[i]);
        }
    }

    class DFA400 extends DFA {

        public DFA400(BaseRecognizer recognizer) {
            this.recognizer = recognizer;
            this.decisionNumber = 400;
            this.eot = DFA400_eot;
            this.eof = DFA400_eof;
            this.min = DFA400_min;
            this.max = DFA400_max;
            this.accept = DFA400_accept;
            this.special = DFA400_special;
            this.transition = DFA400_transition;
        }
        public String getDescription() {
            return "()* loopback of 2470:7: ( type_argument_list_opt DOT IDENTIFIER )*";
        }
    }
 

    public static final BitSet FOLLOW_namespace_or_type_name_in_namespace_name56 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_namespace_or_type_name_in_type_name67 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_namespace_or_type_name83 = new BitSet(new long[]{0x0000080000000000L,0x0000000010000000L});
    public static final BitSet FOLLOW_type_argument_list_opt_in_namespace_or_type_name85 = new BitSet(new long[]{0x0000080000000002L});
    public static final BitSet FOLLOW_qualified_alias_member_in_namespace_or_type_name93 = new BitSet(new long[]{0x0000080000000002L});
    public static final BitSet FOLLOW_DOT_in_namespace_or_type_name102 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_namespace_or_type_name104 = new BitSet(new long[]{0x0000080000000000L,0x0000000010000000L});
    public static final BitSet FOLLOW_type_argument_list_opt_in_namespace_or_type_name106 = new BitSet(new long[]{0x0000080000000002L});
    public static final BitSet FOLLOW_type_argument_list_in_type_argument_list_opt130 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_base_type_in_type152 = new BitSet(new long[]{0x0000000000000002L,0x0000040000040000L,0x0002000000000000L});
    public static final BitSet FOLLOW_INTERR_in_type166 = new BitSet(new long[]{0x0000000000000002L,0x0000040000040000L,0x0002000000000000L});
    public static final BitSet FOLLOW_rank_specifier_in_type180 = new BitSet(new long[]{0x0000000000000002L,0x0000040000040000L,0x0002000000000000L});
    public static final BitSet FOLLOW_STAR_in_type188 = new BitSet(new long[]{0x0000000000000002L,0x0000040000040000L,0x0002000000000000L});
    public static final BitSet FOLLOW_simple_type_in_base_type208 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_class_type_in_base_type214 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_VOID_in_base_type222 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0002000000000000L});
    public static final BitSet FOLLOW_STAR_in_base_type224 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_numeric_type_in_simple_type240 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_BOOL_in_simple_type245 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_integral_type_in_numeric_type256 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_floating_point_type_in_numeric_type261 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_DECIMAL_in_numeric_type266 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_non_nullable_value_type_in_nullable_type344 = new BitSet(new long[]{0x0000000000000000L,0x0000000000040000L});
    public static final BitSet FOLLOW_INTERR_in_nullable_type346 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_base_type_in_non_nullable_value_type360 = new BitSet(new long[]{0x0000000000000002L,0x0000040000000000L,0x0002000000000000L});
    public static final BitSet FOLLOW_rank_specifier_in_non_nullable_value_type374 = new BitSet(new long[]{0x0000000000000002L,0x0000040000000000L,0x0002000000000000L});
    public static final BitSet FOLLOW_STAR_in_non_nullable_value_type382 = new BitSet(new long[]{0x0000000000000002L,0x0000040000000000L,0x0002000000000000L});
    public static final BitSet FOLLOW_simple_type_in_reference_type412 = new BitSet(new long[]{0x0000000000000000L,0x0000040000040000L,0x0002000000000000L});
    public static final BitSet FOLLOW_class_type_in_reference_type422 = new BitSet(new long[]{0x0000000000000000L,0x0000040000040000L,0x0002000000000000L});
    public static final BitSet FOLLOW_VOID_in_reference_type430 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0002000000000000L});
    public static final BitSet FOLLOW_STAR_in_reference_type432 = new BitSet(new long[]{0x0000000000000000L,0x0000040000040000L,0x0002000000000000L});
    public static final BitSet FOLLOW_rank_specifier_in_reference_type450 = new BitSet(new long[]{0x0000000000000000L,0x0000040000040000L,0x0002000000000000L});
    public static final BitSet FOLLOW_rank_specifier_in_reference_type470 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_type_name_in_class_type485 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OBJECT_in_class_type490 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_dynamic_contextual_keyword_in_class_type495 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STRING_in_class_type500 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_type_name_in_interface_type513 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_type_name_in_delegate_type526 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_LT_in_type_argument_list537 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_type_arguments_in_type_argument_list539 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000020L});
    public static final BitSet FOLLOW_GT_in_type_argument_list541 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_type_argument_in_type_arguments552 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_type_arguments556 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_type_argument_in_type_arguments558 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_type_in_type_argument571 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_expression_in_variable_reference586 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_argument_in_argument_list599 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_argument_list603 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910C00000022L,0x000000000010007BL});
    public static final BitSet FOLLOW_argument_in_argument_list605 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_argument_name_in_argument617 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910C00000022L,0x000000000010007BL});
    public static final BitSet FOLLOW_argument_value_in_argument620 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_argument_name631 = new BitSet(new long[]{0x0000000008000000L});
    public static final BitSet FOLLOW_COLON_in_argument_name633 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_expression_in_argument_value644 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_REF_in_argument_value649 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_variable_reference_in_argument_value651 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OUT_in_argument_value656 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_variable_reference_in_argument_value658 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_primary_expression_start_in_primary_expression674 = new BitSet(new long[]{0x0000080000000002L,0x40220C0000000000L});
    public static final BitSet FOLLOW_bracket_expression_in_primary_expression677 = new BitSet(new long[]{0x0000080000000002L,0x40220C0000000000L});
    public static final BitSet FOLLOW_member_access2_in_primary_expression692 = new BitSet(new long[]{0x0000080000000002L,0x40220C0000000000L});
    public static final BitSet FOLLOW_method_invocation2_in_primary_expression702 = new BitSet(new long[]{0x0000080000000002L,0x40220C0000000000L});
    public static final BitSet FOLLOW_OP_INC_in_primary_expression712 = new BitSet(new long[]{0x0000080000000002L,0x40220C0000000000L});
    public static final BitSet FOLLOW_OP_DEC_in_primary_expression722 = new BitSet(new long[]{0x0000080000000002L,0x40220C0000000000L});
    public static final BitSet FOLLOW_OP_PTR_in_primary_expression732 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_primary_expression734 = new BitSet(new long[]{0x0000080000000002L,0x40220C0000000000L});
    public static final BitSet FOLLOW_bracket_expression_in_primary_expression751 = new BitSet(new long[]{0x0000080000000002L,0x40220C0000000000L});
    public static final BitSet FOLLOW_literal_in_primary_expression_start769 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_simple_name_in_primary_expression_start775 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_parenthesized_expression_in_primary_expression_start781 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_predefined_type_in_primary_expression_start787 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_qualified_alias_member_in_primary_expression_start794 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_this_access_in_primary_expression_start802 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_base_access_in_primary_expression_start808 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_NEW_in_primary_expression_start814 = new BitSet(new long[]{0x2000100800114000L,0x0000070008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_type_in_primary_expression_start818 = new BitSet(new long[]{0x0000000000000000L,0x00000E0000000000L});
    public static final BitSet FOLLOW_object_creation_expression2_in_primary_expression_start822 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_object_or_collection_initializer_in_primary_expression_start841 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_BRACKET_in_primary_expression_start860 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_expression_list_in_primary_expression_start862 = new BitSet(new long[]{0x0000000002000000L});
    public static final BitSet FOLLOW_CLOSE_BRACKET_in_primary_expression_start864 = new BitSet(new long[]{0x0000000000000002L,0x0000060000000000L});
    public static final BitSet FOLLOW_rank_specifiers_in_primary_expression_start866 = new BitSet(new long[]{0x0000000000000002L,0x0000020000000000L});
    public static final BitSet FOLLOW_array_initializer_in_primary_expression_start869 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_rank_specifiers_in_primary_expression_start889 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_array_initializer_in_primary_expression_start891 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_anonymous_object_initializer_in_primary_expression_start920 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_rank_specifier_in_primary_expression_start932 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_array_initializer_in_primary_expression_start934 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_typeof_expression_in_primary_expression_start950 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_checked_expression_in_primary_expression_start956 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_unchecked_expression_in_primary_expression_start962 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_default_value_expression_in_primary_expression_start968 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_anonymous_method_expression_in_primary_expression_start974 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_sizeof_expression_in_primary_expression_start980 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_BRACKET_in_bracket_expression994 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_expression_list_in_bracket_expression996 = new BitSet(new long[]{0x0000000002000000L});
    public static final BitSet FOLLOW_CLOSE_BRACKET_in_bracket_expression998 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_simple_name1016 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
    public static final BitSet FOLLOW_type_argument_list_opt_in_simple_name1018 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_parenthesized_expression1031 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_expression_in_parenthesized_expression1033 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_parenthesized_expression1035 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_primary_expression_in_member_access1051 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_expression_in_expression_list1150 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_expression_list1154 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_expression_in_expression_list1156 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_THIS_in_this_access1169 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_BASE_in_base_access1181 = new BitSet(new long[]{0x0000080000000000L});
    public static final BitSet FOLLOW_DOT_in_base_access1183 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_base_access1185 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
    public static final BitSet FOLLOW_type_argument_list_opt_in_base_access1187 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_BASE_in_base_access1192 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_OPEN_BRACKET_in_base_access1194 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_expression_list_in_base_access1196 = new BitSet(new long[]{0x0000000002000000L});
    public static final BitSet FOLLOW_CLOSE_BRACKET_in_base_access1198 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_NEW_in_object_creation_expression1216 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_type_in_object_creation_expression1218 = new BitSet(new long[]{0x0000000000000000L,0x00000A0000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_object_creation_expression1222 = new BitSet(new long[]{0x2400106804715820L,0x002209250800C400L,0x401A910C00000022L,0x000000000010007BL});
    public static final BitSet FOLLOW_argument_list_in_object_creation_expression1224 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_object_creation_expression1227 = new BitSet(new long[]{0x0000000000000002L,0x0000020000000000L});
    public static final BitSet FOLLOW_object_or_collection_initializer_in_object_creation_expression1229 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_object_or_collection_initializer_in_object_creation_expression1247 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_object_initializer_in_object_or_collection_initializer1276 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_collection_initializer_in_object_or_collection_initializer1281 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_object_initializer1297 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_object_initializer1299 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_object_initializer1305 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_member_initializer_list_in_object_initializer1307 = new BitSet(new long[]{0x0000000011000000L});
    public static final BitSet FOLLOW_COMMA_in_object_initializer1309 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_object_initializer1312 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_member_initializer_in_member_initializer_list1324 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_member_initializer_list1328 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_member_initializer_in_member_initializer_list1330 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_member_initializer1343 = new BitSet(new long[]{0x0000000000000080L});
    public static final BitSet FOLLOW_ASSIGNMENT_in_member_initializer1345 = new BitSet(new long[]{0x2400106800715820L,0x00220B250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_initializer_value_in_member_initializer1347 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_expression_in_initializer_value1358 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_object_or_collection_initializer_in_initializer_value1363 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_collection_initializer1379 = new BitSet(new long[]{0x2400106800715820L,0x00220B250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_element_initializer_list_in_collection_initializer1381 = new BitSet(new long[]{0x0000000011000000L});
    public static final BitSet FOLLOW_COMMA_in_collection_initializer1383 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_collection_initializer1386 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_element_initializer_in_element_initializer_list1398 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_element_initializer_list1402 = new BitSet(new long[]{0x2400106800715820L,0x00220B250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_element_initializer_in_element_initializer_list1404 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_non_assignment_expression_in_element_initializer1417 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_element_initializer1422 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_expression_list_in_element_initializer1424 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_element_initializer1426 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_NEW_in_array_creation_expression1440 = new BitSet(new long[]{0x2000100800114000L,0x0000050008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_array_type_in_array_creation_expression1452 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_array_initializer_in_array_creation_expression1454 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_non_array_type_in_array_creation_expression1466 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_OPEN_BRACKET_in_array_creation_expression1468 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_expression_list_in_array_creation_expression1470 = new BitSet(new long[]{0x0000000002000000L});
    public static final BitSet FOLLOW_CLOSE_BRACKET_in_array_creation_expression1472 = new BitSet(new long[]{0x0000000000000002L,0x0000060000000000L});
    public static final BitSet FOLLOW_rank_specifiers_in_array_creation_expression1474 = new BitSet(new long[]{0x0000000000000002L,0x0000020000000000L});
    public static final BitSet FOLLOW_array_initializer_in_array_creation_expression1477 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_rank_specifier_in_array_creation_expression1490 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_array_initializer_in_array_creation_expression1492 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_NEW_in_delegate_creation_expression1516 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_delegate_type_in_delegate_creation_expression1518 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_delegate_creation_expression1520 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_expression_in_delegate_creation_expression1522 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_delegate_creation_expression1524 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_NEW_in_anonymous_object_creation_expression1537 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_anonymous_object_initializer_in_anonymous_object_creation_expression1539 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_anonymous_object_initializer1555 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_anonymous_object_initializer1557 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_anonymous_object_initializer1563 = new BitSet(new long[]{0x2400106800715000L,0x000009240800C400L,0x4018910400000000L,0x000000000010007AL});
    public static final BitSet FOLLOW_member_declarator_list_in_anonymous_object_initializer1565 = new BitSet(new long[]{0x0000000011000000L});
    public static final BitSet FOLLOW_COMMA_in_anonymous_object_initializer1567 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_anonymous_object_initializer1570 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_member_declarator_in_member_declarator_list1582 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_member_declarator_list1586 = new BitSet(new long[]{0x2400106800715000L,0x000009240800C400L,0x4018910400000000L,0x000000000010007AL});
    public static final BitSet FOLLOW_member_declarator_in_member_declarator_list1588 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_primary_expression_in_member_declarator1604 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_member_declarator1610 = new BitSet(new long[]{0x0000000000000080L});
    public static final BitSet FOLLOW_ASSIGNMENT_in_member_declarator1612 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_expression_in_member_declarator1614 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_TYPEOF_in_typeof_expression1626 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_typeof_expression1628 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_unbound_type_name_in_typeof_expression1641 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_typeof_expression1643 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_type_in_typeof_expression1650 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_typeof_expression1652 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_VOID_in_typeof_expression1659 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_typeof_expression1661 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_unbound_type_name1680 = new BitSet(new long[]{0x0000480000000002L,0x0000000010000000L});
    public static final BitSet FOLLOW_generic_dimension_specifier_in_unbound_type_name1684 = new BitSet(new long[]{0x0000080000000002L});
    public static final BitSet FOLLOW_DOUBLE_COLON_in_unbound_type_name1704 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_unbound_type_name1706 = new BitSet(new long[]{0x0000080000000002L,0x0000000010000000L});
    public static final BitSet FOLLOW_generic_dimension_specifier_in_unbound_type_name1708 = new BitSet(new long[]{0x0000080000000002L});
    public static final BitSet FOLLOW_DOT_in_unbound_type_name1733 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_unbound_type_name1735 = new BitSet(new long[]{0x0000080000000002L,0x0000000010000000L});
    public static final BitSet FOLLOW_generic_dimension_specifier_in_unbound_type_name1737 = new BitSet(new long[]{0x0000080000000002L});
    public static final BitSet FOLLOW_LT_in_generic_dimension_specifier1752 = new BitSet(new long[]{0x0000000010000000L,0x0000000000000020L});
    public static final BitSet FOLLOW_commas_in_generic_dimension_specifier1754 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000020L});
    public static final BitSet FOLLOW_GT_in_generic_dimension_specifier1757 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_COMMA_in_commas1768 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_commas1772 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_CHECKED_in_checked_expression1786 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_checked_expression1788 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_expression_in_checked_expression1790 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_checked_expression1792 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_UNCHECKED_in_unchecked_expression1803 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_unchecked_expression1805 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_expression_in_unchecked_expression1807 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_unchecked_expression1809 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_DEFAULT_in_default_value_expression1820 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_default_value_expression1822 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_type_in_default_value_expression1824 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_default_value_expression1826 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_cast_expression_in_unary_expression1851 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_primary_expression_in_unary_expression1856 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PLUS_in_unary_expression1861 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_unary_expression_in_unary_expression1863 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_MINUS_in_unary_expression1868 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_unary_expression_in_unary_expression1870 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_BANG_in_unary_expression1875 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_unary_expression_in_unary_expression1877 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_TILDE_in_unary_expression1882 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_unary_expression_in_unary_expression1884 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_pre_increment_expression_in_unary_expression1889 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_pre_decrement_expression_in_unary_expression1894 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_unary_expression_unsafe_in_unary_expression1899 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_scan_for_cast_generic_precedence1913 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_type_in_scan_for_cast_generic_precedence1915 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_scan_for_cast_generic_precedence1917 = new BitSet(new long[]{0xFDF0146860FDD810L,0x000019260C03FC10L,0xC07D931E000001CEL,0x0000000013B8007FL});
    public static final BitSet FOLLOW_cast_disambiguation_token_in_scan_for_cast_generic_precedence1919 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_TILDE_in_cast_disambiguation_token1935 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_BANG_in_cast_disambiguation_token1939 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_cast_disambiguation_token1943 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_cast_disambiguation_token1947 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_literal_in_cast_disambiguation_token1951 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_ABSTRACT_in_cast_disambiguation_token1955 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_BASE_in_cast_disambiguation_token1959 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_BOOL_in_cast_disambiguation_token1963 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_BREAK_in_cast_disambiguation_token1967 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_BYTE_in_cast_disambiguation_token1971 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_CASE_in_cast_disambiguation_token1975 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_CATCH_in_cast_disambiguation_token1979 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_CHAR_in_cast_disambiguation_token1987 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_CHECKED_in_cast_disambiguation_token1991 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_CLASS_in_cast_disambiguation_token1995 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_CONST_in_cast_disambiguation_token1999 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_CONTINUE_in_cast_disambiguation_token2003 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_DECIMAL_in_cast_disambiguation_token2007 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_DEFAULT_in_cast_disambiguation_token2011 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_DELEGATE_in_cast_disambiguation_token2015 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_DO_in_cast_disambiguation_token2019 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_DOUBLE_in_cast_disambiguation_token2023 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_ELSE_in_cast_disambiguation_token2027 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_ENUM_in_cast_disambiguation_token2031 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_EVENT_in_cast_disambiguation_token2039 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_EXPLICIT_in_cast_disambiguation_token2043 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_EXTERN_in_cast_disambiguation_token2047 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_FINALLY_in_cast_disambiguation_token2051 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_FIXED_in_cast_disambiguation_token2055 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_FLOAT_in_cast_disambiguation_token2059 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_FOR_in_cast_disambiguation_token2063 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_FOREACH_in_cast_disambiguation_token2067 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_GOTO_in_cast_disambiguation_token2071 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IF_in_cast_disambiguation_token2075 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IMPLICIT_in_cast_disambiguation_token2079 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IN_in_cast_disambiguation_token2083 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INT_in_cast_disambiguation_token2087 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INTERFACE_in_cast_disambiguation_token2095 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INTERNAL_in_cast_disambiguation_token2099 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_LOCK_in_cast_disambiguation_token2103 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_LONG_in_cast_disambiguation_token2107 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_NAMESPACE_in_cast_disambiguation_token2111 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_NEW_in_cast_disambiguation_token2115 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OBJECT_in_cast_disambiguation_token2119 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPERATOR_in_cast_disambiguation_token2123 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OUT_in_cast_disambiguation_token2127 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OVERRIDE_in_cast_disambiguation_token2131 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PARAMS_in_cast_disambiguation_token2135 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PRIVATE_in_cast_disambiguation_token2143 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PROTECTED_in_cast_disambiguation_token2147 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PUBLIC_in_cast_disambiguation_token2151 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_READONLY_in_cast_disambiguation_token2155 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_REF_in_cast_disambiguation_token2159 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_RETURN_in_cast_disambiguation_token2163 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_SBYTE_in_cast_disambiguation_token2167 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_SEALED_in_cast_disambiguation_token2171 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_SHORT_in_cast_disambiguation_token2175 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_SIZEOF_in_cast_disambiguation_token2179 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STACKALLOC_in_cast_disambiguation_token2183 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STATIC_in_cast_disambiguation_token2191 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STRING_in_cast_disambiguation_token2195 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STRUCT_in_cast_disambiguation_token2199 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_SWITCH_in_cast_disambiguation_token2203 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_THIS_in_cast_disambiguation_token2207 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_THROW_in_cast_disambiguation_token2211 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_TRY_in_cast_disambiguation_token2215 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_TYPEOF_in_cast_disambiguation_token2219 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_UINT_in_cast_disambiguation_token2223 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_ULONG_in_cast_disambiguation_token2227 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_UNCHECKED_in_cast_disambiguation_token2231 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_UNSAFE_in_cast_disambiguation_token2235 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_USHORT_in_cast_disambiguation_token2243 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_USING_in_cast_disambiguation_token2247 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_VIRTUAL_in_cast_disambiguation_token2251 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_VOID_in_cast_disambiguation_token2255 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_VOLATILE_in_cast_disambiguation_token2259 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_WHILE_in_cast_disambiguation_token2263 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_INC_in_pre_increment_expression2281 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_unary_expression_in_pre_increment_expression2283 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_DEC_in_pre_decrement_expression2294 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_unary_expression_in_pre_decrement_expression2296 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_cast_expression2307 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_type_in_cast_expression2309 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_cast_expression2311 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_unary_expression_in_cast_expression2313 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_unary_expression_in_multiplicative_expression2324 = new BitSet(new long[]{0x0000020000000002L,0x0000000000000000L,0x0002000000000010L});
    public static final BitSet FOLLOW_STAR_in_multiplicative_expression2330 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_unary_expression_in_multiplicative_expression2333 = new BitSet(new long[]{0x0000020000000002L,0x0000000000000000L,0x0002000000000010L});
    public static final BitSet FOLLOW_DIV_in_multiplicative_expression2341 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_unary_expression_in_multiplicative_expression2344 = new BitSet(new long[]{0x0000020000000002L,0x0000000000000000L,0x0002000000000010L});
    public static final BitSet FOLLOW_PERCENT_in_multiplicative_expression2352 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_unary_expression_in_multiplicative_expression2355 = new BitSet(new long[]{0x0000020000000002L,0x0000000000000000L,0x0002000000000010L});
    public static final BitSet FOLLOW_multiplicative_expression_in_additive_expression2371 = new BitSet(new long[]{0x0000000000000002L,0x0000000100000000L,0x0000000000000020L});
    public static final BitSet FOLLOW_PLUS_in_additive_expression2377 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_multiplicative_expression_in_additive_expression2380 = new BitSet(new long[]{0x0000000000000002L,0x0000000100000000L,0x0000000000000020L});
    public static final BitSet FOLLOW_MINUS_in_additive_expression2388 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_multiplicative_expression_in_additive_expression2391 = new BitSet(new long[]{0x0000000000000002L,0x0000000100000000L,0x0000000000000020L});
    public static final BitSet FOLLOW_additive_expression_in_shift_expression2407 = new BitSet(new long[]{0x0000000000000002L,0x0080000000000020L});
    public static final BitSet FOLLOW_OP_LEFT_SHIFT_in_shift_expression2413 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_additive_expression_in_shift_expression2416 = new BitSet(new long[]{0x0000000000000002L,0x0080000000000020L});
    public static final BitSet FOLLOW_right_shift_in_shift_expression2424 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_additive_expression_in_shift_expression2427 = new BitSet(new long[]{0x0000000000000002L,0x0080000000000020L});
    public static final BitSet FOLLOW_shift_expression_in_relational_expression2445 = new BitSet(new long[]{0x0000000000000042L,0x0050000010080020L});
    public static final BitSet FOLLOW_LT_in_relational_expression2449 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_shift_expression_in_relational_expression2451 = new BitSet(new long[]{0x0000000000000042L,0x0050000010080020L});
    public static final BitSet FOLLOW_GT_in_relational_expression2476 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_shift_expression_in_relational_expression2478 = new BitSet(new long[]{0x0000000000000042L,0x0050000010080020L});
    public static final BitSet FOLLOW_OP_LE_in_relational_expression2503 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_shift_expression_in_relational_expression2505 = new BitSet(new long[]{0x0000000000000042L,0x0050000010080020L});
    public static final BitSet FOLLOW_OP_GE_in_relational_expression2530 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_shift_expression_in_relational_expression2532 = new BitSet(new long[]{0x0000000000000042L,0x0050000010080020L});
    public static final BitSet FOLLOW_IS_in_relational_expression2557 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_isType_in_relational_expression2559 = new BitSet(new long[]{0x0000000000000042L,0x0050000010080020L});
    public static final BitSet FOLLOW_AS_in_relational_expression2584 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_type_in_relational_expression2586 = new BitSet(new long[]{0x0000000000000042L,0x0050000010080020L});
    public static final BitSet FOLLOW_IDENTIFIER_in_scan_for_shift_generic_precedence2622 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
    public static final BitSet FOLLOW_LT_in_scan_for_shift_generic_precedence2624 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_type_in_scan_for_shift_generic_precedence2626 = new BitSet(new long[]{0x0000000010000000L,0x0000000000000020L});
    public static final BitSet FOLLOW_COMMA_in_scan_for_shift_generic_precedence2629 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_type_in_scan_for_shift_generic_precedence2631 = new BitSet(new long[]{0x0000000010000000L,0x0000000000000020L});
    public static final BitSet FOLLOW_GT_in_scan_for_shift_generic_precedence2635 = new BitSet(new long[]{0x000008001E000000L,0x0808080000040020L,0x0000040000000000L});
    public static final BitSet FOLLOW_shift_disambiguation_token_in_scan_for_shift_generic_precedence2637 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_non_nullable_value_type_in_isType2705 = new BitSet(new long[]{0x0000000000000002L,0x0000000000040000L});
    public static final BitSet FOLLOW_INTERR_in_isType2717 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_relational_expression_in_equality_expression2754 = new BitSet(new long[]{0x0000000000000002L,0x0808000000000000L});
    public static final BitSet FOLLOW_OP_EQ_in_equality_expression2760 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_relational_expression_in_equality_expression2763 = new BitSet(new long[]{0x0000000000000002L,0x0808000000000000L});
    public static final BitSet FOLLOW_OP_NE_in_equality_expression2771 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_relational_expression_in_equality_expression2774 = new BitSet(new long[]{0x0000000000000002L,0x0808000000000000L});
    public static final BitSet FOLLOW_equality_expression_in_and_expression2790 = new BitSet(new long[]{0x0000000000000022L});
    public static final BitSet FOLLOW_AMP_in_and_expression2794 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_equality_expression_in_and_expression2796 = new BitSet(new long[]{0x0000000000000022L});
    public static final BitSet FOLLOW_and_expression_in_exclusive_or_expression2809 = new BitSet(new long[]{0x0000000000020002L});
    public static final BitSet FOLLOW_CARET_in_exclusive_or_expression2813 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_and_expression_in_exclusive_or_expression2815 = new BitSet(new long[]{0x0000000000020002L});
    public static final BitSet FOLLOW_exclusive_or_expression_in_inclusive_or_expression2828 = new BitSet(new long[]{0x0000000000002002L});
    public static final BitSet FOLLOW_BITWISE_OR_in_inclusive_or_expression2832 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_exclusive_or_expression_in_inclusive_or_expression2834 = new BitSet(new long[]{0x0000000000002002L});
    public static final BitSet FOLLOW_inclusive_or_expression_in_conditional_and_expression2847 = new BitSet(new long[]{0x0000000000000002L,0x0000400000000000L});
    public static final BitSet FOLLOW_OP_AND_in_conditional_and_expression2851 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_inclusive_or_expression_in_conditional_and_expression2853 = new BitSet(new long[]{0x0000000000000002L,0x0000400000000000L});
    public static final BitSet FOLLOW_conditional_and_expression_in_conditional_or_expression2866 = new BitSet(new long[]{0x0000000000000002L,0x1000000000000000L});
    public static final BitSet FOLLOW_OP_OR_in_conditional_or_expression2870 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_conditional_and_expression_in_conditional_or_expression2872 = new BitSet(new long[]{0x0000000000000002L,0x1000000000000000L});
    public static final BitSet FOLLOW_conditional_or_expression_in_null_coalescing_expression2888 = new BitSet(new long[]{0x0000000000000002L,0x0001000000000000L});
    public static final BitSet FOLLOW_OP_COALESCING_in_null_coalescing_expression2891 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_null_coalescing_expression_in_null_coalescing_expression2893 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_null_coalescing_expression_in_conditional_expression2912 = new BitSet(new long[]{0x0000000000000002L,0x0000000000040000L});
    public static final BitSet FOLLOW_INTERR_in_conditional_expression2915 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_expression_in_conditional_expression2917 = new BitSet(new long[]{0x0000000008000000L});
    public static final BitSet FOLLOW_COLON_in_conditional_expression2919 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_expression_in_conditional_expression2921 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_anonymous_function_signature_in_lambda_expression2937 = new BitSet(new long[]{0x0000000000000080L});
    public static final BitSet FOLLOW_right_arrow_in_lambda_expression2939 = new BitSet(new long[]{0x2400106800715820L,0x00220B250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_anonymous_function_body_in_lambda_expression2941 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_DELEGATE_in_anonymous_method_expression2954 = new BitSet(new long[]{0x0000000000000000L,0x00000A0000000000L});
    public static final BitSet FOLLOW_explicit_anonymous_function_signature_in_anonymous_method_expression2956 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_block_in_anonymous_method_expression2959 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_anonymous_function_signature2975 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_anonymous_function_signature2977 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_anonymous_function_signature2983 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110800000002L,0x0000000001100030L});
    public static final BitSet FOLLOW_explicit_anonymous_function_parameter_list_in_anonymous_function_signature2985 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_anonymous_function_signature2987 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_anonymous_function_signature2993 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_implicit_anonymous_function_parameter_list_in_anonymous_function_signature2995 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_anonymous_function_signature2997 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_implicit_anonymous_function_parameter_in_anonymous_function_signature3003 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_explicit_anonymous_function_signature3015 = new BitSet(new long[]{0x2000100804114000L,0x0000010008004400L,0x0008110800000002L,0x0000000001100030L});
    public static final BitSet FOLLOW_explicit_anonymous_function_parameter_list_in_explicit_anonymous_function_signature3017 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_explicit_anonymous_function_signature3020 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_explicit_anonymous_function_parameter_in_explicit_anonymous_function_parameter_list3031 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_explicit_anonymous_function_parameter_list3035 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110800000002L,0x0000000001100030L});
    public static final BitSet FOLLOW_explicit_anonymous_function_parameter_in_explicit_anonymous_function_parameter_list3037 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_anonymous_function_parameter_modifier_in_explicit_anonymous_function_parameter3050 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_type_in_explicit_anonymous_function_parameter3053 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_explicit_anonymous_function_parameter3055 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_implicit_anonymous_function_signature3082 = new BitSet(new long[]{0x0000000004000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_implicit_anonymous_function_parameter_list_in_implicit_anonymous_function_signature3084 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_implicit_anonymous_function_signature3087 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_implicit_anonymous_function_parameter_in_implicit_anonymous_function_signature3092 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_implicit_anonymous_function_parameter_in_implicit_anonymous_function_parameter_list3103 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_implicit_anonymous_function_parameter_list3107 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_implicit_anonymous_function_parameter_in_implicit_anonymous_function_parameter_list3109 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_implicit_anonymous_function_parameter3124 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_expression_in_anonymous_function_body3135 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_block_in_anonymous_function_body3140 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_from_clause_in_query_expression3153 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_query_body_in_query_expression3155 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_from_contextual_keyword_in_from_clause3166 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_type_in_from_clause3179 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_from_clause3183 = new BitSet(new long[]{0x0000000000000000L,0x0000000000002000L});
    public static final BitSet FOLLOW_IN_in_from_clause3185 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_expression_in_from_clause3187 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_query_body_clauses_in_query_body3201 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_select_or_group_clause_in_query_body3204 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000400L});
    public static final BitSet FOLLOW_query_continuation_in_query_body3213 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_query_body_clause_in_query_body_clauses3227 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000400L});
    public static final BitSet FOLLOW_query_body_clause_in_query_body_clauses3231 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000400L});
    public static final BitSet FOLLOW_from_clause_in_query_body_clause3248 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_let_clause_in_query_body_clause3254 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_where_clause_in_query_body_clause3260 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_combined_join_clause_in_query_body_clause3266 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_orderby_clause_in_query_body_clause3272 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_let_contextual_keyword_in_let_clause3284 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_let_clause3286 = new BitSet(new long[]{0x0000000000000080L});
    public static final BitSet FOLLOW_ASSIGNMENT_in_let_clause3288 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_expression_in_let_clause3290 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_where_contextual_keyword_in_where_clause3301 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_boolean_expression_in_where_clause3303 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_join_contextual_keyword_in_join_clause3314 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_type_in_join_clause3316 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_join_clause3319 = new BitSet(new long[]{0x0000000000000000L,0x0000000000002000L});
    public static final BitSet FOLLOW_IN_in_join_clause3321 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_expression_in_join_clause3323 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_on_contextual_keyword_in_join_clause3325 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_expression_in_join_clause3327 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_equals_contextual_keyword_in_join_clause3329 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_expression_in_join_clause3331 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_join_contextual_keyword_in_join_into_clause3342 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_type_in_join_into_clause3344 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_join_into_clause3347 = new BitSet(new long[]{0x0000000000000000L,0x0000000000002000L});
    public static final BitSet FOLLOW_IN_in_join_into_clause3349 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_expression_in_join_into_clause3351 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_on_contextual_keyword_in_join_into_clause3353 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_expression_in_join_into_clause3355 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_equals_contextual_keyword_in_join_into_clause3357 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_expression_in_join_into_clause3359 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_into_contextual_keyword_in_join_into_clause3361 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_join_into_clause3363 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_join_contextual_keyword_in_combined_join_clause3375 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_type_in_combined_join_clause3377 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_combined_join_clause3380 = new BitSet(new long[]{0x0000000000000000L,0x0000000000002000L});
    public static final BitSet FOLLOW_IN_in_combined_join_clause3382 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_expression_in_combined_join_clause3384 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_on_contextual_keyword_in_combined_join_clause3386 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_expression_in_combined_join_clause3388 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_equals_contextual_keyword_in_combined_join_clause3390 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_expression_in_combined_join_clause3392 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000400L});
    public static final BitSet FOLLOW_into_contextual_keyword_in_combined_join_clause3395 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_combined_join_clause3397 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_orderby_contextual_keyword_in_orderby_clause3411 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_orderings_in_orderby_clause3413 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_ordering_in_orderings3424 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_orderings3428 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_ordering_in_orderings3431 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_expression_in_ordering3445 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000400L});
    public static final BitSet FOLLOW_ordering_direction_in_ordering3447 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_ascending_contextual_keyword_in_ordering_direction3459 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_descending_contextual_keyword_in_ordering_direction3464 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_select_clause_in_select_or_group_clause3475 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_group_clause_in_select_or_group_clause3480 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_select_contextual_keyword_in_select_clause3491 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_expression_in_select_clause3493 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_group_contextual_keyword_in_group_clause3504 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_expression_in_group_clause3506 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_by_contextual_keyword_in_group_clause3508 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_expression_in_group_clause3510 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_into_contextual_keyword_in_query_continuation3523 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_query_continuation3525 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_query_body_in_query_continuation3527 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_unary_expression_in_assignment3540 = new BitSet(new long[]{0x0000000000000080L,0xA704A00000000020L,0x0000000000000001L});
    public static final BitSet FOLLOW_assignment_operator_in_assignment3542 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_expression_in_assignment3544 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_ASSIGNMENT_in_assignment_operator3555 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_ADD_ASSIGNMENT_in_assignment_operator3560 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_SUB_ASSIGNMENT_in_assignment_operator3565 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_MULT_ASSIGNMENT_in_assignment_operator3570 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_DIV_ASSIGNMENT_in_assignment_operator3575 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_MOD_ASSIGNMENT_in_assignment_operator3580 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_AND_ASSIGNMENT_in_assignment_operator3585 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_OR_ASSIGNMENT_in_assignment_operator3590 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_XOR_ASSIGNMENT_in_assignment_operator3595 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_LEFT_SHIFT_ASSIGNMENT_in_assignment_operator3600 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_right_shift_assignment_in_assignment_operator3605 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_assignment_in_expression3622 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_non_assignment_expression_in_expression3627 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_lambda_expression_in_non_assignment_expression3643 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_query_expression_in_non_assignment_expression3654 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_conditional_expression_in_non_assignment_expression3659 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_expression_in_constant_expression3670 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_expression_in_boolean_expression3681 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_labeled_statement_in_statement3700 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_declaration_statement_in_statement3711 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_embedded_statement_in_statement3716 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_block_in_embedded_statement3727 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_empty_statement_in_embedded_statement3732 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_expression_statement_in_embedded_statement3737 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_selection_statement_in_embedded_statement3742 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_iteration_statement_in_embedded_statement3747 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_jump_statement_in_embedded_statement3752 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_try_statement_in_embedded_statement3757 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_checked_statement_in_embedded_statement3762 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_unchecked_statement_in_embedded_statement3767 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_lock_statement_in_embedded_statement3772 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_using_statement_in_embedded_statement3777 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_yield_statement_in_embedded_statement3782 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_embedded_statement_unsafe_in_embedded_statement3787 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_block3800 = new BitSet(new long[]{0xF40014686171D820L,0x00220B250C00CC10L,0xC05A951400000020L,0x000000001138007FL});
    public static final BitSet FOLLOW_statement_list_in_block3802 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_block3805 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_statement_in_statement_list3816 = new BitSet(new long[]{0xF40014686071D822L,0x00220B250C00CC10L,0xC05A951400000020L,0x000000001138007FL});
    public static final BitSet FOLLOW_SEMICOLON_in_empty_statement3828 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_labeled_statement3841 = new BitSet(new long[]{0x0000000008000000L});
    public static final BitSet FOLLOW_COLON_in_labeled_statement3843 = new BitSet(new long[]{0xF40014686071D820L,0x00220B250C00CC10L,0xC05A951400000020L,0x000000001138007FL});
    public static final BitSet FOLLOW_statement_in_labeled_statement3845 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_local_variable_declaration_in_declaration_statement3858 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_declaration_statement3860 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_local_constant_declaration_in_declaration_statement3865 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_declaration_statement3867 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_local_variable_type_in_local_variable_declaration3880 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_local_variable_declarators_in_local_variable_declaration3883 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_type_in_local_variable_type3896 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_local_variable_declarator_in_local_variable_declarators3910 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_local_variable_declarators3914 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_local_variable_declarator_in_local_variable_declarators3917 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_local_variable_declarator3934 = new BitSet(new long[]{0x0000000000000082L});
    public static final BitSet FOLLOW_ASSIGNMENT_in_local_variable_declarator3938 = new BitSet(new long[]{0x2400106800715820L,0x00220B250800C400L,0x401B910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_local_variable_initializer_in_local_variable_declarator3940 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_expression_in_local_variable_initializer3953 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_array_initializer_in_local_variable_initializer3958 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_local_variable_initializer_unsafe_in_local_variable_initializer3963 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_CONST_in_local_constant_declaration3974 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_type_in_local_constant_declaration3976 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_constant_declarators_in_local_constant_declaration3978 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_statement_expression_in_expression_statement3988 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_expression_statement3990 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_expression_in_statement_expression4005 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_if_statement_in_selection_statement4014 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_switch_statement_in_selection_statement4019 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IF_in_if_statement4033 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_if_statement4035 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_boolean_expression_in_if_statement4037 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_if_statement4039 = new BitSet(new long[]{0xF40014684071D820L,0x00220B250C00CC10L,0xC05A951400000020L,0x000000001038007FL});
    public static final BitSet FOLLOW_embedded_statement_in_if_statement4041 = new BitSet(new long[]{0x0010000000000002L});
    public static final BitSet FOLLOW_ELSE_in_if_statement4051 = new BitSet(new long[]{0xF40014684071D820L,0x00220B250C00CC10L,0xC05A951400000020L,0x000000001038007FL});
    public static final BitSet FOLLOW_embedded_statement_in_if_statement4053 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_SWITCH_in_switch_statement4068 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_switch_statement4070 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_expression_in_switch_statement4072 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_switch_statement4074 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_switch_block_in_switch_statement4076 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_switch_block4087 = new BitSet(new long[]{0x0000002001040000L});
    public static final BitSet FOLLOW_switch_sections_in_switch_block4089 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_switch_block4092 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_switch_section_in_switch_sections4103 = new BitSet(new long[]{0x0000002000040002L});
    public static final BitSet FOLLOW_switch_section_in_switch_sections4107 = new BitSet(new long[]{0x0000002000040002L});
    public static final BitSet FOLLOW_switch_labels_in_switch_section4121 = new BitSet(new long[]{0xF40014686071D820L,0x00220B250C00CC10L,0xC05A951400000020L,0x000000001138007FL});
    public static final BitSet FOLLOW_statement_list_in_switch_section4123 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_switch_label_in_switch_labels4134 = new BitSet(new long[]{0x0000002000040002L});
    public static final BitSet FOLLOW_switch_label_in_switch_labels4138 = new BitSet(new long[]{0x0000002000040002L});
    public static final BitSet FOLLOW_CASE_in_switch_label4152 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_constant_expression_in_switch_label4154 = new BitSet(new long[]{0x0000000008000000L});
    public static final BitSet FOLLOW_COLON_in_switch_label4156 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_DEFAULT_in_switch_label4161 = new BitSet(new long[]{0x0000000008000000L});
    public static final BitSet FOLLOW_COLON_in_switch_label4163 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_while_statement_in_iteration_statement4174 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_do_statement_in_iteration_statement4179 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_for_statement_in_iteration_statement4184 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_foreach_statement_in_iteration_statement4189 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_WHILE_in_while_statement4200 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_while_statement4202 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_boolean_expression_in_while_statement4204 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_while_statement4206 = new BitSet(new long[]{0xF40014684071D820L,0x00220B250C00CC10L,0xC05A951400000020L,0x000000001038007FL});
    public static final BitSet FOLLOW_embedded_statement_in_while_statement4208 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_DO_in_do_statement4219 = new BitSet(new long[]{0xF40014684071D820L,0x00220B250C00CC10L,0xC05A951400000020L,0x000000001038007FL});
    public static final BitSet FOLLOW_embedded_statement_in_do_statement4221 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000010000000L});
    public static final BitSet FOLLOW_WHILE_in_do_statement4223 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_do_statement4225 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_boolean_expression_in_do_statement4227 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_do_statement4229 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_do_statement4231 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_FOR_in_for_statement4242 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_for_statement4244 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A950400000020L,0x000000000110007BL});
    public static final BitSet FOLLOW_for_initializer_in_for_statement4246 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_for_statement4249 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A950400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_for_condition_in_for_statement4251 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_for_statement4254 = new BitSet(new long[]{0x2400106804715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_for_iterator_in_for_statement4256 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_for_statement4259 = new BitSet(new long[]{0xF40014684071D820L,0x00220B250C00CC10L,0xC05A951400000020L,0x000000001038007FL});
    public static final BitSet FOLLOW_embedded_statement_in_for_statement4261 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_local_variable_declaration_in_for_initializer4278 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_statement_expression_list_in_for_initializer4283 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_boolean_expression_in_for_condition4294 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_statement_expression_list_in_for_iterator4305 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_statement_expression_in_statement_expression_list4316 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_statement_expression_list4320 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_statement_expression_in_statement_expression_list4323 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_FOREACH_in_foreach_statement4337 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_foreach_statement4339 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_local_variable_type_in_foreach_statement4341 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_foreach_statement4343 = new BitSet(new long[]{0x0000000000000000L,0x0000000000002000L});
    public static final BitSet FOLLOW_IN_in_foreach_statement4345 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_expression_in_foreach_statement4347 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_foreach_statement4349 = new BitSet(new long[]{0xF40014684071D820L,0x00220B250C00CC10L,0xC05A951400000020L,0x000000001038007FL});
    public static final BitSet FOLLOW_embedded_statement_in_foreach_statement4351 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_break_statement_in_jump_statement4362 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_continue_statement_in_jump_statement4367 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_goto_statement_in_jump_statement4372 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_return_statement_in_jump_statement4377 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_throw_statement_in_jump_statement4382 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_BREAK_in_break_statement4393 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_break_statement4395 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_CONTINUE_in_continue_statement4406 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_continue_statement4408 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_GOTO_in_goto_statement4419 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_goto_statement4421 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_goto_statement4423 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_GOTO_in_goto_statement4428 = new BitSet(new long[]{0x0000000000040000L});
    public static final BitSet FOLLOW_CASE_in_goto_statement4430 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_constant_expression_in_goto_statement4432 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_goto_statement4434 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_GOTO_in_goto_statement4439 = new BitSet(new long[]{0x0000002000000000L});
    public static final BitSet FOLLOW_DEFAULT_in_goto_statement4441 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_goto_statement4443 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_RETURN_in_return_statement4454 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A950400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_expression_in_return_statement4456 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_return_statement4459 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_THROW_in_throw_statement4470 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A950400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_expression_in_throw_statement4472 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_throw_statement4475 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_TRY_in_try_statement4489 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_block_in_try_statement4491 = new BitSet(new long[]{0x0800000000080002L});
    public static final BitSet FOLLOW_catch_clauses_in_try_statement4493 = new BitSet(new long[]{0x0800000000000002L});
    public static final BitSet FOLLOW_finally_clause_in_try_statement4496 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_specific_catch_clauses_in_catch_clauses4512 = new BitSet(new long[]{0x0000000000080002L});
    public static final BitSet FOLLOW_general_catch_clause_in_catch_clauses4514 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_general_catch_clause_in_catch_clauses4521 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_specific_catch_clause_in_specific_catch_clauses4533 = new BitSet(new long[]{0x0000000000080002L});
    public static final BitSet FOLLOW_specific_catch_clause_in_specific_catch_clauses4537 = new BitSet(new long[]{0x0000000000080002L});
    public static final BitSet FOLLOW_CATCH_in_specific_catch_clause4551 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_specific_catch_clause4553 = new BitSet(new long[]{0x0000000000000000L,0x0000010000000400L,0x0008000000000000L});
    public static final BitSet FOLLOW_class_type_in_specific_catch_clause4555 = new BitSet(new long[]{0x0000000004000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_specific_catch_clause4557 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_specific_catch_clause4560 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_block_in_specific_catch_clause4562 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_CATCH_in_general_catch_clause4573 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_block_in_general_catch_clause4575 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_FINALLY_in_finally_clause4586 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_block_in_finally_clause4588 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_CHECKED_in_checked_statement4599 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_block_in_checked_statement4601 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_UNCHECKED_in_unchecked_statement4612 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_block_in_unchecked_statement4614 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_LOCK_in_lock_statement4625 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_lock_statement4627 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_expression_in_lock_statement4629 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_lock_statement4631 = new BitSet(new long[]{0xF40014684071D820L,0x00220B250C00CC10L,0xC05A951400000020L,0x000000001038007FL});
    public static final BitSet FOLLOW_embedded_statement_in_lock_statement4633 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_USING_in_using_statement4644 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_using_statement4646 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000110007BL});
    public static final BitSet FOLLOW_resource_acquisition_in_using_statement4648 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_using_statement4650 = new BitSet(new long[]{0xF40014684071D820L,0x00220B250C00CC10L,0xC05A951400000020L,0x000000001038007FL});
    public static final BitSet FOLLOW_embedded_statement_in_using_statement4652 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_local_variable_declaration_in_resource_acquisition4671 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_expression_in_resource_acquisition4676 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_yield_contextual_keyword_in_yield_statement4687 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000001000000000L});
    public static final BitSet FOLLOW_RETURN_in_yield_statement4689 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_expression_in_yield_statement4691 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_yield_statement4693 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_yield_contextual_keyword_in_yield_statement4698 = new BitSet(new long[]{0x0000000000008000L});
    public static final BitSet FOLLOW_BREAK_in_yield_statement4700 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_yield_statement4702 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_extern_alias_directives_in_compilation_unit4721 = new BitSet(new long[]{0x0120004000800010L,0x0000040600030400L,0x00240202000001C4L,0x0000000002A80000L});
    public static final BitSet FOLLOW_using_directives_in_compilation_unit4724 = new BitSet(new long[]{0x0120004000800010L,0x0000040600030400L,0x00240202000001C4L,0x0000000002880000L});
    public static final BitSet FOLLOW_global_attribute_section_in_compilation_unit4739 = new BitSet(new long[]{0x0120004000800010L,0x0000040600030400L,0x00240202000001C4L,0x0000000002880000L});
    public static final BitSet FOLLOW_namespace_member_declarations_in_compilation_unit4748 = new BitSet(new long[]{0x0000000000000000L});
    public static final BitSet FOLLOW_EOF_in_compilation_unit4751 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_NAMESPACE_in_namespace_declaration4763 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_qualified_identifier_in_namespace_declaration4767 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_namespace_body_in_namespace_declaration4769 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_namespace_declaration4771 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_qualified_identifier4783 = new BitSet(new long[]{0x0000080000000002L});
    public static final BitSet FOLLOW_DOT_in_qualified_identifier4787 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_qualified_identifier4790 = new BitSet(new long[]{0x0000080000000002L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_namespace_body4804 = new BitSet(new long[]{0x0120004001800010L,0x0000040600030400L,0x00240202000001C4L,0x0000000002A80000L});
    public static final BitSet FOLLOW_extern_alias_directives_in_namespace_body4806 = new BitSet(new long[]{0x0120004001800010L,0x0000040600030400L,0x00240202000001C4L,0x0000000002A80000L});
    public static final BitSet FOLLOW_using_directives_in_namespace_body4809 = new BitSet(new long[]{0x0120004001800010L,0x0000040600030400L,0x00240202000001C4L,0x0000000002880000L});
    public static final BitSet FOLLOW_namespace_member_declarations_in_namespace_body4812 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_namespace_body4815 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_extern_alias_directive_in_extern_alias_directives4826 = new BitSet(new long[]{0x0100000000000002L});
    public static final BitSet FOLLOW_EXTERN_in_extern_alias_directive4838 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_alias_contextual_keyword_in_extern_alias_directive4840 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_extern_alias_directive4842 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_extern_alias_directive4844 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_using_directive_in_using_directives4855 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000200000L});
    public static final BitSet FOLLOW_using_alias_directive_in_using_directive4867 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_using_namespace_directive_in_using_directive4872 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_USING_in_using_alias_directive4883 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_using_alias_directive4885 = new BitSet(new long[]{0x0000000000000080L});
    public static final BitSet FOLLOW_ASSIGNMENT_in_using_alias_directive4887 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_namespace_or_type_name_in_using_alias_directive4889 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_using_alias_directive4891 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_USING_in_using_namespace_directive4902 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_namespace_name_in_using_namespace_directive4904 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_using_namespace_directive4906 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_namespace_member_declaration_in_namespace_member_declarations4917 = new BitSet(new long[]{0x0120004000800012L,0x0000040600030400L,0x00240202000001C4L,0x0000000002880000L});
    public static final BitSet FOLLOW_namespace_declaration_in_namespace_member_declaration4929 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_type_declaration_in_namespace_member_declaration4934 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_type_declaration4948 = new BitSet(new long[]{0x0120004000800010L,0x0000000400030400L,0x00240202000001C4L,0x0000000002880000L});
    public static final BitSet FOLLOW_all_member_modifiers_in_type_declaration4951 = new BitSet(new long[]{0x0020004000800000L,0x0000000000010000L,0x0020000000000000L});
    public static final BitSet FOLLOW_class_definition_in_type_declaration4960 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_struct_definition_in_type_declaration4968 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_interface_definition_in_type_declaration4976 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_enum_definition_in_type_declaration4984 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_delegate_definition_in_type_declaration4992 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_qualified_alias_member5012 = new BitSet(new long[]{0x0000400000000000L});
    public static final BitSet FOLLOW_DOUBLE_COLON_in_qualified_alias_member5014 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_qualified_alias_member5016 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
    public static final BitSet FOLLOW_type_argument_list_opt_in_qualified_alias_member5018 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_class_declaration5032 = new BitSet(new long[]{0x0000000000800010L,0x0000000400020400L,0x00040200000001C0L,0x0000000000080000L});
    public static final BitSet FOLLOW_class_modifiers_in_class_declaration5035 = new BitSet(new long[]{0x0000000000800000L,0x0000000000000400L});
    public static final BitSet FOLLOW_partial_contextual_keyword_in_class_declaration5038 = new BitSet(new long[]{0x0000000000800000L});
    public static final BitSet FOLLOW_CLASS_in_class_declaration5041 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_class_declaration5043 = new BitSet(new long[]{0x0000000008000000L,0x0000020010000400L});
    public static final BitSet FOLLOW_type_parameter_list_in_class_declaration5045 = new BitSet(new long[]{0x0000000008000000L,0x0000020000000400L});
    public static final BitSet FOLLOW_class_base_in_class_declaration5053 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000400L});
    public static final BitSet FOLLOW_type_parameter_constraints_clauses_in_class_declaration5056 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_class_body_in_class_declaration5059 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_class_declaration5061 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_class_modifier_in_class_modifiers5073 = new BitSet(new long[]{0x0000000000000012L,0x0000000400020000L,0x00040200000001C0L,0x0000000000080000L});
    public static final BitSet FOLLOW_class_modifier_in_class_modifiers5077 = new BitSet(new long[]{0x0000000000000012L,0x0000000400020000L,0x00040200000001C0L,0x0000000000080000L});
    public static final BitSet FOLLOW_NEW_in_class_modifier5091 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PUBLIC_in_class_modifier5096 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PROTECTED_in_class_modifier5101 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INTERNAL_in_class_modifier5106 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PRIVATE_in_class_modifier5111 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_ABSTRACT_in_class_modifier5116 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_SEALED_in_class_modifier5121 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STATIC_in_class_modifier5126 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_class_modifier_unsafe_in_class_modifier5131 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_LT_in_type_parameter_list5142 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000400L});
    public static final BitSet FOLLOW_type_parameters_in_type_parameter_list5144 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000020L});
    public static final BitSet FOLLOW_GT_in_type_parameter_list5146 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_type_parameters5157 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_type_parameter_in_type_parameters5160 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_type_parameters5164 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000400L});
    public static final BitSet FOLLOW_attributes_in_type_parameters5167 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_type_parameter_in_type_parameters5171 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_type_parameter5187 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_COLON_in_class_base5202 = new BitSet(new long[]{0x0000000000000000L,0x0000010000000400L,0x0008000000000000L});
    public static final BitSet FOLLOW_class_type_in_class_base5204 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_class_base5208 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_interface_type_in_class_base5211 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_interface_type_in_interface_type_list5226 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_interface_type_list5230 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_interface_type_in_interface_type_list5233 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_type_parameter_constraints_clause_in_type_parameter_constraints_clauses5247 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000400L});
    public static final BitSet FOLLOW_type_parameter_constraints_clause_in_type_parameter_constraints_clauses5251 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000400L});
    public static final BitSet FOLLOW_where_contextual_keyword_in_type_parameter_constraints_clause5265 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_type_parameter_in_type_parameter_constraints_clause5267 = new BitSet(new long[]{0x0000000008000000L});
    public static final BitSet FOLLOW_COLON_in_type_parameter_constraints_clause5269 = new BitSet(new long[]{0x0000000000800000L,0x0000010400000400L,0x0028000000000000L});
    public static final BitSet FOLLOW_type_parameter_constraints_in_type_parameter_constraints_clause5271 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_constructor_constraint_in_type_parameter_constraints5285 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_primary_constraint_in_type_parameter_constraints5291 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_type_parameter_constraints5294 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_secondary_constraints_in_type_parameter_constraints5296 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_type_parameter_constraints5301 = new BitSet(new long[]{0x0000000000000000L,0x0000000400000000L});
    public static final BitSet FOLLOW_constructor_constraint_in_type_parameter_constraints5303 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_class_type_in_primary_constraint5317 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_CLASS_in_primary_constraint5322 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STRUCT_in_primary_constraint5327 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_interface_type_in_secondary_constraints5341 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_secondary_constraints5344 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_interface_type_in_secondary_constraints5346 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_NEW_in_constructor_constraint5360 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_constructor_constraint5362 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_constructor_constraint5364 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_class_body5375 = new BitSet(new long[]{0x21E0104821914010L,0x0000050408035400L,0x002C1302000001C4L,0x0000000003980031L});
    public static final BitSet FOLLOW_class_member_declarations_in_class_body5377 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_class_body5380 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_class_member_declaration_in_class_member_declarations5391 = new BitSet(new long[]{0x21E0104820914012L,0x0000050408035400L,0x002C1302000001C4L,0x0000000003980031L});
    public static final BitSet FOLLOW_attributes_in_class_member_declaration5406 = new BitSet(new long[]{0x21E0104820914010L,0x0000010408035400L,0x002C1302000001C4L,0x0000000003980031L});
    public static final BitSet FOLLOW_all_member_modifiers_in_class_member_declaration5409 = new BitSet(new long[]{0x20E0104820914000L,0x0000010008015400L,0x0028110000000000L,0x0000000001100031L});
    public static final BitSet FOLLOW_common_member_declaration_in_class_member_declaration5417 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_TILDE_in_class_member_declaration5424 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_class_member_declaration5426 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_class_member_declaration5428 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_class_member_declaration5430 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_destructor_body_in_class_member_declaration5432 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_all_member_modifier_in_all_member_modifiers5454 = new BitSet(new long[]{0x0100000000000012L,0x0000000400020400L,0x00040202000001C4L,0x0000000002880000L});
    public static final BitSet FOLLOW_NEW_in_all_member_modifier5468 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PUBLIC_in_all_member_modifier5474 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PROTECTED_in_all_member_modifier5480 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INTERNAL_in_all_member_modifier5486 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PRIVATE_in_all_member_modifier5492 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_READONLY_in_all_member_modifier5498 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_VOLATILE_in_all_member_modifier5504 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_VIRTUAL_in_all_member_modifier5510 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_SEALED_in_all_member_modifier5516 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OVERRIDE_in_all_member_modifier5522 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_ABSTRACT_in_all_member_modifier5528 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STATIC_in_all_member_modifier5534 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_UNSAFE_in_all_member_modifier5540 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_EXTERN_in_all_member_modifier5546 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_partial_contextual_keyword_in_all_member_modifier5552 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_constant_declaration2_in_common_member_declaration5569 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_typed_member_declaration_in_common_member_declaration5575 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_EVENT_in_common_member_declaration5581 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_type_in_common_member_declaration5583 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_variable_declarators_in_common_member_declaration5587 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_common_member_declaration5589 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_member_name_in_common_member_declaration5610 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_common_member_declaration5612 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000400L});
    public static final BitSet FOLLOW_event_accessor_declarations_in_common_member_declaration5614 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_common_member_declaration5616 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_conversion_operator_declarator_in_common_member_declaration5641 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_operator_body_in_common_member_declaration5643 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_common_member_declaration5654 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_common_member_declaration5656 = new BitSet(new long[]{0x2000100804114000L,0x0000050008004400L,0x400811080000000AL,0x0000000001100030L});
    public static final BitSet FOLLOW_formal_parameter_list_in_common_member_declaration5658 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_common_member_declaration5661 = new BitSet(new long[]{0x0000000008000000L,0x0000020000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_constructor_initializer_in_common_member_declaration5663 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_body_in_common_member_declaration5666 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_VOID_in_common_member_declaration5672 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_method_definition_in_common_member_declaration5674 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_CLASS_in_common_member_declaration5680 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_common_member_declaration5684 = new BitSet(new long[]{0x0000000008000000L,0x0000020010000400L});
    public static final BitSet FOLLOW_type_parameter_list_in_common_member_declaration5686 = new BitSet(new long[]{0x0000000008000000L,0x0000020000000400L});
    public static final BitSet FOLLOW_class_base_in_common_member_declaration5689 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000400L});
    public static final BitSet FOLLOW_type_parameter_constraints_clauses_in_common_member_declaration5692 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_class_body_in_common_member_declaration5695 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_common_member_declaration5697 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STRUCT_in_common_member_declaration5704 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_common_member_declaration5706 = new BitSet(new long[]{0x0000000008000000L,0x0000020010000400L});
    public static final BitSet FOLLOW_type_parameter_list_in_common_member_declaration5708 = new BitSet(new long[]{0x0000000008000000L,0x0000020000000400L});
    public static final BitSet FOLLOW_struct_interfaces_in_common_member_declaration5711 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000400L});
    public static final BitSet FOLLOW_type_parameter_constraints_clauses_in_common_member_declaration5714 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_struct_body_in_common_member_declaration5717 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_common_member_declaration5719 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INTERFACE_in_common_member_declaration5726 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_common_member_declaration5728 = new BitSet(new long[]{0x0000000008000000L,0x0000020010000400L});
    public static final BitSet FOLLOW_variant_type_parameter_list_in_common_member_declaration5730 = new BitSet(new long[]{0x0000000008000000L,0x0000020000000400L});
    public static final BitSet FOLLOW_interface_base_in_common_member_declaration5733 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000400L});
    public static final BitSet FOLLOW_type_parameter_constraints_clauses_in_common_member_declaration5736 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_interface_body_in_common_member_declaration5739 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_common_member_declaration5741 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_ENUM_in_common_member_declaration5748 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_common_member_declaration5750 = new BitSet(new long[]{0x0000000008000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_enum_base_in_common_member_declaration5752 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_enum_body_in_common_member_declaration5755 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_common_member_declaration5757 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_DELEGATE_in_common_member_declaration5764 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_return_type_in_common_member_declaration5766 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_common_member_declaration5768 = new BitSet(new long[]{0x0000000000000000L,0x0000080010000000L});
    public static final BitSet FOLLOW_type_parameter_list_in_common_member_declaration5770 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_common_member_declaration5773 = new BitSet(new long[]{0x2000100804114000L,0x0000050008004400L,0x400811080000000AL,0x0000000001100030L});
    public static final BitSet FOLLOW_formal_parameter_list_in_common_member_declaration5775 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_common_member_declaration5778 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L,0x0000040000000000L});
    public static final BitSet FOLLOW_type_parameter_constraints_clauses_in_common_member_declaration5780 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_common_member_declaration5783 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_type_in_typed_member_declaration5798 = new BitSet(new long[]{0x0000000000000000L,0x0000100000000400L,0x4000000000000000L});
    public static final BitSet FOLLOW_interface_type_in_typed_member_declaration5824 = new BitSet(new long[]{0x0000080000000000L});
    public static final BitSet FOLLOW_DOT_in_typed_member_declaration5826 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x4000000000000000L});
    public static final BitSet FOLLOW_THIS_in_typed_member_declaration5828 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_OPEN_BRACKET_in_typed_member_declaration5830 = new BitSet(new long[]{0x2000100800114000L,0x0000050008004400L,0x400811080000000AL,0x0000000001100030L});
    public static final BitSet FOLLOW_formal_parameter_list_in_typed_member_declaration5832 = new BitSet(new long[]{0x0000000002000000L});
    public static final BitSet FOLLOW_CLOSE_BRACKET_in_typed_member_declaration5834 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_typed_member_declaration5836 = new BitSet(new long[]{0x0000000000000000L,0x0000040000020400L,0x00000000000000C0L});
    public static final BitSet FOLLOW_accessor_declarations_in_typed_member_declaration5838 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_typed_member_declaration5840 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_method_definition_in_typed_member_declaration5859 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_property_declaration2_in_typed_member_declaration5875 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_THIS_in_typed_member_declaration5883 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_OPEN_BRACKET_in_typed_member_declaration5885 = new BitSet(new long[]{0x2000100800114000L,0x0000050008004400L,0x400811080000000AL,0x0000000001100030L});
    public static final BitSet FOLLOW_formal_parameter_list_in_typed_member_declaration5887 = new BitSet(new long[]{0x0000000002000000L});
    public static final BitSet FOLLOW_CLOSE_BRACKET_in_typed_member_declaration5889 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_typed_member_declaration5891 = new BitSet(new long[]{0x0000000000000000L,0x0000040000020400L,0x00000000000000C0L});
    public static final BitSet FOLLOW_accessor_declarations_in_typed_member_declaration5893 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_typed_member_declaration5895 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_operator_declaration2_in_typed_member_declaration5903 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_field_declaration2_in_typed_member_declaration5911 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_constant_declarator_in_constant_declarators5931 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_constant_declarators5935 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_constant_declarator_in_constant_declarators5938 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_constant_declarator5952 = new BitSet(new long[]{0x0000000000000080L});
    public static final BitSet FOLLOW_ASSIGNMENT_in_constant_declarator5954 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_constant_expression_in_constant_declarator5956 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_variable_declarator_in_variable_declarators5970 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_variable_declarators5974 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_variable_declarator_in_variable_declarators5977 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_variable_declarator5991 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_variable_declarator5996 = new BitSet(new long[]{0x0000000000000080L});
    public static final BitSet FOLLOW_ASSIGNMENT_in_variable_declarator5998 = new BitSet(new long[]{0x2400106800715820L,0x00220B250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_variable_initializer_in_variable_declarator6000 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_expression_in_variable_initializer6011 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_array_initializer_in_variable_initializer6016 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_method_header_in_method_declaration6027 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_method_body_in_method_declaration6029 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_method_header6040 = new BitSet(new long[]{0x2100100800114010L,0x0000010408024400L,0x000C1300000001C4L,0x0000000001980030L});
    public static final BitSet FOLLOW_method_modifiers_in_method_header6043 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_partial_contextual_keyword_in_method_header6046 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_return_type_in_method_header6049 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_member_name_in_method_header6051 = new BitSet(new long[]{0x0000000000000000L,0x0000080010000000L});
    public static final BitSet FOLLOW_type_parameter_list_in_method_header6053 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_method_header6056 = new BitSet(new long[]{0x2000100804114000L,0x0000050008004400L,0x400811080000000AL,0x0000000001100030L});
    public static final BitSet FOLLOW_formal_parameter_list_in_method_header6058 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_method_header6061 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000400L});
    public static final BitSet FOLLOW_type_parameter_constraints_clauses_in_method_header6063 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_method_modifier_in_method_modifiers6075 = new BitSet(new long[]{0x0100000000000012L,0x0000000400020000L,0x00040200000001C4L,0x0000000000880000L});
    public static final BitSet FOLLOW_NEW_in_method_modifier6087 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PUBLIC_in_method_modifier6092 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PROTECTED_in_method_modifier6097 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INTERNAL_in_method_modifier6102 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PRIVATE_in_method_modifier6107 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STATIC_in_method_modifier6112 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_VIRTUAL_in_method_modifier6117 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_SEALED_in_method_modifier6122 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OVERRIDE_in_method_modifier6127 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_ABSTRACT_in_method_modifier6132 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_EXTERN_in_method_modifier6137 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_method_modifier_unsafe_in_method_modifier6142 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_type_in_return_type6155 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_VOID_in_return_type6160 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_interface_type_in_member_name6176 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_block_in_method_body6188 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_SEMICOLON_in_method_body6193 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_parameter_array_in_formal_parameter_list6216 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_fixed_parameters_in_formal_parameter_list6222 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_formal_parameter_list6234 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000000L,0x0000000000000008L});
    public static final BitSet FOLLOW_parameter_array_in_formal_parameter_list6236 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_fixed_parameter_in_fixed_parameters6250 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_fixed_parameters6262 = new BitSet(new long[]{0x2000100800114000L,0x0000050008004400L,0x4008110800000002L,0x0000000001100030L});
    public static final BitSet FOLLOW_fixed_parameter_in_fixed_parameters6264 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_attributes_in_fixed_parameter6281 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x4008110800000002L,0x0000000001100030L});
    public static final BitSet FOLLOW_parameter_modifier_in_fixed_parameter6284 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_type_in_fixed_parameter6287 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_fixed_parameter6289 = new BitSet(new long[]{0x0000000000000082L});
    public static final BitSet FOLLOW_default_argument_in_fixed_parameter6291 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_arglist_in_fixed_parameter6298 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_ASSIGNMENT_in_default_argument6310 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_expression_in_default_argument6312 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_parameter_array6344 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
    public static final BitSet FOLLOW_PARAMS_in_parameter_array6347 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_array_type_in_parameter_array6349 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_parameter_array6351 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_property_declaration6362 = new BitSet(new long[]{0x2100100800114010L,0x0000010408024400L,0x000C1300000001C4L,0x0000000001980030L});
    public static final BitSet FOLLOW_property_modifiers_in_property_declaration6365 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_type_in_property_declaration6368 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_member_name_in_property_declaration6370 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_property_declaration6372 = new BitSet(new long[]{0x0000000000000000L,0x0000040000020400L,0x00000000000000C0L});
    public static final BitSet FOLLOW_accessor_declarations_in_property_declaration6374 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_property_declaration6376 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_property_modifier_in_property_modifiers6387 = new BitSet(new long[]{0x0100000000000012L,0x0000000400020000L,0x00040200000001C4L,0x0000000000880000L});
    public static final BitSet FOLLOW_NEW_in_property_modifier6399 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PUBLIC_in_property_modifier6404 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PROTECTED_in_property_modifier6409 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INTERNAL_in_property_modifier6414 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PRIVATE_in_property_modifier6419 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STATIC_in_property_modifier6424 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_VIRTUAL_in_property_modifier6429 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_SEALED_in_property_modifier6434 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OVERRIDE_in_property_modifier6439 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_ABSTRACT_in_property_modifier6444 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_EXTERN_in_property_modifier6449 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_property_modifier_unsafe_in_property_modifier6454 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_accessor_declarations6470 = new BitSet(new long[]{0x0000000000000000L,0x0000000000020400L,0x00000000000000C0L});
    public static final BitSet FOLLOW_accessor_modifier_in_accessor_declarations6479 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_get_contextual_keyword_in_accessor_declarations6489 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_accessor_body_in_accessor_declarations6491 = new BitSet(new long[]{0x0000000000000002L,0x0000040000020400L,0x00000000000000C0L});
    public static final BitSet FOLLOW_set_accessor_declaration_in_accessor_declarations6493 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_set_contextual_keyword_in_accessor_declarations6502 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_accessor_body_in_accessor_declarations6504 = new BitSet(new long[]{0x0000000000000002L,0x0000040000020400L,0x00000000000000C0L});
    public static final BitSet FOLLOW_get_accessor_declaration_in_accessor_declarations6506 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_get_accessor_declaration6525 = new BitSet(new long[]{0x0000000000000000L,0x0000000000020400L,0x00000000000000C0L});
    public static final BitSet FOLLOW_accessor_modifier_in_get_accessor_declaration6528 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_get_contextual_keyword_in_get_accessor_declaration6531 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_accessor_body_in_get_accessor_declaration6533 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_set_accessor_declaration6544 = new BitSet(new long[]{0x0000000000000000L,0x0000000000020400L,0x00000000000000C0L});
    public static final BitSet FOLLOW_accessor_modifier_in_set_accessor_declaration6547 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_set_contextual_keyword_in_set_accessor_declaration6550 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_accessor_body_in_set_accessor_declaration6552 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PROTECTED_in_accessor_modifier6563 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INTERNAL_in_accessor_modifier6568 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PRIVATE_in_accessor_modifier6573 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PROTECTED_in_accessor_modifier6578 = new BitSet(new long[]{0x0000000000000000L,0x0000000000020000L});
    public static final BitSet FOLLOW_INTERNAL_in_accessor_modifier6580 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INTERNAL_in_accessor_modifier6585 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000080L});
    public static final BitSet FOLLOW_PROTECTED_in_accessor_modifier6587 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_block_in_accessor_body6598 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_SEMICOLON_in_accessor_body6603 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_event_declaration6617 = new BitSet(new long[]{0x0140000000000010L,0x0000000400020000L,0x00040200000001C4L,0x0000000000880000L});
    public static final BitSet FOLLOW_event_modifiers_in_event_declaration6620 = new BitSet(new long[]{0x0040000000000000L});
    public static final BitSet FOLLOW_EVENT_in_event_declaration6623 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_type_in_event_declaration6625 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_variable_declarators_in_event_declaration6633 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_event_declaration6635 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_member_name_in_event_declaration6643 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_event_declaration6645 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000400L});
    public static final BitSet FOLLOW_event_accessor_declarations_in_event_declaration6647 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_event_declaration6649 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_event_modifier_in_event_modifiers6667 = new BitSet(new long[]{0x0100000000000012L,0x0000000400020000L,0x00040200000001C4L,0x0000000000880000L});
    public static final BitSet FOLLOW_event_modifier_in_event_modifiers6671 = new BitSet(new long[]{0x0100000000000012L,0x0000000400020000L,0x00040200000001C4L,0x0000000000880000L});
    public static final BitSet FOLLOW_NEW_in_event_modifier6685 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PUBLIC_in_event_modifier6690 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PROTECTED_in_event_modifier6695 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INTERNAL_in_event_modifier6700 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PRIVATE_in_event_modifier6705 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STATIC_in_event_modifier6710 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_VIRTUAL_in_event_modifier6715 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_SEALED_in_event_modifier6720 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OVERRIDE_in_event_modifier6725 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_ABSTRACT_in_event_modifier6730 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_EXTERN_in_event_modifier6735 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_event_modifier_unsafe_in_event_modifier6740 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_event_accessor_declarations6751 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_add_contextual_keyword_in_event_accessor_declarations6759 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_block_in_event_accessor_declarations6761 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000400L});
    public static final BitSet FOLLOW_remove_accessor_declaration_in_event_accessor_declarations6763 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_remove_contextual_keyword_in_event_accessor_declarations6770 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_block_in_event_accessor_declarations6772 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000400L});
    public static final BitSet FOLLOW_add_accessor_declaration_in_event_accessor_declarations6774 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_add_accessor_declaration6790 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_add_contextual_keyword_in_add_accessor_declaration6793 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_block_in_add_accessor_declaration6795 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_remove_accessor_declaration6806 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_remove_contextual_keyword_in_remove_accessor_declaration6809 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_block_in_remove_accessor_declaration6811 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_indexer_declaration6822 = new BitSet(new long[]{0x2100100800114010L,0x0000010408024400L,0x00081300000001C4L,0x0000000001980030L});
    public static final BitSet FOLLOW_indexer_modifiers_in_indexer_declaration6825 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_indexer_declarator_in_indexer_declaration6828 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_indexer_declaration6830 = new BitSet(new long[]{0x0000000000000000L,0x0000040000020400L,0x00000000000000C0L});
    public static final BitSet FOLLOW_accessor_declarations_in_indexer_declaration6832 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_indexer_declaration6834 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_indexer_modifier_in_indexer_modifiers6845 = new BitSet(new long[]{0x0100000000000012L,0x0000000400020000L,0x00000200000001C4L,0x0000000000880000L});
    public static final BitSet FOLLOW_indexer_modifier_in_indexer_modifiers6849 = new BitSet(new long[]{0x0100000000000012L,0x0000000400020000L,0x00000200000001C4L,0x0000000000880000L});
    public static final BitSet FOLLOW_NEW_in_indexer_modifier6863 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PUBLIC_in_indexer_modifier6868 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PROTECTED_in_indexer_modifier6873 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INTERNAL_in_indexer_modifier6878 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PRIVATE_in_indexer_modifier6883 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_VIRTUAL_in_indexer_modifier6888 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_SEALED_in_indexer_modifier6893 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OVERRIDE_in_indexer_modifier6898 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_ABSTRACT_in_indexer_modifier6903 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_EXTERN_in_indexer_modifier6908 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_indexer_modifier_unsafe_in_indexer_modifier6913 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_type_in_indexer_declarator6927 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L,0x4000000000000000L});
    public static final BitSet FOLLOW_interface_type_in_indexer_declarator6930 = new BitSet(new long[]{0x0000080000000000L});
    public static final BitSet FOLLOW_DOT_in_indexer_declarator6932 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x4000000000000000L});
    public static final BitSet FOLLOW_THIS_in_indexer_declarator6936 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_OPEN_BRACKET_in_indexer_declarator6938 = new BitSet(new long[]{0x2000100800114000L,0x0000050008004400L,0x400811080000000AL,0x0000000001100030L});
    public static final BitSet FOLLOW_formal_parameter_list_in_indexer_declarator6940 = new BitSet(new long[]{0x0000000002000000L});
    public static final BitSet FOLLOW_CLOSE_BRACKET_in_indexer_declarator6942 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_operator_declaration6954 = new BitSet(new long[]{0x0100000000000000L,0x0000000000000000L,0x0004000000000100L,0x0000000000080000L});
    public static final BitSet FOLLOW_operator_modifiers_in_operator_declaration6957 = new BitSet(new long[]{0x2080100800114000L,0x0000010008005400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_operator_declarator_in_operator_declaration6959 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_operator_body_in_operator_declaration6961 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_operator_modifier_in_operator_modifiers6972 = new BitSet(new long[]{0x0100000000000002L,0x0000000000000000L,0x0004000000000100L,0x0000000000080000L});
    public static final BitSet FOLLOW_operator_modifier_in_operator_modifiers6976 = new BitSet(new long[]{0x0100000000000002L,0x0000000000000000L,0x0004000000000100L,0x0000000000080000L});
    public static final BitSet FOLLOW_PUBLIC_in_operator_modifier6990 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STATIC_in_operator_modifier6995 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_EXTERN_in_operator_modifier7000 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_operator_modifier_unsafe_in_operator_modifier7005 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_unary_operator_declarator_in_operator_declarator7025 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_binary_operator_declarator_in_operator_declarator7031 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_conversion_operator_declarator_in_operator_declarator7037 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_type_in_unary_operator_declarator7049 = new BitSet(new long[]{0x0000000000000000L,0x0000100000000000L});
    public static final BitSet FOLLOW_OPERATOR_in_unary_operator_declarator7051 = new BitSet(new long[]{0x0400000000000800L,0x0022000100000000L,0x0000000000000020L,0x0000000000000003L});
    public static final BitSet FOLLOW_overloadable_unary_operator_in_unary_operator_declarator7053 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_unary_operator_declarator7055 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_type_in_unary_operator_declarator7057 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_unary_operator_declarator7059 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_unary_operator_declarator7061 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_type_in_binary_operator_declarator7118 = new BitSet(new long[]{0x0000000000000000L,0x0000100000000000L});
    public static final BitSet FOLLOW_OPERATOR_in_binary_operator_declarator7120 = new BitSet(new long[]{0x0000020000022020L,0x08D8000110000020L,0x0002000000000030L});
    public static final BitSet FOLLOW_overloadable_binary_operator_in_binary_operator_declarator7122 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_binary_operator_declarator7124 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_type_in_binary_operator_declarator7126 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_binary_operator_declarator7128 = new BitSet(new long[]{0x0000000010000000L});
    public static final BitSet FOLLOW_COMMA_in_binary_operator_declarator7130 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_type_in_binary_operator_declarator7132 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_binary_operator_declarator7134 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_binary_operator_declarator7136 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PLUS_in_overloadable_binary_operator7147 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_MINUS_in_overloadable_binary_operator7152 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STAR_in_overloadable_binary_operator7157 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_DIV_in_overloadable_binary_operator7162 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PERCENT_in_overloadable_binary_operator7167 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_AMP_in_overloadable_binary_operator7172 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_BITWISE_OR_in_overloadable_binary_operator7177 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_CARET_in_overloadable_binary_operator7182 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_LEFT_SHIFT_in_overloadable_binary_operator7187 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_right_shift_in_overloadable_binary_operator7192 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_EQ_in_overloadable_binary_operator7197 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_NE_in_overloadable_binary_operator7202 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_GT_in_overloadable_binary_operator7207 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_LT_in_overloadable_binary_operator7212 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_GE_in_overloadable_binary_operator7217 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_LE_in_overloadable_binary_operator7222 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PLUS_in_overloadable_operator7236 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_MINUS_in_overloadable_operator7242 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_BANG_in_overloadable_operator7248 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_TILDE_in_overloadable_operator7254 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_INC_in_overloadable_operator7260 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_DEC_in_overloadable_operator7266 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_TRUE_in_overloadable_operator7272 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_FALSE_in_overloadable_operator7278 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STAR_in_overloadable_operator7284 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_DIV_in_overloadable_operator7290 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PERCENT_in_overloadable_operator7296 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_AMP_in_overloadable_operator7302 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_BITWISE_OR_in_overloadable_operator7308 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_CARET_in_overloadable_operator7314 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_LEFT_SHIFT_in_overloadable_operator7320 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_right_shift_in_overloadable_operator7326 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_EQ_in_overloadable_operator7332 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_NE_in_overloadable_operator7338 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_GT_in_overloadable_operator7344 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_LT_in_overloadable_operator7350 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_GE_in_overloadable_operator7356 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OP_LE_in_overloadable_operator7362 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IMPLICIT_in_conversion_operator_declarator7375 = new BitSet(new long[]{0x0000000000000000L,0x0000100000000000L});
    public static final BitSet FOLLOW_OPERATOR_in_conversion_operator_declarator7377 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_type_in_conversion_operator_declarator7379 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_conversion_operator_declarator7381 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_type_in_conversion_operator_declarator7383 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_conversion_operator_declarator7385 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_conversion_operator_declarator7387 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_EXPLICIT_in_conversion_operator_declarator7392 = new BitSet(new long[]{0x0000000000000000L,0x0000100000000000L});
    public static final BitSet FOLLOW_OPERATOR_in_conversion_operator_declarator7394 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_type_in_conversion_operator_declarator7396 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_conversion_operator_declarator7398 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_type_in_conversion_operator_declarator7400 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_conversion_operator_declarator7402 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_conversion_operator_declarator7404 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_block_in_operator_body7415 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_SEMICOLON_in_operator_body7420 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_constructor_declaration7431 = new BitSet(new long[]{0x0100000000000000L,0x0000000000020400L,0x00000000000001C0L,0x0000000000080000L});
    public static final BitSet FOLLOW_constructor_modifiers_in_constructor_declaration7434 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_constructor_declarator_in_constructor_declaration7437 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_constructor_body_in_constructor_declaration7439 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_constructor_modifier_in_constructor_modifiers7450 = new BitSet(new long[]{0x0100000000000002L,0x0000000000020000L,0x00000000000001C0L,0x0000000000080000L});
    public static final BitSet FOLLOW_PUBLIC_in_constructor_modifier7462 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PROTECTED_in_constructor_modifier7467 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INTERNAL_in_constructor_modifier7472 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PRIVATE_in_constructor_modifier7477 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_EXTERN_in_constructor_modifier7482 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_constructor_modifier_unsafe_in_constructor_modifier7487 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_constructor_declarator7498 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_constructor_declarator7500 = new BitSet(new long[]{0x2000100804114000L,0x0000050008004400L,0x400811080000000AL,0x0000000001100030L});
    public static final BitSet FOLLOW_formal_parameter_list_in_constructor_declarator7502 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_constructor_declarator7505 = new BitSet(new long[]{0x0000000008000002L});
    public static final BitSet FOLLOW_constructor_initializer_in_constructor_declarator7507 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_COLON_in_constructor_initializer7519 = new BitSet(new long[]{0x0000000000001000L});
    public static final BitSet FOLLOW_BASE_in_constructor_initializer7521 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_constructor_initializer7523 = new BitSet(new long[]{0x2400106804715820L,0x002209250800C400L,0x401A910C00000022L,0x000000000010007BL});
    public static final BitSet FOLLOW_argument_list_in_constructor_initializer7525 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_constructor_initializer7528 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_COLON_in_constructor_initializer7533 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x4000000000000000L});
    public static final BitSet FOLLOW_THIS_in_constructor_initializer7535 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_constructor_initializer7537 = new BitSet(new long[]{0x2400106804715820L,0x002209250800C400L,0x401A910C00000022L,0x000000000010007BL});
    public static final BitSet FOLLOW_argument_list_in_constructor_initializer7539 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_constructor_initializer7542 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_block_in_constructor_body7553 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_SEMICOLON_in_constructor_body7558 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_static_constructor_declaration7569 = new BitSet(new long[]{0x0100000000000000L,0x0000000000000000L,0x0004000000000000L,0x0000000000080000L});
    public static final BitSet FOLLOW_static_constructor_modifiers_in_static_constructor_declaration7572 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_static_constructor_declaration7574 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_static_constructor_declaration7576 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_static_constructor_declaration7578 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_static_constructor_body_in_static_constructor_declaration7580 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_static_constructor_modifiers_unsafe_in_static_constructor_modifiers7594 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_block_in_static_constructor_body7606 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_SEMICOLON_in_static_constructor_body7611 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_destructor_declaration_unsafe_in_destructor_declaration7624 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_block_in_destructor_body7635 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_SEMICOLON_in_destructor_body7640 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_block_in_body7652 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_SEMICOLON_in_body7658 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_struct_declaration7672 = new BitSet(new long[]{0x0000000000000000L,0x0000000400020400L,0x00200000000001C0L,0x0000000000080000L});
    public static final BitSet FOLLOW_struct_modifiers_in_struct_declaration7675 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L,0x0020000000000000L});
    public static final BitSet FOLLOW_partial_contextual_keyword_in_struct_declaration7678 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0020000000000000L});
    public static final BitSet FOLLOW_STRUCT_in_struct_declaration7681 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_struct_declaration7683 = new BitSet(new long[]{0x0000000008000000L,0x0000020010000400L});
    public static final BitSet FOLLOW_type_parameter_list_in_struct_declaration7685 = new BitSet(new long[]{0x0000000008000000L,0x0000020000000400L});
    public static final BitSet FOLLOW_struct_interfaces_in_struct_declaration7688 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000400L});
    public static final BitSet FOLLOW_type_parameter_constraints_clauses_in_struct_declaration7691 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_struct_body_in_struct_declaration7694 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_struct_declaration7696 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_struct_modifier_in_struct_modifiers7708 = new BitSet(new long[]{0x0000000000000002L,0x0000000400020000L,0x00000000000001C0L,0x0000000000080000L});
    public static final BitSet FOLLOW_struct_modifier_in_struct_modifiers7712 = new BitSet(new long[]{0x0000000000000002L,0x0000000400020000L,0x00000000000001C0L,0x0000000000080000L});
    public static final BitSet FOLLOW_NEW_in_struct_modifier7726 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PUBLIC_in_struct_modifier7731 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PROTECTED_in_struct_modifier7736 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INTERNAL_in_struct_modifier7741 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PRIVATE_in_struct_modifier7746 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_struct_modifier_unsafe_in_struct_modifier7751 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_COLON_in_struct_interfaces7762 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_interface_type_list_in_struct_interfaces7764 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_struct_body7775 = new BitSet(new long[]{0x31E0104821914010L,0x0000050408035400L,0x002C1302000001C4L,0x0000000003980030L});
    public static final BitSet FOLLOW_struct_member_declarations_in_struct_body7777 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_struct_body7780 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_struct_member_declaration_in_struct_member_declarations7791 = new BitSet(new long[]{0x31E0104820914012L,0x0000050408035400L,0x002C1302000001C4L,0x0000000003980030L});
    public static final BitSet FOLLOW_struct_member_declaration_in_struct_member_declarations7795 = new BitSet(new long[]{0x31E0104820914012L,0x0000050408035400L,0x002C1302000001C4L,0x0000000003980030L});
    public static final BitSet FOLLOW_attributes_in_struct_member_declaration7811 = new BitSet(new long[]{0x31E0104820914010L,0x0000010408035400L,0x002C1302000001C4L,0x0000000003980030L});
    public static final BitSet FOLLOW_all_member_modifiers_in_struct_member_declaration7814 = new BitSet(new long[]{0x30E0104820914000L,0x0000010008015400L,0x0028110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_common_member_declaration_in_struct_member_declaration7821 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_FIXED_in_struct_member_declaration7827 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_buffer_element_type_in_struct_member_declaration7829 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_fixed_size_buffer_declarators_in_struct_member_declaration7831 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_struct_member_declaration7833 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_base_type_in_array_type7853 = new BitSet(new long[]{0x0000000000000000L,0x0000040000040000L,0x0002000000000000L});
    public static final BitSet FOLLOW_rank_specifier_in_array_type7865 = new BitSet(new long[]{0x0000000000000002L,0x0000040000040000L,0x0002000000000000L});
    public static final BitSet FOLLOW_base_type_in_non_array_type7882 = new BitSet(new long[]{0x0000000000000002L,0x0000040000040000L,0x0002000000000000L});
    public static final BitSet FOLLOW_rank_specifier_in_non_array_type7885 = new BitSet(new long[]{0x0000000000000002L,0x0000040000040000L,0x0002000000000000L});
    public static final BitSet FOLLOW_INTERR_in_non_array_type7889 = new BitSet(new long[]{0x0000000000000002L,0x0000040000040000L,0x0002000000000000L});
    public static final BitSet FOLLOW_STAR_in_non_array_type7893 = new BitSet(new long[]{0x0000000000000002L,0x0000040000040000L,0x0002000000000000L});
    public static final BitSet FOLLOW_rank_specifier_in_rank_specifiers7911 = new BitSet(new long[]{0x0000000000000002L,0x0000040000000000L});
    public static final BitSet FOLLOW_OPEN_BRACKET_in_rank_specifier7926 = new BitSet(new long[]{0x0000000012000000L});
    public static final BitSet FOLLOW_dim_separators_in_rank_specifier7928 = new BitSet(new long[]{0x0000000002000000L});
    public static final BitSet FOLLOW_CLOSE_BRACKET_in_rank_specifier7931 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_COMMA_in_dim_separators7942 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_dim_separators7946 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_array_initializer7965 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_array_initializer7967 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_array_initializer7973 = new BitSet(new long[]{0x2400106800715820L,0x00220B250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_variable_initializer_list_in_array_initializer7975 = new BitSet(new long[]{0x0000000011000000L});
    public static final BitSet FOLLOW_COMMA_in_array_initializer7977 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_array_initializer7980 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_variable_initializer_in_variable_initializer_list7992 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_variable_initializer_list7996 = new BitSet(new long[]{0x2400106800715820L,0x00220B250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_variable_initializer_in_variable_initializer_list7999 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_attributes_in_interface_declaration8014 = new BitSet(new long[]{0x0000000000000000L,0x0000000400030400L,0x00000000000001C0L,0x0000000000080000L});
    public static final BitSet FOLLOW_interface_modifiers_in_interface_declaration8017 = new BitSet(new long[]{0x0000000000000000L,0x0000000000010400L});
    public static final BitSet FOLLOW_partial_contextual_keyword_in_interface_declaration8020 = new BitSet(new long[]{0x0000000000000000L,0x0000000000010000L});
    public static final BitSet FOLLOW_INTERFACE_in_interface_declaration8023 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_interface_declaration8025 = new BitSet(new long[]{0x0000000008000000L,0x0000020010000400L});
    public static final BitSet FOLLOW_variant_type_parameter_list_in_interface_declaration8027 = new BitSet(new long[]{0x0000000008000000L,0x0000020000000400L});
    public static final BitSet FOLLOW_interface_base_in_interface_declaration8030 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000400L});
    public static final BitSet FOLLOW_type_parameter_constraints_clauses_in_interface_declaration8033 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_interface_body_in_interface_declaration8036 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_interface_declaration8038 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_interface_modifier_in_interface_modifiers8050 = new BitSet(new long[]{0x0000000000000002L,0x0000000400020000L,0x00000000000001C0L,0x0000000000080000L});
    public static final BitSet FOLLOW_interface_modifier_in_interface_modifiers8054 = new BitSet(new long[]{0x0000000000000002L,0x0000000400020000L,0x00000000000001C0L,0x0000000000080000L});
    public static final BitSet FOLLOW_NEW_in_interface_modifier8068 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PUBLIC_in_interface_modifier8073 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PROTECTED_in_interface_modifier8078 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INTERNAL_in_interface_modifier8083 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PRIVATE_in_interface_modifier8088 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_interface_modifier_unsafe_in_interface_modifier8093 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_LT_in_variant_type_parameter_list8104 = new BitSet(new long[]{0x0000000000000000L,0x0000040000002400L,0x0000000000000002L});
    public static final BitSet FOLLOW_variant_type_parameters_in_variant_type_parameter_list8106 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000020L});
    public static final BitSet FOLLOW_GT_in_variant_type_parameter_list8108 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_variant_type_parameters8119 = new BitSet(new long[]{0x0000000000000000L,0x0000000000002400L,0x0000000000000002L});
    public static final BitSet FOLLOW_variance_annotation_in_variant_type_parameters8122 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_type_parameter_in_variant_type_parameters8125 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_variant_type_parameters8129 = new BitSet(new long[]{0x0000000000000000L,0x0000040000002400L,0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_variant_type_parameters8132 = new BitSet(new long[]{0x0000000000000000L,0x0000000000002400L,0x0000000000000002L});
    public static final BitSet FOLLOW_variance_annotation_in_variant_type_parameters8136 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_type_parameter_in_variant_type_parameters8140 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COLON_in_interface_base8170 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_interface_type_list_in_interface_base8172 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_interface_body8183 = new BitSet(new long[]{0x2040100801114000L,0x0000050408004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_interface_member_declarations_in_interface_body8185 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_interface_body8188 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_interface_member_declaration_in_interface_member_declarations8199 = new BitSet(new long[]{0x2040100800114002L,0x0000050408004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_attributes_in_interface_member_declaration8214 = new BitSet(new long[]{0x2040100800114000L,0x0000010408004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_NEW_in_interface_member_declaration8217 = new BitSet(new long[]{0x2040100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_type_in_interface_member_declaration8226 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L,0x4000000000000000L});
    public static final BitSet FOLLOW_IDENTIFIER_in_interface_member_declaration8236 = new BitSet(new long[]{0x0000000000000000L,0x0000080010000000L});
    public static final BitSet FOLLOW_type_parameter_list_in_interface_member_declaration8238 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_interface_member_declaration8241 = new BitSet(new long[]{0x2000100804114000L,0x0000050008004400L,0x400811080000000AL,0x0000000001100030L});
    public static final BitSet FOLLOW_formal_parameter_list_in_interface_member_declaration8243 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_interface_member_declaration8246 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L,0x0000040000000000L});
    public static final BitSet FOLLOW_type_parameter_constraints_clauses_in_interface_member_declaration8248 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_interface_member_declaration8251 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_interface_member_declaration8261 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_interface_member_declaration8263 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000400L});
    public static final BitSet FOLLOW_interface_accessors_in_interface_member_declaration8265 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_interface_member_declaration8267 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_THIS_in_interface_member_declaration8277 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_OPEN_BRACKET_in_interface_member_declaration8279 = new BitSet(new long[]{0x2000100800114000L,0x0000050008004400L,0x400811080000000AL,0x0000000001100030L});
    public static final BitSet FOLLOW_formal_parameter_list_in_interface_member_declaration8281 = new BitSet(new long[]{0x0000000002000000L});
    public static final BitSet FOLLOW_CLOSE_BRACKET_in_interface_member_declaration8283 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_interface_member_declaration8285 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000400L});
    public static final BitSet FOLLOW_interface_accessors_in_interface_member_declaration8287 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_interface_member_declaration8289 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_VOID_in_interface_member_declaration8305 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_interface_member_declaration8307 = new BitSet(new long[]{0x0000000000000000L,0x0000080010000000L});
    public static final BitSet FOLLOW_type_parameter_list_in_interface_member_declaration8309 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_interface_member_declaration8312 = new BitSet(new long[]{0x2000100804114000L,0x0000050008004400L,0x400811080000000AL,0x0000000001100030L});
    public static final BitSet FOLLOW_formal_parameter_list_in_interface_member_declaration8314 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_interface_member_declaration8317 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L,0x0000040000000000L});
    public static final BitSet FOLLOW_type_parameter_constraints_clauses_in_interface_member_declaration8319 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_interface_member_declaration8322 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_EVENT_in_interface_member_declaration8330 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_type_in_interface_member_declaration8332 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_interface_member_declaration8334 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_interface_member_declaration8336 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_interface_method_declaration8354 = new BitSet(new long[]{0x2000100800114000L,0x0000010408004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_NEW_in_interface_method_declaration8357 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_return_type_in_interface_method_declaration8360 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_interface_method_declaration8362 = new BitSet(new long[]{0x0000000000000000L,0x0000080010000000L});
    public static final BitSet FOLLOW_type_parameter_list_in_interface_method_declaration8364 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_interface_method_declaration8367 = new BitSet(new long[]{0x2000100804114000L,0x0000050008004400L,0x400811080000000AL,0x0000000001100030L});
    public static final BitSet FOLLOW_formal_parameter_list_in_interface_method_declaration8369 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_interface_method_declaration8372 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L,0x0000040000000000L});
    public static final BitSet FOLLOW_type_parameter_constraints_clauses_in_interface_method_declaration8374 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_interface_method_declaration8377 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_interface_property_declaration8388 = new BitSet(new long[]{0x2000100800114000L,0x0000010408004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_NEW_in_interface_property_declaration8391 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_type_in_interface_property_declaration8394 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_interface_property_declaration8396 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_interface_property_declaration8398 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000400L});
    public static final BitSet FOLLOW_interface_accessors_in_interface_property_declaration8400 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_interface_property_declaration8402 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_interface_accessors8416 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_get_contextual_keyword_in_interface_accessors8425 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_interface_accessors8427 = new BitSet(new long[]{0x0000000000000002L,0x0000040000000400L});
    public static final BitSet FOLLOW_attributes_in_interface_accessors8430 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_set_contextual_keyword_in_interface_accessors8433 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_interface_accessors8435 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_set_contextual_keyword_in_interface_accessors8445 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_interface_accessors8447 = new BitSet(new long[]{0x0000000000000002L,0x0000040000000400L});
    public static final BitSet FOLLOW_attributes_in_interface_accessors8450 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_get_contextual_keyword_in_interface_accessors8453 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_interface_accessors8455 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_interface_event_declaration8475 = new BitSet(new long[]{0x0040000000000000L,0x0000000400000000L});
    public static final BitSet FOLLOW_NEW_in_interface_event_declaration8478 = new BitSet(new long[]{0x0040000000000000L});
    public static final BitSet FOLLOW_EVENT_in_interface_event_declaration8481 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_type_in_interface_event_declaration8483 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_interface_event_declaration8485 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_interface_event_declaration8487 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_interface_indexer_declaration8498 = new BitSet(new long[]{0x2000100800114000L,0x0000010408004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_NEW_in_interface_indexer_declaration8501 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_type_in_interface_indexer_declaration8504 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x4000000000000000L});
    public static final BitSet FOLLOW_THIS_in_interface_indexer_declaration8506 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_OPEN_BRACKET_in_interface_indexer_declaration8508 = new BitSet(new long[]{0x2000100800114000L,0x0000050008004400L,0x400811080000000AL,0x0000000001100030L});
    public static final BitSet FOLLOW_formal_parameter_list_in_interface_indexer_declaration8510 = new BitSet(new long[]{0x0000000002000000L});
    public static final BitSet FOLLOW_CLOSE_BRACKET_in_interface_indexer_declaration8512 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_interface_indexer_declaration8514 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000400L});
    public static final BitSet FOLLOW_interface_accessors_in_interface_indexer_declaration8516 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_interface_indexer_declaration8518 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_enum_declaration8532 = new BitSet(new long[]{0x0020000000000000L,0x0000000400020000L,0x00000000000001C0L});
    public static final BitSet FOLLOW_enum_modifiers_in_enum_declaration8535 = new BitSet(new long[]{0x0020000000000000L});
    public static final BitSet FOLLOW_ENUM_in_enum_declaration8538 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_enum_declaration8540 = new BitSet(new long[]{0x0000000008000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_enum_base_in_enum_declaration8542 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_enum_body_in_enum_declaration8545 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_enum_declaration8547 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_COLON_in_enum_base8559 = new BitSet(new long[]{0x0000000000110000L,0x0000000008004000L,0x0000110000000000L,0x0000000000100030L});
    public static final BitSet FOLLOW_integral_type_in_enum_base8561 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_enum_body8575 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_enum_body8577 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_enum_body8583 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000400L});
    public static final BitSet FOLLOW_enum_member_declarations_in_enum_body8585 = new BitSet(new long[]{0x0000000011000000L});
    public static final BitSet FOLLOW_COMMA_in_enum_body8587 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_enum_body8590 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_enum_modifier_in_enum_modifiers8602 = new BitSet(new long[]{0x0000000000000002L,0x0000000400020000L,0x00000000000001C0L});
    public static final BitSet FOLLOW_enum_member_declaration_in_enum_member_declarations8645 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_enum_member_declarations8649 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000400L});
    public static final BitSet FOLLOW_enum_member_declaration_in_enum_member_declarations8652 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_attributes_in_enum_member_declaration8669 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_enum_member_declaration8672 = new BitSet(new long[]{0x0000000000000082L});
    public static final BitSet FOLLOW_ASSIGNMENT_in_enum_member_declaration8675 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_constant_expression_in_enum_member_declaration8677 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_delegate_declaration8693 = new BitSet(new long[]{0x0000004000000000L,0x0000000400020000L,0x00000000000001C0L,0x0000000000080000L});
    public static final BitSet FOLLOW_delegate_modifiers_in_delegate_declaration8696 = new BitSet(new long[]{0x0000004000000000L});
    public static final BitSet FOLLOW_DELEGATE_in_delegate_declaration8699 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_return_type_in_delegate_declaration8701 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_delegate_declaration8703 = new BitSet(new long[]{0x0000000000000000L,0x0000080010000000L});
    public static final BitSet FOLLOW_variant_type_parameter_list_in_delegate_declaration8705 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_delegate_declaration8714 = new BitSet(new long[]{0x2000100804114000L,0x0000050008004400L,0x400811080000000AL,0x0000000001100030L});
    public static final BitSet FOLLOW_formal_parameter_list_in_delegate_declaration8716 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_delegate_declaration8719 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L,0x0000040000000000L});
    public static final BitSet FOLLOW_type_parameter_constraints_clauses_in_delegate_declaration8721 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_delegate_declaration8724 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_delegate_modifier_in_delegate_modifiers8735 = new BitSet(new long[]{0x0000000000000002L,0x0000000400020000L,0x00000000000001C0L,0x0000000000080000L});
    public static final BitSet FOLLOW_delegate_modifier_in_delegate_modifiers8739 = new BitSet(new long[]{0x0000000000000002L,0x0000000400020000L,0x00000000000001C0L,0x0000000000080000L});
    public static final BitSet FOLLOW_NEW_in_delegate_modifier8753 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PUBLIC_in_delegate_modifier8758 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PROTECTED_in_delegate_modifier8763 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INTERNAL_in_delegate_modifier8768 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PRIVATE_in_delegate_modifier8773 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_delegate_modifier_unsafe_in_delegate_modifier8778 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_global_attribute_sections_in_global_attributes8793 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_global_attribute_section_in_global_attribute_sections8804 = new BitSet(new long[]{0x0000000000000002L,0x0000040000000000L});
    public static final BitSet FOLLOW_OPEN_BRACKET_in_global_attribute_section8819 = new BitSet(new long[]{0xFDF0146860DDD050L,0x000011260C0B7C10L,0xC06D931A000001CEL,0x0000000013B8007EL});
    public static final BitSet FOLLOW_global_attribute_target_specifier_in_global_attribute_section8821 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_attribute_list_in_global_attribute_section8823 = new BitSet(new long[]{0x0000000012000000L});
    public static final BitSet FOLLOW_COMMA_in_global_attribute_section8825 = new BitSet(new long[]{0x0000000002000000L});
    public static final BitSet FOLLOW_CLOSE_BRACKET_in_global_attribute_section8828 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_global_attribute_target_in_global_attribute_target_specifier8840 = new BitSet(new long[]{0x0000000008000000L});
    public static final BitSet FOLLOW_COLON_in_global_attribute_target_specifier8842 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_keyword_in_global_attribute_target8854 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_global_attribute_target8860 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attribute_sections_in_attributes8874 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attribute_section_in_attribute_sections8885 = new BitSet(new long[]{0x0000000000000002L,0x0000040000000000L});
    public static final BitSet FOLLOW_OPEN_BRACKET_in_attribute_section8900 = new BitSet(new long[]{0xFDF0146860DDD050L,0x000011260C0B7C10L,0xC06D931A000001CEL,0x0000000013B8007EL});
    public static final BitSet FOLLOW_attribute_target_specifier_in_attribute_section8902 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_attribute_list_in_attribute_section8905 = new BitSet(new long[]{0x0000000012000000L});
    public static final BitSet FOLLOW_COMMA_in_attribute_section8907 = new BitSet(new long[]{0x0000000002000000L});
    public static final BitSet FOLLOW_CLOSE_BRACKET_in_attribute_section8910 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attribute_target_in_attribute_target_specifier8922 = new BitSet(new long[]{0x0000000008000000L});
    public static final BitSet FOLLOW_COLON_in_attribute_target_specifier8924 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_keyword_in_attribute_target8936 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_attribute_target8942 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attribute_in_attribute_list8956 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_attribute_list8960 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_attribute_in_attribute_list8963 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_attribute_name_in_attribute8977 = new BitSet(new long[]{0x0000000000000002L,0x0000080000000000L});
    public static final BitSet FOLLOW_attribute_arguments_in_attribute8979 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_type_name_in_attribute_name8991 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_attribute_arguments9008 = new BitSet(new long[]{0x2400106804715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_positional_argument_list_in_attribute_arguments9010 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_attribute_arguments9013 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_positional_argument_in_positional_argument_list9027 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_positional_argument_list9036 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_positional_argument_in_positional_argument_list9041 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_attribute_argument_expression_in_positional_argument9057 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_named_argument_in_named_argument_list9070 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_named_argument_list9074 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_named_argument_in_named_argument_list9077 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_named_argument9093 = new BitSet(new long[]{0x0000000000000080L});
    public static final BitSet FOLLOW_ASSIGNMENT_in_named_argument9095 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_attribute_argument_expression_in_named_argument9097 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_expression_in_attribute_argument_expression9108 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_UNSAFE_in_class_modifier_unsafe9122 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_UNSAFE_in_struct_modifier_unsafe9133 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_UNSAFE_in_interface_modifier_unsafe9144 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_UNSAFE_in_delegate_modifier_unsafe9155 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_UNSAFE_in_field_modifier_unsafe9166 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_UNSAFE_in_method_modifier_unsafe9177 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_UNSAFE_in_property_modifier_unsafe9188 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_UNSAFE_in_event_modifier_unsafe9199 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_UNSAFE_in_indexer_modifier_unsafe9210 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_UNSAFE_in_operator_modifier_unsafe9221 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_UNSAFE_in_constructor_modifier_unsafe9232 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_destructor_declaration_unsafe9246 = new BitSet(new long[]{0x0100000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000080001L});
    public static final BitSet FOLLOW_EXTERN_in_destructor_declaration_unsafe9255 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000080001L});
    public static final BitSet FOLLOW_UNSAFE_in_destructor_declaration_unsafe9258 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000001L});
    public static final BitSet FOLLOW_UNSAFE_in_destructor_declaration_unsafe9267 = new BitSet(new long[]{0x0100000000000000L});
    public static final BitSet FOLLOW_EXTERN_in_destructor_declaration_unsafe9269 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000001L});
    public static final BitSet FOLLOW_TILDE_in_destructor_declaration_unsafe9283 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_destructor_declaration_unsafe9285 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_destructor_declaration_unsafe9287 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_destructor_declaration_unsafe9289 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_destructor_body_in_destructor_declaration_unsafe9291 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STATIC_in_static_constructor_modifiers_unsafe9315 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_EXTERN_in_static_constructor_modifiers_unsafe9321 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000080000L});
    public static final BitSet FOLLOW_UNSAFE_in_static_constructor_modifiers_unsafe9323 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0004000000000000L});
    public static final BitSet FOLLOW_STATIC_in_static_constructor_modifiers_unsafe9325 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_UNSAFE_in_static_constructor_modifiers_unsafe9331 = new BitSet(new long[]{0x0100000000000000L});
    public static final BitSet FOLLOW_EXTERN_in_static_constructor_modifiers_unsafe9333 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0004000000000000L});
    public static final BitSet FOLLOW_STATIC_in_static_constructor_modifiers_unsafe9335 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_EXTERN_in_static_constructor_modifiers_unsafe9341 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0004000000000000L});
    public static final BitSet FOLLOW_STATIC_in_static_constructor_modifiers_unsafe9343 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000080000L});
    public static final BitSet FOLLOW_UNSAFE_in_static_constructor_modifiers_unsafe9345 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_UNSAFE_in_static_constructor_modifiers_unsafe9351 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0004000000000000L});
    public static final BitSet FOLLOW_STATIC_in_static_constructor_modifiers_unsafe9353 = new BitSet(new long[]{0x0100000000000000L});
    public static final BitSet FOLLOW_EXTERN_in_static_constructor_modifiers_unsafe9355 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STATIC_in_static_constructor_modifiers_unsafe9361 = new BitSet(new long[]{0x0100000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000080000L});
    public static final BitSet FOLLOW_set_in_static_constructor_modifiers_unsafe9363 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STATIC_in_static_constructor_modifiers_unsafe9375 = new BitSet(new long[]{0x0100000000000000L});
    public static final BitSet FOLLOW_EXTERN_in_static_constructor_modifiers_unsafe9377 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000080000L});
    public static final BitSet FOLLOW_UNSAFE_in_static_constructor_modifiers_unsafe9379 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STATIC_in_static_constructor_modifiers_unsafe9385 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000080000L});
    public static final BitSet FOLLOW_UNSAFE_in_static_constructor_modifiers_unsafe9387 = new BitSet(new long[]{0x0100000000000000L});
    public static final BitSet FOLLOW_EXTERN_in_static_constructor_modifiers_unsafe9389 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_unsafe_statement_in_embedded_statement_unsafe9403 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_fixed_statement_in_embedded_statement_unsafe9408 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_UNSAFE_in_unsafe_statement9419 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_block_in_unsafe_statement9421 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_pointer_type_in_type_unsafe9432 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_simple_type_in_pointer_type9454 = new BitSet(new long[]{0x0000000000000000L,0x0000040000040000L,0x0002000000000000L});
    public static final BitSet FOLLOW_class_type_in_pointer_type9461 = new BitSet(new long[]{0x0000000000000000L,0x0000040000040000L,0x0002000000000000L});
    public static final BitSet FOLLOW_VOID_in_pointer_type9468 = new BitSet(new long[]{0x0000000000000000L,0x0000040000040000L,0x0002000000000000L});
    public static final BitSet FOLLOW_rank_specifier_in_pointer_type9482 = new BitSet(new long[]{0x0000000000000000L,0x0000040000040000L,0x0002000000000000L});
    public static final BitSet FOLLOW_INTERR_in_pointer_type9494 = new BitSet(new long[]{0x0000000000000000L,0x0000040000040000L,0x0002000000000000L});
    public static final BitSet FOLLOW_STAR_in_pointer_type9502 = new BitSet(new long[]{0x0000000000000000L,0x0000040000040000L,0x0002000000000000L});
    public static final BitSet FOLLOW_STAR_in_pointer_type9513 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_type_in_unmanaged_type9536 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_primary_expression_in_primary_no_array_creation_expression_unsafe9549 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_pointer_indirection_expression_in_unary_expression_unsafe9562 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_addressof_expression_in_unary_expression_unsafe9567 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STAR_in_pointer_indirection_expression9578 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_unary_expression_in_pointer_indirection_expression9580 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_AMP_in_addressof_expression9597 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_unary_expression_in_addressof_expression9599 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_SIZEOF_in_sizeof_expression9610 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_sizeof_expression9612 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_unmanaged_type_in_sizeof_expression9614 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_sizeof_expression9616 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_FIXED_in_fixed_statement9627 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_fixed_statement9629 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_pointer_type_in_fixed_statement9631 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_fixed_pointer_declarators_in_fixed_statement9633 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_fixed_statement9635 = new BitSet(new long[]{0xF40014684071D820L,0x00220B250C00CC10L,0xC05A951400000020L,0x000000001038007FL});
    public static final BitSet FOLLOW_embedded_statement_in_fixed_statement9637 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_fixed_pointer_declarator_in_fixed_pointer_declarators9648 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_COMMA_in_fixed_pointer_declarators9652 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_fixed_pointer_declarator_in_fixed_pointer_declarators9655 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_fixed_pointer_declarator9669 = new BitSet(new long[]{0x0000000000000080L});
    public static final BitSet FOLLOW_ASSIGNMENT_in_fixed_pointer_declarator9671 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_fixed_pointer_initializer_in_fixed_pointer_declarator9673 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_AMP_in_fixed_pointer_initializer9693 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_variable_reference_in_fixed_pointer_initializer9695 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_expression_in_fixed_pointer_initializer9701 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_fixed_size_buffer_declaration_in_struct_member_declaration_unsafe9713 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_fixed_size_buffer_declaration9724 = new BitSet(new long[]{0x1000000000000000L,0x0000000400020000L,0x00000000000001C0L,0x0000000000080000L});
    public static final BitSet FOLLOW_fixed_size_buffer_modifiers_in_fixed_size_buffer_declaration9727 = new BitSet(new long[]{0x1000000000000000L});
    public static final BitSet FOLLOW_FIXED_in_fixed_size_buffer_declaration9730 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_buffer_element_type_in_fixed_size_buffer_declaration9732 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_fixed_size_buffer_declarators_in_fixed_size_buffer_declaration9734 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_fixed_size_buffer_declaration9736 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_fixed_size_buffer_modifier_in_fixed_size_buffer_modifiers9747 = new BitSet(new long[]{0x0000000000000002L,0x0000000400020000L,0x00000000000001C0L,0x0000000000080000L});
    public static final BitSet FOLLOW_type_in_buffer_element_type9795 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_fixed_size_buffer_declarator_in_fixed_size_buffer_declarators9806 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_fixed_size_buffer_declarator9818 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_OPEN_BRACKET_in_fixed_size_buffer_declarator9820 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_constant_expression_in_fixed_size_buffer_declarator9822 = new BitSet(new long[]{0x0000000002000000L});
    public static final BitSet FOLLOW_CLOSE_BRACKET_in_fixed_size_buffer_declarator9824 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_stackalloc_initializer_in_local_variable_initializer_unsafe9837 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STACKALLOC_in_stackalloc_initializer9848 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_unmanaged_type_in_stackalloc_initializer9850 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_OPEN_BRACKET_in_stackalloc_initializer9852 = new BitSet(new long[]{0x2400106800715820L,0x002209250800C400L,0x401A910400000020L,0x000000000010007BL});
    public static final BitSet FOLLOW_expression_in_stackalloc_initializer9854 = new BitSet(new long[]{0x0000000002000000L});
    public static final BitSet FOLLOW_CLOSE_BRACKET_in_stackalloc_initializer9856 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_from_contextual_keyword9878 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_let_contextual_keyword9892 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_where_contextual_keyword9906 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_join_contextual_keyword9920 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_on_contextual_keyword9934 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_equals_contextual_keyword9948 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_into_contextual_keyword9962 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_orderby_contextual_keyword9976 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_ascending_contextual_keyword9990 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_descending_contextual_keyword10004 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_select_contextual_keyword10018 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_group_contextual_keyword10032 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_by_contextual_keyword10046 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_partial_contextual_keyword10060 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_alias_contextual_keyword10074 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_yield_contextual_keyword10088 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_get_contextual_keyword10102 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_set_contextual_keyword10116 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_add_contextual_keyword10130 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_remove_contextual_keyword10144 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_dynamic_contextual_keyword10158 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_arglist10172 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_ASSIGNMENT_in_right_arrow10186 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000020L});
    public static final BitSet FOLLOW_GT_in_right_arrow10190 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_GT_in_right_shift10207 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000020L});
    public static final BitSet FOLLOW_GT_in_right_shift10211 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_GT_in_right_shift_assignment10228 = new BitSet(new long[]{0x0000000000000000L,0x0010000000000000L});
    public static final BitSet FOLLOW_OP_GE_in_right_shift_assignment10232 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_boolean_literal_in_literal10247 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INTEGER_LITERAL_in_literal10253 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_REAL_LITERAL_in_literal10259 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_CHARACTER_LITERAL_in_literal10265 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STRING_LITERAL_in_literal10271 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_NULL_in_literal10277 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_CLASS_in_class_definition10779 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_class_definition10781 = new BitSet(new long[]{0x0000000008000000L,0x0000020010000400L});
    public static final BitSet FOLLOW_type_parameter_list_in_class_definition10783 = new BitSet(new long[]{0x0000000008000000L,0x0000020000000400L});
    public static final BitSet FOLLOW_class_base_in_class_definition10786 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000400L});
    public static final BitSet FOLLOW_type_parameter_constraints_clauses_in_class_definition10789 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_class_body_in_class_definition10798 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_class_definition10800 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STRUCT_in_struct_definition10813 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_struct_definition10815 = new BitSet(new long[]{0x0000000008000000L,0x0000020010000400L});
    public static final BitSet FOLLOW_type_parameter_list_in_struct_definition10817 = new BitSet(new long[]{0x0000000008000000L,0x0000020000000400L});
    public static final BitSet FOLLOW_struct_interfaces_in_struct_definition10820 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000400L});
    public static final BitSet FOLLOW_type_parameter_constraints_clauses_in_struct_definition10823 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_struct_body_in_struct_definition10832 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_struct_definition10834 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INTERFACE_in_interface_definition10847 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_interface_definition10849 = new BitSet(new long[]{0x0000000008000000L,0x0000020010000400L});
    public static final BitSet FOLLOW_variant_type_parameter_list_in_interface_definition10851 = new BitSet(new long[]{0x0000000008000000L,0x0000020000000400L});
    public static final BitSet FOLLOW_interface_base_in_interface_definition10854 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000400L});
    public static final BitSet FOLLOW_type_parameter_constraints_clauses_in_interface_definition10863 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_interface_body_in_interface_definition10866 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_interface_definition10868 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_ENUM_in_enum_definition10881 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_enum_definition10883 = new BitSet(new long[]{0x0000000008000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_enum_base_in_enum_definition10885 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_enum_body_in_enum_definition10888 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_enum_definition10890 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_DELEGATE_in_delegate_definition10903 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_return_type_in_delegate_definition10905 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_delegate_definition10907 = new BitSet(new long[]{0x0000000000000000L,0x0000080010000000L});
    public static final BitSet FOLLOW_variant_type_parameter_list_in_delegate_definition10909 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_delegate_definition10912 = new BitSet(new long[]{0x2000100804114000L,0x0000050008004400L,0x400811080000000AL,0x0000000001100030L});
    public static final BitSet FOLLOW_formal_parameter_list_in_delegate_definition10920 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_delegate_definition10923 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L,0x0000040000000000L});
    public static final BitSet FOLLOW_type_parameter_constraints_clauses_in_delegate_definition10925 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_delegate_definition10928 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_method_member_name_in_method_definition10940 = new BitSet(new long[]{0x0000000000000000L,0x0000080010000000L});
    public static final BitSet FOLLOW_type_parameter_list_in_method_definition10942 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_method_definition10945 = new BitSet(new long[]{0x2000100804114000L,0x0000050008004400L,0x400811080000000AL,0x0000000001100030L});
    public static final BitSet FOLLOW_formal_parameter_list_in_method_definition10947 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_method_definition10950 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000400L,0x0000040000000000L});
    public static final BitSet FOLLOW_type_parameter_constraints_clauses_in_method_definition10959 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_method_body_in_method_definition10962 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_method_member_name10977 = new BitSet(new long[]{0x0000080000000002L,0x0000000010000000L});
    public static final BitSet FOLLOW_IDENTIFIER_in_method_member_name10985 = new BitSet(new long[]{0x0000400000000000L});
    public static final BitSet FOLLOW_DOUBLE_COLON_in_method_member_name10987 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_method_member_name10989 = new BitSet(new long[]{0x0000080000000002L,0x0000000010000000L});
    public static final BitSet FOLLOW_type_argument_list_opt_in_method_member_name10998 = new BitSet(new long[]{0x0000080000000000L});
    public static final BitSet FOLLOW_DOT_in_method_member_name11000 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_method_member_name11002 = new BitSet(new long[]{0x0000080000000002L,0x0000000010000000L});
    public static final BitSet FOLLOW_variable_declarators_in_field_declaration211017 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_field_declaration211019 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_member_name_in_property_declaration211031 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_property_declaration211033 = new BitSet(new long[]{0x0000000000000000L,0x0000040000020400L,0x00000000000000C0L});
    public static final BitSet FOLLOW_accessor_declarations_in_property_declaration211035 = new BitSet(new long[]{0x0000000001000000L});
    public static final BitSet FOLLOW_CLOSE_BRACE_in_property_declaration211037 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_CONST_in_constant_declaration211049 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_type_in_constant_declaration211051 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_constant_declarators_in_constant_declaration211053 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_SEMICOLON_in_constant_declaration211055 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPERATOR_in_operator_declaration211068 = new BitSet(new long[]{0x0400020000022820L,0x08FA000110000020L,0x0002000000000030L,0x0000000000000003L});
    public static final BitSet FOLLOW_overloadable_operator_in_operator_declaration211070 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_operator_declaration211072 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_type_in_operator_declaration211074 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_operator_declaration211076 = new BitSet(new long[]{0x0000000014000000L});
    public static final BitSet FOLLOW_COMMA_in_operator_declaration211088 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004400L,0x0008110000000000L,0x0000000001100030L});
    public static final BitSet FOLLOW_type_in_operator_declaration211090 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_operator_declaration211092 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_operator_declaration211096 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_operator_body_in_operator_declaration211098 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_DOT_in_member_access211111 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_member_access211113 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
    public static final BitSet FOLLOW_type_argument_list_opt_in_member_access211115 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_method_invocation211127 = new BitSet(new long[]{0x2400106804715820L,0x002209250800C400L,0x401A910C00000022L,0x000000000010007BL});
    public static final BitSet FOLLOW_argument_list_in_method_invocation211129 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_method_invocation211132 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_object_creation_expression211144 = new BitSet(new long[]{0x2400106804715820L,0x002209250800C400L,0x401A910C00000022L,0x000000000010007BL});
    public static final BitSet FOLLOW_argument_list_in_object_creation_expression211146 = new BitSet(new long[]{0x0000000004000000L});
    public static final BitSet FOLLOW_CLOSE_PARENS_in_object_creation_expression211149 = new BitSet(new long[]{0x0000000000000002L,0x0000020000000000L});
    public static final BitSet FOLLOW_object_or_collection_initializer_in_object_creation_expression211151 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_type_argument_list_in_synpred1_CSharp4125 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INTERR_in_synpred2_CSharp4161 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_rank_specifier_in_synpred3_CSharp4175 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_rank_specifier_in_synpred4_CSharp4369 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_array_type_in_synpred5_CSharp41445 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000000L});
    public static final BitSet FOLLOW_OPEN_BRACKET_in_synpred5_CSharp41447 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_unbound_type_name_in_synpred6_CSharp41636 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_scan_for_cast_generic_precedence_in_synpred7_CSharp41840 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_synpred7_CSharp41844 = new BitSet(new long[]{0x2000100800114000L,0x0000010008004000L,0x0008110000000000L,0x0000000000100030L});
    public static final BitSet FOLLOW_predefined_type_in_synpred7_CSharp41846 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INTERR_in_synpred8_CSharp42710 = new BitSet(new long[]{0x0000000004000000L,0x1000400000040000L});
    public static final BitSet FOLLOW_is_disambiguation_token_in_synpred8_CSharp42712 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_type_in_synpred9_CSharp43170 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
    public static final BitSet FOLLOW_IDENTIFIER_in_synpred9_CSharp43172 = new BitSet(new long[]{0x0000000000000000L,0x0000000000002000L});
    public static final BitSet FOLLOW_IN_in_synpred9_CSharp43174 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_into_contextual_keyword_in_synpred10_CSharp43208 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_assignment_in_synpred11_CSharp43617 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_lambda_expression_in_synpred12_CSharp43638 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_query_expression_in_synpred13_CSharp43649 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_labeled_statement_in_synpred14_CSharp43695 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_declaration_statement_in_synpred15_CSharp43706 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_ELSE_in_synpred16_CSharp44046 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_local_variable_declaration_in_synpred17_CSharp44273 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_local_variable_declaration_in_synpred18_CSharp44666 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_global_attribute_section_in_synpred19_CSharp44734 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_interface_type_in_synpred20_CSharp45807 = new BitSet(new long[]{0x0000080000000000L});
    public static final BitSet FOLLOW_DOT_in_synpred20_CSharp45809 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x4000000000000000L});
    public static final BitSet FOLLOW_THIS_in_synpred20_CSharp45811 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_member_name_in_synpred21_CSharp45849 = new BitSet(new long[]{0x0000000000000000L,0x0000080010000000L});
    public static final BitSet FOLLOW_type_parameter_list_in_synpred21_CSharp45851 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});
    public static final BitSet FOLLOW_OPEN_PARENS_in_synpred21_CSharp45854 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_member_name_in_synpred22_CSharp45868 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
    public static final BitSet FOLLOW_OPEN_BRACE_in_synpred22_CSharp45870 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_attributes_in_synpred23_CSharp46208 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});
    public static final BitSet FOLLOW_PARAMS_in_synpred23_CSharp46211 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_COMMA_in_synpred24_CSharp46227 = new BitSet(new long[]{0x0000000000000000L,0x0000040000000000L,0x0000000000000008L});
    public static final BitSet FOLLOW_parameter_array_in_synpred24_CSharp46229 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_COMMA_in_synpred25_CSharp46255 = new BitSet(new long[]{0x2000100800114000L,0x0000050008004400L,0x4008110800000002L,0x0000000001100030L});
    public static final BitSet FOLLOW_fixed_parameter_in_synpred25_CSharp46257 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_unary_operator_declarator_in_synpred26_CSharp47020 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_AMP_in_synpred27_CSharp49688 = new BitSet(new long[]{0x0000000000000002L});

}